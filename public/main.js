(function () {
    'use strict';

    var nsGmx$1 = {};
    window.nsGmx = nsGmx$1;

    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    /** Загрузчик модулей ГеоМиксера
    Позволяет загружать модули из разных файлов.
    Модуль - единица кода, имеющая уникальное имя и зависящая от других модулей и скриптов.
    @namespace
    */

    var gmxCore$1 = function () {
      var _callbacks = [];
      var _modules = {}; //null - файл модуля уже загружается, но сам модуль пока не доступен

      var _globalNamespace = this;

      var _modulesDefaultHost = "";
      var _modulePathes = {
        /*#buildinclude<modules_path.txt>*/
      };
      var _moduleFiles = {
        /*#buildinclude<module_files.txt>*/
      };

      var getScriptURL = function getScriptURL(scriptName) {
        scriptName = scriptName.toLowerCase();
        var scripts1 = document.getElementsByTagName("script");

        for (var i = 0; i < scripts1.length; i++) {
          var src = scripts1[i].getAttribute("src");
          if (src && src.toLowerCase().indexOf(scriptName) != -1) return src;
        }

        return false;
      }; //производится регистронезависимое сравнение


      var getScriptBase = function getScriptBase(scriptName) {
        scriptName = scriptName.toLowerCase();
        var url = getScriptURL(scriptName);
        return url ? url.toLowerCase().substring(0, url.toLowerCase().indexOf(scriptName)) : "";
      };

      var invokeCallbacks = function invokeCallbacks() {
        for (var k = 0; k < _callbacks.length; k++) {
          var isAllModules = true;
          var curModules = _callbacks[k].modules;
          var modules = [];

          for (var m = 0; m < curModules.length; m++) {
            if (!_modules[curModules[m]]) {
              isAllModules = false;
              break;
            }

            modules.push(_modules[curModules[m]]);
          }

          if (isAllModules) {
            var curCallback = _callbacks[k].callback; //first delete, then callback!

            _callbacks.splice(k, 1);

            k = k - 1;
            curCallback.apply(null, modules);
          }
        }
      };

      var LABjsDeferred = null;

      var lazyLoadLABjs = function lazyLoadLABjs() {
        if (!LABjsDeferred) {
          LABjsDeferred = $.Deferred(); //load LAB.js (snippest from its website)

          (function (g, b, _d) {
            var c = b.head || b.getElementsByTagName("head"),
                D = "readyState",
                E = "onreadystatechange",
                F = "DOMContentLoaded",
                G = "addEventListener",
                H = setTimeout;
            H(function () {
              if ("item" in c) {
                if (!c[0]) {
                  H(arguments.callee, 25);
                  return;
                }

                c = c[0];
              }

              var a = b.createElement("script"),
                  e = false;

              a.onload = a[E] = function () {
                if (a[D] && a[D] !== "complete" && a[D] !== "loaded" || e) {
                  return false;
                }

                a.onload = a[E] = null;
                e = true;
                LABjsDeferred.resolve();
              };

              a.src = (getScriptBase('gmxcore.js') || window.gmxJSHost || "") + 'LAB.min.js';
              c.insertBefore(a, c.firstChild);
            }, 0);

            if (b[D] == null && b[G]) {
              b[D] = "loading";
              b[G](F, _d = function d() {
                b.removeEventListener(F, _d, false);
                b[D] = "complete";
              }, false);
            }
          })(this, document);
        }

        return LABjsDeferred.promise();
      };

      var cssLoader = null;

      var withCachePostfix = function withCachePostfix(filename) {
        var sym = filename.indexOf('?') === -1 ? '?' : '&';

        if (window.gmxDropBrowserCache) {
          filename += sym + Math.random();
        } else if (window.nsGmx && nsGmx$1.buildGUID) {
          filename += sym + nsGmx$1.buildGUID;
        }

        return filename;
      };

      var publicInterface =
      /** @lends gmxCore */
      {
        /** Добавить новый модуль
        * @param {String} moduleName Уникальное имя модуля
        * @param {Object|Function} moduleObj Тело модуля или ф-ция, возвращающая тело. Аргумент ф-ции - путь к модулю. Будет вызвана после загрузки всех зависимостей.
        * @param {Object} [options] Дополнительные параметры модуля
        * @param {String[]} [options.require] Какие модули должны быть загрежены перед данным
        * @param {Function} [options.init] Ф-ция для инициализации модуля. Сигнатура: function (moduleObj, modulePath)->{void|{@link jQuery.Deferred}}. Если ф-ция возвращает {@link jQuery.Deferred}, загрузчик будет ждать его для окончания инициализации.
        * @param {String|String[]} [options.css] CSS файлы для загрузки. Пути к CSS указываются относительно файла текущего модуля.
        */
        addModule: function addModule(moduleName, moduleObj, options) {
          var requiredModules = options && 'require' in options ? options.require : [];
          var initDeferred = null;

          var _this = this;

          for (var r = 0; r < requiredModules.length; r++) {
            this.loadModule(requiredModules[r]);
          }

          this.addModulesCallback(requiredModules, function () {
            if (options && 'init' in options) {
              initDeferred = options.init(moduleObj, _modulePathes[moduleName]);
            }

            if (options && 'css' in options) {
              var cssFiles = typeof options.css === 'string' ? [options.css] : options.css;
              var path = _modulePathes[moduleName] || window.gmxJSHost || "";

              for (var iF = 0; iF < cssFiles.length; iF++) {
                _this.loadCSS(withCachePostfix(path + cssFiles[iF]));
              }
            }

            var doAdd = function doAdd() {
              if (typeof moduleObj === 'function') {
                moduleObj = moduleObj(_modulePathes[moduleName]);
              }

              _modules[moduleName] = moduleObj;
              invokeCallbacks();
            };

            if (initDeferred) {
              initDeferred.done(doAdd);
            } else {
              doAdd();
            }
          });
        },

        /** Загрузить модуль
        * @param { String } moduleName Имя модуля для загрузки
        * @param { String } [moduleSource] Имя файла, откуда загружать модуль. Если не указан, будет сформирован в виде (defaultHost + moduleName + '.js')
        * @param { Function } [callback] Ф-ция, которая будет вызвана после загрузки и инициализации. В ф-цию первым параметром передаётся тело модуля
        * @return { jQuery.Deferred } Promise, который будет resolve при загрузке модуля (параметр - модуль).
        */
        loadModule: function loadModule(moduleName, moduleSource, callback) {
          var def = $.Deferred();

          if (typeof moduleSource === 'function') {
            callback = moduleSource;
            moduleSource = undefined;
          }

          this.addModulesCallback([moduleName], function (module) {
            callback && callback(module);
            def.resolve(module);
          });

          if (!(moduleName in _modules)) {
            _modules[moduleName] = null;
            var headElem = document.getElementsByTagName("head")[0];
            var newScript = document.createElement('script');
            var path;

            if (typeof moduleSource != 'undefined') {
              path = moduleSource.match(new RegExp('^https?://', 'i')) ? moduleSource : (window.gmxJSHost || "") + moduleSource;
            } else {
              path = moduleName in _moduleFiles ? _moduleFiles[moduleName] : (_modulesDefaultHost || window.gmxJSHost || "") + moduleName + '.js';
            }

            var pathRegexp = new RegExp('(.*)/[^/]+');
            if (typeof _modulePathes[moduleName] === 'undefined') _modulePathes[moduleName] = pathRegexp.test(path) ? path.match(pathRegexp)[1] + "/" : ""; // var pathPostfix = "";

            newScript.onerror = function () {
              def.reject();
            };

            newScript.type = 'text/javascript';
            newScript.src = withCachePostfix(path);
            newScript.charset = "utf-8";
            headElem.appendChild(newScript);
          }

          return def;
        },

        /** Добавить callback, который будет вызван после загрузки моделей
        *
        * Если модули уже загружены, callback будет вызван сразу же
        *
        * @param {Array} moduleNames Массив имён модулей
        * @param {Function} callback Ф-ция, которую нужно вызвать после загрузки. В качестве аргументов в ф-цию передаются загруженные модули
        */
        addModulesCallback: function addModulesCallback(moduleNames, callback) {
          _callbacks.push({
            modules: moduleNames,
            callback: callback
          });

          invokeCallbacks();
        },

        /** Получить модуль по имени.
        *
        * @param {String} moduleName Имя модуля
        * @return {Object} Тело модуля. Если модуль не загружен, вернётся null.
        */
        getModule: function getModule(moduleName) {
          return _modules[moduleName] || null;
        },

        /** Установить дефольный путь к модулям. Используется если указан локальный файл модуля.
        * @param {String} defaultHost Дефолтный путь у модулям.
        */
        setDefaultModulesHost: function setDefaultModulesHost(defaultHost) {
          _modulesDefaultHost = defaultHost;
        },

        /** Явно задать полный путь к модулю
        * @param {String} moduleName Имя модуля
        * @param {String} defaultHost Путь к файлу модулю. При загрузке модуля будет загружен файл по указанному пути
        */
        setModuleFile: function setModuleFile(moduleName, moduleFile) {
          _moduleFiles[moduleName] = moduleFile;
        },
        pushModule2GlobalNamespace: function pushModule2GlobalNamespace(moduleName) {
          if (!_modules[moduleName]) return;
          var module = _modules[moduleName];

          for (var p in module) {
            _globalNamespace[p] = module[p];
          }
        },

        /** Получить путь к директории, из которой был загружен модуль.
        * @param {String} moduleName Имя модуля
        * @returns {String} Путь к директории, из которой был загружен модуль. Для не загруженных модулей ничего не возвращает
        */
        getModulePath: function getModulePath(moduleName) {
          return _modulePathes[moduleName];
        },

        /** Возвращает ф-цию, которая делает следующее:
        *
        *  - Если модуль moduleName не загружен, загружает его
        *  - Потом просто вызывает ф-цию с именем functionName из этого модуля, передав ей все свои параметры
        *
        *  - Возвращённая ф-ция при вызове возвращает jQuery.Promise, который будет resolve с параметрами, возвращёнными исходной ф-цией из модуля
        * @param {String} moduleName Имя модуля
        * @param {String} functionName Название ф-ции внутри модуля
        * @param {Function} callback Ф-ция, которая будет вызвана после того, как отработает ф-ция модуля. В callback будет передан ответ исходной ф-ции.
        */
        createDeferredFunction: function createDeferredFunction(moduleName, functionName, callback) {
          var _this = this;

          return function () {
            var deferred = $.Deferred();
            var args = arguments;

            _this.loadModule(moduleName).done(function (module) {
              var res = module[functionName].apply(this, args);
              callback && callback(res);
              deferred.resolve(res);
            });

            return deferred.promise();
          };
        },

        /** Загружает скрипт после предвариетельной проверки условий.
        *
        * @param {Array} filesInfo Массив объектов со следующими свойствами:
        *
        *   * check: function() -> Bool. Если возвращает true, ни js ни css не будет загружены
        *   * script: String. Не обязательно. Скрипт для загрузки, если провалится проверка
        *   * css: String | String[]. Не обязательно. CSS файл(ы) для загрузки, если провалится проверка
        *   @returns {jQuery.Deferred} Deferred, который будет разрешён когда все скрипты выполнятся (окончание загрузки css не отслеживается)
        */
        loadScriptWithCheck: function loadScriptWithCheck(filesInfo) {
          var _this = this;

          var localFilesInfo = filesInfo.slice(0);
          var def = $.Deferred();

          var doLoad = function doLoad() {
            if (localFilesInfo.length > 0) {
              var curInfo = localFilesInfo.shift();
              if (curInfo.check()) doLoad();else {
                var css = curInfo.css || [];

                if (typeof css === 'string') {
                  css = [css];
                }

                css.forEach(_this.loadCSS);
                if (curInfo.script) _this.loadScript(curInfo.script).then(doLoad);else doLoad();
              }
            } else def.resolve();
          };

          doLoad();
          return def.promise();
        },

        /**
        * Загружает отдельный скрипт
        * @param {String} fileName Имя файла скрипта
        * @param {function} [callback] Ф-ция, которая будет вызвана после загрузки
        * @param {String} [charset=utf-8] Кодировка загружаемого файла
        * @returns {jQuery.Deferred}
        */
        loadScript: function loadScript(fileName, callback, charset) {
          var def = $.Deferred();
          lazyLoadLABjs().done(function () {
            var descr = {
              src: withCachePostfix(fileName)
            };

            if (charset) {
              descr.charset = charset;
            }

            $LAB.script(descr).wait(function () {
              def.resolve();
              callback && callback();
            });
          });
          return def.promise();
        },

        /** Загрузить отдельный css файл
        * @param {String} cssFilename Имя css файла.
        */
        loadCSS: function loadCSS(cssFilename) {
          var doLoadCss = function doLoadCss() {
            $.getCSS(withCachePostfix(cssFilename));
          };

          if ('getCSS' in $) {
            doLoadCss();
          } else {
            if (!cssLoader) {
              var path = getScriptBase('gmxcore.js') || window.gmxJSHost || "";
              cssLoader = $.getScript(path + "jquery/jquery.getCSS.js");
            }

            cssLoader.done(doLoadCss);
          }
        }
      };
      return publicInterface;
    }();

    window.gmxCore = gmxCore$1;

    nsGmx$1.Utils = nsGmx$1.Utils || {};
    var domManipulation = {
      // _el(nodeName, [childs], [attrs])
      _el: function _el(str, childs, attributes) {
        var el = document.createElement(str),
            children = childs,
            attrs = attributes;
        if (children) domManipulation._childs(el, children);
        if (attrs && attrs.length) domManipulation._attr(el, attrs);
        return el;
      },
      // _t("some text")
      _t: function _t(str) {
        return document.createTextNode(String(str));
      },
      // children - всегда массив
      _childs: function _childs(el, children) {
        for (var i = 0; i < children.length; ++i) {
          el.appendChild(children[i]);
        }
      },
      //[['css','width','100%']]
      //[['dir','className','name']]
      //[['attr','colSpan',2]]
      _attr: function _attr(el, attrs) {
        for (var i = 0; i < attrs.length; ++i) {
          var atr = attrs[i],
              type = atr[0];

          switch (type) {
            case 'css':
              el.style[atr[1]] = atr[2];
              break;

            case 'dir':
              el[atr[1]] = atr[2];
              break;

            case 'attr':
              el.setAttribute(atr[1], atr[2]);
              break;
          }
        }
      },
      _table: function _table(children, attrs) {
        return _el('TABLE', children, attrs);
      },
      _caption: function _caption(children, attrs) {
        return _el('CAPTION', children, attrs);
      },
      _thead: function _thead(children, attrs) {
        return _el('THEAD', children, attrs);
      },
      _tbody: function _tbody(children, attrs) {
        return _el('TBODY', children, attrs);
      },
      _tfoot: function _tfoot(children, attrs) {
        return _el('TFOOT', children, attrs);
      },
      _textarea: function _textarea(children, attrs) {
        return _el('TEXTAREA', children, attrs);
      },
      _th: function _th(children, attrs) {
        return _el('TH', children, attrs);
      },
      _tr: function _tr(children, attrs) {
        return _el('TR', children, attrs);
      },
      _td: function _td(children, attrs) {
        return _el('TD', children, attrs);
      },
      _span: function _span(children, attrs) {
        return _el('SPAN', children, attrs);
      },
      _label: function _label(children, attrs) {
        return _el('LABEL', children, attrs);
      },
      _li: function _li(children, attrs) {
        return _el('LI', children, attrs);
      },
      _ul: function _ul(children, attrs) {
        return _el('UL', children, attrs);
      },
      _div: function _div(children, attrs) {
        return _el('DIV', children, attrs);
      },
      _radio: function _radio(attrs) {
        return _el('INPUT', null, attrs && attrs.concat([['attr', 'type', 'radio']]) || [['attr', 'type', 'radio']]);
      },
      _button: function _button(children, attrs) {
        return _el('BUTTON', children, attrs);
      },
      _a: function _a(children, attrs) {
        return _el('A', children, attrs);
      },
      _select: function _select(children, attrs) {
        return _el('SELECT', children, attrs);
      },
      _option: function _option(children, attrs) {
        return _el('OPTION', children, attrs);
      },
      _form: function _form(children, attrs) {
        return _el('FORM', children, attrs);
      },
      _iframe: function _iframe(children, attrs) {
        return _el('IFRAME', children, attrs);
      },
      _image: function _image(children, attrs) {
        return _el('IMG', children, attrs);
      },
      _img: function _img(children, attrs) {
        return _el('IMG', children, attrs);
      },
      _br: function _br() {
        return _el('BR');
      },
      _hr: function _hr() {
        return _el('HR');
      },
      _p: function _p(children, attrs) {
        return _el('P', children, attrs);
      },
      _b: function _b(children, attrs) {
        return _el('B', children, attrs);
      },
      _i: function _i(children, attrs) {
        return _el('I', children, attrs);
      },
      _input: function _input(children, attrs) {
        return _el('INPUT', children, attrs);
      }
    };
    var _el = domManipulation._el; // _(elem, [childs], [attrs])

    var _$1 = function _(ent, childs, attributes) {
      var el = ent,
          children = childs,
          attrs = attributes;
      if (children) domManipulation._childs(el, children);
      if (attrs && attrs.length) domManipulation._attr(el, attrs);
      return el;
    };

    var prevGlobals = {};

    for (var k in domManipulation) {
      prevGlobals[k] = window[k];
    }
    /** Удаляет из глобальной видимости часть методов, записанных туда при загрузке utilities.js
    * @memberOf nsGmx.Utils
    */


    nsGmx$1.Utils.noConflicts = function () {
      for (var k in domManipulation) {
        window[k] = prevGlobals[k];
      }

      return nsGmx$1.Utils;
    };

    jQuery.extend(window, domManipulation); //для обратной совместимости

    jQuery.extend(nsGmx$1.Utils, domManipulation);
    nsGmx$1.Utils._ = _$1;

    if (window.Node && window.Node.prototype) {
      Node.prototype.removeNode = function () {
        var parent = this.parentNode;
        parent && parent.removeChild(this);
      };
    }

    function show(elem) {
      elem.style.display = '';
    }

    function hide(elem) {
      elem.style.display = 'none';
    }

    function hidden(elem) {
      elem.style.visibility = 'hidden';
    }

    function visible(elem) {
      elem.style.visibility = 'visible';
    }

    function switchSelect(sel, value) {
      if (!sel.options || !sel.options.length) return sel;

      for (var i = 0; i < sel.options.length; i++) {
        if (value == sel.options[i].value) {
          sel.options[i].selected = true;
          sel.selectedIndex = i;
          break;
        }
      }

      return sel;
    }

    function parseColor(str) {
      var res = 0xffffff;
      if (!str) return res;else {
        var components = str.split(" ");
        if (components.length == 1) return parseInt("0x" + str);else if (components.length == 3) return parseInt(components[0]) * 0x10000 + parseInt(components[1]) * 0x100 + parseInt(components[2]);else return res;
      }
    }

    function objLength(obj) {
      var cnt = 0;

      for (var field in obj) {
        cnt++;
      }

      return cnt;
    }

    function valueInArray(arr, value) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] == value) return true;
      }

      return false;
    }

    function getOffsetRect(elem) {
      var box = elem.getBoundingClientRect(),
          body = document.body,
          docElem = document.documentElement,
          scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
          scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
          clientTop = docElem.clientTop || body.clientTop || 0,
          clientLeft = docElem.clientLeft || body.clientLeft || 0,
          top = box.top + scrollTop - clientTop,
          left = box.left + scrollLeft - clientLeft;
      return {
        top: Math.round(top),
        left: Math.round(left)
      };
    }

    function attachEffects(elem, className) {
      elem.onmouseover = function () {
        jQuery(this).addClass(className);
      };

      elem.onmouseout = function (e) {
        var evt = e || window.event,
            // target = evt.srcElement || evt.target,
        relTarget = evt.relatedTarget || evt.toElement;

        try {
          while (relTarget) {
            if (relTarget == elem) return;
            relTarget = relTarget.parentNode;
          }

          jQuery(elem).removeClass(className);
        } catch (e) {
          jQuery(elem).removeClass(className);
        }
      };
    }

    function makeButton(value, id) {
      var inp = _input(null, [['dir', 'className', 'btn'], ['attr', 'type', 'submit'], ['attr', 'value', value]]);

      if (typeof id != 'undefined' && id != null) inp.id = id;
      inp.style.padding = '0px 5px';
      return inp;
    }

    function makeImageButton(url, urlHover) {
      var btn = _img();

      btn.setAttribute('src', url);
      btn.style.cursor = 'pointer';
      btn.style.border = 'none';

      if (urlHover) {
        btn.onmouseover = function () {
          this.setAttribute('src', urlHover);
        };

        btn.onmouseout = function () {
          this.setAttribute('src', url);
        };
      }

      return btn;
    }

    function makeLinkButton(text) {
      var span = _span([_t(String(text))], [['dir', 'className', 'buttonLink']]);

      attachEffects(span, 'buttonLinkHover');
      return span;
    } // function makeHelpButton(helpText){
    //  var btn = makeImageButton(window.gmxAPI.getAPIHostRoot() + 'api/img/help.gif');
    //  btn.setAttribute('title', helpText)
    //  btn.onclick = function(){
    //      showDialog('', _t(helpText), 300, 150);
    //  }
    //  return btn;
    // }


    function getOwnChildNumber(elem) {
      for (var i = 0; i < elem.parentNode.childNodes.length; i++) {
        if (elem == elem.parentNode.childNodes[i]) return i;
      }
    }

    function stopEvent(e) {
      if (!e) e = window.event; //e.cancelBubble is supported by IE - this will kill the bubbling process.

      e.cancelBubble = true;
      e.returnValue = false; //e.stopPropagation works only in Firefox.

      if (e.stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      return false;
    } //Показывает диалог (на основе jQuery UI dialog)
    //Параметры можно передавать явно и в виде объекта params:
    //1. showDialog(title, content, width, height, ?posX, ?posY, ?resizeFunc, ?closeFunc)
    //2. showDialog(title, content, params)
    //Параметры:
    // - title {string} Заголовок диалога
    // - content {HTMLDomElement} контент диалога
    // - width, height {int} высота и ширина диалога (обязательные параметры!)
    // - posX, posY {int} положение диалога относительно экрана. Если не задано - по центру
    // - resizeFunc {function} будет вызываться при изменении размера диалога. Аргумент ф-ции - объект с атриубтами width и height
    // - closeFunc {function} будет вызываться при закрытии диалога
    // - setMinSize {bool} если true (по умолчанию), будут заданы минимальная ширина и высота, равные начальным размерам (width, height)


    function showDialog(title, content, width, height, posX, posY, resizeFunc, closeFunc) {
      var params = null;

      if (arguments.length == 3) {
        params = $.extend({
          posX: false,
          posY: false,
          setMinSize: true
        }, width);
      } else {
        params = {
          width: width,
          height: height,
          posX: posX,
          posY: posY,
          resizeFunc: resizeFunc,
          closeFunc: closeFunc,
          setMinSize: true
        };
      }

      var canvas = _div([content]);

      document.body.appendChild(canvas);
      var dialogParams = {
        width: params.width,
        height: params.height,
        title: title,
        position: params.posX == false ? 'center' : [params.posX, params.posY],
        resizable: true,
        resize: function resize(event, ui) {
          params.resizeFunc && params.resizeFunc(ui.size);
        },
        close: function close() {
          if (params.closeFunc && params.closeFunc()) return;
          removeDialog(canvas);
        },
        open: function open() {},
        closeText: null
      };

      if (params.setMinSize) {
        dialogParams.minWidth = params.width;
        dialogParams.minHeight = params.height;
      }

      jQuery(canvas).dialog(dialogParams);
      var dialog = canvas.parentNode;
      dialog.style.overflow = '';
      $(dialog).focusout(function (event) {
        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        jQuery.support.focusinBubbles = false;
        var ui = $('.ui-dialog-content', this);
        ui.context.st = $(ui).scrollTop();
      });
      $(dialog).focusin(function () {
        var uis = $('.ui-dialog-content');
        $(uis).each(function () {
          var st = $(this).context.st;
          $(this).scrollTop(st);
        });
      });
      jQuery(dialog).children("div.ui-resizable-se").removeClass("ui-icon").removeClass("ui-icon-gripsmall-diagonal-se").removeClass("ui-icon-grip-diagonal-se");
      return canvas;
    }

    function removeDialog(canvas) {
      jQuery(canvas).dialog('destroy').remove();
    }

    function showErrorMessage(message, removeFlag, title) {
      var canvas = _div([_t(message)], [['dir', 'className', 'errorDialog']]);

      var jQueryDiv = showDialog(title || "Ошибка!", canvas, {
        width: 250,
        height: 150,
        closeFunc: function closeFunc() {
          canvas = null;
        }
      });

      if (removeFlag) {
        setTimeout(function () {
          if (canvas) {
            jQuery(jQueryDiv).dialog("destroy");
            jQuery(canvas.parentNode).remove();
          }
        }, 2500);
      }
    }

    function _checkbox(flag, type, name) {
      var box = _input(null, [['attr', 'type', type]]);

      box.checked = flag;
      if (name) box.setAttribute('name', name);
      return box;
    }

    function insertAtCursor(myField, myValue, sel) {
      if (myField.id && window.tinyMCE && tinyMCE.get(myField.id)) {
        tinyMCE.execInstanceCommand(myField.id, "mceInsertContent", false, myValue);
        return;
      }

      if (document.selection) {
        if (typeof sel != 'undefined') sel.text = myValue;else {
          myField.focus();
          sel = document.selection.createRange();
          sel.text = myValue;
        }
      } else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart,
            endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);
      } else myField.value += myValue;
    }
    /* ----------------------------- */
    // function sendRequest(url, callback, body)
    // {
    //  var xmlhttp;
    //  if (typeof XMLHttpRequest != 'undefined')
    //      xmlhttp = new XMLHttpRequest();
    //  else
    //      try { xmlhttp = new ActiveXObject("Msxml2.XMLHTTP"); }
    //      catch (E) { try {xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); } catch (e) { console.log(e); }}
    //  xmlhttp.open(body ? "POST" : "GET", url, true);
    //  if (body)
    //  {
    //      xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    //      xmlhttp.setRequestHeader('Content-length', body.length);
    //  }
    //  xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4) callback(xmlhttp); }
    //  xmlhttp.send(body || "");
    // }
    // function sendJSONRequest(url, callback)
    // {
    //  sendRequest(url, function(xmlhttp)
    //  {
    //      var text = xmlhttp.responseText;
    //      callback(JSON.parse(text));
    //  });
    // }


    nsGmx$1.Utils.uniqueGlobalName = function () {
      var freeid = 0;
      return function (thing) {
        var id = 'gmx_unique_' + freeid++;
        window[id] = thing;
        return id;
      };
    }();
    /** Посылает кросс-доменный GET запрос к серверу с использованием транспорта JSONP.
     *
     * @memberOf nsGmx.Utils
     * @param {String} url URL сервера.
     * @param {Function} callback Ф-ция, которая будет вызвана при получении от сервера результата.
     * @param {String} [callbackParamName=CallbackName] Имя параметра для задания имени ф-ции ответа.
     * @param {Function} [errorCallback] Ф-ция, которая будет вызвана в случае ошибки запроса к серверу
     */


    function sendCrossDomainJSONRequest(url, callback, callbackParamName, errorCallback) {
      callbackParamName = callbackParamName || 'CallbackName';
      var script = document.createElement("script");
      script.setAttribute("charset", "UTF-8");
      var callbackName = nsGmx$1.Utils.uniqueGlobalName(function (obj) {
        callback && callback(obj);
        window[callbackName] = false;
        document.getElementsByTagName("head").item(0).removeChild(script);
      });
      var sepSym = url.indexOf('?') == -1 ? '?' : '&';

      if (errorCallback) {
        script.onerror = errorCallback;
      }

      script.setAttribute("src", url + sepSym + callbackParamName + "=" + callbackName + "&" + Math.random());
      document.getElementsByTagName("head").item(0).appendChild(script);
    }

    nsGmx$1.Utils.sendCrossDomainJSONRequest = sendCrossDomainJSONRequest;

    function createCookie(name, value, days) {
      var expires = '';

      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
        expires = "; expires=" + date.toGMTString();
      }

      document.cookie = name + "=" + value + expires + "; path=/";
    }

    function readCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');

      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];

        while (c.charAt(0) == ' ') {
          c = c.substring(1, c.length);
        }

        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
      }

      return null;
    }

    function eraseCookie(name) {
      createCookie(name, "", -1);
    }

    function getWindowWidth() {
      var myWidth = 0;
      if (typeof window.innerWidth == 'number') myWidth = window.innerWidth;else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) myWidth = document.documentElement.clientWidth;else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
        myWidth = document.body.clientWidth;
      }
      return myWidth;
    }

    function getWindowHeight() {
      var myHeight = 0;
      if (typeof window.innerWidth == 'number') myHeight = window.innerHeight;else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) myHeight = document.documentElement.clientHeight;else if (document.body && (document.body.clientWidth || document.body.clientHeight)) myHeight = document.body.clientHeight;
      return myHeight;
    }

    function strip(s) {
      return s.replace(/^\s*/, "").replace(/\s*$/, "");
    }

    (function () {
      var replacements = {};
      var temp;

      for (var rus in temp = {
        "qwertyuiopasdfghjklzxcvbnm_1234567890": "qwertyuiopasdfghjklzxcvbnm_1234567890",
        "абвгдезийклмнопрстуфыэ ": "abvgdeziyklmnoprstufye_",
        "ёжчхцшщюя": "yozhchkhtsshshyuya",
        "ьъ": "",
        ".": "."
      }) {
        var eng = temp[rus],
            k = eng.length / rus.length;

        for (var i = 0; i < rus.length; i++) {
          var r = rus.substring(i, i + 1),
              e = eng.substring(i * k, (i + 1) * k);
          replacements[r] = e;
          replacements[r.toUpperCase()] = e.toUpperCase();
        }
      }

      nsGmx$1.Utils.translit = function (name) {
        var result = "";

        for (var i = 0; i < name.length; i++) {
          result += replacements[name.substring(i, i + 1)] || "";
        }

        return result;
      };
    })();

    (function () {
      var requests = {},
          lastRequestId = 0,
          uniquePrefix = 'id' + Math.random();

      var processMessage = function processMessage(e) {
        if (!(e.origin in requests)) {
          return;
        }

        var dataStr = decodeURIComponent(e.data.replace(/\n/g, '\n\\'));

        try {
          var dataObj = JSON.parse(dataStr);
        } catch (e) {
          request.callback && request.callback({
            Status: "error",
            ErrorInfo: {
              ErrorMessage: "JSON.parse exeption",
              ExceptionType: "JSON.parse",
              StackTrace: dataStr
            }
          });
        } // console.log(dataObj);


        var request = requests[e.origin][dataObj.CallbackName];
        if (!request) return; // message от других запросов

        delete requests[e.origin][dataObj.CallbackName];
        delete dataObj.CallbackName;
        request.iframe.parentNode.removeChild(request.iframe);
        request.callback && request.callback(dataObj);
      }; //совместимость с IE8


      if (window.addEventListener) {
        window.addEventListener('message', processMessage);
      } else {
        window.attachEvent('onmessage', processMessage);
      } //скопирована из API для обеспечения независимости от него


      var parseUri = function parseUri(str) {
        var o = parseUri.options,
            m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
            uri = {},
            i = 14;

        while (i--) {
          uri[o.key[i]] = m[i] || '';
        }

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
          if ($1) {
            uri[o.q.name][$1] = $2;
          }
        });
        uri.hostOnly = uri.host;
        uri.host = uri.authority; // HACK

        return uri;
      };

      parseUri.options = {
        strictMode: false,
        key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
        q: {
          name: 'queryKey',
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };

      function createPostIframe2(id, callback, url) {
        var uniqueId = uniquePrefix + lastRequestId++;
        var iframe = document.createElement("iframe");
        iframe.style.display = 'none';
        iframe.setAttribute('id', id);
        iframe.setAttribute('name', id);
        iframe.src = 'javascript:true';
        iframe.callbackName = uniqueId; //iframe.onload = window[callbackName];

        var parsedURL = parseUri(url);
        var origin = (parsedURL.protocol ? parsedURL.protocol + ':' : window.location.protocol) + '//' + (parsedURL.host || window.location.host);
        requests[origin] = requests[origin] || {};
        requests[origin][uniqueId] = {
          callback: callback,
          iframe: iframe
        };
        return iframe;
      }

      window.createPostIframe2 = createPostIframe2;
    })();
    /** Посылает кроссдоменный POST запрос
    *
    * @memberOf nsGmx.Utils
    * @param {String} url URL запроса
    * @param {Object} params Хэш параметров-запросов
    * @param {Function} [callback] Callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
    * @param {DOMElement} [baseForm] базовая форма запроса. Используется, когда нужно отправить на сервер файл.
    *                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
    */


    function sendCrossDomainPostRequest(url, params, callback, baseForm) {
      var form,
          rnd = String(Math.random()),
          id = '$$iframe_' + url + rnd;
      var iframe = window.createPostIframe2(id, callback, url),
          originalFormAction;

      if (baseForm) {
        form = baseForm;
        originalFormAction = form.getAttribute('action');
        form.setAttribute('action', url);
        form.target = id;
      } else {
        try {
          form = document.createElement('<form id=' + id + '" enctype="multipart/form-data" style="display:none" target="' + id + '" action="' + url + '" method="post"></form>');
        } catch (e) {
          form = document.createElement("form");
          form.style.display = 'none';
          form.setAttribute('enctype', 'multipart/form-data');
          form.target = id;
          form.setAttribute('method', 'POST');
          form.setAttribute('action', url);
          form.id = id;
        }
      }

      var hiddenParamsDiv = document.createElement("div");
      hiddenParamsDiv.style.display = 'none';

      if (params.WrapStyle === 'window') {
        params.WrapStyle = 'message';
      }

      if (params.WrapStyle === 'message') {
        params.CallbackName = iframe.callbackName;
      }

      for (var paramName in params) {
        var input = document.createElement("input");
        var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';
        input.setAttribute('type', 'hidden');
        input.setAttribute('name', paramName);
        input.setAttribute('value', value);
        hiddenParamsDiv.appendChild(input);
      }

      form.appendChild(hiddenParamsDiv);
      if (!baseForm) document.body.appendChild(form);
      document.body.appendChild(iframe);
      form.submit();

      if (baseForm) {
        form.removeChild(hiddenParamsDiv);
        if (originalFormAction !== null) form.setAttribute('action', originalFormAction);else form.removeAttribute('action');
      } else {
        form.parentNode.removeChild(form);
      }
    }

    var hooks = {};
    /** Добавляет "хук", который будет вызван при ответе сервера соответвующего типа
    * @param type {object} - тип хука (соответствует полю "Status" ответа сервера) или '*' - добавить к любому ответу
    * @param hookFunction {function(response, customErrorDescriptions)} - собственно хук
    */

    function addParseResponseHook(type, hookFunction) {
      hooks[type] = hooks[type] || [];
      hooks[type].push(hookFunction);
    }
    /** Обрабатывает результат выполнения серверного скрипта.
    * Для выполнения действий вызывает "хуки" соответствующиего типа, добавленные через addParseResponseHook()
    * @function
    * @global
    * @param {object} response JSON, вернувшийся с сервера
    * @param {object} customErrorDescriptions хэш "тип ошибки" -> "кастомное сообщение пользователям".
    * @return true, если статус ответа "ok", иначе false
    */


    function parseResponse(response, customErrorDescriptions) {
      var responseHooks = (hooks[response.Status] || []).concat(hooks['*'] || []);

      for (var h = 0; h < responseHooks.length; h++) {
        responseHooks[h](response, customErrorDescriptions);
      }

      return response.Status == 'ok';
    }

    function _title(elem, title) {
      elem.setAttribute('title', title);
    }

    function parseXML(str) {
      var xmlDoc;

      try {
        if (window.DOMParser) {
          var parser = new DOMParser();
          xmlDoc = parser.parseFromString(str, "text/xml");
        } else // Internet Explorer
          {
            xmlDoc = new ActiveXObject("MSXML2.DOMDocument.3.0");
            xmlDoc.validateOnParse = false;
            xmlDoc.async = false;
            xmlDoc.loadXML(str);
          }
      } catch (e) {
        alert(e);
      }

      return xmlDoc;
    }

    function disableSelection(target) {
      if (typeof target.onselectstart != "undefined") target.onselectstart = function () {
        return false;
      };else if (typeof target.style.MozUserSelect != "undefined") target.style.MozUserSelect = "none";else target.onmousedown = function () {
        return false;
      };
    } // function parsePropertiesDate(str)
    // {
    //  if (str == null || str == "")
    //      return 0;
    //  var dateParts = str.split('.');
    //  if (dateParts.length != 3)
    //      return 0;
    //  return new Date(dateParts[2], dateParts[1] - 1, dateParts[0]).valueOf();
    // }


    function stringDate(msec, isUtc) {
      var date = new Date(msec),
          excDate = isUtc ? date.getUTCDate() : date.getDate(),
          excMonth = (isUtc ? date.getUTCMonth() : date.getMonth()) + 1,
          excYear = isUtc ? date.getUTCFullYear() : date.getFullYear();
      return (excDate < 10 ? '0' + excDate : excDate) + '.' + (excMonth < 10 ? '0' + excMonth : excMonth) + '.' + excYear;
    }

    function stringTime(msec, isUtc) {
      var date = new Date(msec),
          excHour = isUtc ? date.getUTCHours() : date.getHours(),
          excMin = isUtc ? date.getUTCMinutes() : date.getMinutes(),
          excSec = isUtc ? date.getUTCSeconds() : date.getSeconds();
      return (excHour < 10 ? '0' + excHour : excHour) + ':' + (excMin < 10 ? '0' + excMin : excMin) + ':' + (excSec < 10 ? '0' + excSec : excSec);
    }

    function stringDateTime(msec, isUtc) {
      return stringDate(msec, isUtc) + ' ' + stringTime(msec, isUtc);
    }
    /** Подсвечивает красным input, убирает подсветку через некоторое время
    *
    * @param {HTMLDOMElement|Array<HTMLDOMElement>} input - целевой input-элемент или массив таких элементов
    * @param {integer} delay - время подсвечивания ошибки в миллисекундах
    */


    function inputError(input, delay) {
      delay = delay || 1000;
      if (!jQuery.isArray(input)) input = [input];

      for (var k = 0; k < input.length; k++) {
        jQuery(input[k]).addClass('error');
      }

      setTimeout(function () {
        for (var k = 0; k < input.length; k++) {
          if (input[k]) jQuery(input[k]).removeClass('error');
        }
      }, delay);
    }

    function equals(x, y) {
      for (var p in y) {
        if (typeof x[p] == 'undefined') {
          return false;
        }
      }

      for (var _p2 in y) {
        if (y[_p2]) {
          switch (_typeof(y[_p2])) {
            case 'object':
              if (!equals(x[_p2], y[_p2])) {
                return false;
              }

              break;

            case 'function':
              if (typeof x[_p2] == 'undefined' || _p2 != 'equals' && y[_p2].toString() != x[_p2].toString()) {
                return false;
              }

              break;

            default:
              if (y[_p2] != x[_p2]) {
                return false;
              }

          }
        } else if (x[_p2]) {
          return false;
        }
      }

      for (var _p3 in x) {
        if (typeof y[_p3] == 'undefined') {
          return false;
        }
      }

      return true;
    }
    /**
        @namespace nsGmx.Utils
        @description Разнообразные вспомогательные ф-ции
    */


    $.extend(nsGmx$1.Utils, {
      /**
          Возвращает уникальную строку (16 символов из букв и латинских цифр)
          @function
          @memberOf nsGmx.Utils
      */
      generateUniqueID: function generateUniqueID() {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",
            randomstring = '';

        for (var i = 0; i < 16; i++) {
          var rnum = Math.floor(Math.random() * chars.length);
          randomstring += chars.charAt(rnum);
        }

        return randomstring;
      },

      /**
          Преобразует цвет, заданный в виде числа (0xaabbcc) в строку вида #aabbcc
          @function
          @memberOf nsGmx.Utils
      */
      convertColor: function convertColor(intColor) {
        var r, g, b;
        b = (intColor % 256).toString(16);
        if (b.length == 1) b = '0' + b;
        intColor = Math.floor(intColor / 256);
        g = (intColor % 256).toString(16);
        if (g.length == 1) g = '0' + g;
        intColor = Math.floor(intColor / 256);
        r = (intColor % 256).toString(16);
        if (r.length == 1) r = '0' + r;
        return '#' + r + g + b;
      },

      /**
          Преобразует цвет, заданный в виде строки rgb(255, 255, 255) в строку вида #aabbcc
          @function
          @memberOf nsGmx.Utils
      */
      rgb2hex: function rgb2hex(intColor) {
        var str,
            arr = intColor.substring(4, intColor.length - 1).split(', ');
        arr = arr.map(function (c) {
          var hex = Number(c).toString(16);
          return hex.length == 1 ? "0" + hex : hex;
        });
        str = "#" + arr.join('');
        return str;
      },
      checkForNumber: function checkForNumber(number) {
        return !(isNaN(number) || typeof number === 'undefined' || number === null || number === '');
      },
      isJSON: function isJSON(str) {
        try {
          JSON.parse(str);
        } catch (e) {
          return false;
        }

        if (str === '' || str === 'null' || str === 'undefined' || typeof str === 'number') {
          return false;
        } else {
          return true;
        }
      },

      /** Возвращает позицию окна такую, чтобы окно не мешало текущему элементу
          @memberOf nsGmx.Utils
      */
      getDialogPos: function getDialogPos(div, offsetFlag, height) {
        var pos = getOffsetRect(div),
            left = pos.left + 30,
            top = pos.top - 10,
            windowHeight = getWindowHeight();

        if (offsetFlag) {
          $(div).children('div,img').each(function () {
            if (!this.getAttribute('multiStyle')) left += this.offsetWidth;
          });
        }

        if (top + 15 + height > windowHeight) top -= top + 15 + height - windowHeight;
        return {
          left: left,
          top: top
        };
      },

      /** Устанавливает обычный стиль и генерит похожий стиль при наведении мышки
      @memberOf nsGmx.Utils
      @param layer {L.gmxVectorLayer} Слой
      @param styleIndex {Number} Номер стиля слоя
      @param templateStyle {Style} Стиль, похожий на который надо установить*/
      setMapObjectStyle: function setMapObjectStyle(layer, styleIndex, templateStyle) {
        var hoverStyle = $.extend(true, {}, templateStyle);
        var style = layer.getStyle(styleIndex);
        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;
        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0) hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);
        var newStyle = $.extend(true, {}, style);
        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

        if (templateStyle.labelTemplate) {
          newStyle.RenderStyle.labelTemplate = templateStyle.labelTemplate;
        }

        if (hoverStyle.labelTemplate) {
          newStyle.HoverStyle.labelTemplate = hoverStyle.labelTemplate;
        }

        if (templateStyle.labelAnchor) {
          newStyle.RenderStyle.labelAnchor = templateStyle.labelAnchor;
        }

        if (hoverStyle.labelAnchor) {
          newStyle.HoverStyle.labelAnchor = hoverStyle.labelAnchor;
        }

        layer.setStyle(newStyle, styleIndex);
      },
      // берёт стиль в формате сервера, добавляет в него hover-подсветку
      // и возвращает этот стиль в новом формате Leafelt-Geomixer
      prepareGmxLayerStyle: function prepareGmxLayerStyle(style) {
        var templateStyle = style.RenderStyle,
            newStyle = $.extend(true, {}, style),
            hoverStyle = $.extend(true, {}, templateStyle);
        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;
        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0) hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);
        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);
        return newStyle;
      },

      /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
      *
      * Форматы сервера:
      *
      *  * datetime - unix timestamp
      *  * date - unix timestamp, кратный 24*3600 секунд
      *  * time - кол-во секунд с полуночи
      *
      * Форматы клиента:
      *
      *  * все числа превращаются в строки
      *  * дата - строка в формате dd.mm.yy
      *  * время - строка в формате hh:mm:ss
      *  * дата-время - dd.mm.yy hh:mm:ss
      *
      * @memberOf nsGmx.Utils
      */
      convertFromServer: function convertFromServer(type, value) {
        //if (value === null) return "null";
        if (!type) {
          return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string') {
          return value !== null ? value : ''; //все null интерпретируем как пустые строки!
        } else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number') {
          return value !== null ? String(value) : '';
        } else if (lowerCaseType == 'date') {
          if (value === null) return '';
          return stringDate(value * 1000, true);
        } else if (lowerCaseType == 'time') {
          if (value === null) return '';
          return stringTime(value * 1000, true);
        } else if (lowerCaseType == 'datetime') {
          if (value === null) return '';
          return stringDateTime(value * 1000, true);
        }

        return value;
      },

      /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
      * Описание форматов см. в {@link nsGmx.Utils.convertFromServer}
      * Если конвертация невозможна для данного типа, возвращает null
      * @memberOf nsGmx.Utils
      */
      convertToServer: function convertToServer(type, value) {
        if (!type) {
          return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string') {
          return value;
        } else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number') {
          if (value === '') return null;
          var num = Number(value);
          return isNaN(num) ? null : num;
        } else if (lowerCaseType == 'date') {
          var localDateValue = $.datepicker.parseDate('dd.mm.yy', value);
          if (localDateValue === null) return null;
          var localValue = localDateValue.valueOf() / 1000;
          var timeOffset = new Date(localValue * 1000).getTimezoneOffset() * 60;
          return localValue - timeOffset;
        } else if (lowerCaseType == 'time') {
          var resTime = $.datepicker.parseTime('HH:mm:ss', value);
          if (!resTime) return null;
          return resTime.hour * 3600 + resTime.minute * 60 + resTime.second;
        } else if (lowerCaseType == 'datetime') {
          var _localDateValue = $.datepicker.parseDateTime('dd.mm.yy', 'HH:mm:ss', value);

          if (_localDateValue === null) return null;

          var _localValue = _localDateValue.valueOf() / 1000;

          var _timeOffset = new Date(_localValue * 1000).getTimezoneOffset() * 60;

          return _localValue - _timeOffset;
        }

        return value;
      },
      login: function login(redirect_uri, authServerBase, callback, authServer, isHidden) {
        var oAuthServer = authServer || 'MyKosmosnimki';

        window.gmxGetServerBase = function () {
          return authServerBase;
        };

        var redirectUri = redirect_uri + (redirect_uri.indexOf('?') > 0 ? '&' : '?') + 'authServer=' + oAuthServer;

        window.gmxProcessAuthentication = function (userInfo) {
          callback && callback(userInfo);
        };

        var features,
            w = 600,
            h = 350;
        var handlerName = 'LoginDialog';

        if (oAuthServer != 'MyKosmosnimki') {
          handlerName += oAuthServer;
          h = 400;
        }

        var url = authServerBase + handlerName + '.ashx?redirect_uri=' + escape(redirectUri);

        if (!isHidden) {
          var top = (screen.height - h) / 2,
              left = (screen.width - w) / 2;
          features = 'location=0,menubar=0,resizable=0,status=0,toolbar=0,width=' + w + ',height=' + h + ',left=' + left + ',top=' + top;
          window.open(url, '_blank', features);
        } else {
          $('<iframe />', {
            'src': url,
            'style': 'display: block !important; position: absolute; left: -99999px;'
          }).appendTo('body'); //стиль такой кривой иначе будет бага в FF
        }
      },

      /** Загружает пользовательский shp файл.
      * Проверяет на ошибки, выводит предупреждения и ошибки в виде стандартных диалогов.
      * @memberof nsGmx.Utils
      * @function
      * @param {File|Form} shpSource Либо форма с полем file, в которой пользователь выбрал файл, либо HTML5 File. Форма должна иметь атрибуты method="post" и enctype="multipart/form-data"
      * @return {jQuery.Deferred} Возвращает promise (аргумент ф-ции - массив объектов из shp файла)
      */
      parseShpFile: function () //приватные данные
      {
        var translationsAdded = false;

        var addTranslationsLazy = function addTranslationsLazy() {
          if (translationsAdded) return;

          _translationsHash.addtext("rus", {
            "loadShape.Errors.FileTooBigException": "Файл слишком большой. Ограничение на размер файла 1000 Кб.",
            "loadShape.Errors.ErrorUploadExeption": "Произошла ошибка при попытке загрузить файл.",
            "loadShape.Errors.NoGeometryFile": "Загруженный файл не содержит геометрических данных.",
            "loadShape.Errors.ErrorUploadNoDependentFiles": "Не найдено необходимых зависимых файлов. Запакуйте все файлы в ZIP архив и повторите загрузку."
          });

          _translationsHash.addtext("eng", {
            "loadShape.Errors.FileTooBigException": "Too big file. File size limit is 1000 Kb.",
            "loadShape.Errors.ErrorUploadExeption": "Error during file uploading.",
            "loadShape.Errors.NoGeometryFile": "There are no geometry in uploaded file.",
            "loadShape.Errors.ErrorUploadNoDependentFiles": "Not found the necessary dependent files. Add all files in a ZIP archive and upload it again."
          });

          translationsAdded = true;
        }; //непосредственно ф-ция


        return function (shpFileForm) {
          var def = $.Deferred();
          addTranslationsLazy();
          var errorMessages = {
            "CommonUtil.FileTooBigException": _gtxt("loadShape.Errors.FileTooBigException"),
            "CommonUtil.ErrorUploadExeption": _gtxt("loadShape.Errors.ErrorUploadExeption"),
            "CommonUtil.NoGeometryFile": _gtxt("loadShape.Errors.NoGeometryFile"),
            "CommonUtil.ErrorUploadNoDependentFiles": _gtxt("loadShape.Errors.ErrorUploadNoDependentFiles")
          };

          if (window.File && shpFileForm instanceof window.File) {
            if (!window.FormData) {
              def.reject();
              return false;
            }

            var formData = new FormData();
            formData.append('file', shpFileForm);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', window.serverBase + 'ShapeLoader');

            xhr.onload = function (response) {
              if (xhr.status === 200) {
                response = JSON.parse(xhr.responseText.substr(1, xhr.responseText.length - 2));

                if (parseResponse(response, errorMessages)) {
                  def.resolve(response.Result);
                } else {
                  def.reject(response);
                }
              }
            };

            xhr.send(formData);
          } else {
            sendCrossDomainPostRequest(window.serverBase + "ShapeLoader", {
              WrapStyle: "window"
            }, function (response) {
              if (parseResponse(response, errorMessages)) {
                def.resolve(response.Result);
              } else {
                def.reject(response);
              }
            }, shpFileForm);
          }

          return def.promise();
        };
      }(),

      /** Позволяет скачать в браузере геометрию в одном из форматов (упакованный в zip архив).
      * @memberof nsGmx.Utils
      * @function
      * @param {Object[]} geoJSONFeatures Массив GeoJSON Features. К сожалению, другие типы GeoJSON объектов не поддерживаются.
      * @param {Object} [options] Доп. параметры
      * @param {String} [options.fileName=markers] Имя файла для скачивания
      * @param {String} [options.format=Shape] В каком формате скачать (Shape, Tab, gpx или несколько через запятую)
      */
      downloadGeometry: function downloadGeometry(geoJSONFeatures, options) {
        var objectsByType = {},
            markerIdx = 1;
        options = $.extend({
          fileName: 'markers',
          format: 'Shape'
        }, options);
        geoJSONFeatures.forEach(function (item) {
          var geom = item.geometry,
              type = geom.type;
          objectsByType[type] = objectsByType[type] || [];
          var title = item.properties && item.properties.title || '';

          if (type == "Point" && !title) {
            title = "marker " + markerIdx++;
          }

          objectsByType[type].push({
            geometry: {
              type: type.toUpperCase(),
              coordinates: geom.coordinates
            },
            properties: {
              text: title
            }
          });
        });
        sendCrossDomainPostRequest(window.serverBase + "Shapefile", {
          name: options.fileName,
          format: options.format,
          points: JSON.stringify(objectsByType["Point"] || []),
          lines: JSON.stringify([].concat(objectsByType["LineString"] || [], objectsByType["MultiLineString"] || [])),
          polygons: JSON.stringify([].concat(objectsByType["Polygon"] || [], objectsByType["MultiPolygon"] || []))
        });
      },

      /** Объединяет массив полигонов/мультиполигонов в новый полигон/мультиполигон
      * @memberof nsGmx.Utils
      */
      joinPolygons: function joinPolygons(objs) {
        var polygonObjects = [];

        for (var i = 0; i < objs.length; i++) {
          var geom = objs[i];

          if (geom.type == 'POLYGON') {
            polygonObjects.push(geom.coordinates);
          } else if (geom.type == 'MULTIPOLYGON') {
            for (var iC = 0; iC < geom.coordinates.length; iC++) {
              polygonObjects.push(geom.coordinates[iC]);
            }
          }
        }

        if (polygonObjects.length > 1) return {
          type: "MULTIPOLYGON",
          coordinates: polygonObjects
        };else if (polygonObjects.length == 1) {
          return {
            type: "POLYGON",
            coordinates: polygonObjects[0]
          };
        } else return null;
      },
      joinClippedPolygon: function joinClippedPolygon(polygon) {
        if (polygon.type !== 'MULTIPOLYGON') {
          return polygon;
        }

        var origData = [],
            segmentsToJoin = [],
            joinedSegments = [],
            crossPoints = [],
            finalPolygon = [];

        var equal = function equal(a, b) {
          return Math.abs(a - b) < 1e-5;
        };

        var coords = polygon.coordinates;

        for (var c = 0; c < coords.length; c++) {
          for (var r = 0; r < coords[c].length; r++) {
            coords[c][r].length = coords[c][r].length - 1;
          }
        }

        var parseRing = function parseRing(origRing) {
          var ring = origRing.coords,
              len = ring.length;

          var getNextSegment = function getNextSegment(i) {
            var il = (i - 1 + len) % len,
                points = [];

            while (i != il) {
              if (equal(Math.abs(ring[i][0]), 180) && equal(Math.abs(ring[(i + 1) % len][0]), 180)) {
                return [i, points];
              }

              points.push(ring[i]);
              i = (i + 1) % len;
            }

            return [i, points];
          };

          var segment = getNextSegment(0);
          var lastI = segment[0];

          if (!equal(Math.abs(ring[segment[0]][0]), 180)) {
            origRing.regularRing = ring;
            return;
          }

          do {
            var startI = (segment[0] + 1) % len;
            segment = getNextSegment((startI + 1) % len);
            var nextSegment = {
              points: [].concat([ring[startI]], segment[1], [ring[segment[0]]])
            };
            segmentsToJoin.push(nextSegment);
            origRing.segments.push(nextSegment);
          } while (segment[0] !== lastI);
        };

        var findSegment = function findSegment(y, joinedSeg) {
          for (var s = 0; s < segmentsToJoin.length; s++) {
            var seg = segmentsToJoin[s];

            if (equal(seg.points[0][1], y) || equal(seg.points[seg.points.length - 1][1], y)) {
              segmentsToJoin.splice(s, 1);
              seg.joinedSeg = joinedSeg;
              var isReg = equal(seg.points[0][1], y);
              return {
                points: isReg ? seg.points.slice(1, seg.points.length - 1) : seg.points.slice(1, seg.points.length - 1).reverse(),
                lastY: isReg ? seg.points[seg.points.length - 1][1] : seg.points[0][1]
              };
            }
          }
        };

        var joinSegment = function joinSegment(y0) {
          var res = {},
              seg = findSegment(y0, res),
              points = seg.points,
              crossPoints = [y0];

          while (seg.lastY !== y0) {
            crossPoints.push(seg.lastY);
            seg = findSegment(seg.lastY);
            points = points.concat(seg.points);
          }

          res.points = points;
          res.crossPoints = crossPoints;
          res.minCrossPoint = Math.min.apply(Math, crossPoints);
          return res;
        };

        var parseGeometry = function parseGeometry(geom) {
          for (var _c = 0; _c < geom.coordinates.length; _c++) {
            var origComp = [];
            origData.push(origComp);
            var comp = geom.coordinates[_c];

            for (var _r = 0; _r < comp.length; _r++) {
              var origRing = {
                coords: comp[_r],
                segments: []
              };
              origComp.push(origRing);
              parseRing(origRing);
            }
          }
        };

        parseGeometry(polygon);
        segmentsToJoin.forEach(function (segment) {
          if (segment.points[0][0] < 0) {
            segment.points = segment.points.map(function (c) {
              return [c[0] + 360, c[1]];
            });
          }
        });

        while (segmentsToJoin.length) {
          var y0 = segmentsToJoin[0].points[0][1];
          var joinedSeg = joinSegment(y0);
          joinedSegments.push(joinedSeg);
          crossPoints = crossPoints.concat(joinedSeg.crossPoints);
        }

        crossPoints = crossPoints.sort();
        joinedSegments = joinedSegments.sort(function (s1, s2) {
          return s1.minCrossPoint - s2.minCrossPoint;
        });
        joinedSegments.forEach(function (s) {
          s.isExternal = crossPoints.indexOf(s.minCrossPoint) % 2 === 0;
        }); //собираем объединённые сегменты в мультиполигон

        joinedSegments.forEach(function (s) {
          if (s.isExternal) {
            finalPolygon.push([s.points]);
          } else {
            finalPolygon[finalPolygon.length - 1].push(s.points);
          }

          s.finalComponent = finalPolygon[finalPolygon.length - 1];
        }); //добавляем компоненты, которые не пересекались со 180 градусом

        for (var _c2 = 0; _c2 < origData.length; _c2++) {
          if (origData[_c2][0].regularRing) {
            console.log('external component', _c2);
            var geomToCopy = [];

            for (var _r2 = 0; _r2 < origData[_c2].length; _r2++) {
              geomToCopy.push(origData[_c2][_r2].regularRing);
            }

            finalPolygon.push(geomToCopy);
            continue;
          }

          for (var _r3 = 1; _r3 < origData[_c2].length; _r3++) {
            if (origData[_c2][_r3].regularRing) {
              console.log('internal component', _c2, _r3, origData[_c2][0].segments);

              for (var s = 0; s < origData[_c2][0].segments.length; s++) {
                var _joinedSeg = origData[_c2][0].segments[s].joinedSeg;

                if (_joinedSeg.isExternal) {
                  _joinedSeg.finalComponent.push(origData[_c2][_r3].regularRing);

                  break;
                }
              }
            }
          }
        }

        if (finalPolygon.length === 1) {
          return {
            type: 'POLYGON',
            coordinates: finalPolygon[0]
          };
        } else {
          return {
            type: 'MULTIPOLYGON',
            coordinates: finalPolygon
          };
        }
      },

      /** Методы для работы с сохранёнными на сервере данными.
      * Сервер позволяет сохранять произвольный текст на сервере и получить ID, по которому можно этот текст получить.
      * Используется для формирования пермалинков (сохранение состояния)
      * @namespace
      * @memberOf nsGmx.Utils
      */
      TinyReference: {
        /** Создать новую ссылку
        * @param {String} data Данные, которые нужно сохранить
        * @return {jQuery.Deferred} Промис, который будет resolve при сохранении данных. Параметр при ресолве: ID, по которому можно получить данные обратно
        */
        create: function create(data, tempFlag) {
          var def = $.Deferred();
          sendCrossDomainPostRequest(window.serverBase + "TinyReference/Create.ashx", {
            WrapStyle: 'message',
            content: JSON.stringify(data),
            temp: tempFlag
          }, function (response) {
            if (parseResponse(response)) {
              def.resolve(response.Result);
            } else {
              def.reject();
            }
          });
          return def.promise();
        },

        /** Получить ранее сохранённые данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при получении данных. Параметр при ресолве: данные с сервера
        */
        get: function get(id) {
          var def = $.Deferred();
          sendCrossDomainJSONRequest(window.serverBase + "TinyReference/Get.ashx?id=" + id, function (response) {
            //если пермалинк не найден, сервер не возвращает ошибку, а просто пустой результат
            if (parseResponse(response) && response.Result) {
              def.resolve(JSON.parse(response.Result));
            } else {
              def.reject();
            }
          });
          return def.promise();
        },

        /** Удалить данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при удалении данных
        */
        remove: function remove(id) {
          var def = $.Deferred();
          sendCrossDomainJSONRequest(window.serverBase + "TinyReference/Delete.ashx?id=" + id, function (response) {
            if (parseResponse(response)) {
              def.resolve();
            } else {
              def.reject();
            }
          });
          return def.promise();
        }
      },
      isIpad: function isIpad() {
        return navigator.userAgent.match(/iPad/i) != null;
      },
      getLatLngBounds: function getLatLngBounds(layer) {
        var gmxBounds = layer._gmx.layerID ? L.gmxUtil.getGeometryBounds(layer._gmx.geometry) : layer._gmx.dataManager.getItemsBounds(),
            // srs = layer._gmx.srs,
        array = []; // if (srs) {
        //     for (let proj in L.CRS) {
        //         if (proj.indexOf(srs) !== -1) {
        //             projection = L.CRS[proj];
        //             break;
        //         }
        //     }
        // } else {
        //     projection = L.CRS['EPSG:3395'];
        // }

        array.push(L.Projection.Mercator.unproject(gmxBounds.min));
        array.push(L.Projection.Mercator.unproject(gmxBounds.max));
        return L.latLngBounds(array);
      },
      showDialog: showDialog,
      removeDialog: removeDialog,
      makeImageButton: makeImageButton,
      makeLinkButton: makeLinkButton,
      makeButton: makeButton,
      _title: _title,
      _checkbox: _checkbox
    });
    window.gmxCore.addModule('utilities', nsGmx$1.Utils);
    var _br = domManipulation._br,
        _div = domManipulation._div,
        _form = domManipulation._form,
        _img = domManipulation._img,
        _input = domManipulation._input,
        _li = domManipulation._li,
        _option = domManipulation._option,
        _span = domManipulation._span,
        _a = domManipulation._a,
        _t = domManipulation._t,
        _table = domManipulation._table,
        _tbody = domManipulation._tbody,
        _textarea = domManipulation._textarea,
        _thead = domManipulation._thead,
        _tr = domManipulation._tr,
        _th = domManipulation._th,
        _td = domManipulation._td,
        _ul = domManipulation._ul;
    window.addParseResponseHook = addParseResponseHook;
    window.parseResponse = parseResponse;

    // {
    // 	this.hash = {};
    // 	this.flags = {};
    // 	this.titles = {};
    //     this._errorHandlers = [];
    // }

    var DEFAULT_LANGUAGE = 'rus'; //Для запоминания выбора языка пользователем используются куки. 
    //Запоминается выбор для каждого pathname, а не только для домена целиком
    //Формат куки: pathname1=lang1&pathname2=lang2&...

    var _parseLanguageCookie = function _parseLanguageCookie() {
      var text = readCookie("language");
      if (!text) return {};
      var items = text.split('&'); //поддержка старого формата кук (просто названия взыка для всех pathname)

      if (items % 2) items = [];
      var langs = {};

      for (var i = 0; i < items.length; i++) {
        var elems = items[i].split('=');
        langs[decodeURIComponent(elems[0])] = decodeURIComponent(elems[1]);
      }

      return langs;
    };

    var _saveLanguageCookie = function _saveLanguageCookie(langs) {
      var cookies = [];

      for (var h in langs) {
        cookies.push(encodeURIComponent(h) + '=' + encodeURIComponent(langs[h]));
      }

      eraseCookie("language");
      createCookie("language", cookies.join('&'));
    };

    var TranslationsManager = function TranslationsManager() {
      this.flags = {};
      this.titles = {};
      this.hash = {};
      this._errorHandlers = [];
    };

    TranslationsManager.prototype._language = null;

    TranslationsManager.prototype._addTextWithPrefix = function (prefix, lang, newHash) {
      var res = true,
          hash = this.hash;

      if (!(lang in hash)) {
        hash[lang] = {};
      }

      for (var k in newHash) {
        var fullKey = prefix + k;

        if (fullKey in hash[lang]) {
          res = false;
        } else if (typeof newHash[k] === 'string') {
          hash[lang][fullKey] = newHash[k];
        } else {
          this._addTextWithPrefix(fullKey + '.', lang, newHash[k]);
        }
      }

      return res;
    };
    /** Добавить строки в словарь локализации
     @func addText
     @memberOf nsGmx.Translations
     @param {String} lang Язык, к которому добавляются строки
     @param {Object} strings Список добавляемых строк. Должен быть объектом, в котором атрибуты являются ключами перевода.
                     Если значение атрибута - строка, то она записывается как результат локализации данного ключа.
                     Если значение атрибута - другой объект, то название текущего атрибута будет добавлено с точкой 
                     к названию атрибутов в этом объекте. Например: {a: {b: 'бэ', c: 'це'}} сформируют ключи локализации 'a.b' и 'a.c'.
    */


    TranslationsManager.prototype.addText = function (lang, newHash) {
      this._addTextWithPrefix('', lang, newHash);
    };
    /** Получить локализованный текст по ключу для текущего языка
     @func getText
     @memberOf nsGmx.Translations
     @param {String} key Ключ локализации
     @return {String} Локализованный текст
    */


    TranslationsManager.prototype.getText = function (dictKey) {
      var lang = this.getLanguage(),
          args = arguments,
          getArg = function getArg(i) {
        return args[i + 1] || '';
      };

      if (!this.hash[lang] || !this.hash[lang][dictKey]) {
        this._errorHandlers.forEach(function (handler) {
          handler(dictKey, lang);
        });

        return '';
      } else {
        return this.hash[lang][dictKey].replace(/\[value(\d)\]/g, function (match, argIndex) {
          return getArg(Number(argIndex));
        });
      }
    };
    /** Установить текущий язык
     @func setLanguage
     @memberOf nsGmx.Translations
     @param {String} lang Текущий язык (eng/rus/...)
    */


    TranslationsManager.prototype.setLanguage = function (lang) {
      TranslationsManager.prototype._language = lang;
    };
    /** Получить текущий язык локализации
     @func getLanguage
     @memberOf nsGmx.Translations
     @return {String} Текущий язык (eng/rus/...)
    */


    TranslationsManager.prototype.getLanguage = function () {
      return TranslationsManager.prototype._language || typeof window !== 'undefined' && window.language || DEFAULT_LANGUAGE;
    };
    /** Добавить обработчик ошибок локализации. 
        При возникновении ошибок (не определён язык, не найден перевод) будет вызываться каждый из обработчиков
     @func addErrorHandler
     @memberOf nsGmx.Translations
     @param {function(text, lang)} Обработчик ошибки. В ф-цию передаётся текст и язык
    */


    TranslationsManager.prototype.addErrorHandler = function (handler) {
      this._errorHandlers.push(handler);
    };
    /** Считать из кук текущий язык локализации.
     * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
     @func getLanguageFromCookies
     @memberOf nsGmx.Translations
     @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
     @return {String} Язык, записанный в куках для данного pathname
    */


    TranslationsManager.prototype.getLanguageFromCookies = function (pathname) {
      return _parseLanguageCookie()[pathname || window.location.pathname];
    };
    /** Записать в куки текущий язык локализации.
     * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
     @func updateLanguageCookies
     @memberOf nsGmx.Translations
     @param {String} lang Язык, который нужно записать в куку
     @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
    */


    TranslationsManager.prototype.updateLanguageCookies = function (lang, pathname) {
      var langs = _parseLanguageCookie();

      langs[pathname || window.location.pathname] = lang;

      _saveLanguageCookie(langs);
    };
    /** Ф-ции для локализации пользовательского интерфейса
     @namespace nsGmx.Translations
    */


    var commonTranslationsManager = new TranslationsManager();
    TranslationsManager.commonManager = commonTranslationsManager; //хелпер для вставки локализованных констант в шаблоны. Например: {{i "layerEditor.dialogTitle"}}

    var addHanlebarsHelper = function addHanlebarsHelper(Handlebars) {
      Handlebars.registerHelper('i', function (dictKey) {
        return commonTranslationsManager.getText(dictKey);
      });
    };

    addHanlebarsHelper(Handlebars);
    nsGmx$1.Translations = commonTranslationsManager; //Поддерживаем обратную совместимость - глобальные объекты _gtxt, _translationsHash, translationsHash

    var prev_gtxt = window._gtxt,
        prev_translationsHash = window._translationsHash,
        prevTranslationsHash = window.translationsHash;
    /** Убирает из глобальной видимости все объекты и ф-ции, связанные с локализацией
     @name noConflicts
     @memberOf nsGmx.Translations
    */

    TranslationsManager.prototype.noConflicts = function () {
      window._gtxt = prev_gtxt;
      window._translationsHash = prev_translationsHash;
      window.translationsHash = prevTranslationsHash;
    }; //Явно добавляем объекты в глобальную видимость


    var DumpClass = function DumpClass() {};

    DumpClass.prototype = commonTranslationsManager;
    window._translationsHash = new DumpClass();
    window._translationsHash.gettext = commonTranslationsManager.getText.bind(commonTranslationsManager);
    window._translationsHash.addtext = commonTranslationsManager.addText.bind(commonTranslationsManager);

    window._translationsHash.showLanguages = function () {
      var langCanvas = _div(null, [['dir', 'className', 'floatRight'], ['css', 'margin', ' 7px 10px 0px 0px']]);

      for (var lang in this.hash) {
        if (lang != window.language) {
          var button = makeLinkButton(window._translationsHash.titles[lang]);
          button.style.marginLeft = '5px';
          button.style.fontSize = '11px';

          button.onclick = function (lang) {
            window.translationsHash.updateLanguageCookies(lang);

            if (nsGmx$1 && nsGmx$1.GeomixerFramework) {
              window.language = lang;

              _mapHelper.reloadMap();
            } else {
              window.location.reload();
            }
          }.bind(null, lang);

          _title(button, this.titles[lang]);

          langCanvas.appendChild(button);
        } else {
          langCanvas.appendChild(_span([_t(window._translationsHash.titles[lang])], [['css', 'marginLeft', '5px'], ['css', 'color', '#fc830b']]));
        }
      }

      document.getElementById("headerLinks").appendChild(langCanvas);
    };

    window._gtxt = function () {
      return commonTranslationsManager.getText.apply(commonTranslationsManager, arguments);
    };

    window.translationsHash = {
      getLanguageFromCookies: commonTranslationsManager.getLanguageFromCookies.bind(commonTranslationsManager),
      updateLanguageCookies: commonTranslationsManager.updateLanguageCookies.bind(commonTranslationsManager)
    };
    window.gmxCore && window.gmxCore.addModule('translations', {
      _translationsHash: window._translationsHash
    });
    var translationsHash = window.translationsHash;

    _translationsHash.flags["rus"] = "img/flag_ru.png";
    _translationsHash.titles["rus"] = "Русский";
    _translationsHash.hash["rus"] = {
      "Да": "Да",
      "Нет": "Нет",
      "Карта": "Карта",
      "Создать": "Создать",
      "Создать карту": "Создать карту",
      "Сохранить": "Сохранить",
      "Сохранить как": "Сохранить как",
      "Сохранить карту как": "Сохранить карту как",
      "Сохранить карту": "Сохранить карту",
      "Экспорт": "Экспорт",
      "Ссылки": "Ссылки",
      "Карта пожаров": "Карта пожаров",
      "Платформа Геомиксер": "Веб-ГИС GeoMixer",
      "http://fires.ru": "http://fires.ru",
      "https://search.kosmosnimki.ru": "https://search.kosmosnimki.ru",
      "Данные": "Данные",
      "Сервисы": "Сервисы",
      "Поделиться": "Поделиться",
      "Открыть слой": "Открыть слой",
      "Создать слой": "Создать слой",
      "Растровый": "Растровый",
      "Векторный": "Векторный",
      "Создать группу": "Создать группу",
      "Базовые слои": "Базовые слои",
      "Подключить WMS": "Подключить WMS",
      "Подключить WFS": "Подключить WFS",
      "Объекты": "Объекты",
      "Результаты поиска": "Результаты поиска",
      "Буфер": "Буфер",
      "Создание буферных зон": "Создание буферных зон",
      "Ручная привязка растров": "Ручная привязка растров",
      "Поиск слоев на карте": "Поиск слоев на карте",
      "Краудсорсинг данных": "Краудсорсинг данных",
      "Пакетный геокодинг": "Пакетный геокодинг",
      "Маршруты": "Маршруты",
      "Кадастр Росреестра": "Кадастр Росреестра",
      "Выбрать кадастровый объект": "Выбрать кадастровый объект",
      "Викимапиа": "Викимапиа",
      "Каталог СКАНЭКС": "Поиск снимков",
      "Космоснимки-пожары": "Космоснимки-пожары",
      "GIBS NASA": "Съёмка MODIS (NASA)",
      "Руководство пользователя": "Документация",
      "Руководство": "Руководство пользователя",
      "GeoMixer API": "GeoMixer API",
      "Использование плагинов": "Использование плагинов",
      "копия": "копия",
      "Открыть": "Открыть",
      "Слой": "Слой",
      "Создать векторный слой": "Создать векторный слой",
      "Создать растровый слой": "Создать растровый слой",
      "Создать мультислой": "Создать мультислой",
      "Вид": "Вид",
      "Дерево слоев": "Дерево слоев",
      "Объекты на карте": "Объекты на карте",
      "Координатная сетка": "Координатная сетка",
      "Индексная сетка": "Индексная сетка",
      "Панель оверлеев": "Панель оверлеев",
      "Загрузить объекты": "Загрузить объекты",
      "Загрузить фотографии": "Загрузить фотографии",
      "Загрузить данные": "Загрузить данные",
      "WFS сервер": "WFS сервер",
      "WMS сервер": "WMS сервер",
      "Кадастровые данные": "Кадастровые данные",
      "Ссылка на карту": "Ссылка на карту",
      "Код для вставки": "Код для вставки карты",
      "Печать": "Печать",
      "Привязать изображение": "Привязать изображение",
      "Сообщить об ошибке на карте": "Сообщить об ошибке на карте",
      "Справка": "Справка",
      "Использование": "Использование",
      "О проекте": "О проекте/Контакты",
      "$$phrase$$_1": "Укажите карту в параметре defaultMapID в файле config.js",
      "У вас нет прав на просмотр данной карты": "У вас нет прав на просмотр данной карты",
      "Access error": "У вас нет прав на просмотр данной карты",
      "Map not found": "Данная карта не существует",
      "Unable to locate EXIF content": "отсутствуют координаты в EXIF",
      "Развернуть карту": "Развернуть карту",
      "Свернуть карту": "Свернуть карту",
      "Точки на изображении:": "Точки на изображении:",
      "Точки на карте:": "Точки на карте:",
      "Координаты": "Координаты",
      "Нарисовать": "Нарисовать",
      "Восстановить": "Восстановить",
      "Видимость": "Видимость",
      "Привязка изображения": "Привязка изображения",
      "$$phrase$$_2": "Точка [value0] находится за пределами изображения",
      "$$phrase$$_3": "Не задана точка [value0] на карте",
      "Соответствие точек": "Соответствие точек",
      "$$phrase$$_4": "Точки 1 и 2 на изображении совпадают",
      "$$phrase$$_5": "Точки 1 и 3 на изображении совпадают",
      "$$phrase$$_6": "Точки 2 и 3 на изображении совпадают",
      "$$phrase$$_7": "Точки 1 и 2 на карте совпадают",
      "$$phrase$$_8": "Точки 1 и 3 на карте совпадают",
      "$$phrase$$_9": "Точки 2 и 3 на карте совпадают",
      "$$phrase$$_10": "Точки на изображении лежат на одной прямой",
      "Создать экскурсию": "Создать экскурсию",
      "Чтобы пользоваться этим сайтом, установите Flash Player": "Чтобы пользоваться этим сайтом, установите Flash Player",
      "из Интернет": "из Интернет",
      "или с локального диска ": "или с локального диска ",
      "для Internet Explorer": "для Internet Explorer",
      " или ": " или ",
      "для Internet Firefox": "для Internet Firefox",
      "Скачать shp-файл": "Скачать shp-файл",
      "shp-файл": "shp-файл",
      "gpx-файл": "gpx-файл",
      "Скачать фрагмент растра": "Скачать фрагмент растра",
      "точка": "точка",
      "линия": "линия",
      "прямоугольник": "прямоугольник",
      "многоугольник": "многоугольник",
      "Скачать": "Скачать",
      "Введите имя файла для скачивания": "Введите имя файла для скачивания",
      "Выберите область рамкой на карте": "Выберите область рамкой на карте",
      "Вырезать фрагмент растра": "Вырезать фрагмент растра",
      "К прямоугольнику не подходит ни одного растрового слоя": "К прямоугольнику не подходит ни одного растрового слоя",
      "Загруженный shp-файл пуст": "Загруженный shp-файл пуст",
      "Ошибка скачивания": "Ошибка скачивания",
      "Обновить": "Обновить",
      "Домашняя директория": "Директория проекта",
      "Имя папки": "Имя папки",
      "Имя": "Имя",
      "Размер": "Размер",
      "Дата": "Дата",
      "Дата создания": "Дата создания",
      "Снять выделение": "Снять выделение",
      "Скопировать": "Скопировать",
      "Удалить": "Удалить",
      "Извлечь": "Извлечь",
      "Упаковать": "Упаковать",
      "Загрузить": "Загрузить",
      "Параметр": "Параметр",
      "Значение": "Значение",
      "VALUE": "VALUE",
      "WHERE": "WHERE",
      "Операторы": "Операторы",
      "Функции": "Функции",
      "Метаданные": "Метаданные",
      "Редактировать колонки": "Редактировать колонки",
      "URL сервера": "URL сервера",
      "Формат изображения": "Формат изображения",
      "Введите имя gml-файла для скачивания:": "Введите имя gml-файла для скачивания:",
      "точки": "точки",
      "линии": "линии",
      "полигоны": "полигоны",
      "(ссылка)": "(ссылка)",
      "Сохранить состояние карты": "Сохранить состояние карты",
      "Ссылка на текущее состояние карты": "Ссылка на текущее состояние карты",
      "Добавить стиль": "Добавить стиль",
      "Атрибут >": "Атрибут >",
      "Значение >": "Значение >",
      "Операция >": "Операция >",
      "Накладываемое изображение": "Накладываемое изображение",
      "Цвет": "Цвет",
      "Прозрачность": "Прозрачность",
      "Авторизуйтесь для редактирования фильтров": "Авторизуйтесь для редактирования фильтров",
      "Имя фильтра": "Имя фильтра",
      "Переместить фильтр вверх": "Переместить фильтр вверх",
      "Переместить фильтр вниз": "Переместить фильтр вниз",
      "Удалить фильтр": "Удалить фильтр",
      "Размер шрифта": "Размер шрифта",
      "Смещение": "Смещение",
      "Смещение по x": "Смещение по x",
      "Смещение по y": "Смещение по y",
      "Имя атрибута": "Имя атрибута",
      "Граница обрезки": "Граница обрезки",
      "Граница": "Граница",
      "Толщина линии": "Толщина линии",
      "Заливка": "Заливка",
      "Заливка цветом": "Заливка цветом",
      "Заливка штриховкой": "Заливка штриховкой",
      "Заливка рисунком": "Заливка рисунком",
      "Ширина паттерна": "Ширина паттерна",
      "Ширина отступа": "Ширина отступа",
      "URL рисунка": "URL рисунка",
      "Маркер URL": "Маркер URL",
      "URL изображения": "URL изображения",
      "Изображение": "Изображение",
      "Размер точек": "Размер точек",
      "Редактировать стили": "Редактировать стили",
      "Авторизуйтесь для редактирования настроек слоя": "Авторизуйтесь для редактирования настроек слоя",
      "Недостаточно прав для редактирования настроек слоя": "Недостаточно прав для редактирования настроек слоя",
      "Недостаточно прав для редактирования объектов слоя": "Недостаточно прав для редактирования объектов слоя",
      "ID": "ID",
      "Описание": "Описание",
      "Файл": "Файл",
      "Таблица": "Таблица",
      "Каталог с тайлами": "Каталог с тайлами",
      "Каталог растров": "Каталог растров",
      "Источник": "Источник",
      "Данные с датой": "Разбить по датам",
      "Дополнительно": "Дополнительно",
      "Шаблон названий объектов": "Шаблон названий объектов",
      "Y (широта)": "Y (широта)",
      "X (долгота)": "X (долгота)",
      "Каталог": "Каталог",
      "Изменить": "Изменить",
      "Вид вложенных элементов": "Вид вложенных элементов",
      "Использовать KosmosnimkiAPI": "Загрузить подложки Kosmosnimki",
      "Использовать OpenStreetMap": "Использовать OpenStreetMap",
      "Язык по умолчанию": "Язык по умолчанию",
      "Единицы длины": "Единицы длины",
      "Единицы площади": "Единицы площади",
      "Формат координат": "Формат координат",
      "units.auto": "авто",
      "units.m": "м",
      "units.km": "км",
      "units.nm": "м. мили",
      "units.m2": "м<sup>2",
      "units.ha": "га",
      "units.km2": "км<sup>2",
      "coords.dd": "dd.dddd",
      "coords.dms": "dd°mm′ss″",
      "Генерализация": "Генерализация",
      "gereralization.on": "включить",
      "gereralization.off": "выключить",
      "gereralization.disable": "использовать настройки слоев",
      "Количество информационных окошек": "Количество информационных окошек",
      "layerOrder.title": "Порядок слоёв",
      "layerOrder.native": "Стандартный",
      "layerOrder.vectorOnTop": "Вектора сверху",
      "Разрешить поиск в векторных слоях": "Разрешить поиск в векторных слоях",
      "Начальная позиция": "Начальная позиция",
      "Широта": "Широта",
      "Долгота": "Долгота",
      "placeholder degrees": "dd.dddd",
      "placeholder zoom": "1-21",
      "placeholder minZoom": "1",
      "placeholder maxZoom": "21",
      "Зум": "Зум",
      "Ссылка (permalink)": "Ссылка (permalink)",
      "Разрешить скачивание": "Разрешить скачивание",
      "Векторных слоев": "Векторных слоев",
      "Растровых слоев": "Растровых слоев",
      "Масштабирование в миникарте": "Масштабирование в миникарте",
      "Показывать всплывающие подсказки": "Показывать всплывающие подсказки",
      "Свойства": "Свойства",
      "Создать копию слоя": "Создать копию слоя",
      "Стили": "Стили",
      "Изображение на карте": "Изображение на карте",
      "Слой [value0]": "Слой [value0]",
      "Стили слоя [value0]": "Стили слоя [value0]",
      "Мультислой [value0]": "Мультислой [value0]",
      "Группа [value0]": "Группа [value0]",
      "Карта [value0]": "Карта [value0]",
      "Редактировать стиль": "Редактировать стиль",
      "Редактирование стилей объекта": "Редактирование стилей объекта",
      "Стили слоя": "Стили слоя",
      "Навигация по карте и инструменты": "Навигация по карте и инструменты",
      "Стиль векторного слоя": "Стиль векторного слоя",
      "Управление содержанием карты": "Управление содержанием карты",
      "Пользовательские инструменты": "Пользовательские инструменты",
      "$$help$$_1": "Держите нажатой левую клавишу мыши – перетаскивайте карту курсором. Для приближения и удаления используйте колесико мыши (карта зуммируется к точке под курсором). Для перецентровки по координатам – введите их в строке поиска.",
      "$$help$$_2": "В левой панели отображается список слоев в виде дерева. Для перецентровки карты по экстенту слоя – кликните по его названию в списке. Если данная опция включена администратором карты, вы можете скачивать векторные слои и вырезать и скачивать фрагменты растровых слоев.",
      "$$help$$_3": "Для редактирования стиля векторного слоя кликните на иконку перед названием слоя.",
      "$$help$$_4": "Карта представляет собой набор слоев, отображение которого задается с помощью списка слоев. Чтобы иметь возможность редактировать набор слоев (создавать группы, изменять порядок отображения и т.д.) и сохранять изменения – необходимо авторизоваться. Более подробно см ",
      " - Руководство пользователя": " - Руководство пользователя",
      "$$help$$_5": "Пользовательские инструменты одновременно служат для создания объектов на карте, которые затем можно сохранять через «ссылку на карту», и для выполнения простых аналитических функций. ",
      "В режиме маркеров: ": "В режиме маркеров: ",
      "$$help$$_6": "одиночный клик - добавить маркер. Двойной клик по маркеру - удалить. Клик на маркер – открыть всплывающее окошко (балун), клик по балуну – добавить надпись.",
      "В режиме линейка/измерения расстояния, полигон/измерение площади: ": "В режиме линейка/измерения расстояния, полигон/измерение площади: ",
      "$$help$$_7": "одиночный клик - добавить вершину. Двойной клик - завершить фигуру. Клик на линию - добавить вершину. Двойной клик по вершине - удалить.",
      "$$help$$_8": "Кликните по объекту в списке «объектов на карте», чтобы перецентровать карту на него. Вы можете скачать контуры объектов в shp/tab/kml формате.",
      "$$about$$_1": "это веб-приложение для интерактивного просмотра геоданных и доступа к источникам базовых геоданных в интернете, таким как: ",
      "$$about$$_2": "С помощью GeoMixer можно публиковать собственные геоданные во внутренней сети предприятий или в интернет, накладывать их поверх базовых источников и предоставлять к ним доступ для совместной работы сколь угодно большому числу пользователей, разграничивая права доступа.",
      "$$about$$_3": "GeoMixer также включает компонент API, который позволяет встраивать созданные проекты в сторонние веб-сайты и приложения и программно управлять фукционалом интерактивной карты.",
      " - Общее описание": " - Общее описание",
      " - Руководство разработчика": " - Руководство разработчика",
      "Получить API-ключ": "Получить API-ключ",
      "Введите API-ключ": "Введите API-ключ",
      "Печать карты": "Печать карты",
      "$$serviceHelp$$_1": "Позволяет на лету загрузить shp/tab/kml файл небольшого размера в виде пользовательских объектов. После загрузки пользователь может редактировать геометрию объектов и скачивать объекты в том же наборе форматов.",
      "$$serviceHelp$$_2": "По ссылке запоминается текущее положение карты, а так же пользовательские объекты и надписи.",
      "$$serviceHelp$$_3": "Отправляет на печать текущий фрагмент карты.",
      "Редактировать": "Редактировать",
      "Удалить объект?": "Удалить объект?",
      "Удалить отмеченные объекты?": "Удалить отмеченные объекты?",
      "Длина": "Длина",
      "Площадь": "Площадь",
      "Добавить подгруппу": "Добавить группу",
      "Введите имя группы": "Создание новой группы",
      "Имя группы": "Имя группы",
      "Включая вложенные слои": "Включая вложенные слои",
      "Удаление группы [value0]": "Удаление группы [value0]",
      "Сохранено": "Сохранено",
      "Прозрачность выбранного слоя/группы/карты": "Прозрачность выбранного слоя/группы/карты",
      "$$updateInfo$$_1": "Для отображения нового слоя необходимо сохранить и перезагрузить карту",
      "Любой": "Любой",
      "Владелец": "Владелец",
      "Последнее изменение": "Последнее изменение",
      "Список слоев": "Список слоев",
      "Вы действительно хотите удалить этот слой?": "Вы действительно хотите удалить этот слой?",
      "Ошибка!": "Ошибка!",
      "Ошибка": "Ошибка",
      "Выберите колонку": "Выберите колонку",
      "Список карт": "Список карт",
      "Показать": "Показать",
      "загрузка...": "загрузка...",
      "удаление...": "удаление...",
      "Вы действительно хотите удалить эту карту?": "Вы действительно хотите удалить эту карту?",
      "maplist.hint": "Группы и слои можно перетащить в текущую карту",
      "Слоя нет в базе": "Слоя нет в базе",
      "ScanEx Web Geomixer - просмотр карты": "ScanEx Web Geomixer - просмотр карты",
      "Изменить параметры поиска": "Изменить параметры поиска",
      "$$search$$_1": "Поиск по векторным слоям и адресной базе",
      "$$search$$_2": "Поиск по адресной базе",
      "Поиск не дал результатов": "Поиск не дал результатов",
      "Очистить": "Очистить",
      "Регистрация": "Регистрация",
      "Восстановление пароля": "Восстановление пароля",
      "Вход": "Вход",
      "Выход": "Выход",
      "Логин": "Логин",
      "Пароль": "Пароль",
      "пароль": "пароль",
      "Псевдоним": "Псевдоним",
      "Полное имя": "Полное имя",
      "Пожалуйста, авторизуйтесь": "Пожалуйста, авторизуйтесь",
      "адрес электронной почты": "адрес электронной почты",
      "Ошибка сервера": "Ошибка сервера",
      "Папка": "Папка",
      " и ": " и ",
      "Название": "Название",
      "Рейтинг": "Рейтинг",
      "Автор": "Автор",
      "Тематика": "Тематика",
      "Развлекательная": "Развлекательная",
      "Спортивная": "Спортивная",
      "Историческая": "Историческая",
      "Экологическая": "Экологическая",
      "Любая": "Любая",
      "Создать новую тему": "Создать новую тему",
      "Начало периода": "Начало периода",
      "Окончание периода": "Окончание периода",
      "Накладываемые тайлы": "Накладываемые тайлы",
      "Отображать с зума": "Отображать с зума",
      "По": "по",
      "Фильтр": "Фильтр",
      "Подпись": "Подпись",
      "Балун": "Подсказка при наведении и клике",
      "По умолчанию": "По умолчанию",
      "Показывать при клике": "Показывать при клике",
      "Показывать при наведении": "Показывать при наведении",
      "Символика": "Символика",
      "Библиотека стилей": "Библиотека стилей",
      "Настройка стилей": "Настройка стилей",
      "скопировать": "скопировать",
      "применить везде": "применить везде",
      "Применить": "Применить",
      "Кластеризация": "Кластеризация",
      "Минимальный": "Минимальный",
      "Максимальный": "Максимальный",
      "Мин. зум": "Мин. зум",
      "Макс. зум": "Макс. зум",
      "Тип": "Тип",
      "Пешеходная": "Пешеходная",
      "Велосипедная": "Велосипедная",
      "Автомобильная": "Автомобильная",
      "Речная": "Речная",
      "Места": "Места",
      "Маршрут": "Маршрут",
      "Редактировать экскурсию": "Редактировать экскурсию",
      "Добавьте маршрут": "Добавьте маршрут",
      "Выберете темы на пути следования": "Выберете темы на пути следования",
      "$$phrase$$_11": "Добавьте маршрут при помощи инструмента \"Линия\" на панели инструментов",
      "$$phrase$$_12": "Нет подходящих объектов на карте",
      "Выбор маршрута": "Выбор маршрута",
      "Выбор мест": "Выбор мест",
      "$$phrase$$_13": "У вас нет опубликованных тем на карте. Вы можете добавить тему в разделе Вид-Обсуждения",
      "Обсуждения": "Обсуждения",
      "Экскурсии": "Экскурсии",
      "$$phrase$$_14": "Невозможно удалить карту, использующуюся в качестве карты по умолчанию",
      "$$phrase$$_15": "Невозможно удалить загруженную карту",
      "Назад": "Назад",
      "Вперед": "Вперед",
      "$$phrase$$_16": "Альбома с указанным ID изображения не существует",
      "Редактировать альбом": "Редактировать альбом",
      "Оценить": "Оценить",
      "Поставьте маркер": "Поставьте маркер",
      "на карту и переместите его в нужное место.": "на карту и переместите его в нужное место.",
      "Недостаточно прав для совершения операции": "Недостаточно прав для совершения операции",
      "Новая папка": "Новая папка",
      "Выбрать": "Выбрать",
      "Добавить": "Добавить",
      "$$serviceHelp$$_4": "Пользователь может встроить созданную карту в другой сайт, скопировав код и вставив его внутрь HTML. Требуется указать api-ключ для сайта, на котором будет использоваться данный код.",
      "Масштаб": "Масштаб",
      "Угол поворота": "Угол поворота",
      "Диаграммы": "Диаграммы",
      "График по времени": "График по времени",
      "Маска атрибутов": "Маска атрибутов",
      "Закладки": "Закладки",
      "Добавить закладку": "Добавить закладку",
      "Имя закладки": "Имя закладки",
      "Дерево": "Дерево",
      "Поиск слоев": "Поиск слоев",
      "Пример выражения": "[Атрибут1]\n[Атрибут2]\nпроизвольный текст",
      "Шкала прозрачности": "Шкала прозрачности",
      "Цвет заливки": "Цвет заливки",
      "Цвет обводки": "Цвет обводки",
      "Цвет шрифта": "Цвет шрифта",
      "Легенда": "Легенда",
      "Событие загрузки карты": "Событие загрузки карты",
      "Мин": "Мин",
      "Макс": "Макс",
      "График": "График",
      "Гистограмма": "Гистограмма",
      "Столбчатая": "Столбчатая",
      "Временная": "Временная",
      "Круговая": "Круговая",
      "Копировать стиль": "Копировать стиль",
      "Применить стиль": "Применить стиль",
      "Не выбран стиль": "Не выбран стиль",
      "Невозможно применить стиль к другому типу геометрии": "Невозможно применить стиль к другому типу геометрии",
      "Общие": "Общие",
      "Доступ": "Доступ",
      "Окно карты": "Окно карты",
      "Загрузка": "Загрузка",
      "Копирайт": "Копирайт",
      "Инструменты": "Инструменты",
      "Загрузить KML": "Загрузить KML",
      "URL файла": "URL файла",
      "Поиск": "Поиск",
      "Подложки": "Подложки",
      "Доступные подложки": "Доступные подложки",
      "Подложки карты": "Подложки карты",
      "Выберите слои для поиска по атрибутам": "Выберите слои для поиска по атрибутам",
      "Включить синхронизацию слоев": "Включить синхронизацию слоев",
      "Выключить синхронизацию слоев": "Выключить синхронизацию слоев",
      "Редактирование прав доступа карты [value0]": "Редактирование прав доступа карты [value0]",
      "Редактирование прав доступа слоя [value0]": "Редактирование прав доступа слоя [value0]",
      "Редактирование прав доступа слоев карты [value0]": "Редактирование прав доступа слоев карты [value0]",
      "Состав группы [value0]": "Состав группы [value0]",
      "Роль": "Роль",
      "Добавить пользователя": "Добавить пользователя",
      "Права доступа": "Права доступа",
      "Права доступа к слоям": "Права доступа к слоям",
      "Пользователи без прав доступа:": "Пользователи без прав доступа:",
      "Пользователи с правами доступа:": "Пользователи с правами доступа:",
      "Выберите нового владельца": "Выберите нового владельца",
      "Сменить владельца": "Сменить владельца",
      "Объекты RuMap": "Данные RuMap",
      "Объекты пользователей": "Данные пользователей",
      "Контакты": "Контакты",
      "Фотографии": "Фотографии",
      "Момент съемки": "Момент съемки",
      "Видео": "Видео",
      "Сообщения": "Сообщения",
      "Ссылка на место": "Ссылка на место",
      "Ссылка на экскурсию": "Ссылка на экскурсию",
      "Ссылка на событие": "Ссылка на событие",
      "Создать новое событие": "Создать новое событие",
      "События": "События",
      "Календарь": "Календарь",
      "Новости": "Новости",
      "Мероприятия": "Мероприятия",
      "Отмена": "Отмена",
      "Пропустить": "Пропустить",
      "Время": "Время",
      "Альбом OpenPhotoVR": "Фотоальбом",
      "Встраиваемый код": "Встраиваемое видео",
      "Объекты экологического риска": "Объекты экологического риска",
      "Санкционированные свалки": "Санкционированные свалки",
      "Несанкционированные свалки": "Несанкционированные свалки",
      "Полигоны отходов": "Полигоны отходов",
      "Предприятия переработки отходов": "Предприятия переработки отходов",
      "Факельные установки, ТЭЦ, трубы": "Факельные установки, ТЭЦ, трубы",
      "Закрытые свалки": "Закрытые свалки",
      "Пункты приема отходов": "Пункты приема отходов",
      "Оползни": "Оползни",
      "Карстовые явления": "Карстовые явления",
      "Суффозионные явления": "Суффозионные явления",
      "Государство и общество": "Государство и общество",
      "Радио": "Радиостанции",
      "Правительственные учреждения": "Правительственные учреждения",
      "Оптики": "Оптики",
      "Охранные агенства": "Охранные агенства",
      "Травмпункты": "Травмпункты",
      "Таможня": "Таможня",
      "Ветеринарные клиники": "Ветеринарные клиники",
      "ЗАГС": "ЗАГС",
      "Больницы": "Больницы",
      "Аптеки": "Аптеки",
      "Поликлиники": "Поликлиники",
      "Колледжи": "Колледжи",
      "Университеты": "Университеты",
      "ОВИР": "ОВИР",
      "Посольства": "Посольства",
      "Почтовые отделения": "Почтовые отделения",
      "Суды": "Суды",
      "Банки": "Банки",
      "Родильные дома": "Родильные дома",
      "Дома престарелых": "Дома престарелых",
      "Детские сады": "Детские сады",
      "Школы": "Школы",
      "Инспекции": "Инспекции",
      "Адвокаты": "Адвокаты",
      "МЧС": "МЧС",
      "Муниципальные учреждения": "Муниципальные учреждения",
      "Администрация": "Администрация",
      "Культура и отдых": "Культура и отдых",
      "Боулинг": "Боулинг",
      "Аквапарки": "Аквапарки",
      "Парки развлечений": "Парки развлечений",
      "Библиотеки": "Библиотеки",
      "Памятники": "Памятники",
      "Лагери отдыха": "Лагери отдыха",
      "Кинотеатры": "Кинотеатры",
      "Цирки": "Цирки",
      "Галереи": "Галереи",
      "Отели": "Отели",
      "Мотели": "Мотели",
      "Музеи": "Музеи",
      "Концертные залы": "Концертные залы",
      "Ночные клубы": "Ночные клубы",
      "Театры": "Театры",
      "Санатории": "Санатории",
      "Зоопарки": "Зоопарки",
      "Общественное питание": "Общественное питание",
      "Кафе": "Кафе",
      "Фастфуды": "Фастфуды",
      "Рестораны": "Рестораны",
      "Кафе-мороженое": "Кафе-мороженое",
      "Столовые": "Столовые",
      "Природные достопримечательности": "Природные достопримечательности",
      "Ботанический сад": "Ботанические сады",
      "Пещеры": "Пещеры",
      "Водопады": "Водопады",
      "Парки": "Парки",
      "Источники": "Источники",
      "Заповедники": "Заповедники",
      "Прочие архитектурные и природные достопримечательности": "Архитектурные достопримечательности",
      "Религия": "Религия",
      "Культовые сооружения": "Культовые сооружения",
      "Мечети": "Мечети",
      "Монастыри": "Монастыри",
      "Церкви других христианских конфессий": "Церкви других христианских конфессий",
      "Православные церкви": "Православные церкви",
      "Синагоги": "Синагоги",
      "Спорт": "Спорт",
      "Стадионы": "Стадионы",
      "Теннисные корты": "Теннисные корты",
      "Катки": "Катки",
      "Ипподромы": "Ипподромы",
      "Фитнес": "Фитнес",
      "Бассейны": "Бассейны",
      "Прокат спортинвентаря": "Прокат спортинвентаря",
      "Торговля и услуги": "Торговля и услуги",
      "Солярии": "Солярии",
      "Интернет-кафе": "Интернет-кафе",
      "Рынки": "Рынки",
      "Стоматологические клиники": "Стоматологические клиники",
      "Магазины одежды": "Магазины одежды",
      "Парикмахерские": "Парикмахерские",
      "Бани": "Бани",
      "Магазины обуви": "Магазины обуви",
      "Магазины": "Магазины",
      "Ателье": "Ателье",
      "Такси": "Такси",
      "Туризм": "Туризм",
      "Транспорт и услуги": "Транспорт и услуги",
      "Аэропорты": "Аэропорты",
      "Автосервисы": "Автосервисы",
      "Автовокзалы": "Автовокзалы",
      "ДПС": "ДПС",
      "ГИБДД": "ГИБДД",
      "Шиномонтаж": "Шиномонтаж",
      "Парковки бесплатные": "Парковки бесплатные",
      "Парковки платные": "Парковки платные",
      "АЗС": "АЗС",
      "Автомойки": "Автомойки",
      "Экстренные службы": "Экстренные службы",
      "Пожарные/спасатели": "Пожарные/спасатели",
      "Милиция": "Милиция",
      "Скорая помощь": "Скорая помощь",
      "Другие темы": "Другие темы",
      "Разное": "Разное",
      "Изменение пароля": "Изменение пароля",
      "Новый пароль": "Новый пароль",
      "Старый пароль": "Старый пароль",
      "Подтвердите пароль": "Подтвердите пароль",
      "Контур": "Контур",
      "$$phrase$$_17": "Добавьте контур при помощи инструмента \"Полигон\" на панели инструментов",
      "Выбор контура": "Выбор контура",
      "Таблица атрибутов слоя [value0]": "Таблица атрибутов слоя [value0]",
      "Показать параметры поиска": "Показать параметры поиска",
      "Скрыть параметры поиска": "Скрыть параметры поиска",
      "Скрыть": "Скрыть",
      "SQL-условие WHERE": "SQL-условие WHERE",
      "Искать внутри полигона": "Искать внутри полигона",
      "Искать по пересечению с объектом": "Искать по пересечению с объектом",
      "Колонки": "Колонки",
      "Показывать колонки": "Показывать колонки",
      "Скрыть колонки": "Скрыть колонки",
      "Найти": "Найти",
      "Нет полей": "Нет полей",
      "Нет данных": "Нет данных",
      "Таблица атрибутов": "Таблица атрибутов",
      "Разрешить поиск": "Разрешить поиск",
      "Произвольный": "Произвольный",
      "День": "День",
      "Неделя": "Неделя",
      "Месяц": "Месяц",
      "Год": "Год",
      "Ежегодно": "Ежегодно",
      "Облачность": "Облачность",
      "Период": "Период",
      "Спутниковые покрытия": "Спутниковые покрытия",
      "Редактировать объект слоя [value0]": "Редактировать объект слоя [value0]",
      "Создать объект слоя [value0]": "Создать объект слоя [value0]",
      "Геометрия": "Геометрия",
      "Найти объекты": "Найти объекты",
      "Добавить объекты": "Добавить объекты",
      "Обновить объекты": "Обновить объекты",
      "Копировать объекты": "Копировать объекты",
      "Объекты скопированы": "Объекты скопированы",
      "Объекты добавлены": "Объекты добавлены",
      "Вставить объекты": "Вставить объекты",
      "Вставить объекты не удалось": "Вставить объекты не удалось",
      "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"": "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"",
      "Изменить колонки": "Изменить колонки",
      "Обновить колонку": "Обновить колонку",
      "Очистить поиск": "Очистить поиск",
      "Скачать shp": "Скачать shp",
      "Скачать gpx": "Скачать gpx",
      "Скачать csv": "Скачать csv",
      "Скачать geojson": "Скачать geojson",
      "Рассчитать площадь": "Суммарная площадь",
      "Создать столбец": "Создать столбец",
      "Мультислой": "Мультислой",
      "В дереве слоев остались несохраненные изменения!": "В дереве слоев остались несохраненные изменения!",
      "файл версии отсутствует": "файл версии отсутствует",
      "оверлеи отсутствуют": "оверлеи отсутствуют",
      "Хост": "Хост",
      "Дополнительные карты": "Дополнительные карты",
      "Добавить карту": "Добавить карту",
      "Добавить в таймлайн": "Добавить в таймлайн",
      "Удалить из таймлайна": "Удалить из таймлайна",
      "Невозможно загрузить карту [value0] с домена [value1]": "Невозможно загрузить карту [value0] с домена [value1]",
      "Показывать": "Показывать",
      "Поиск снимков": "Поиск снимков",
      "Принудительно обновить тайлы": "Принудительно обновить тайлы",
      "Обводка": "Обводка",
      "Карта имеет более новую версию. Сохранить?": "Карта имеет более новую версию. Сохранить?",
      "Кодировка": "Кодировка",
      "helpPostfix": "_rus.html",
      "Показывать чекбокс видимости": "Чекбокс видимости",
      "Разворачивать автоматически": "Разворачивать автоматически",
      "Другая": "Другая",
      "Временнóй слой": "Мультивременнóй слой",
      "Колонка даты": "Колонка даты",
      "Минимальный период": "Мин. период (дни)",
      "Максимальный период": "Макс. период (дни)",
      "Отсутствует временной атрибут": "Отсутствует атрибут типа 'Дата'",
      "Период 1 день": "Период 1 день",
      "Показывать на карте данные за": "Показывать на карте данные за",
      "1 день": "1 день",
      "произвольный период": "произвольный период",
      "По границе экрана": "По границе экрана",
      "По центру экрана": "По центру экрана",
      "Пересечение": "Пересечение",
      "Пролистывать слои": "Пролистывать слои",
      "Следующий слой": "Следующий слой",
      "Предыдущий слой": "Предыдущий слой",
      "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.",
      "WMS доступ": "WMS/WFS доступ",
      "ссылка": "ссылка",
      "Слой '[value0]' уже есть в карте": "Слой '[value0]' уже есть в карте",
      "Группа '[value0]' уже есть в карте": "Группа '[value0]' уже есть в карте",
      "Плагины": "Плагины",
      "Вручную": "Вручную",
      "Добавить атрибут": "Добавить поле",
      "Проекция": "Проекция",
      "Широта/Долгота (EPSG:4326)": "Широта/Долгота (EPSG:4326)",
      "Меркатор (EPSG:3395)": "Меркатор (EPSG:3395)",
      "Из файла": "Из файла",
      "Мультиполигон": "Мультиполигон",
      "Мультилиния": "Мультилиния",
      "Мультиточка": "Мультиточка",
      "Администрирование": "Администрирование",
      "Системные настройки": "Системные настройки",
      "Управление группами": "Управление группами",
      "Управление группами пользователей": "Управление группами пользователей",
      "Добавить снимки": "Добавить растры",
      "Существующие слои": "Существующие слои",
      "Слои из карты": "Слои из карты",
      "Слои из КР": "Слои из КР",
      "Новый слой": "Новый слой",
      "С экрана": "С экрана",
      "Добавлен растр": "Добавлен растр",
      "Добавлены растры": "Добавлены растры",
      "Выбранный объект не имеет растра": "Выбранный объект не имеет растра",
      "Этот растр уже был выбран": "Этот растр уже был выбран",
      "Каталог Растров": "Каталог растров",
      "Растр": "Растр",
      "Добавить выбранные растры": "Добавить выбранные растры",
      "EditObject.menuTitle": "Добавить объект",
      "FileBrowser.ExceedLimitMessage": "Размер файла превышает 500 Мб. Используйте GeoMixerFileBrowser для загрузки больших файлов.",
      "FileBrowser.DropInfo": "Перетащите файлы сюда",
      "EditObject.drawingMenuTitle": "Добавить объект в активный слой",
      "Поставить маркер": "Поставить маркер",
      "Центрировать": "Центрировать",
      "Пароль изменён": "Пароль изменён",
      "портретная": "портретная",
      "альбомная": "альбомная",
      "gmx_geometry": "gmx_geometry"
    };

    _translationsHash.flags["eng"] = "img/flag_en.png";
    _translationsHash.titles["eng"] = "English";
    _translationsHash.hash["eng"] = {
      "Да": "Yes",
      "Нет": "No",
      "Карта": "Map",
      "Создать": "Create",
      "Создать карту": "Create map",
      "Сохранить": "Save",
      "Сохранить как": "Save as",
      "Сохранить карту как": "Save map as",
      "Сохранить карту": "Save map",
      "Экспорт": "Export",
      "Ссылки": "Links",
      "Карта пожаров": "Fires map",
      "Поиск снимков": "Search Imagery",
      "Платформа Геомиксер": "GeoMixer Web-GIS",
      "http://fires.ru": "http://fires-map.com",
      "https://search.kosmosnimki.ru": "https://search.kosmosnimki.ru/index_eng.html",
      "Данные": "Datasets",
      "Сервисы": "Services",
      "Поделиться": "Share",
      "Открыть слой": "Open layer",
      "Создать слой": "Create layer",
      "Растровый": "Raster",
      "Векторный": "Vector",
      "Создать группу": "Create group",
      "Базовые слои": "Base layers",
      "Подключить WMS": "Add WMS",
      "Подключить WFS": "Add WFS",
      "Объекты": "User objects",
      "Результаты поиска": "Search results",
      "Буфер": "Buffer",
      "Создание буферных зон": "Buffer zones",
      "Ручная привязка растров": "Manual rasters shift",
      "Поиск слоев на карте": "Search layers on map",
      "Краудсорсинг данных": "Crowdsourcing",
      "Пакетный геокодинг": "Batch geocode",
      "Маршруты": "Directions",
      "Кадастр Росреестра": "Cadastre data of Rosreestr",
      "Выбрать кадастровый объект": "Select Cadastre item",
      "Викимапиа": "Wikimapia",
      "Каталог СКАНЭКС": "Search imagery",
      "Космоснимки-пожары": "Kosmosnimki-fires",
      "GIBS NASA": "MODIS Images (NASA)",
      "Руководство пользователя": "Documentation",
      "Руководство": "User guide",
      "GeoMixer API": "GeoMixer API",
      "Использование плагинов": "Plugins usage",
      "копия": "копия",
      "Открыть": "Open",
      "Слой": "Layer",
      "Создать векторный слой": "Create vector layer",
      "Создать растровый слой": "Create raster layer",
      "Создать мультислой": "Create multilayer",
      "Вид": "View",
      "Дерево слоев": "Layers tree",
      "Объекты на карте": "Objects on map",
      "Координатная сетка": "Coordinate grid",
      "Индексная сетка": "Index grid",
      "Панель оверлеев": "Overlays panel",
      "Загрузить объекты": "Upload objects",
      "Загрузить фотографии": "Upload photos",
      "Загрузить данные": "Load data",
      "WFS сервер": "WFS server",
      "WMS сервер": "WMS server",
      "Кадастровые данные": "Cadastre data",
      "Ссылка на карту": "Link to the map",
      "Код для вставки": "Embed code",
      "Печать": "Print",
      "Привязать изображение": "Bind image",
      "Сообщить об ошибке на карте": "Report a map error",
      "Справка": "Help",
      "Использование": "Usage",
      "О проекте": "About/Contacts",
      "$$phrase$$_1": "Choose parameter defaultMapID in config.js file",
      "У вас нет прав на просмотр данной карты": "Sorry, you don’t have permission to view this map",
      "Access error": "Sorry, you don’t have permission to view this map",
      "Map not found": "Sorry, this map not found",
      "Unable to locate EXIF content": "Unable to locate EXIF content",
      "Развернуть карту": "Unfold map",
      "Свернуть карту": "Fold map",
      "Точки на изображении:": "Points on image:",
      "Точки на карте:": "Points on map:",
      "Координаты": "Coordinates",
      "Нарисовать": "Draw",
      "Восстановить": "Restore",
      "Прозрачность": "Transparency",
      "Видимость": "Visibility",
      "Привязка изображения": "Image binding",
      "$$phrase$$_2": "Point [value0] is outside the limits of image",
      "$$phrase$$_3": "Point [value0] is not specified on a map",
      "Соответствие точек": "Point correspondence",
      "$$phrase$$_4": "Points 1 and 2 coincide at the image",
      "$$phrase$$_5": "Points 1 and 3 coincide at the image",
      "$$phrase$$_6": "Points 2 and 3 coincide at the image",
      "$$phrase$$_7": "Points 1 and 2 coincide at the map",
      "$$phrase$$_8": "Points 1 and 3 coincide at the map ",
      "$$phrase$$_9": "Points 2 and 3 coincide at the map ",
      "$$phrase$$_10": "Points lie on a straight line at the image ",
      "Создать экскурсию": "Create guide",
      "Чтобы пользоваться этим сайтом, установите Flash Player": "To use this web site, please, install Flash Player",
      "из Интернет": "from Internet",
      "или с локального диска ": "or from local disc",
      "для Internet Explorer": "for Internet Explorer",
      " или ": " or ",
      "для Firefox": "for Firefox",
      "Скачать shp-файл": "Download shp-file",
      "shp-файл": "shp-file",
      "gpx-файл": "gpx-file",
      "Скачать фрагмент растра": "Download fragment of raster",
      "Очистить": "Delete",
      "точка": "point",
      "линия": "line",
      "прямоугольник": "rectangle",
      "многоугольник": "polygon",
      "Скачать": "Download",
      "Введите имя файла для скачивания": "Enter file name to download",
      "Выберите область рамкой на карте": "Select region using frame",
      "Вырезать фрагмент растра": "Cut fragment of raster",
      "К прямоугольнику не подходит ни одного растрового слоя": "No one raster layer fit the rectangle",
      "Загруженный shp-файл пуст": "The uploaded shp-file is empty",
      "Ошибка скачивания": "Download error",
      "Обновить": "Update",
      "Домашняя директория": "Project directory",
      "Имя папки": "Folder name",
      "Имя": "Name",
      "Тип": "Type",
      "Размер": "Size",
      "Дата": "Date",
      "Дата создания": "Дата создания",
      "Снять выделение": "Clear selection",
      "Скопировать": "Copy",
      "Удалить": "Delete",
      "Извлечь": "Extract",
      "Упаковать": "Add to archive",
      "Загрузить": "Download",
      "Параметр": "Parameter",
      "Значение": "Value",
      "VALUE": "VALUE",
      "WHERE": "WHERE",
      "Колонки": "Columns",
      "Операторы": "Operators",
      "Функции": "Functions",
      "Метаданные": "Metadata",
      "Редактировать колонки": "Edit columns",
      "URL сервера": "Server URL",
      "Формат изображения": "Image format",
      "Введите имя gml-файла для скачивания:": "Enter gml-file name to download:",
      "точки": "points",
      "линии": "lines",
      "полигоны": "polygons",
      "(ссылка)": "(link)",
      "Сохранить состояние карты": "Save map state",
      "Ссылка на текущее состояние карты": "Link to the map",
      "Добавить стиль": "Add style",
      "Атрибут >": "Attribute >",
      "Значение >": "Value >",
      "Операция >": "Operation >",
      "Накладываемое изображение": "Ground overlay",
      "Цвет": "Color",
      "Авторизуйтесь для редактирования фильтров": "Authorize to edit filters",
      "Имя фильтра": "Filter name",
      "Переместить фильтр вверх": "Move filter up",
      "Переместить фильтр вниз": "Move filter down",
      "Удалить фильтр": "Delete filter",
      "Размер шрифта": "Typesize",
      "Смещение": "Shift",
      "Смещение по x": "X shift",
      "Смещение по y": "Y shift",
      "Имя атрибута": "Attribute name",
      "Граница обрезки": "Clip region",
      "Граница": "Outline",
      "Толщина линии": "Line thickness",
      "Заливка": "Fill",
      "Заливка цветом": "Color fill",
      "Заливка штриховкой": "Pattern fill",
      "Заливка рисунком": "Image fill",
      "Ширина паттерна": "Pattern width",
      "Ширина отступа": "Indent width",
      "URL рисунка": "Image URL",
      "Маркер URL": "Icon URL ",
      "URL изображения": "Image URL",
      "Изображение": "Image",
      "Размер точек": "Point size",
      "Редактировать стили": "Edit styles",
      "Авторизуйтесь для редактирования настроек слоя": " Authorize to edit layer properties",
      "Недостаточно прав для редактирования настроек слоя": "You have not enough permission to edit layer properties ",
      "Недостаточно прав для редактирования объектов слоя": "You have not enough permission to edit layer objects ",
      "ID": "ID",
      "Описание": "Description",
      "Файл": "File",
      "Таблица": "Table",
      "Каталог с тайлами": "Tile catalogue",
      "Каталог растров": "Raster catalogue",
      "Данные с датой": "Split through time",
      "Источник": "Source",
      "Дополнительно": "Advanced options",
      "Шаблон названий объектов": "Objects title template",
      "Y (широта)": "Y (latitude)",
      "X (долгота)": "X (longitude)",
      "Каталог": "Catalogue",
      "Изменить": "Change",
      "Вид вложенных элементов": "Form of attached elements",
      "Использовать KosmosnimkiAPI": "Load Kosmosnimki base layers",
      "Использовать OpenStreetMap": "Use OpenStreetMap",
      "Язык по умолчанию": "Default language",
      "Единицы длины": "Distance unit",
      "Единицы площади": "Square unit",
      "Формат координат": "Coordinates format",
      "units.auto": "auto",
      "units.m": "m",
      "units.km": "km",
      "units.nm": "nmi",
      "units.m2": "m<sup>2</sup>",
      "units.ha": "ha",
      "units.km2": "km<sup>2</sup>",
      "coords.dd": "dd.dddd",
      "coords.dms": "dd°mm′ss″",
      "Генерализация": "Generalization",
      "gereralization.on": "on",
      "gereralization.off": "off",
      "gereralization.disable": "use layers settings",
      "Количество информационных окошек": "Max popup count",
      "layerOrder.title": "Layers order",
      "layerOrder.native": "Native",
      "layerOrder.vectorOnTop": "Vector on top",
      "Разрешить поиск в векторных слоях": "Allow search vector layers",
      "Начальная позиция": "Start position",
      "Широта": "Latitude",
      "Долгота": "Longitude",
      "placeholder degrees": "dd.dddd",
      "placeholder zoom": "1-21",
      "placeholder minZoom": "1",
      "placeholder maxZoom": "21",
      "Зум": "Zoom",
      "Ссылка (permalink)": "Permalink",
      "Разрешить скачивание": "Allow to download",
      "Векторных слоев": "Vector layers",
      "Растровых слоев": "Raster layers",
      "Масштабирование в миникарте": "Minimap zoom delta",
      "Показывать всплывающие подсказки": "Show tooltips",
      "Свойства": "Properties",
      "Создать копию слоя": "Create layer copy",
      "Стили": "Styles",
      "Изображение на карте": "Ground overlay",
      "Слой [value0]": "Layer [value0]",
      "Стили слоя [value0]": "Styles of layer [value0]",
      "Мультислой [value0]": "Multilayer [value0]",
      "Группа [value0]": "Group [value0]",
      "Карта [value0]": "Map [value0]",
      "Редактировать стиль": "Edit style",
      "Редактирование стилей объекта": "Object styles editing",
      "Стили слоя": "Layer styles",
      "Навигация по карте и инструменты": "Map navigation and tools",
      "Список слоев": "List of layers",
      "Стиль векторного слоя": "Vector layer style",
      "Управление содержанием карты": "Map content management",
      "Пользовательские инструменты": "Users tools",
      "$$help$$_1": "Hold mouse left button – move map with cursor. To zoom in or out use mouse wheel (or map zoom slider to zoom to the cursor position). In order to move map center to specified coordinates – enter coordinates in search line.",
      "$$help$$_2": "Layer tree is represented in the left panel. To change map center according to layer extent – click its title in the list. If this option was activated by map administrator, you can download vector layers and cut and download raster layers fragments.",
      "$$help$$_3": "To edit vector layer style click icon near layer name.",
      "$$help$$_4": "Map is a collection of layers, which is displayed using layer tree. It is necessary to authorize to be able to edit the collection of layers (create groups, change display order etc.) and save changes. For more information see ",
      " - Руководство пользователя": " – User guide",
      "$$help$$_5": "User tools serve the purpose of creation of objects on map, which can be saved via «save link to the map», and, at the same time, simple analytic functions fulfillment.",
      "В режиме маркеров: ": "Creating markers: ",
      "$$help$$_6": "single click – add marker. Double click on marker – delete. Click on marker – open pop-up window (balloon), click on balloon – add text.",
      "В режиме линейка/измерения расстояния, полигон/измерение площади: ": "Drawing lines/distance measurement, polygon/area measurement: ",
      "$$help$$_7": "single click – add vertex. Double click – complete figure. Click on line – add vertex. Double click on vertex – delete.",
      "$$help$$_8": "Click on object in list of «objects on map» to move map center to it. You can download object in shp/tab/kml format.",
      "$$about$$_1": "this web application for interactive geodata view and access to basic data sources in the Internet, such as: ",
      "$$about$$_2": " Using GeoMixer you can publish own geodata in intranet or in the Internet, put them over basic data coverages and give access to them for however large number of users, changing access permissions.",
      "$$about$$_3": "GeoMixer also includes API component, which enables integrating the created projects into other web sites and applications and carry out program control over interactive map functional.",
      " - Общее описание": " – General manual",
      " - Руководство разработчика": " – Developer’s gudie",
      "Получить API-ключ": "Get API-key",
      "Введите API-ключ": "Enter API-key",
      "$$serviceHelp$$_1": "Allows to upload small shp/tab/kml file on the fly in the form of user objects. After uploading user can edit geometry of objects and download objects in the same format kit.",
      "$$serviceHelp$$_2": "Link saves current map state, and also user objects and texts.",
      "$$serviceHelp$$_3": "Print current map fragment.",
      "Редактировать": "Edit",
      "Удалить объект?": "Delete object?",
      "Удалить отмеченные объекты?": "Delete selected objects?",
      "Длина": "Length",
      "Площадь": "Area",
      "Добавить подгруппу": "Create group",
      "Введите имя группы": "New group creation",
      "Имя группы": "Group name",
      "Включая вложенные слои": "Including attached layers",
      "Удаление группы [value0]": "Delete group [value0]",
      "Сохранено": "Saved",
      "Прозрачность выбранного слоя/группы/карты": "Transparency of the selected layer/group/map",
      "$$updateInfo$$_1": "To display new layer it is necessary to save and reload map",
      "Любой": "Any",
      "Владелец": "Owner",
      "Последнее изменение": "Last modification",
      "Вы действительно хотите удалить этот слой?": "Do you really want to delete the selected layer?",
      "Ошибка!": "Error!",
      "Ошибка": "Error",
      "Выберите колонку": "Select column",
      "Список карт": "Maps list",
      "Показать": "Show",
      "загрузка...": "loading...",
      "удаление...": "deleting...",
      "Вы действительно хотите удалить эту карту?": " Do you really want to delete the selected map?",
      "maplist.hint": "You can drag layers and folders from here to current map",
      "Слоя нет в базе": "Layer is not in base",
      "ScanEx Web Geomixer - просмотр карты": "ScanEx Web Geomixer – map view",
      "Изменить параметры поиска": "Change search parameters",
      "$$search$$_1": "Search vector layers and address base",
      "$$search$$_2": "Search address base",
      "Поиск не дал результатов": "There are no search results",
      "Регистрация": "Registration",
      "Восстановление пароля": "Restore password",
      "Вход": "Login",
      "Выход": "Logout",
      "Логин": "User name",
      "Пароль": "Password",
      "пароль": "password",
      "Псевдоним": "Nickname",
      "Полное имя": "Full name",
      "Пожалуйста, авторизуйтесь": "Please, authorize",
      "адрес электронной почты": "enter your e-mail",
      "Ошибка сервера": "Server error",
      "Папка": "Folder",
      " и ": " and ",
      "Название": "Title",
      "Рейтинг": "Rating",
      "Автор": "Author",
      "Тематика": "Theme",
      "Развлекательная": "Fun",
      "Спортивная": "Sport",
      "Историческая": "History",
      "Экологическая": "Ecology",
      "Любая": "All",
      "Создать новую тему": "Create topic",
      "Начало периода": "Since",
      "Окончание периода": "Till",
      "Накладываемые тайлы": "Ground tiles",
      "Отображать с зума": "Show with zoom",
      "По": "to",
      "Фильтр": "Filter",
      "Подпись": "Label",
      "Балун": "Balloon",
      "По умолчанию": "Default",
      "Показывать при клике": "Show on click",
      "Показывать при наведении": "Show on mouse over",
      "Символика": "Shown style",
      "Библиотека стилей": "Style library",
      "Настройка стилей": "Style settings",
      "скопировать": "copy style",
      "применить везде": "apply to all",
      "Применить": "Apply",
      "Кластеризация": "Clustering",
      "Минимальный": "Mininmal",
      "Максимальный": "Maximal",
      "Мин. зум": "Min. zoom",
      "Макс. зум": "Max. zoom",
      "Пешеходная": "Footpath",
      "Велосипедная": "Bicycle",
      "Автомобильная": "Automobile",
      "Места": "Places",
      "Маршрут": "Route",
      "Редактировать экскурсию": "Edit excursion",
      "Добавьте маршрут": "Add route",
      "Выберете темы на пути следования": "Choose places throughout the journey",
      "$$phrase$$_11": "Add route by clicking \"Line\" tool on toolbar",
      "$$phrase$$_12": "There are no corresponding objects on the map",
      "Выбор маршрута": "Routes choice",
      "Выбор мест": "Places choice",
      "$$phrase$$_13": "You haven't places om map. You can add place in View-Forum tab",
      "Обсуждения": "Forum",
      "Экскурсии": "Excursions",
      "$$phrase$$_14": "Unable to delete default map",
      "$$phrase$$_15": "Unable to delete current map",
      "Назад": "Back",
      "Вперед": "Forward",
      "$$phrase$$_16": "There is no album with given image ID",
      "Редактировать альбом": "Edit album",
      "Оценить": "Vote",
      "Поставьте маркер": "Add marker",
      "на карту и переместите его в нужное место.": "to map and move it to choosen place.",
      "Недостаточно прав для совершения операции": "Insufficient rights to perform operation",
      "Новая папка": "New folder",
      "Выбрать": "Choose",
      "Добавить": "Add",
      "$$serviceHelp$$_4": "Embedding the map: the user can embed a map window into their site by copying and pasting an HTML snippet. An API key for the site's domain is required.",
      "Масштаб": "Scale",
      "Угол поворота": "Angle",
      "Диаграммы": "Charts",
      "График по времени": "Time chart",
      "Круговая": "Pie chart",
      "Маска атрибутов": "Attributes mask",
      "Закладки": "Bookmarks",
      "Добавить закладку": "Add bookmark",
      "Имя закладки": "Bookmark name",
      "Дерево": "Tree view",
      "Поиск слоев": "Layers search",
      "Пример выражения": "[Field1]\n[Field2]\nsimple text",
      "Шкала прозрачности": "Transparency bar",
      "Цвет заливки": "Fill color",
      "Цвет обводки": "Outline color",
      "Цвет шрифта": "Font color",
      "Легенда": "Legend",
      "Событие загрузки карты": "Событие загрузки карты",
      "Мин": "Min",
      "Макс": "Max",
      "График": "График",
      "Гистограмма": "Гистограмма",
      "Столбчатая": "Столбчатая",
      "Временная": "Временная",
      "Копировать стиль": "Copy style",
      "Применить стиль": "Apply style",
      "Не выбран стиль": "There is no copied style",
      "Невозможно применить стиль к другому типу геометрии": "Can't apply style to different geometry type",
      "Общие": "Common",
      "Доступ": "Policy",
      "Окно карты": "View",
      "Загрузка": "Onload",
      "Копирайт": "Copyright",
      "Инструменты": "Tools",
      "Загрузить KML": "Load KML",
      "URL файла": "File URL",
      "Поиск": "Search",
      "Подложки": "Base Layers",
      "Доступные подложки": "Available base layers",
      "Подложки карты": "Base layers on map",
      "Выберите слои для поиска по атрибутам": "Select layers for attributes search",
      "Включить синхронизацию слоев": "Enable sync layers",
      "Выключить синхронизацию слоев": "Disable sync layers",
      "Редактирование прав доступа карты [value0]": "Map [value0] access editor",
      "Редактирование прав доступа слоя [value0]": "Layer [value0] access editor",
      "Редактирование прав доступа слоев карты [value0]": "Map [value0] layers access editor",
      "Состав группы [value0]": "Users of group [value0]",
      "Роль": "Role",
      "Добавить пользователя": "Add user",
      "Права доступа": "Access permissions",
      "Права доступа к слоям": "Layers access permissions",
      "Пользователи без прав доступа:": "Users wihout access:",
      "Пользователи с правами доступа:": "Users with access:",
      "Выберите нового владельца": "Select new owner",
      "Сменить владельца": "Change owner",
      "Объекты RuMap": "RuMap objects",
      "Объекты пользователей": "User objects",
      "Контакты": "Contacts",
      "Фотографии": "Photo",
      "Момент съемки": "Image date",
      "Видео": "Video",
      "Сообщения": "Messages",
      "Ссылка на место": "Ссылка на место",
      "Ссылка на экскурсию": "Ссылка на экскурсию",
      "Ссылка на событие": "Ссылка на событие",
      "Создать новое событие": "Создать новое событие",
      "События": "События",
      "Календарь": "Календарь",
      "Новости": "Новости",
      "Мероприятия": "Мероприятия",
      "Отмена": "Отмена",
      "Пропустить": "Skip",
      "Время": "Время",
      "Альбом OpenPhotoVR": "Фотоальбом",
      "Встраиваемый код": "Embed video",
      "Объекты экологического риска": "Объекты экологического риска",
      "Санкционированные свалки": "Санкционированные свалки",
      "Несанкционированные свалки": "Несанкционированные свалки",
      "Полигоны отходов": "Полигоны отходов",
      "Предприятия переработки отходов": "Предприятия переработки отходов",
      "Факельные установки, ТЭЦ, трубы": "Факельные установки, ТЭЦ, трубы",
      "Закрытые свалки": "Закрытые свалки",
      "Пункты приема отходов": "Пункты приема отходов",
      "Оползни": "Оползни",
      "Карстовые явления": "Карстовые явления",
      "Суффозионные явления": "Суффозионные явления",
      "Государство и общество": "Государство и общество",
      "Радио": "Радио",
      "Правительственные учреждения": "Правительственные учреждения",
      "Оптики": "Оптики",
      "Охранные агенства": "Охранные агенства",
      "Травмпункты": "Травмпункты",
      "Таможня": "Таможня",
      "Ветеринарные клиники": "Ветеринарные клиники",
      "ЗАГС": "ЗАГС",
      "Больницы": "Больницы",
      "Аптеки": "Аптеки",
      "Поликлиники": "Поликлиники",
      "Колледжи": "Колледжи",
      "Университеты": "Университеты",
      "ОВИР": "ОВИР",
      "Посольства": "Посольства",
      "Почтовые отделения": "Почтовые отделения",
      "Суды": "Суды",
      "Банки": "Банки",
      "Родильные дома": "Родильные дома",
      "Дома престарелых": "Дома престарелых",
      "Детские сады": "Детские сады",
      "Школы": "Школы",
      "Инспекции": "Инспекции",
      "Адвокаты": "Адвокаты",
      "МЧС": "МЧС",
      "Муниципальные учреждения": "Муниципальные учреждения",
      "Администрация": "Администрация",
      "Культура и отдых": "Культура и отдых",
      "Боулинг": "Боулинг",
      "Аквапарки": "Аквапарки",
      "Парки развлечений": "Парки развлечений",
      "Библиотеки": "Библиотеки",
      "Памятники": "Памятники",
      "Лагери отдыха": "Лагери отдыха",
      "Кинотеатры": "Кинотеатры",
      "Цирки": "Цирки",
      "Галереи": "Галереи",
      "Отели": "Отели",
      "Мотели": "Мотели",
      "Музеи": "Музеи",
      "Концертные залы": "Концертные залы",
      "Ночные клубы": "Ночные клубы",
      "Театры": "Театры",
      "Санатории": "Санатории",
      "Зоопарки": "Зоопарки",
      "Общественное питание": "Общественное питание",
      "Кафе": "Кафе",
      "Фастфуды": "Фастфуды",
      "Рестораны": "Рестораны",
      "Кафе-мороженое": "Кафе-мороженое",
      "Столовые": "Столовые",
      "Природные достопримечательности": "Природные достопримечательности",
      "Ботанический сад": "Ботанические сады",
      "Пещеры": "Пещеры",
      "Водопады": "Водопады",
      "Парки": "Парки",
      "Источники": "Источники",
      "Заповедники": "Заповедники",
      "Прочие архитектурные и природные достопримечательности": "Архитектурные достопримечательности",
      "Религия": "Религия",
      "Культовые сооружения": "Культовые сооружения",
      "Мечети": "Мечети",
      "Монастыри": "Монастыри",
      "Церкви других христианских конфессий": "Церкви других христианских конфессий",
      "Православные церкви": "Православные церкви",
      "Синагоги": "Синагоги",
      "Спорт": "Спорт",
      "Стадионы": "Стадионы",
      "Теннисные корты": "Теннисные корты",
      "Катки": "Катки",
      "Ипподромы": "Ипподромы",
      "Фитнес": "Фитнес",
      "Бассейны": "Бассейны",
      "Прокат спортинвентаря": "Прокат спортинвентаря",
      "Торговля и услуги": "Торговля и услуги",
      "Солярии": "Солярии",
      "Интернет-кафе": "Интернет-кафе",
      "Рынки": "Рынки",
      "Стоматологические клиники": "Стоматологические клиники",
      "Магазины одежды": "Магазины одежды",
      "Парикмахерские": "Парикмахерские",
      "Бани": "Бани",
      "Магазины обуви": "Магазины обуви",
      "Магазины": "Магазины",
      "Ателье": "Ателье",
      "Такси": "Такси",
      "Туризм": "Туризм",
      "Транспорт и услуги": "Транспорт и услуги",
      "Аэропорты": "Аэропорты",
      "Автосервисы": "Автосервисы",
      "Автовокзалы": "Автовокзалы",
      "ДПС": "ДПС",
      "ГИБДД": "ГИБДД",
      "Шиномонтаж": "Шиномонтаж",
      "Парковки бесплатные": "Парковки бесплатные",
      "Парковки платные": "Парковки платные",
      "АЗС": "АЗС",
      "Автомойки": "Автомойки",
      "Экстренные службы": "Экстренные службы",
      "Пожарные/спасатели": "Пожарные/спасатели",
      "Милиция": "Милиция",
      "Скорая помощь": "Скорая помощь",
      "Другие темы": "Другие темы",
      "Разное": "Разное",
      "Изменение пароля": "Password change",
      "Новый пароль": "New password",
      "Старый пароль": "Old password",
      "Подтвердите пароль": "Confirm password",
      "Контур": "Border",
      "$$phrase$$_17": "Add border by clicking \"Polygon\" tool on toolbar",
      "Выбор контура": "Border select",
      "Таблица атрибутов слоя [value0]": "[value0] attributes table",
      "Показать параметры поиска": "Show search params",
      "Скрыть параметры поиска": "Hide search params",
      "Скрыть": "Hide",
      "Искать внутри полигона": "Search inside polygon",
      "Искать по пересечению с объектом": "Search by geometry",
      "SQL-условие WHERE": "WHERE SQL expression",
      "Показывать колонки": "Show columns",
      "Скрыть колонки": "Hide columns",
      "Найти": "Search",
      "Нет полей": "Empty fields",
      "Нет данных": "Empty data",
      "Таблица атрибутов": "Attributes table",
      "Разрешить поиск": "Allow search",
      "Произвольный": "Any",
      "День": "Day",
      "Неделя": "Week",
      "Месяц": "Month",
      "Год": "Year",
      "Ежегодно": "Every year",
      "Облачность": "Clouds",
      "Период": "Period",
      "Спутниковые покрытия": "Satellite cover",
      "Редактировать объект слоя [value0]": "Edit layer [value0] object",
      "Создать объект слоя [value0]": "Add layer [value0] object",
      "Геометрия": "Geometry",
      "Найти объекты": "Find objects",
      "Добавить объекты": "Add objects",
      "Обновить объекты": "Update objects",
      "Копировать объекты": "Copy objects",
      "Объекты скопированы": "Objects are copied",
      "Объекты добавлены": "Объекты добавлены",
      "Вставить объекты": "Paste objects",
      "Вставить объекты не удалось": "Paste objects failed",
      "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"": "Right-click on layer name and select \"Paste objects\"",
      "Изменить колонки": "Update columns",
      "Обновить колонку": "Update column",
      "Очистить поиск": "Clean search",
      "Скачать shp": "Download shp",
      "Скачать gpx": "Download gpx",
      "Скачать csv": "Download csv",
      "Скачать geojson": "Download geojson",
      "Рассчитать площадь": "Total square",
      "Создать столбец": "Create column",
      "Мультислой": "Multilayer",
      "В дереве слоев остались несохраненные изменения!": "There are unsaved changes on layers tree!",
      "файл версии отсутствует": "version file doesn't exists",
      "оверлеи отсутствуют": "no overlays present",
      "Хост": "Host",
      "Дополнительные карты": "Additional maps",
      "Добавить карту": "Add map",
      "Добавить в таймлайн": "Add to timeLine",
      "Удалить из таймлайна": "Remove from timeline",
      "Невозможно загрузить карту [value0] с домена [value1]": "Unable to load map [value0] from domain [value1]",
      "Показывать": "Show",
      "Принудительно обновить тайлы": "Forced retiling",
      "Обводка": "Outline",
      "Карта имеет более новую версию. Сохранить?": "The map has a newer version. Save anyway?",
      "Кодировка": "Encoding",
      "helpPostfix": "_eng.html",
      "Показывать чекбокс видимости": "Visibility checkbox",
      "Разворачивать автоматически": "Expand automatically",
      "Другая": "Another",
      "Временнóй слой": "Multitemporal layer",
      "Колонка даты": "Date column",
      "Минимальный период": "Min. period (days)",
      "Максимальный период": "Max. period (days)",
      "Отсутствует временной атрибут": "Missing attribute with type 'Date'",
      "Период 1 день": "Period 1 day",
      "Показывать на карте данные за": "Show data on map within",
      "1 день": "single day",
      "произвольный период": "arbitrary period",
      "По границе экрана": "Screen border",
      "По центру экрана": "Screen center",
      "Пересечение": "Intersection",
      "Пролистывать слои": "Scroll layers",
      "Следующий слой": "Next layer",
      "Предыдущий слой": "Previous layer",
      "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Geometry is not saved. This feature will be implemented in future Geomixer versions",
      "WMS доступ": "WMS/WFS access",
      "ссылка": "link",
      "Слой '[value0]' уже есть в карте": "Layer '[value0]' already exists in this map",
      "Группа '[value0]' уже есть в карте": "Group '[value0]' already exists in this map",
      "Плагины": "Plugins",
      "Вручную": "Manually",
      "Добавить атрибут": "Add attribute",
      "Проекция": "Projection",
      "Широта/Долгота (EPSG:4326)": "Lat/Lon (EPSG:4326)",
      "Меркатор (EPSG:3395)": "Mercator (EPSG:3395)",
      "Из файла": "From file",
      "Мультиполигон": "Multipolygon",
      "Мультилиния": "Multipolyline",
      "Мультиточка": "Multipoint",
      "Администрирование": "Administration",
      "Системные настройки": "System settings",
      "Управление группами": "User group management",
      "Управление группами пользователей": "User group management",
      "Добавить снимки": "Add rasters",
      "Существующие слои": "Existing layers",
      "Слои из карты": "Layers from map",
      "Слои из КР": "Layers from RC",
      "Новый слой": "New layer",
      "С экрана": "Select on map",
      "Добавлен растр": "Raster is added",
      "Добавлены растры": "Rasters are added",
      "Выбранный объект не имеет растра": "Selected object has no raster",
      "Этот растр уже был выбран": "This raster is already selected",
      "Каталог Растров": "Raster catalog",
      "Растр": "Raster",
      "Добавить выбранные растры": "Add selected rasters",
      "EditObject.menuTitle": "Add object",
      "FileBrowser.ExceedLimitMessage": "File size exceeds 500 Mb. Use GeoMixerFileBrowser tool to upload large files.",
      "FileBrowser.DropInfo": "Drop files here",
      "EditObject.drawingMenuTitle": "Add object to active layer",
      "Поставить маркер": "Add marker",
      "Центрировать": "Set center",
      "Пароль изменён": "Password has been changed",
      "портретная": "portrait view",
      "альбомная": "layout view",
      "gmx_geometry": "gmx_geometry"
    };

    /**
      @class
      @virtual
      @name IMenuElem
      @desc Описание пункта верхнего меню ГеоМиксера
      @property {String} id Уникальный идентификатор элемента меню
      @property {String} title Tекст, который будет показываться пользователю
      @property {Function} func Ф-ция, которую нужно вызвать при клике
      @property {IMenuElem[]} childs Массив элементов подменю
    */

    /**
        Верхнее меню ГеоМиксера. Может содержать до 3 уровней вложенности элементов.
        @class
    */

    var UpMenu = function UpMenu() {
      this.submenus = [];
      this.currSel = null;
      this.currUnSel = null;
      this.refs = {};
      this.parent = null;
      this.loginContainer = null;
      this._isCreated = false;
      this.defaultHash = 'layers';
      this.clicked = false;
      this.openedMenus = [];
      this.currentTopHash = null;
      document.addEventListener('click', this.hideOnClick.bind(this));
    };

    UpMenu.prototype.hideOnClick = function (e) {
      var parents = $(e.target).parents(),
          parentsArr = $(parents).toArray(),
          isHeader = $(e.target).hasClass('header1Internal'),
          isInsideHeader = parentsArr.some(function (elem) {
        return $(elem).hasClass('header1');
      });

      if (!isInsideHeader) {
        this.clicked = false;
        this.hideMenus();
        this.currentTopHash = null;
      }

      if (!isHeader) {
        $(document).find('.header1').each(function () {
          $(this).removeClass('menuActive');
        });
      }
    }; //предполагает, что если callback возвращает true, то итерирование можно прекратить


    UpMenu.prototype._iterateMenus = function (elem, callback) {
      if (!elem.childs) {
        return;
      }

      for (var i = 0; i < elem.childs.length; i++) {
        if (elem.childs[i] && (callback(elem.childs[i]) || this._iterateMenus(elem.childs[i], callback))) {
          return true;
        }
      }
    };
    /** Добавляет к меню новый элемент верхнего уровня
    *
    * Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
    *
    *    @param {IMenuElem} elem Элемент меню
    */


    UpMenu.prototype.addItem = function (elem) {
      this.submenus.push(elem);
      this._isCreated && this.draw();
    };
    /** Добавляет к меню новый элемент.
    *
    * Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
    *
    *    @param {IMenuElem} newElem Вставляемый элемент меню
    *    @param {String} parentID ID элемента меню, к которому добавляется новый элемент
    *    @param {String} [insertBeforeID] ID элемента меню, перед которым нужно вставить пункт меню.
    *                    Если не указан, пункт меню будет добавлен в конец списка.
    */


    UpMenu.prototype.addChildItem = function (newElem, parentID, insertBeforeID) {
      this._iterateMenus({
        childs: this.submenus
      }, function (elem) {
        if (elem.id && elem.id === parentID) {
          elem.childs = elem.childs || [];
          var index = elem.childs.length;
          elem.childs.forEach(function (childElem, i) {
            if (childElem.id === insertBeforeID) {
              index = i;
            }
          });
          elem.childs.splice(index, 0, newElem);
          this._isCreated && this.draw();
          return true;
        }
      }.bind(this));
    };
    /** Задаёт родителя в DOM дереве для меню
    * @param {DOMElement} parent Родительский элемент в DOM дереве
    */


    UpMenu.prototype.setParent = function (parent) {
      this.parent = parent;

      if (parent) {
        $(parent).empty();
        parent.appendChild(_span());
      }

      this.disabledTabs = {};
    }; // Показывает элемент меню


    UpMenu.prototype.showmenu = function (elem) {
      elem.style.visibility = 'visible';

      if (this.openedMenus.indexOf(elem) === -1) {
        this.openedMenus.push(elem);
      }
    }; // Скрывает элемент меню


    UpMenu.prototype.hidemenu = function (elem) {
      elem.style.visibility = 'hidden';

      if (this.openedMenus.indexOf(elem) !== -1) {
        this.openedMenus.splice(this.openedMenus.indexOf(elem), 1);
      }
    };

    UpMenu.prototype._template = Handlebars.compile('<div class="headerContainer">\
{{#childs}}{{#if id}}\
    <div class = "header1{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
        <div class = "header1Internal">{{title}}</div>\
        {{#if childs}}\
            <ul class = "header2" id="{{id}}">\
            {{#childs}}{{#if id}}\
                <li class = "header2{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
                    <div class = "header2{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                        <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                        {{title}}\
                        {{#if childs}}\
                            <div class = "menuMarkerRight"></div>\
                        {{/if}}\
                    </div>\
                    {{#if childs}}\
                        <ul class = "header3" id="{{id}}">\
                        {{#childs}}{{#if id}}\
                            <li class = "header3 menuClickable" hash = "{{id}}">\
                                <div class = "header3{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                                    <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                                    {{title}}\
                                </div>\
                            </li>\
                        {{/if}}{{/childs}}\
                        </ul>\
                    {{/if}}\
                </li>\
            {{/if}}{{/childs}}\
            </ul>\
        {{/if}}\
    </div>\
    {{/if}}{{/childs}}\
</div>');
    /** Основная функция  - рисует меню по заданной структуре
    */

    UpMenu.prototype.draw = function () {
      var ui = $(this._template({
        childs: this.submenus
      })),
          _this = this;

      $(this.parent.firstChild).empty().append(ui);
      $(ui).find('.header1').each(function () {
        _this.attachEventOnClick(this, 'menuActive');

        _this.attachEventOnMouseover(this, 'menuActive');

        _this.attachEventOnMouseout(this, 'menuActive');

        $(this).width($(this).width() + 10);
      });
      $(ui).find('li.header2').each(function () {
        _this.attachEventOnMouseover(this, 'menu2Active');

        _this.attachEventOnMouseout(this, 'menu2Active');
      });
      $(ui).find('li.header3').each(function () {
        attachEffects(this, 'menu3Active');
      });
      $(ui).find('.menuClickable').each(function () {
        var id = $(this).attr('hash');
        $(this).click(function (e) {
          e.stopPropagation();
          _this.refs[id].disabled || _this.openTab(id, e);
        });
      });

      this._iterateMenus({
        childs: this.submenus
      }, function (elem) {
        _this.refs[elem.id] = elem;
      }); //убираем все скрытые меню


      for (var d in this.disabledTabs) {
        this.disableMenus([d]);
      }

      this._isCreated = true;
    };

    UpMenu.prototype.checkItem = function (id, isChecked) {
      if (this.refs[id]) {
        this.refs[id].checked = isChecked;
        $(this.parent).find('li[hash=' + id + ']').find('.menuMarkerLeft').toggleClass('ui-icon ui-icon-check', isChecked);
      }
    };

    UpMenu.prototype.removeSelections = function () {
      $('li.menu3Active').removeClass('menu3Active');
      $('li.menu2Active').removeClass('menu2Active');
      $('li.menuActive').removeClass('menuActive');
    }; // Закрывает открытые меню


    UpMenu.prototype.hideMenus = function () {
      var _this = this;

      $('ul.header2').each(function () {
        _this.hidemenu(this);
      });
      $('ul.header3').each(function () {
        _this.hidemenu(this);
      });
    }; // Открывает закладку


    UpMenu.prototype.openRef = function (hash) {
      _menuUp.removeSelections();

      _menuUp.hideMenus();

      _menuUp.openTab(hash);
    };

    UpMenu.prototype.attachEventOnClick = function (elem) {
      var _this = this;

      elem.onclick = function () {
        if (!_this.clicked) {
          var isTopLevel = $(elem).hasClass('header1'),
              hash = this.getAttribute('hash');

          if (isTopLevel && !_this.currentTopHash) {
            _this.currentTopHash = hash;
            _this.clicked = true;
          }

          if ($('#' + hash)[0]) {
            _this.showmenu($('#' + this.getAttribute('hash'))[0]);
          }
        } else {
          return;
        }
      };
    };

    UpMenu.prototype.attachEventOnMouseover = function (elem, className) {
      var _this = this;

      elem.onmouseover = function () {
        $(this).addClass(className);

        if (_this.clicked) {
          var itemsToClose = [];

          for (var i = 0; i < _this.openedMenus.length; i++) {
            if (!_this.checkInsideElem(elem, _this.openedMenus[i])) {
              itemsToClose.push(_this.openedMenus[i]);
            }
          }

          for (var _i = 0; _i < itemsToClose.length; _i++) {
            var ee = itemsToClose[_i];

            _this.hidemenu(ee);
          }

          if ($('#' + this.getAttribute('hash'))[0]) {
            _this.showmenu($('#' + this.getAttribute('hash'))[0]);
          } //add top-level hash


          var isTopLevel = $(elem).hasClass('header1'),
              hash = this.getAttribute('hash');

          if (isTopLevel) {
            _this.currentTopHash = hash;
            $(document).find('.header1').each(function () {
              $(this).removeClass('menuActive');
            });
            $(this).addClass(className);
          }
        }
      };
    };

    UpMenu.prototype.checkInsideElem = function (elem, descendant) {
      var parents = $(descendant).parents(),
          parentsArr = $(parents).toArray(),
          isInsideElem = parentsArr.some(function (em) {
        return $(em).attr('hash') === $(elem).attr('hash');
      });
      return isInsideElem;
    };

    UpMenu.prototype.attachEventOnMouseout = function (elem, className) {
      var _this = this;

      elem.onmouseout = function (e) {
        var evt = e || window.event,
            // target = evt.srcElement || evt.target,
        relTarget = evt.relatedTarget || evt.toElement,
            elem = this,
            isTopLevel = $(elem).hasClass('header1'),
            hash = this.getAttribute('hash');

        try {
          while (relTarget) {
            if (relTarget == elem) {
              stopEvent(e);
              return false;
            }

            relTarget = relTarget.parentNode;
          }

          if (isTopLevel && hash === _this.currentTopHash) {
            return false;
          } else {
            // _this.currentTopHash = null;
            $(elem).removeClass(className);
          }
        } catch (e) {
          if (isTopLevel && hash === _this.currentTopHash) {
            return false;
          } else {
            // _this.currentTopHash = null;
            $(elem).removeClass(className);
          }
        }
      };
    };

    UpMenu.prototype.getNavigatePath = function (path) {
      for (var menuIdx = 0; menuIdx < this.submenus.length; menuIdx++) {
        var submenu = this.submenus[menuIdx];

        if (!submenu) {
          continue;
        }

        if (path == submenu.id) {
          return [submenu.title];
        }

        if (submenu.childs) {
          var childsLevel2 = submenu.childs;

          for (var i = 0; i < childsLevel2.length; i++) {
            if (!childsLevel2[i]) {
              continue;
            }

            if (childsLevel2[i].childs) {
              var childsLevel3 = childsLevel2[i].childs; // есть подменю, смотрим там

              for (var j = 0; j < childsLevel3.length; j++) {
                if (!childsLevel3[j]) {
                  continue;
                }

                if (path == childsLevel3[j].id) {
                  return [submenu.title, childsLevel2[i].title, childsLevel3[j].title];
                }
              }
            }

            if (path == childsLevel2[i].id) {
              // совпадение в меню 2го уровня
              return [submenu.title, childsLevel2[i].title];
            }
          }
        }
      }

      return [];
    };
    /** Показывает все ранее скрытые элементы меню
    */


    UpMenu.prototype.enableMenus = function () {
      for (var name in this.disabledTabs) {
        $(this.parent).find("li[hash='" + name + "']").children('div').css('display', '');
        delete this.disabledTabs[name];
      }
    };
    /** Скрывает заданные элементы меню
    * @param {String[]} arr Массив ID элементов меню, которые нужно скрыть
    */


    UpMenu.prototype.disableMenus = function (arr) {
      for (var i = 0; i < arr.length; i++) {
        $(this.parent).find("li[hash='" + arr[i] + "']").children('div').css('display', 'none');
        this.disabledTabs[arr[i]] = true;
      }
    };

    UpMenu.prototype.checkView = function () {
      if (!nsGmx$1.AuthManager.isLogin()) {
        this.enableMenus();
        this.disableMenus(['mapCreate', 'mapSave', 'mapSaveAs', 'layersMenu', 'pictureBinding']);
      } else if (_queryMapLayers.currentMapRights() != "edit") {
        this.enableMenus();
        this.disableMenus(['mapSave', 'mapSaveAs', 'layersVector', 'layersRaster', 'layersMultiRaster']);
      }

      if (!nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN)) {
        this.disableMenus(['stileLibrary']);
      }

      if (_queryMapLayers.currentMapRights() !== "edit") {
        this.disableMenus(['mapTabsNew']);
      }

      if (!nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_CREATE_LAYERS)) {
        this.disableMenus(['layersVector', 'layersRaster', 'layersMultiRaster']);
      }

      if (!nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_CREATE_MAP)) {
        this.disableMenus(['mapCreate']);
      }
    };

    UpMenu.prototype.go = function (container) {
      this.setParent(container);
      this.createMenu();
      this.draw();
      this.checkView();

      if (window.location.hash) {
        this.currUnsel = function () {};
      }

      this.openTab(this.defaultHash);
    };

    UpMenu.prototype.openTab = function (id, event) {
      if (this.disabledTabs[id] || !this.refs[id]) {
        return;
      }

      var item = this.refs[id];
      this.removeSelections();
      this.hideMenus();

      if (item.func) {
        this.clicked = false;
        event.stopPropagation();
        this.hideOnClick(event);
        item.func(id);
      } else {
        var func = item[item.checked ? 'onunsel' : 'onsel'];
        this.checkItem(id, !item.checked);
        func && func(id);
      }
    };
    /** Блок (контейнер с заголовком) левой панели
        @class
        @param {String} canvasID Уникальный идентификатор блока
        @param {Object} options Параметры
        @param {function} [options.closeFunc] Ф-ция, которая будет вызвана при нажатии на иконку закрытия блока. По умолчанию ничего не делается.
        @param {String[]} [options.path] Массив строк для формирования названия блока (см. метод setTitle()).
                          По умолчанию будет сформирован из верхнего меню ГеоМиксера по canvasID.
        @param {Boolean} [options.showCloseButton=true] Показывать ли кнопку закрытия блока
        @param {Boolean} [options.showMinimizeButton=true] Показывать ли кнопку сворачивания блока
    */


    nsGmx$1.LeftPanelItem = function (canvasID, options) {
      /** Изменение видимости контента ("свёрнутости") панели
       * @event nsGmx.LeftPanelItem.changeVisibility
      */
      options = $.extend({
        closeFunc: function closeFunc() {},
        showCloseButton: true,
        showMinimizeButton: true
      }, options); //по умолчанию оставляем только последний элемент списка

      if (!options.path) {
        var menuPath = _menuUp.getNavigatePath(canvasID);

        options.path = menuPath.length ? [menuPath[menuPath.length - 1]] : [];
      }

      var getPathHTML = function getPathHTML(path) {
        if (!path) return '';
        return Handlebars.compile('<tr>' + '{{#path}}' + '<td class="leftmenu-path-item {{#last}}menuNavigateCurrent{{/last}}">{{name}}</td>' + '{{^last}}<td><div class="markerRight"></div></td>{{/last}}' + '{{/path}}' + '</tr>')({
          path: path.map(function (item, index, arr) {
            return {
              name: item,
              last: index === arr.length - 1
            };
          })
        });
      };

      var ui = Handlebars.compile('<div class="leftmenu-canvas {{id}}" id="{{id}}">' + '{{#isTitle}}<div class="leftTitle">' + '{{#showMinimizeButton}}' + '<div class = "leftmenu-toggle-zone">' + '<div class="ui-helper-noselect leftmenu-toggle-icon leftmenu-down-icon"></div>' + '</div>' + '{{/showMinimizeButton}}' + '<table class="leftmenu-path ui-helper-noselect">{{{pathTR}}}</table>' + '{{#showCloseButton}}<div class="gmx-icon-close"></div>{{/showCloseButton}}' + '</div>{{/isTitle}}' + '<div class = "workCanvas"></div>' + '</div>');
      /**HTML элемент с блоком (содержит шапку и рабочую область)*/

      this.panelCanvas = $(ui({
        isTitle: !!(options.path.length || options.showCloseButton || options.showMinimizeButton),
        id: 'left_' + canvasID,
        pathTR: getPathHTML(options.path),
        showCloseButton: options.showCloseButton,
        showMinimizeButton: options.showMinimizeButton
      }))[0];
      /**Рабочая область блока*/

      this.workCanvas = $(this.panelCanvas).find('.workCanvas')[0];
      /** Программная имитация нажатия кнопки закрытия блока
          @function
      */

      this.close = options.closeFunc;

      var isUICollapsed = false,
          _this = this;

      var toggleContentVisibility = function toggleContentVisibility(isCollapsed) {
        if (isUICollapsed !== isCollapsed) {
          isUICollapsed = !isUICollapsed;
          $(_this.workCanvas).toggle();
          $(_this.panelCanvas).find('.leftmenu-toggle-zone div').toggleClass('leftmenu-down-icon leftmenu-right-icon');
          $(_this).trigger('changeVisibility');
        }
      };

      $('.leftmenu-toggle-zone, .leftmenu-path', this.panelCanvas).click(function () {
        toggleContentVisibility(!isUICollapsed);
      });
      /** Свернуть панель
          @function
      */

      this.hide = toggleContentVisibility.bind(null, true);
      /** Развернуть панель
          @function
      */

      this.show = toggleContentVisibility.bind(null, false);
      /** Свёрнута ли панель */

      this.isCollapsed = function () {
        return isUICollapsed;
      };

      $('.leftTitle .gmx-icon-close', this.panelCanvas).click(options.closeFunc);
      /** Задать новый заголовок окна
       @param {String[]} [path] Массив строк для формирования названия блока.
                        Предполагается, что последний элемент является собственно названием, а предыдущие - названиями категорий.
      */

      this.setTitle = function (path) {
        $('.leftmenu-path', this.panelCanvas).html(getPathHTML(path));
      };
    };
    /** Основное меню ГеоМиксера
     * @global
     * @type {UpMenu}
     */


    var _menuUp = new UpMenu(); // содержит ссылку на рабочую область для текущей вкладки


    var leftMenu = function leftMenu() {
      this.workCanvas = null;
      this.parentWorkCanvas = null;
    }; //варианты вызова:
    //    function(canvasID, closeFunc, options) - для обратной совместимости
    //    function(canvasID, options)
    // options - те же, что и в LeftPanelItem


    leftMenu.prototype.createWorkCanvas = function (canvasID, closeFunc, options) {
      if (typeof closeFunc !== 'function') {
        options = closeFunc || {};
        closeFunc = options.closeFunc;
      } else {
        options = options || {};
      }

      options.closeFunc = function () {
        $(_this.parentWorkCanvas).hide();
        closeFunc && closeFunc();
      };

      var _this = this;

      if (!$('#left_' + canvasID).length) {
        var leftPanelItem = new nsGmx$1.LeftPanelItem(canvasID, options);
        this.parentWorkCanvas = leftPanelItem.panelCanvas;
        this.workCanvas = leftPanelItem.workCanvas;
        this.leftPanelItem = leftPanelItem; // так как мы используем dom элементы для поиска панелей после первого добавления
        // возможно, лучше сделать полноценный менеджер панелей левой вкладки

        this.parentWorkCanvas.leftPanelItem = leftPanelItem;
        $('#leftContentInner').prepend(this.parentWorkCanvas);
        return false;
      } else {
        this.parentWorkCanvas = $('#left_' + canvasID)[0];
        this.workCanvas = this.parentWorkCanvas.lastChild;
        this.leftPanelItem = this.parentWorkCanvas.leftPanelItem;
        this.leftPanelItem.close = options.closeFunc;
        $(this.parentWorkCanvas).show();
        $('#leftContentInner').prepend(this.parentWorkCanvas);
        return true;
      }
    };

    nsGmx$1.VirtualLayerManager = function () {
      this._classes = window.gmxVirtualClasses || {};
      this.loader = this.loader.bind(this);
    };

    nsGmx$1.VirtualLayerManager.prototype.loader = function (type) {
      var promise = new L.gmx.Deferred(),
          classInfo = this._classes[type];

      if (!classInfo) {
        promise.resolve();
        return promise;
      }

      window.gmxCore.loadModule(classInfo.module, classInfo.file).then(function (module) {
        promise.resolve(module.layerClass);
      }, promise.reject);
      return promise;
    };

    (function () {
      //внутреннее представление плагина
      var Plugin = function Plugin(moduleName, file, body, params, pluginName, mapPlugin, isPublic, lazyLoad) {
        var usageState = mapPlugin && !lazyLoad ? 'unknown' : 'used'; //used, notused, unknown

        var _this = this;

        var doLoad = function doLoad() {
          if (_this.body || _this.isLoading) return;
          _this.isLoading = true;
          window.gmxCore.loadModule(moduleName, file).then(function () {
            _this.body = window.gmxCore.getModule(moduleName);
            _this.isLoading = false;
            _this.pluginName = _this.pluginName || _this.body.pluginName;

            _this.def.resolve();
          }, function () {
            _this.isLoading = false;

            _this.def.reject();
          });
        };

        this.body = body;
        this.moduleName = moduleName;
        this.params = params || {};
        this.def = $.Deferred(); //будет resolve когда плагин загрузится

        this.isLoading = false;
        this.mapPlugin = mapPlugin || body && body.pluginName;
        this.pluginName = pluginName || this.body && this.body.pluginName;
        this.isPublic = isPublic;
        this.lazyLoad = lazyLoad;
        this.file = file;
        if (this.body) this.def.resolve(); //мы не будем пока загружать плагин только если он не глобальный и имеет имя
        // и только если специально не указана загрузка по требованию

        if (!mapPlugin || !pluginName) {
          if (!lazyLoad) {
            doLoad();
          }
        }

        this.setUsage = function (usage) {
          usageState = usage;

          if (usageState === 'used') {
            doLoad();
          }
        };

        this.isUsed = function () {
          return usageState === 'used';
        };

        this.updateParams = function (newParams) {
          $.extend(true, _this.params, newParams);
        };
      };
      /**
        @name IGeomixerPlugin
        @desc Интерфейс плагинов ГеоМиксера
        @class
        @abstract
        @property {String} pluginName Имя плагина для списка плагинов
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name beforeMap
        @desc Вызывется сразу после загрузки всех модулей ядра вьюера (до инициализации карты, проверки пользователя и т.п.).
              Ещё нет информации о пользователе, но пока можно сменить карту для загрузки.
        @param {Object} params Параметры плагина
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name preloadMap
        @desc Вызывется непосредственно перед началом создания слоёв по загруженной информации о карте.
              Карту сменить уже нельзя, но можно как-нибудь повлиять на процесс создания слоёв (например, добавить новые классы слоёв)
        @param {Object} params Параметры плагина
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name beforeViewer
        @desc вызовется до начала инициализации ГеоМиксера, но сразу после инициализации карты
        @param {Object} params Параметры плагина
        @param {gmxAPI.Map} map Основная карта
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name afterViewer
        @desc вызовется после окончания инициализации ГеоМиксера
        @param {Object} params Параметры плагина
        @param {gmxAPI.Map} map Основная карта
      */

      /** Менеджер плагинов. Загружает плагины из конфигурационного файла
      *
      * Загрузка плагинов происходит из массива window.gmxPlugins.
      *
      * Каждый элемент этого массива - объект со следующими свойствами:
      *
      *   * module (имя модуля)
      *   * file (из какого файла подгружать модуль, может отсутствовать). Только если указано module
      *   * plugin (сам плагин). Если указано, плагин подгружается в явном виде, иначе используется module (и file)
      *   * params - объект параметров, будет передаваться в методы модуля
      *   * pluginName - имя плагина. Должно быть уникальным. Заменяет IGeomixerPlugin.pluginName. Не рекомендуется использовать без особых причин
      *   * mapPlugin {bool, default: true} - является ли плагин плагином карт. Если является, то не будет грузиться по умолчанию.
      *   * isPublic {bool, default: false} - нужно ли показывать плагин в списках плагинов (для некоторых плагинов хочется иметь возможность подключать их к картам, но не показывать всем пользователям)
      *
      * Если очередной элемент массива просто строка (например, "name"), то это эквивалентно {module: "name", file: "plugins/name.js"}
      *
      * Каждый плагин хранится в отдельном модуле (через свойство module) или подгружается в явном виде (через свойство plugin). Модуль должен реализовывать интерфейс IGeomixerPlugin.
      *  @class PluginsManager
      */


      var PluginsManager = function PluginsManager() {
        var _plugins = [];
        var _pluginsWithName = {};
        var joinedPluginInfo = {}; //сначала загружаем инфу о плагинах из переменной nsGmx._defaultPlugins - плагины по умолчанию

        window.nsGmx && nsGmx$1._defaultPlugins && $.each(nsGmx$1._defaultPlugins, function (i, info) {
          if (typeof info === 'string') {
            info = {
              module: info,
              file: 'plugins/' + info + '.js'
            };
          }

          joinedPluginInfo[info.module] = info;
        }); //дополняем её инфой из window.gmxPlugins с возможностью перезаписать

        window.gmxPlugins && $.each(window.gmxPlugins, function (i, info) {
          if (typeof info === 'string') {
            info = {
              module: info,
              file: 'plugins/' + info + '.js'
            };
          }

          joinedPluginInfo[info.module] = $.extend(true, joinedPluginInfo[info.module], info);
        });
        $.each(joinedPluginInfo, function (key, info) {
          if (typeof info === 'string') info = {
            module: info,
            file: 'plugins/' + info + '.js'
          };
          var plugin = new Plugin(info.module, info.file, info.plugin, info.params, info.pluginName, info.mapPlugin, info.isPublic || false, info.lazyLoad || false);

          _plugins.push(plugin);

          if (plugin.pluginName) {
            _pluginsWithName[plugin.pluginName] = plugin;
          } else {
            plugin.def.done(function () {
              if (plugin.pluginName) {
                _pluginsWithName[plugin.pluginName] = plugin;
              }
            });
          }
        });

        var _genIterativeFunction = function _genIterativeFunction(funcName) {
          return function (map) {
            for (var p = 0; p < _plugins.length; p++) {
              if (_plugins[p].isUsed() && _plugins[p].body && _plugins[p].body[funcName]) {
                //передаём в плагин deep clone параметров, чтобы плагин не мог их менять in-place
                var params = $.extend(true, {}, _plugins[p].params);

                try {
                  _plugins[p].body[funcName](params, map || nsGmx$1.leafletMap);
                } catch (e) {
                  console && console.error('Error in function ' + funcName + '() of plugin ' + _plugins[p].moduleName + ': ' + e);
                  console && console.error(e.stack);
                }
              }
            }
          };
        }; //public interface

        /**
        Вызывет callback когда будут загружены все плагины, загружаемые в данный момент
        @memberOf PluginsManager
         @name done
         @method
         @param {Function} callback Ф-ция, которую нужно будет вызвать
        */


        this.done = function (f) {
          //не можем использовать $.when, так как при первой ошибке результирующий promise сразу же reject'ится, а нам нужно дождаться загрузки всех плагинов
          var loadingPlugins = _.where(_plugins, {
            isLoading: true
          }),
              count = loadingPlugins.length;

          count || f();
          loadingPlugins.forEach(function (plugin) {
            plugin.def.always(function () {
              --count || f();
            });
          });
        };
        /**
         Вызывает beforeMap() у всех плагинов
         @memberOf PluginsManager
         @name beforeMap
         @method
        */


        this.beforeMap = _genIterativeFunction('beforeMap');
        /**
         Вызывает preloadMap() у всех плагинов
         @memberOf PluginsManager
         @name preloadMap
         @method
        */

        this.preloadMap = _genIterativeFunction('preloadMap');
        /**
         Вызывает beforeViewer() у всех плагинов
         @memberOf PluginsManager
         @name beforeViewer
         @method
        */

        this.beforeViewer = _genIterativeFunction('beforeViewer');
        /**
         Вызывает afterViewer() у всех плагинов
         @memberOf PluginsManager
         @name afterViewer
         @method
        */

        this.afterViewer = _genIterativeFunction('afterViewer');
        /**
         Добавляет пункты меню всех плагинов к меню upMenu
         Устарело! Используйте непосредственное добавление элемента к меню из afterViewer()
         @method
         @ignore
        */

        this.addMenuItems = function (upMenu) {
          for (var p = 0; p < _plugins.length; p++) {
            if (_plugins[p].isUsed() && _plugins[p].body && _plugins[p].body.addMenuItems) {
              var menuItems = _plugins[p].body.addMenuItems();

              for (var i = 0; i < menuItems.length; i++) {
                upMenu.addChildItem(menuItems[i].item, menuItems[i].parentID);
              }
            }
          }
        };
        /**
         Вызывает callback(plugin) для каждого плагина
         @memberOf PluginsManager
         @name forEachPlugin
         @method
         @param {Function} callback Ф-ция для итерирования. Первый аргумент ф-ции - модуль плагина.
        */


        this.forEachPlugin = function (callback) {
          //if (!_initDone) return;
          for (var p = 0; p < _plugins.length; p++) {
            callback(_plugins[p]);
          }
        };
        /**
         Задаёт, нужно ли в дальнейшем использовать данный плагин
         @memberOf PluginsManager
         @name setUsePlugin
         @method
         @param {String} pluginName Имя плагина
         @param {Bool} isInUse Использовать ли его для карты
        */


        this.setUsePlugin = function (pluginName, isInUse) {
          if (pluginName in _pluginsWithName) _pluginsWithName[pluginName].setUsage(isInUse ? 'used' : 'notused');
        };
        /**
         Получить плагин по имени
         @memberOf PluginsManager
         @name getPluginByName
         @method
         @param {String} pluginName Имя плагина
         @returns {IGeomixerPlugin} Модуль плагина, ничего не возвращает, если плагина нет
        */


        this.getPluginByName = function (pluginName) {
          return _pluginsWithName[pluginName];
        };
        /**
         Проверка публичности плагина (можно ли его показывать в различных списках с перечислением подключенных плагинов)
         @memberOf PluginsManager
         @name isPublic
         @method
         @param {String} pluginName Имя плагина
         @returns {Bool} Является ли плагин публичным
        */


        this.isPublic = function (pluginName) {
          return _pluginsWithName[pluginName] && _pluginsWithName[pluginName].isPublic;
        };
        /**
         Обновление параметров плагина
         @memberOf PluginsManager
         @name updateParams
         @method
         @param {String} pluginName Имя плагина
         @param {Object} newParams Новые параметры плагина. Параметры с совпадающими именами будут перезатёрты
        */


        this.updateParams = function (pluginName, newParams) {
          _pluginsWithName[pluginName] && _pluginsWithName[pluginName].updateParams(newParams);
        };
      };

      var publicInterface = {
        PluginsManager: PluginsManager
      };
      window.gmxCore.addModule('PluginsManager', publicInterface);
    })();

    // Методы:
    //   - isHidden(obj) -> Bool
    //   - isSerializable(obj) -> Bool

    nsGmx$1.DrawingObjectCustomControllers = function () {
      var _delegates = [];
      return {
        addDelegate: function addDelegate(delegate) {
          _delegates.push(delegate);
        },
        isHidden: function isHidden(obj) {
          for (var d = 0; d < _delegates.length; d++) {
            if ('isHidden' in _delegates[d] && _delegates[d].isHidden(obj)) return true;
          }

          return false;
        },
        isSerializable: function isSerializable(obj) {
          for (var d = 0; d < _delegates.length; d++) {
            if ('isSerializable' in _delegates[d] && !_delegates[d].isSerializable(obj)) return false;
          }

          return true;
        }
      };
    }();

    (function (_) {
      var BaseLayersControl = function BaseLayersControl(container, blm) {
        var lang = _translationsHash.getLanguage();

        $(container).append('<table class="group-editor-blm-table">' + '<tr>' + '<td class="group-editor-blm-title">' + _gtxt('Доступные подложки') + '</td>' + '<td class="group-editor-blm-title">' + _gtxt('Подложки карты') + '</td>' + '</tr><tr>' + '<td class="group-editor-blm-available"></td>' + '<td class="group-editor-blm-map"></td>' + '</tr>' + '</table>');
        var availContainer = $('<ul class="group-editor-blm-ul"></ul>').appendTo($('.group-editor-blm-available', container));
        var mapContainer = $('<ul class="group-editor-blm-ul"></ul>').appendTo($('.group-editor-blm-map', container));

        var constructItem = function constructItem(id, title) {
          if (title) {
            return $('<li class="group-editor-blm-item">' + title + '</li>').data('baseLayerID', id);
          } else {
            return $('<li class="group-editor-blm-item group-editor-blm-missing-item">' + id + '</li>').data('baseLayerID', id);
          }
        };

        var activeIDs = blm.getActiveIDs();
        blm.getAll().forEach(function (baseLayer) {
          if (activeIDs.indexOf(baseLayer.id) === -1) {
            var item = constructItem(baseLayer.id, baseLayer.options[lang]);
            availContainer.append(item);
          }
        });
        activeIDs.forEach(function (id) {
          var baseLayer = blm.get(id);
          mapContainer.append(constructItem(id, baseLayer && baseLayer.options[lang]));
        });

        var updateBaseLayers = function updateBaseLayers() {
          var activeIDs = [];
          mapContainer.children('li').each(function (index, elem) {
            activeIDs.push($(elem).data('baseLayerID'));
          });
          blm.setActiveIDs(activeIDs);
        };

        mapContainer.sortable({
          connectWith: '.group-editor-blm-available > ul',
          stop: updateBaseLayers
        });
        availContainer.sortable({
          connectWith: '.group-editor-blm-map > ul',
          stop: updateBaseLayers
        });
      };

      var GroupVisibilityPropertiesModel = Backbone.Model.extend({
        defaults: {
          isChildRadio: false,
          isVisibilityControl: false,
          isExpanded: false
        }
      }); //возвращает массив описания элементов таблицы для использования в mapHelper.createPropertiesTable
      //model {GroupVisibilityPropertiesModel} - ассоциированные параметры видимости
      //showVisibilityCheckbox {bool} - добавлять ли возможность скрывать чекбокс видимости или нет

      var GroupVisibilityPropertiesView = function GroupVisibilityPropertiesView(model, showVisibilityCheckbox, showExpanded) {
        var _model = model;

        var boxSwitch = _checkbox(!_model.get('isChildRadio'), 'checkbox'),
            radioSwitch = _checkbox(_model.get('isChildRadio'), 'radio');

        var showCheckbox = _checkbox(_model.get('isVisibilityControl'), 'checkbox');

        var isExpanded = _checkbox(_model.get('isExpanded'), 'checkbox');

        showCheckbox.onclick = function () {
          _model.set('isVisibilityControl', this.checked);
        };

        isExpanded.onclick = function () {
          _model.set('isExpanded', this.checked);
        };

        boxSwitch.onclick = function () {
          this.checked = true;
          radioSwitch.checked = !this.checked;

          _model.set('isChildRadio', !this.checked);
        };

        radioSwitch.onclick = function () {
          this.checked = true;
          boxSwitch.checked = !this.checked;

          _model.set('isChildRadio', this.checked);
        };

        var ret = [{
          name: _gtxt("Вид вложенных элементов"),
          field: 'list',
          elem: _div([boxSwitch, radioSwitch])
        }];
        if (showVisibilityCheckbox) ret.push({
          name: _gtxt("Показывать чекбокс видимости"),
          elem: _div([showCheckbox])
        });
        if (showExpanded) ret.push({
          name: _gtxt("Разворачивать автоматически"),
          elem: _div([isExpanded])
        });
        return ret;
      };
      /** Показывает диалог добавления новой подгруппы
        @param div {HTMLNode} - куда добавлять новую подгруппу (группа или карта)
        @param layersTree {layersTree} - дерево главной карты
      */


      var addSubGroup = function addSubGroup(div, layersTree) {
        var ul = window._abstractTree.getChildsUl(div.parentNode),
            newIndex;

        if (!ul) newIndex = 0;else newIndex = ul.childNodes.length + 1;
        var groupVisibilityProperties = new GroupVisibilityPropertiesModel();
        var groupVisibilityPropertiesControls = new GroupVisibilityPropertiesView(groupVisibilityProperties, true, true);

        var elemProperties = div.gmxProperties.content ? div.gmxProperties.content.properties : div.gmxProperties.properties,
            newName = elemProperties.title,
            inputIndex = _input(null, [['attr', 'value', newName + ' ' + newIndex], ['dir', 'className', 'inputStyle'], ['css', 'width', '140px']]),
            create = makeButton(_gtxt('Создать')),
            pos = nsGmx$1.Utils.getDialogPos(div, true, 100),
            createSubGroup = function createSubGroup() {
          if (inputIndex.value == '') return;

          var parentProperties = div.gmxProperties,
              newGroupProperties = {
            type: 'group',
            content: {
              properties: {
                title: inputIndex.value,
                list: groupVisibilityProperties.get('isChildRadio'),
                visible: true,
                ShowCheckbox: groupVisibilityProperties.get('isVisibilityControl'),
                expanded: groupVisibilityProperties.get('isExpanded'),
                initExpand: groupVisibilityProperties.get('isExpanded'),
                GroupID: nsGmx$1.Utils.generateUniqueID()
              },
              children: []
            }
          },
              li = window._layersTree.getChildsList(newGroupProperties, parentProperties, false, div.getAttribute('MapID') ? true : window._layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0]));

          _queryMapLayers.addDraggable(li);

          _queryMapLayers.addDroppable(li);

          _queryMapLayers.addSwappable(li);

          layersTree.addTreeElem(div, 0, newGroupProperties);

          var childsUl = window._abstractTree.getChildsUl(div.parentNode);

          if (childsUl) {
            window._abstractTree.addNode(div.parentNode, li);

            window._layersTree.updateListType(li, true);

            if (!childsUl.loaded) li.removeNode(true);
          } else {
            window._abstractTree.addNode(div.parentNode, li);

            window._layersTree.updateListType(li, true);
          }

          $(dialogDiv).dialog('destroy');
          dialogDiv.removeNode(true);

          _mapHelper.updateUnloadEvent(true);
        };

        create.onclick = createSubGroup;
        $(inputIndex).on('keyup', function (e) {
          if (this.value == '') $(this).addClass('error');else $(this).removeClass('error');

          if (e.keyCode === 13) {
            createSubGroup();
            return false;
          }

          return true;
        });
        create.style.marginTop = '5px';

        var parentDiv = _div([inputIndex, _br(), create], [['css', 'textAlign', 'center']]);

        var trs = [{
          name: _gtxt("Имя группы"),
          elem: inputIndex
        }].concat(groupVisibilityPropertiesControls);

        var trsControls = _mapHelper.createPropertiesTable(trs, elemProperties, {
          leftWidth: 100
        });

        var propsTable = _div([_table([_tbody(trsControls)], [['dir', 'className', 'propertiesTable']])]);

        _(parentDiv, [propsTable, _br(), create]);

        var dialogDiv = showDialog(_gtxt("Введите имя группы"), parentDiv, 270, 220, pos.left, pos.top);
      };

      var createGroupEditorProperties = function createGroupEditorProperties(div, isMap, mainLayersTree) {
        var elemProperties = isMap ? div.gmxProperties.properties : div.gmxProperties.content.properties;
        var rawTree = mainLayersTree.treeModel.getRawTree();

        var title = _input(null, [['attr', 'value', typeof elemProperties.title != 'undefined' ? elemProperties.title : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '206px']]);

        var visibilityProperties = new GroupVisibilityPropertiesModel({
          isChildRadio: elemProperties.list,
          isVisibilityControl: typeof elemProperties.ShowCheckbox === 'undefined' ? false : elemProperties.ShowCheckbox,
          isExpanded: typeof elemProperties.initExpand === 'undefined' ? false : elemProperties.initExpand
        });
        var visibilityPropertiesView = GroupVisibilityPropertiesView(visibilityProperties, !isMap, !isMap);
        visibilityProperties.on('change', function () {
          elemProperties.list = visibilityProperties.get('isChildRadio');
          elemProperties.ShowCheckbox = visibilityProperties.get('isVisibilityControl');
          elemProperties.expanded = elemProperties.initExpand = visibilityProperties.get('isExpanded');

          window._layersTree.treeModel.updateNodeVisibility(mainLayersTree.findTreeElem(div).elem, null);

          var curBox = div.firstChild;

          if (!elemProperties.ShowCheckbox) {
            curBox.checked = true;
            curBox.style.display = 'none';
            curBox.isDummyCheckbox = true;
          } else {
            curBox.style.display = 'block';
            delete curBox.isDummyCheckbox;
          }

          if (isMap) {
            rawTree.properties = div.gmxProperties.properties;
          } else {
            mainLayersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
          }

          var ul = window._abstractTree.getChildsUl(div.parentNode);

          $(ul).children('li').each(function () {
            window._layersTree.updateListType(this, true);
          });
        });

        title.onkeyup = function () {
          if (title.value == '') {
            $(title).addClass('error');
            return;
          } else $(title).removeClass('error');

          var span = $(div).find(".groupLayer")[0];
          $(span).empty();

          _(span, [_t(title.value)]);

          if (isMap) {
            $('.mainmap-title').text(title.value);
            div.gmxProperties.properties.title = title.value;
            rawTree.properties = div.gmxProperties.properties;
          } else {
            div.gmxProperties.content.properties.title = title.value;
            mainLayersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
          }

          return true;
        };

        var addProperties = function addProperties(shownProperties) {
          return _mapHelper.createPropertiesTable(shownProperties, elemProperties, {
            leftWidth: 100
          });
        };

        if (isMap) {
          var useAPI = _checkbox(elemProperties.UseKosmosnimkiAPI, 'checkbox'),
              useOSM = _checkbox(elemProperties.UseOpenStreetMap, 'checkbox'),
              defLang = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="defLang" value="rus">rus</label>' + '<label><input type="radio" name="defLang" value="eng">eng</label>' + '</span>')[0],
              distUnit = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="distUnit" value="auto">' + _gtxt('units.auto') + '</label>' + '<label><input type="radio" name="distUnit" value="m">' + _gtxt('units.m') + '</label>' + '<label><input type="radio" name="distUnit" value="km">' + _gtxt('units.km') + '</label>' + '<label><input type="radio" name="distUnit" value="nm">' + _gtxt('units.nm') + '</label>' + '</span>')[0],
              squareUnit = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="squareUnit" value="auto">' + _gtxt('units.auto') + '</label>' + '<label><input type="radio" name="squareUnit" value="m2">' + _gtxt('units.m2') + '</label>' + '<label><input type="radio" name="squareUnit" value="ha">' + _gtxt('units.ha') + '</label>' + '<label><input type="radio" name="squareUnit" value="km2">' + _gtxt('units.km2') + '</label>' + '</span>')[0],
              coordinatesFormat = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="coordinatesFormat" value="0">' + _gtxt('coords.dd') + '</label>' + '<label><input type="radio" name="coordinatesFormat" value="1">' + _gtxt('coords.dms') + '</label>' + '</span>')[0],
              maxPopupCount = $('<span class="maxPopupCountContainer">' + '<input type="number" min="1" class="inputStyle inputShortWidth">' + '</input>' + '</span>')[0],
              layerOrder = $('<select class="selectStyle">' + '<option value="Native">' + _gtxt('layerOrder.native') + '</label>' + '<option value="VectorOnTop">' + _gtxt('layerOrder.vectorOnTop') + '</label>' + '</select>')[0],
              downloadVectors = _checkbox(elemProperties.CanDownloadVectors, 'checkbox'),
              downloadRasters = _checkbox(elemProperties.CanDownloadRasters, 'checkbox'),
              // WMSLink = _a([_t(_gtxt('ссылка'))], [['attr', 'href', window.serverBase + 'TileService.ashx?map=' + elemProperties.name]]),
          WMSLinks = $(Handlebars.compile('<div>' + '<ul>' + '{{#each this.services}}' + '<li>' + '{{this.upper}}: {{this.url}}rest/ver1/service/{{this.name}}?map={{this.mapName}}{{#if this.site}}&apikey=[APIKEY_VALUE]{{/if}}' + '</li>' + '<br>' + '{{/each}}' + '</ul>' + '</div>')({
            services: [{
              site: window.mapsSite,
              url: window.serverBase,
              mapName: elemProperties.MapID,
              name: 'wms',
              upper: 'WMS'
            }, {
              site: window.mapsSite,
              url: window.serverBase,
              mapName: elemProperties.MapID,
              name: 'wfs',
              upper: 'WFS'
            }]
          }))[0],
              WMSAccess = _checkbox(elemProperties.WMSAccess, 'checkbox'),
              defLat = _input(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.DefaultLat !== null ? elemProperties.DefaultLat : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              defLong = _input(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.DefaultLong !== null ? elemProperties.DefaultLong : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              defPermalink = _input(null, [['attr', 'value', elemProperties.ViewUrl != null ? elemProperties.ViewUrl : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '206px']]),
              defZoom = _input(null, [['attr', 'placeholder', _gtxt("placeholder zoom")], ['attr', 'value', elemProperties.DefaultZoom != null ? elemProperties.DefaultZoom : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '60px']]),
              onLoad = _textarea(null, [['dir', 'className', 'inputStyle group-editor-onload']]),
              copyright = _input(null, [['attr', 'value', elemProperties.Copyright != null ? elemProperties.Copyright : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '206px']]),
              minViewX = _input(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MinViewX != null && elemProperties.MinViewX != 0 ? elemProperties.MinViewX : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              minViewY = _input(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MinViewY != null && elemProperties.MinViewY != 0 ? elemProperties.MinViewY : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              maxViewX = _input(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MaxViewX != null && elemProperties.MaxViewX != 0 ? elemProperties.MaxViewX : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              maxViewY = _input(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MaxViewY != null && elemProperties.MaxViewY != 0 ? elemProperties.MaxViewY : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              minZoom = _input(null, [['attr', 'placeholder', _gtxt("placeholder minZoom")], ['attr', 'value', elemProperties.MinZoom != null ? elemProperties.MinZoom : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              maxZoom = _input(null, [['attr', 'placeholder', _gtxt("placeholder maxZoom")], ['attr', 'value', elemProperties.MaxZoom != null ? elemProperties.MaxZoom : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]);

          onLoad.value = nsGmx$1.mappletLoader.get();

          useAPI.onclick = function () {
            div.gmxProperties.properties.UseKosmosnimkiAPI = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          $([useAPI, useOSM]).addClass('propertiesTable-checkbox');
          $('input[value=' + elemProperties.DefaultLanguage + ']', defLang).attr('checked', 'checked');
          $('input[value=' + elemProperties.DistanceUnit + ']', distUnit).attr('checked', 'checked');
          $('input[value=' + elemProperties.SquareUnit + ']', squareUnit).attr('checked', 'checked');
          $('input[value=' + elemProperties.coordinatesFormat + ']', coordinatesFormat).attr('checked', 'checked');
          $('input', maxPopupCount).val(elemProperties.maxPopupContent);
          $('option[value=' + (elemProperties.LayerOrder || 'Native') + ']', layerOrder).attr('selected', 'selected');
          $('input', defLang).change(function () {
            div.gmxProperties.properties.DefaultLanguage = this.value;
            rawTree.properties = div.gmxProperties.properties;
          });
          $('input', distUnit).change(function () {
            div.gmxProperties.properties.DistanceUnit = this.value;
            rawTree.properties = div.gmxProperties.properties;
            nsGmx$1.leafletMap.options.distanceUnit = this.value;
          });
          $('input', squareUnit).change(function () {
            div.gmxProperties.properties.SquareUnit = this.value;
            rawTree.properties = div.gmxProperties.properties;
            nsGmx$1.leafletMap.options.squareUnit = this.value;
          });
          $('input', coordinatesFormat).change(function () {
            var num = Number(this.value),
                locationControl = nsGmx$1.leafletMap.gmxControlsManager.get('location');

            if (locationControl) {
              locationControl.setCoordinatesFormat(num);
            }

            nsGmx$1.leafletMap.options.coordinatesFormat = num;
            div.gmxProperties.properties.coordinatesFormat = num;
          });
          $('input', maxPopupCount).change(function () {
            if (Number(this.value) > 0) {
              div.gmxProperties.properties.maxPopupContent = this.value;
              rawTree.properties = div.gmxProperties.properties;
              nsGmx$1.leafletMap.options.maxPopupCount = this.value;
            }
          });
          $(layerOrder).change(function () {
            div.gmxProperties.properties.LayerOrder = this.value;
            rawTree.properties = div.gmxProperties.properties;
          });

          useOSM.onclick = function () {
            div.gmxProperties.properties.UseOpenStreetMap = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          downloadVectors.onclick = function () {
            div.gmxProperties.properties.CanDownloadVectors = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          downloadRasters.onclick = function () {
            div.gmxProperties.properties.CanDownloadRasters = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          WMSAccess.onclick = function () {
            div.gmxProperties.properties.WMSAccess = this.checked;
            rawTree.properties = div.gmxProperties.properties;
            $(WMSLinks).toggle(this.checked);
          };

          defLat.onkeyup = function () {
            div.gmxProperties.properties.DefaultLat = this.value === '' || isNaN(Number(this.value)) ? null : Number(this.value);
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          defLong.onkeyup = function () {
            div.gmxProperties.properties.DefaultLong = this.value === '' || isNaN(Number(this.value)) ? null : Number(this.value);
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          defPermalink.onkeyup = function () {
            div.gmxProperties.properties.ViewUrl = this.value;
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          defZoom.onkeyup = function () {
            div.gmxProperties.properties.DefaultZoom = this.value === '' || isNaN(Number(this.value)) ? null : Number(this.value);
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          onLoad.onkeyup = function () {
            nsGmx$1.mappletLoader.set(this.value);
            return true;
          };

          copyright.onkeyup = function () {
            div.gmxProperties.properties.Copyright = this.value;
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          minViewX.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MinViewX = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          minViewY.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MinViewY = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          maxViewX.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MaxViewX = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          maxViewY.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MaxViewY = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          minZoom.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MinZoom = Number(this.value) || null;
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          maxZoom.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MaxZoom = Number(this.value) || null;
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          WMSAccess.style.verticalAlign = "middle";
          $(WMSLinks).toggle(elemProperties.WMSAccess);
          var shownCommonProperties = [{
            name: _gtxt("Имя"),
            field: 'title',
            elem: title
          }, {
            name: _gtxt("ID"),
            field: 'name'
          }, {
            name: _gtxt("Копирайт"),
            field: 'Copyright',
            elem: copyright
          }].concat([{
            name: _gtxt("Использовать KosmosnimkiAPI"),
            elem: useAPI
          }, {
            name: _gtxt("Язык по умолчанию"),
            elem: defLang
          }, {
            name: _gtxt("Единицы длины"),
            elem: distUnit
          }, {
            name: _gtxt("Единицы площади"),
            elem: squareUnit
          }, {
            name: _gtxt("Формат координат"),
            elem: coordinatesFormat
          }, {
            name: _gtxt("Количество информационных окошек"),
            elem: maxPopupCount
          }, {
            name: _gtxt("layerOrder.title"),
            elem: layerOrder
          }, {
            name: _gtxt("Ссылка (permalink)"),
            elem: defPermalink
          }]),
              shownPolicyProperties = [{
            name: _gtxt("Разрешить скачивание"),
            elem: _table([_tbody([_tr([_td([_t(_gtxt('Векторных слоев'))], [['css', 'width', '100px'], ['css', 'height', '20px'], ['css', 'paddingLeft', '3px']]), _td([downloadVectors])]), _tr([_td([_t(_gtxt('Растровых слоев'))], [['css', 'width', '100px'], ['css', 'height', '20px'], ['css', 'paddingLeft', '3px']]), _td([downloadRasters])])])])
          }, {
            name: _gtxt("WMS доступ"),
            elem: _div([WMSAccess
            /*, WMSLinks*/
            ])
          }],
              shownViewProperties = [{
            name: _gtxt("Начальная позиция"),
            elem: _table([_tbody([_tr([_td([_span([_t(_gtxt('Широта'))], [['css', 'marginLeft', '3px']]), _br(), defLat], [['css', 'width', '70px']]), _td([_span([_t(_gtxt('Долгота'))], [['css', 'marginLeft', '3px']]), _br(), defLong], [['css', 'width', '70px']]), _td([_span([_t(_gtxt('Зум'))], [['css', 'marginLeft', '3px']]), _br(), defZoom], [['css', 'width', '68px']])])])], [['css', 'borderCollapse', 'collapse']])
          }, {
            name: _gtxt("Зум"),
            elem: _table([_tbody([_tr([_td([_span([_t(_gtxt('Мин'))], [['css', 'marginLeft', '3px']]), _br(), minZoom], [['css', 'width', '70px']]), _td([_span([_t(_gtxt('Макс'))], [['css', 'marginLeft', '3px']]), _br(), maxZoom], [['css', 'width', '70px'], ['css', 'rowspan', '2']])])])], [['css', 'borderCollapse', 'collapse']])
          }, {
            name: _gtxt("Граница обрезки"),
            elem: _table([_tbody([_tr([_td([_span(null, [['css', 'marginLeft', '3px']]), _br()], [['css', 'width', '73px']]), _td([_span([_t(_gtxt('Широта'))], [['css', 'marginLeft', '3px']])], [['css', 'width', '70px']]), _td([_span([_t(_gtxt('Долгота'))], [['css', 'marginLeft', '3px']])], [['css', 'width', '68px']])]), _tr([_td([_span([_t(_gtxt('Мин'))], [['css', 'marginLeft', '3px']])]), _td([minViewY]), _td([minViewX])]), _tr([_td([_span([_t(_gtxt('Макс'))], [['css', 'marginLeft', '3px']])]), _td([maxViewY]), _td([maxViewX])])])], [['css', 'borderCollapse', 'collapse']])
          }];

          var id = 'mapProperties' + String(Math.random()).substring(2, 12),
              tabMenu = _div([_ul([_li([_a([_t(_gtxt("Общие"))], [['attr', 'href', '#common' + id]])]), _li([_a([_t(_gtxt("Подложки"))], [['attr', 'href', '#baselayers' + id]])]), _li([_a([_t(_gtxt("Доступ"))], [['attr', 'href', '#policy' + id]])]), _li([_a([_t(_gtxt("Поиск"))], [['attr', 'href', '#search' + id]])]), _li([_a([_t(_gtxt("Окно карты"))], [['attr', 'href', '#view' + id]])]), _li([_a([_t(_gtxt("Загрузка"))], [['attr', 'href', '#onload' + id]])]), _li([_a([_t(_gtxt("Плагины"))], [['attr', 'href', '#plugins' + id]])])])]),
              divCommon = _div(null, [['attr', 'id', 'common' + id], ['css', 'width', '320px']]),
              divBaseLayers = _div(null, [['attr', 'id', 'baselayers' + id], ['dir', 'className', 'group-editor-tab-container'], ['css', 'overflowY', 'auto']]),
              divPolicy = _div(null, [['attr', 'id', 'policy' + id], ['css', 'width', '320px']]),
              divSearch = _div(null, [['attr', 'id', 'search' + id], ['dir', 'className', 'group-editor-tab-container']]),
              divView = _div(null, [['attr', 'id', 'view' + id], ['css', 'width', '320px']]),
              divOnload = _div(null, [['attr', 'id', 'onload' + id], ['dir', 'className', 'group-editor-tab-container']]),
              divPlugins = _div(null, [['attr', 'id', 'plugins' + id], ['dir', 'className', 'group-editor-tab-container']]);

          _(tabMenu, [divCommon, divBaseLayers, divPolicy, divSearch, divView, divOnload, divPlugins]);

          new BaseLayersControl(divBaseLayers, nsGmx$1.leafletMap.gmxBaseLayersManager);

          _(divCommon, [_table([_tbody(addProperties(shownCommonProperties))], [['css', 'width', '100%'], ['dir', 'className', 'propertiesTable']])]);

          _(divPolicy, [_table([_tbody(addProperties(shownPolicyProperties))], [['css', 'width', '100%'], ['dir', 'className', 'propertiesTable']]), WMSLinks]);

          _(divView, [_table([_tbody(addProperties(shownViewProperties))], [['css', 'width', '100%'], ['dir', 'className', 'propertiesTable']])]);

          _(divOnload, [onLoad]);

          var pluginsEditor = nsGmx$1.createPluginsEditor(divPlugins, _mapHelper.mapPlugins);
          var mapLayersTree = new window.layersTree({
            showVisibilityCheckbox: false,
            allowActive: false,
            allowDblClick: false,
            showStyle: false,
            visibilityFunc: function visibilityFunc(props, isVisible) {
              var origTreeNode = mainLayersTree.treeModel.findElem('LayerID', props.LayerID).elem;
              origTreeNode.content.properties.AllowSearch = isVisible;
            }
          }); //формируем новое дерево - без не-векторных слоёв и пустых папок,
          //в котором видимость слоя отражает возможность его скачивания

          var searchRawTree = mainLayersTree.treeModel.cloneRawTree(function (node) {
            if (node.type === 'layer') {
              var props = node.content.properties;

              if (props.type !== 'Vector') {
                return null;
              }

              props.visible = !!props.AllowSearch;
              return node;
            }

            if (node.type === 'group') {
              var children = node.content.children;

              if (!children.length) {
                return null;
              }

              var isVisible = false;

              for (var i = 0; i < children.length; i++) {
                isVisible = isVisible || children[i].content.properties.visible;
              }

              node.content.properties.visible = isVisible;
              return node;
            }
          });
          var mapLayersDOM = mapLayersTree.drawTree(searchRawTree, 2);
          $('<div class="group-editor-search-title"/>').text(_gtxt('Выберите слои для поиска по атрибутам')).appendTo(divSearch);
          $(mapLayersDOM).treeview().appendTo(divSearch);

          tabMenu.updateFunc = function () {
            var props = div.gmxProperties.properties;
            props.UseKosmosnimkiAPI = useAPI.checked;
            props.UseOpenStreetMap = useOSM.checked;
            props.CanDownloadVectors = downloadVectors.checked;
            props.CanDownloadRasters = downloadRasters.checked;
            props.WMSAccess = WMSAccess.checked;
            props.DefaultLat = isNaN(Number(defLat.value)) || defLat.value === '' ? null : Number(defLat.value);
            props.DefaultLong = isNaN(Number(defLong.value)) || defLong.value === '' ? null : Number(defLong.value);
            props.ViewUrl = defPermalink.checked;
            props.DefaultZoom = isNaN(Number(defZoom.value)) || defZoom.value === '' ? null : Number(defZoom.value);
            props.onLoad = onLoad.value;
            props.Copyright = copyright.value;
            props.MinViewX = isNaN(Number(minViewX.value)) ? null : Number(minViewX.value);
            props.MinViewY = isNaN(Number(minViewY.value)) ? null : Number(minViewY.value);
            props.MaxViewX = isNaN(Number(maxViewX.value)) ? null : Number(maxViewX.value);
            props.MaxViewY = isNaN(Number(maxViewY.value)) ? null : Number(maxViewY.value);
            props.MaxZoom = isNaN(Number(maxZoom.value)) ? null : Number(maxZoom.value) || null;
            props.MinZoom = isNaN(Number(minZoom.value)) ? null : Number(minZoom.value) || null;
            rawTree.properties = props;
            pluginsEditor.update();
          };

          tabMenu.closeFunc = function () {
            pluginsEditor.closeParamsDialogs();
          };

          return tabMenu;
        } else {
          var shownProperties = [{
            name: _gtxt("Имя"),
            field: 'title',
            elem: title
          }, {
            name: _gtxt("ID"),
            field: 'GroupID'
          }].concat(visibilityPropertiesView);
          return _div([_table([_tbody(addProperties(shownProperties))], [['css', 'width', '100%']])], [['css', 'width', '320px'], ['dir', 'className', 'propertiesTable']]);
        }
      };

      var _groupEditorsHash = {};
      /** Создаёт диалог редактирование свойств группы. Есть проверка на создание дублирующих диалогов
       @param div {HTMLHNode} - элемент дерева, соответствующий редактируемой группе
      */

      var createGroupEditor = function createGroupEditor(div) {
        var elemProperties = div.gmxProperties.content.properties;
        if (_groupEditorsHash[elemProperties.GroupID]) return;

        var pos = nsGmx$1.Utils.getDialogPos(div, true, 140),
            closeFunc = function closeFunc() {
          delete _groupEditorsHash[elemProperties.GroupID];
          return false;
        };

        var canvas = createGroupEditorProperties(div, false, window._layersTree);
        showDialog(_gtxt('Группа [value0]', elemProperties.title), canvas, 340, 230, pos.left, pos.top, null, closeFunc);
        _groupEditorsHash[elemProperties.GroupID] = true;
        canvas.parentNode.style.width = canvas.clientWidth + 'px';
      };

      window._mapEditorsHash = {};
      /** Создаёт диалог редактирование свойств группы. Есть проверка на создание дублирующих диалогов
       @param div {HTMLHNode} - элемент дерева, соответствующий редактируемой карте
      */

      var createMapEditor = function createMapEditor(div, activePage) {
        var elemProperties = div.gmxProperties.properties;
        if (window._mapEditorsHash[elemProperties.MapID]) return;

        var pos = nsGmx$1.Utils.getDialogPos(div, true, 530),
            closeFunc = function closeFunc() {
          delete window._mapEditorsHash[elemProperties.MapID];
          canvas.updateFunc();
          canvas.closeFunc();
          return false;
        };

        var canvas = createGroupEditorProperties(div, true, window._layersTree);
        showDialog(_gtxt('Карта [value0]', elemProperties.title), canvas, 450, 410, pos.left, pos.top, null, closeFunc);
        window._mapEditorsHash[elemProperties.MapID] = {
          update: canvas.updateFunc
        };
        $(canvas).tabs({
          active: activePage || 0
        });
        canvas.parentNode.style.width = canvas.clientWidth + 'px';
      };

      window.gmxCore.addModule('GroupEditor', {
        addSubGroup: addSubGroup,
        createGroupEditor: createGroupEditor,
        createMapEditor: createMapEditor
      });
    })(nsGmx$1.Utils._);

    (function (_) {
      /** Разнообразные вспомогательные контролы (базовые элементы GUI)
          @namespace nsGmx.Controls
      */
      nsGmx$1.Controls = {
        /** Создаёт контрол выбора цвета */
        createColorPicker: function createColorPicker(color, showFunc, hideFunc, changeFunc) {
          var colorPicker = _div(null, [['dir', 'className', 'colorSelector'], ['css', 'backgroundColor', nsGmx$1.Utils.convertColor(color)]]);

          $(colorPicker).ColorPicker({
            color: nsGmx$1.Utils.convertColor(color),
            onShow: showFunc,
            onHide: hideFunc,
            onChange: changeFunc
          });

          _title(colorPicker, _gtxt("Цвет"));

          return colorPicker;
        },

        /** Создаёт иконку по описанию стиля слоя и типа геометрии
           */
        createGeometryIcon: function createGeometryIcon(parentStyle, type) {
          var icon = _div(null, [['css', 'display', 'inline-block'], ['dir', 'className', 'colorIcon'], ['attr', 'styleType', 'color']]);

          if (window.newStyles) {
            if (type.indexOf('linestring') < 0) {
              if (parentStyle.fill && parentStyle.fill.pattern) {
                var opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {
                  fill: {
                    opacity: 100
                  }
                })),
                    patternData = L.gmxUtil.getPatternIcon(null, opaqueStyle);
                icon = patternData ? patternData.canvas : document.createElement('canvas');

                _(icon, [], [['dir', 'className', 'icon'], ['attr', 'styleType', 'icon'], ['css', 'width', '13px'], ['css', 'height', '13px']]);
              } else {
                var fill = _div(null, [['dir', 'className', 'fillIcon'], ['css', 'backgroundColor', parentStyle.fillColor ? color2Hex(parentStyle.fillColor) : "#FFFFFF"]]),
                    fillOpacity = typeof parentStyle.fillOpacity !== 'undefined' ? parentStyle.fillOpacity : 1,
                    border = _div(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.color ? color2Hex(parentStyle.color) : "#0000FF"]]),
                    borderOpacity = typeof parentStyle.opacity !== 'undefined' ? parentStyle.opacity : 1;

                fill.style.opacity = fillOpacity;
                border.style.opacity = borderOpacity;

                if (type.indexOf('point') > -1) {
                  border.style.height = '5px';
                  fill.style.height = '5px';
                  border.style.width = '5px';
                  fill.style.width = '5px';
                  border.style.top = '3px';
                  fill.style.top = '4px';
                  border.style.left = '1px';
                  fill.style.left = '2px';
                }

                _(icon, [border, fill]);
              }
            } else {
              var _border = _div(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.color ? color2Hex(parentStyle.color) : "#0000FF"]]),
                  _borderOpacity = parentStyle.opacity !== 'undefined' ? parentStyle.opacity : 1;

              _border.style.opacity = _borderOpacity;
              _border.style.width = '4px';
              _border.style.height = '13px';
              _border.style.borderTop = 'none';
              _border.style.borderBottom = 'none';
              _border.style.borderLeft = 'none';

              _(icon, [_border]);
            }
          } else if (type.indexOf('linestring') < 0) {
            if (parentStyle.fill && parentStyle.fill.pattern) {
              var _opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {
                fill: {
                  opacity: 100
                }
              })),
                  _patternData = L.gmxUtil.getPatternIcon(null, _opaqueStyle);

              icon = _patternData ? _patternData.canvas : document.createElement('canvas');

              _(icon, [], [['dir', 'className', 'icon'], ['attr', 'styleType', 'icon'], ['css', 'width', '13px'], ['css', 'height', '13px']]);
            } else {
              var _fill = _div(null, [['dir', 'className', 'fillIcon'], ['css', 'backgroundColor', parentStyle.fill && typeof parentStyle.fill.color != 'undefined' ? nsGmx$1.Utils.convertColor(parentStyle.fill.color) : "#FFFFFF"]]),
                  _border2 = _div(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.outline && typeof parentStyle.outline.color != 'undefined' ? nsGmx$1.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
                  _fillOpacity = parentStyle.fill && typeof parentStyle.fill.opacity != 'undefined' ? parentStyle.fill.opacity : 100,
                  _borderOpacity2 = parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined' ? parentStyle.outline.opacity : 100;

              _fill.style.opacity = _fillOpacity / 100;
              _border2.style.opacity = _borderOpacity2 / 100;

              if (type.indexOf('point') > -1) {
                _border2.style.height = '5px';
                _fill.style.height = '5px';
                _border2.style.width = '5px';
                _fill.style.width = '5px';
                _border2.style.top = '3px';
                _fill.style.top = '4px';
                _border2.style.left = '1px';
                _fill.style.left = '2px';
              }

              _(icon, [_border2, _fill]);
            }
          } else {
            var _border3 = _div(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.outline && typeof parentStyle.outline.color != 'undefined' ? nsGmx$1.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
                _borderOpacity3 = parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined' ? parentStyle.outline.opacity : 100;

            _border3.style.opacity = _borderOpacity3 / 100;
            _border3.style.width = '4px';
            _border3.style.height = '13px';
            _border3.style.borderTop = 'none';
            _border3.style.borderBottom = 'none';
            _border3.style.borderLeft = 'none';

            _(icon, [_border3]);
          }

          icon.oncontextmenu = function () {
            return false;
          };

          return icon;

          function color2Hex(color) {
            if (typeof color === 'number') {
              return nsGmx$1.Utils.convertColor(color);
            } else if (typeof color === 'string') {
              if (color.indexOf('#') === -1) {
                return color2Hex(Number(color));
              } else {
                return color;
              }
            }
          }
        },

        /** Создаёт контрол "слайдер".
           */
        createSlider: function createSlider(opacity, changeFunc) {
          var divSlider = _div(null, [['css', 'width', '86px'], ['css', 'height', '8px'], ['css', 'border', '1px solid #cdcdcd']]);

          $(divSlider).slider({
            min: 0,
            max: 100,
            step: 1,
            value: opacity,
            slide: function slide(event, ui) {
              changeFunc(event, ui);

              _title(divSlider.firstChild, ui.value);
            }
          });
          divSlider.firstChild.style.zIndex = 1;
          divSlider.style.width = '100px';
          divSlider.style.border = 'none';
          divSlider.style.backgroundImage = 'url(img/slider.png)';
          divSlider.firstChild.style.border = 'none';
          divSlider.firstChild.style.width = '12px';
          divSlider.firstChild.style.height = '14px';
          divSlider.firstChild.style.marginLeft = '-6px';
          divSlider.firstChild.style.top = '-3px';
          divSlider.firstChild.style.background = 'transparent url(img/sliderIcon.png) no-repeat';

          divSlider.firstChild.onmouseover = function () {
            divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon_a.png)';
          };

          divSlider.firstChild.onmouseout = function () {
            divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon.png)';
          };

          _title(divSlider.firstChild, opacity);

          _title(divSlider, _gtxt("Прозрачность"));

          return divSlider;
        },
        createInput: function createInput(value, changeFunc) {
          var input = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '30px'], ['attr', 'value', value]]);

          input.onkeyup = changeFunc;
          return input;
        },

        /** Создаёт диалог, позволяющий выбрать пользователю один из нарисованных на карте объектов
         * @param {String} name Уникальный идентификатор диалога
         * @param {function(gmxAPI.DrawingObject)} callback Ф-ция, которая вызовется при выборе пользователем одного из объектов
         * @param {Object} [params] Дополнительные параметры диалога
         * @param {String} [params.title] Заголовок диалога
         * @param {String} [params.geomType=null] Ограничения на тип геометрии (POINT, LINESTRING, POLYGON). null - без ограничений
         * @param {String} [params.errorTitle] Заголовок диалога с ошибками (например, если нет объектов)
         * @param {String} [params.errorMessage] Текст диалога с ошибками (например, если нет объектов)
         * @param {Number} [params.width=250] Ширина диалога в пикселях
        */
        chooseDrawingBorderDialog: function chooseDrawingBorderDialog(name, callback, params) {
          var TYPE_CONVERT_DICT = {
            Polyline: 'linestring',
            MultiPolyline: 'linestring',
            Rectangle: 'polygon',
            Polygon: 'polygon',
            MultiPolygon: 'polygon',
            Point: 'point'
          };

          var _params = $.extend({
            title: _gtxt("Выбор контура"),
            geomType: null,
            errorTitle: _gtxt("$$phrase$$_12"),
            errorMessage: _gtxt("$$phrase$$_12"),
            width: 250
          }, params);

          if ($('#drawingBorderDialog' + name).length) return;
          var drawingObjs = [];
          nsGmx$1.leafletMap.gmxDrawing.getFeatures().forEach(function (obj) {
            if (!_params.geomType || TYPE_CONVERT_DICT[obj.getType()] === _params.geomType.toLowerCase()) {
              drawingObjs.push(obj);
            }
          });
          if (!drawingObjs.length) showErrorMessage(_params.errorMessage, true, _params.errorTitle);else {
            window.gmxCore.loadModule('DrawingObjects').done(function (drawing) {
              var canvas = _div();

              var collection = new drawing.DrawingObjectCollection(nsGmx$1.leafletMap);

              for (var i = 0; i < drawingObjs.length; i++) {
                collection.Add(drawingObjs[i]);
              }

              new drawing.DrawingObjectList(nsGmx$1.leafletMap, canvas, collection, {
                allowDelete: false,
                editStyle: false,
                showButtons: false,
                click: function click(drawingObject) {
                  callback && callback(drawingObject);
                  removeDialog(jDialog);
                }
              });
              var jDialog = nsGmx$1.Utils.showDialog(_params.title, _div([canvas], [['attr', 'id', 'drawingBorderDialog' + name], ['dir', 'className', 'drawingObjectsCanvas']]), {
                width: _params.width,
                height: 180
              });
            });
          }
        },

        /**
         Создаёт виджет для управления видимостью (скрытия/показа) других элементов
         Сам виджет представляет из себя изменяющуюся иконку с текстом заголовка рядом с ней
         @class
         @param {String} title - текст заголовка
         @param {DOMElement} titleElem - элемент для размещения самого виджета
         @param {DOMElement|Array[]} managedElems - элементы, видимостью которых будем
         @param {Bool} isCollapsed - начальное состояние виджета
        */
        CollapsibleWidget: function CollapsibleWidget(title, titleElem, managedElems, isCollapsed) {
          //let contentTr = _tr([_td([layerTagsParent], [['dir', 'colSpan', '2']])]);
          var collapseTagIcon = $('<div/>').addClass('collabsible-icon');

          var _isCollapsed = !!isCollapsed;

          managedElems = managedElems || [];
          if (!$.isArray(managedElems)) managedElems = [managedElems];

          var updateElems = function updateElems() {
            for (var iE = 0; iE < managedElems.length; iE++) {
              $(managedElems[iE]).toggle(!_isCollapsed);
            }
          };

          var updateView = function updateView() {
            collapseTagIcon.toggleClass('collabsible-icon-hidden', _isCollapsed).toggleClass('collabsible-icon-shown', !_isCollapsed);
            updateElems();
          };

          updateView();
          $(titleElem).empty().append(collapseTagIcon, $('<div/>').addClass('collabsible-title').text(title)).click(function () {
            _isCollapsed = !_isCollapsed;
            updateView();
          });

          this.addManagedElements = function (elems) {
            managedElems = managedElems.concat(elems);
            updateElems();
          };

          this.isCollapsed = function () {
            return _isCollapsed;
          };
        },

        /** Показывает аттрибутивную информацию объекта в виде таблички в отдельном диалоге */
        showLayerInfo: function showLayerInfo(layer, obj) {
          var trs = [];
          var typeSpans = {};

          for (var key in obj.properties) {
            var content = _div(),
                contentText = String(obj.properties[key]);

            if (contentText.indexOf("http://") == 0 || contentText.indexOf("https://") == 0 || contentText.indexOf("www.") == 0) contentText = "<a href=\"" + contentText + "\" target=\"_blank\">" + contentText + "</a>";
            content.innerHTML = contentText;

            var typeSpan = _span([_t(key)]);

            typeSpans[key] = typeSpan;
            trs.push(_tr([_td([typeSpan], [['css', 'width', '30%']]), _td([content], [['css', 'width', '70%']])]));
          } // let title = _span(null, [['dir','className','title'], ['css','cursor','default']]),
          //     summary = _span(null, [['dir','className','summary']]),


          var div;

          if ($('#layerPropertiesInfo').length) {
            div = $('#layerPropertiesInfo')[0];

            if (!trs.length && !layer.properties.Legend) {
              $(div.parentNode).dialog('close');
              return;
            }

            $(div).empty();

            _(div, [_table([_tbody(trs)], [['dir', 'className', 'vectorInfoParams']])]);

            if (layer.properties.Legend) {
              var legend = _div();

              legend.innerHTML = layer.properties.Legend;

              _(div, [legend]);
            }

            var dialogTitle = div.parentNode.parentNode.firstChild.firstChild;
            $(dialogTitle).empty();

            _(dialogTitle, [_t(_gtxt("Слой [value0]", layer.properties.title))]);

            $(div.parentNode).dialog('open');
          } else {
            if (!trs.length && !layer.properties.Legend) return;
            div = _div([_table([_tbody(trs)], [['dir', 'className', 'vectorInfoParams']])], [['attr', 'id', 'layerPropertiesInfo']]);

            if (layer.properties.Legend) {
              var _legend = _div();

              _legend.innerHTML = layer.properties.Legend;

              _(div, [_legend]);
            }

            showDialog(_gtxt("Слой [value0]", layer.properties.title), div, 360, 'auto', false, false, null, function () {
              return true;
            });
          } //подстраиваем ширину


          setTimeout(function () {
            var dialogDiv = $('#layerPropertiesInfo')[0].parentNode;
            var width = $(div).find('.vectorInfoParams').width();

            if (width > 340) {
              $(dialogDiv).dialog('option', 'width', width + 18);
            }
          }, 100);
          nsGmx$1.TagMetaInfo.loadFromServer(function (tagInfo) {
            for (var _key in typeSpans) {
              if (tagInfo.isTag(_key)) $(typeSpans[_key]).attr('title', tagInfo.getTagDescription(_key));
            }
          });
        }
      };
      gmxCore.addModule('Controls', nsGmx$1.Controls);
    })(nsGmx$1.Utils._);

    (function () {
      var getZoomValue = function getZoomValue(zoomControl) {
        var isNotValid = zoomControl.value == '' || isNaN(Number(zoomControl.value)) || Number(zoomControl.value) != Math.floor(Number(zoomControl.value)) || Number(zoomControl.value) < 1;

        if (isNotValid) {
          $(zoomControl).addClass("error");
          return null;
        } else {
          $(zoomControl).removeClass("error");
          return Number(zoomControl.value);
        }
      };

      var checkZoom = function checkZoom(minZoomInput, maxZoomInput) {
        var minVal = getZoomValue(minZoomInput);
        var maxVal = getZoomValue(maxZoomInput);

        if (minVal && maxVal && minVal > maxVal) {
          $(minZoomInput).addClass("error");
          $(maxZoomInput).addClass("error");
          return false;
        }

        return !!(minVal && maxVal);
      };
      /**
       Контрол для задания максимального и минимального зумов слоя/стиля.
       Выдаёт два 'li' элемента, которые клиент сам помещает куда-нибудь.
       Генерит событие "change", когда изменились валидные значения зумов
       @memberOf nsGmx
       @class
       @param minZoom {int} Начальный минимальный зум
       @param maxZoom {int} Начальный максимальный зум
      */


      var ZoomPropertiesControl = function ZoomPropertiesControl(minZoom, maxZoom) {
        var _this = this;

        var minZoomInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'paramName', 'MinZoom'], ['css', 'width', '30px'], ['attr', 'value', minZoom || 1]]);

        var maxZoomInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'paramName', 'MaxZoom'], ['css', 'width', '30px'], ['attr', 'value', maxZoom || 17]]);

        checkZoom(minZoomInput, maxZoomInput);

        var liMinZoom = _li([_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Мин. зум"))], [['css', 'fontSize', '12px']])], [['css', 'width', '60px']]), _td([minZoomInput])])])])])]);

        var liMaxZoom = _li([_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Макс. зум"))], [['css', 'fontSize', '12px']])], [['css', 'width', '60px']]), _td([maxZoomInput])])])])])]);

        minZoomInput.onkeyup = maxZoomInput.onkeyup = function () {
          if (checkZoom(minZoomInput, maxZoomInput)) $(_this).change();
          return true;
        };

        this.getMinLi = function () {
          return liMinZoom;
        };

        this.getMaxLi = function () {
          return liMaxZoom;
        };
        /** Получить минимальный зум
        */


        this.getMinZoom = function () {
          return Number(minZoomInput.value);
        };
        /** Получить максимальный зум
        */


        this.getMaxZoom = function () {
          return Number(maxZoomInput.value);
        };
      };

      nsGmx$1.ZoomPropertiesControl = ZoomPropertiesControl;
    })();

    tinyMCE.init({
      mode: "none",
      theme: "advanced",
      plugins: 'fullscreen',
      language: 'ru',
      convert_urls: false,
      theme_advanced_buttons1: 'bold,italic,underline,|,justifyleft,justifycenter,justifyright,|,link,unlink,fullscreen,code',
      theme_advanced_buttons2: '',
      theme_advanced_buttons3: '',
      theme_advanced_statusbar_location: 'none',
      theme_advanced_toolbar_location: 'bottom',
      theme_advanced_toolbar_align: 'center'
    });

    (function (_) {
      //явно прописывает все свойства балунов в стиле.
      var applyBalloonDefaultStyle = function applyBalloonDefaultStyle(style) {
        //слой только что создали - всё по умолчанию!
        if (typeof style.BalloonEnable === 'undefined') {
          style.BalloonEnable = true;
          style.DisableBalloonOnClick = false;
          style.DisableBalloonOnMouseMove = true;
        } else {
          //поддержка совместимости - если слой уже был, но новых параметров нет
          if (typeof style.DisableBalloonOnClick === 'undefined') style.DisableBalloonOnClick = false;
          if (typeof style.DisableBalloonOnMouseMove === 'undefined') style.DisableBalloonOnMouseMove = false;
        }

        return style;
      };

      var FillStyleControl = function FillStyleControl(initStyle, params) {
        var _params = $.extend({
          showSelectors: true
        }, params);

        var _fillStyle = $.extend(true, {
          fill: {
            color: 0xFFFFFF,
            opacity: 50,
            image: "",
            pattern: {
              width: 8,
              step: 0,
              colors: [0x000000, 0xFFFFFF],
              style: 'diagonal1'
            }
          }
        }, initStyle).fill;

        var _this = this;

        var selectorDiv = $("<div/>", {
          'class': "fillStyleSelectorDiv"
        });
        var colorContainer = $("<div/>");
        var patternContainer = $("<div/>");
        var imagePatternContainer = $("<div/>");
        var colorIcon = $("<img/>", {
          src: 'img/styles/color.png',
          title: _gtxt("Заливка цветом")
        }).data('type', 'color');
        var patternIcon = $("<img/>", {
          src: 'img/styles/pattern.png',
          title: _gtxt("Заливка штриховкой")
        }).data('type', 'pattern');
        var patternURLIcon = $("<img/>", {
          src: 'img/styles/globe.gif',
          title: _gtxt("Заливка рисунком")
        }).data('type', 'bitmapPattern');
        var controls = {
          "color": {
            icon: colorIcon,
            control: colorContainer
          },
          "pattern": {
            icon: patternIcon,
            control: patternContainer
          },
          "bitmapPattern": {
            icon: patternURLIcon,
            control: imagePatternContainer
          }
        };
        var initFillStyle = initStyle.fill || {};
        var activeFillType = null;
        if ('image' in initFillStyle) activeFillType = 'bitmapPattern';else if ('pattern' in initFillStyle) activeFillType = 'pattern';else //if ('color' in initFillStyle)
          activeFillType = 'color';

        for (var c in controls) {
          if (c == activeFillType) controls[c].icon.addClass('selectedType');else controls[c].control.hide();
        }

        var selectorIconsDiv = $('<div/>').append(colorIcon).append(patternIcon).append(patternURLIcon);
        selectorDiv.append($("<span/>").text(_gtxt("Заливка"))).append($("<br/>"));
        if (_params.showSelectors) selectorDiv.append(selectorIconsDiv);
        $("img", selectorDiv).click(function () {
          activeFillType = $(this).data('type');

          for (var k in controls) {
            if (k === activeFillType) $(controls[k].control).show(500);else $(controls[k].control).hide(500);
          }

          $("img", selectorDiv).removeClass('selectedType');
          $(this).addClass('selectedType');
          $(_this).change();
        });
        var fillColor = _fillStyle.color;
        var fillOpacity = _fillStyle.opacity; //выбор цвета

        var fillColorPicker = nsGmx$1.Controls.createColorPicker(fillColor, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          $(_this).change();
          return false;
        }, function (hsb, hex) {
          fillColorPicker.style.backgroundColor = '#' + hex;
          fillColor = parseInt("0x" + hex);
          $(_this).change();
        }),
            fillOpacitySlider = nsGmx$1.Controls.createSlider(fillOpacity, function (event, ui) {
          fillOpacity = ui.value;
          $(_this).change();
        });
        colorContainer.append($("<table/>").append($("<tr/>").append($("<td/>").append(fillColorPicker)).append($("<td/>", {
          'class': 'fillColorOpacity'
        }).append(fillOpacitySlider))));
        var patternURL = new window.mapHelper.ImageInputControl(_fillStyle.image);
        $(patternURL).change(function () {
          $(_this).change();
        });
        imagePatternContainer.append(patternURL.getControl()); //выбор втроенных паттернов

        var patternTypeIcons = [['horizontal', 'img/styles/horisontal.png'], ['vertical', 'img/styles/vertical.png'], ['diagonal1', 'img/styles/diagonal1.png'], ['diagonal2', 'img/styles/diagonal2.png'], ['circle', 'img/styles/circle.png'], ['cross', 'img/styles/cross.png']];
        var patternStyleSelector = $("<div/>", {
          id: "patternStyleSelector"
        });

        for (var i = 0; i < patternTypeIcons.length; i++) {
          var icon = $('<img/>', {
            src: patternTypeIcons[i][1]
          }).data("style", patternTypeIcons[i][0]);
          patternStyleSelector.append(icon);
          if (patternTypeIcons[i][0] === _fillStyle.pattern.style) icon.addClass('activePatternType');
        }

        $("img", patternStyleSelector).click(function () {
          $("img", patternStyleSelector).removeClass('activePatternType');
          $(this).addClass('activePatternType');
          _fillStyle.pattern.style = $(this).data("style");
          $(_this).change();
        });
        var patternOpacity = _fillStyle.opacity;
        var patternOpacitySlider = nsGmx$1.Controls.createSlider(_fillStyle.opacity, function (event, ui) {
          patternOpacity = ui.value;
          $(_this).change();
        });
        $(patternOpacitySlider).attr({
          id: "patternOpacitySlider"
        });
        var patternOpacityContainer = $('<div/>', {
          'class': 'patternOpacityContainer'
        }).append($('<table/>').append($('<tr/>').append($('<td/>').append($('<img/>', {
          src: 'img/styles/pattern-opacity.PNG',
          'class': 'opacityIcon'
        }))).append($('<td/>').append(patternOpacitySlider))));
        var widthIcon = $("<img/>", {
          src: 'img/styles/pattern-width.PNG'
        });
        var stepIcon = $("<img/>", {
          src: 'img/styles/pattern-step.PNG',
          'class': 'stepIcon'
        });
        var widthInput = $("<input/>", {
          'class': 'widthInput',
          title: _gtxt("Ширина паттерна")
        }).val(_fillStyle.pattern.width).change(function () {
          $(_this).change();
        });
        var stepInput = $("<input/>", {
          title: _gtxt("Ширина отступа")
        }).val(_fillStyle.pattern.step).change(function () {
          $(_this).change();
        });
        var widthStepInputs = $("<table/>", {
          'class': "widthStepTable"
        }).append($("<tr/>").append($("<td/>").append(widthIcon).append(widthInput)).append($("<td/>").append(stepIcon).append(stepInput)));

        var PatternColorControl = function PatternColorControl(parentDiv, initColors) {
          var _parentDiv = $(parentDiv);

          var _colors = initColors;

          var _this = this;

          var _redraw = function _redraw() {
            _parentDiv.empty();

            var table = $('<table/>', {
              'class': 'patternColorControl'
            });

            for (var k = 0; k < _colors.length; k++) {
              (function (k) {
                if (_colors[k] === null) return;
                var colorPicker = nsGmx$1.Controls.createColorPicker(_colors[k], function (colpkr) {
                  $(colpkr).fadeIn(500);
                  return false;
                }, function (colpkr) {
                  $(colpkr).fadeOut(500);
                  $(_this).change();
                  return false;
                }, function (hsb, hex) {
                  colorPicker.style.backgroundColor = '#' + hex;
                  _colors[k] = parseInt('0x' + hex);
                  $(_this).change();
                });
                colorPicker.style.width = '100%';
                var deleteIcon = makeImageButton('img/close.png', 'img/close_orange.png');

                deleteIcon.onclick = function () {
                  _colors[k] = null;

                  _redraw();

                  $(_this).change();
                };

                table.append($("<tr/>").append($("<td/>", {
                  'class': 'patternColorPicker'
                }).append(colorPicker)).append($("<td/>", {
                  'class': 'patternColorDelete'
                }).append(deleteIcon)));
              })(k);
            }

            var addIcon = makeImageButton('img/zoom_plus.png', 'img/zoom_plus_a.png');

            addIcon.onclick = function () {
              var initColor = 0x00FF00;

              for (var c = 0; c < _colors.length; c++) {
                if (_colors[c] !== null) initColor = _colors[c];
              }

              _colors.push(initColor);

              _redraw();

              $(_this).change();
            };

            table.append($("<tr/>").append($("<td/>", {
              'class': 'patternColorPicker'
            })).append($("<td/>").append(addIcon)));

            _parentDiv.append(table);
          };

          _redraw();

          this.getColors = function () {
            var res = [];

            for (var c = 0; c < _colors.length; c++) {
              if (_colors[c] !== null) res.push(_colors[c]);
            }

            return res;
          };
        };

        var patternColorSelector = $("<div/>");
        var patternColorControl = new PatternColorControl(patternColorSelector, _fillStyle.pattern.colors);
        $(patternColorControl).change(function () {
          $(_this).change();
        });
        patternContainer.append(patternStyleSelector).append(patternOpacityContainer).append(widthStepInputs).append(patternColorSelector);
        var fillControlsDiv = $("<div/>", {
          'class': 'fillStyleControls'
        }).append(colorContainer).append(imagePatternContainer).append(patternContainer); //public interface

        this.getSelector = function () {
          return selectorDiv;
        };

        this.getControls = function () {
          return fillControlsDiv;
        };

        this.getFillStyle = function () {
          var fillStyle = {};

          if (activeFillType === 'color') {
            fillStyle.color = fillColor;
            fillStyle.opacity = fillOpacity;
          } else if (activeFillType === 'bitmapPattern') {
            fillStyle.image = patternURL.value();
          } else if (activeFillType === 'pattern') {
            fillStyle.pattern = {
              style: _fillStyle.pattern.style,
              width: parseInt(widthInput.val()),
              step: parseInt(stepInput.val()),
              colors: patternColorControl.getColors()
            };
            fillStyle.opacity = patternOpacity;
          }

          return fillStyle;
        };

        this.setVisibleSelectors = function (isVisible) {
          if (isVisible) selectorIconsDiv.show();else selectorIconsDiv.hide();
        };
      };

      var createFilterEditorInner = function createFilterEditorInner(filter, attrs, elemCanvas) {
        var filterText = _textarea(null, [['dir', 'className', 'inputStyle'], ['css', 'overflow', 'auto'], ['css', 'width', '250px'], ['css', 'height', '50px']]),
            setFilter = function setFilter() {
          var filterNum = getOwnChildNumber(filterText.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode),
              layer = nsGmx$1.gmxMap.layersByID[elemCanvas.parentNode.gmxProperties.content.properties.name],
              filter = layer.getStyle(filterNum);
          var newStyle = $.extend(true, {}, filter);
          newStyle.Filter = filterText.value;
          layer.setStyle(newStyle, filterNum);
        };

        filterText.value = filter;

        filterText.onkeyup = function () {
          setFilter();
          return true;
        };

        var mapName = elemCanvas.parentNode.gmxProperties.content.properties.mapName,
            layerName = elemCanvas.parentNode.gmxProperties.content.properties.name,
            attrSuggestWidget = new nsGmx$1.AttrSuggestWidget([filterText], attrs || [], _mapHelper.attrValues[mapName][layerName], setFilter, ['attrs', 'operators']);
        var suggestCanvas = attrSuggestWidget.el[0];

        var div = _div([filterText, suggestCanvas], [['attr', 'filterTable', true]]);

        div.getFilter = function () {
          return filterText.value;
        };

        div.setFilter = function () {
          setFilter();
        };

        return div;
      };

      var createFilterEditor = function createFilterEditor(filterParam, attrs, elemCanvas) {
        var filter = typeof filterParam == 'undefined' ? '' : filterParam,
            props = elemCanvas.parentNode.gmxProperties.content.properties,
            mapName = props.mapName;
        _mapHelper.attrValues[mapName] = _mapHelper.attrValues[mapName] || {};

        if (!_mapHelper.attrValues[mapName][props.name]) {
          var div = _div([_t(_gtxt("Авторизуйтесь для редактирования фильтров"))], [['css', 'padding', '5px 0px 5px 5px'], ['css', 'color', 'red']]);

          div.getFilter = function () {
            return filter;
          };

          div.setFilter = function () {};

          div.setAttribute('filterTable', true);
          return div;
        } else return createFilterEditorInner(filter, attrs, elemCanvas);
      };

      var _balloonEditorId = 0; //identityField - будем исключать из списка аттрибутов, показываемых в балуне, так как это внутренняя техническая информация

      var createBalloonEditor = function createBalloonEditor(balloonParams, attrs, elemCanvas, identityField) {
        applyBalloonDefaultStyle(balloonParams);

        var layerName = elemCanvas.parentNode.gmxProperties.content.properties.name,
            textareaID = 'ballooneditor' + layerName + _balloonEditorId++,
            balloonText = _textarea(null, [['dir', 'className', 'inputStyle balloonEditor'], ['css', 'overflow', 'auto'], ['css', 'width', '251px'], ['css', 'height', '80px'], ['dir', 'id', textareaID]]),
            setBalloon = function setBalloon() {
          var filterNum = getOwnChildNumber(balloonText.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode),
              layer = nsGmx$1.gmxMap.layersByID[layerName],
              style = layer.getStyle(filterNum);
          var newStyle = $.extend(true, {}, style, div.getBalloonState());
          layer.setStyle(newStyle, filterNum);
        },
            defaultBalloonText = function defaultBalloonText() {
          var sortAttrs = attrs.slice(0),
              text = "";

          for (var i = 0; i < sortAttrs.length; ++i) {
            var key = sortAttrs[i];
            if (key !== identityField) text += "<b>" + key + ":</b> [" + key + "]<br />" + br;
          }

          text += "<br />" + br + "[SUMMARY]";
          return text;
        },
            boxClick = _checkbox(!balloonParams.DisableBalloonOnClick && balloonParams.BalloonEnable, 'checkbox'),
            boxMove = _checkbox(!balloonParams.DisableBalloonOnMouseMove && balloonParams.BalloonEnable, 'checkbox'),
            br = "\n";

        tinyMCE.onAddEditor.add(function (mgr, ed) {
          if (ed.id === textareaID) {
            ed.onKeyUp.add(setBalloon);
            ed.onChange.add(setBalloon);
            ed.onClick.add(function () {
              $(suggestWidget.el).fadeOut(300);
            });
          }
        }); // gmxCore.loadModule('TinyMCELoader', window.location.protocol + '//' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function() {
        // 	tinyMCE.onAddEditor.add(function(mgr,ed) {
        // 		if (ed.id === textareaID) {
        // 			ed.onKeyUp.add(setBalloon);
        // 			ed.onChange.add(setBalloon);
        // 			ed.onClick.add(function() {
        // 				$(suggestWidget.el).fadeOut(300);
        // 			});
        // 		}
        // 	});
        // })

        boxClick.className = 'box';

        boxClick.onclick = function () {
          setBalloon();
        };

        boxMove.className = 'box';

        boxMove.onclick = function () {
          setBalloon();
        };

        balloonText.value = balloonParams.Balloon ? balloonParams.Balloon : defaultBalloonText();
        var suggestWidget = new nsGmx$1.SuggestWidget(attrs ? attrs : [], [balloonText], '[suggest]', setBalloon);

        var divAttr = _div([_t(_gtxt("Атрибут >")), suggestWidget.el], [['dir', 'className', 'suggest-link-container']]);

        divAttr.onclick = function () {
          if (suggestWidget.el.style.display == 'none') $(suggestWidget.el).fadeIn(300);
          return true;
        };

        var setDefaultBalloonText = nsGmx$1.Utils.makeLinkButton(_gtxt('По умолчанию'));

        setDefaultBalloonText.onclick = function () {
          window.tinyMCE.get(textareaID).setContent(defaultBalloonText());
          setBalloon();
        };

        var suggestCanvas = _table([_tbody([_tr([_td([_div([divAttr], [['css', 'position', 'relative']])]), _td([_div([setDefaultBalloonText], [['css', 'float', 'right']])])])])], [['css', 'margin', '0px 3px'], ['css', 'width', '249px']]);

        var div = _div([_div([boxClick, _span([_t(_gtxt("Показывать при клике"))], [['css', 'marginLeft', '5px']])], [['css', 'margin', '2px 0px 4px 3px']]), _div([boxMove, _span([_t(_gtxt("Показывать при наведении"))], [['css', 'marginLeft', '5px']])], [['css', 'margin', '2px 0px 4px 3px']]), balloonText, suggestCanvas], [['attr', 'balloonTable', true]]);

        div.getBalloon = function () {
          var value = window.tinyMCE && window.tinyMCE.get(textareaID) ? window.tinyMCE.get(textareaID).getContent() : balloonText.value;
          return value == defaultBalloonText() ? '' : value;
        };

        div.getBalloonEnable = function () {
          return boxClick.checked || boxMove.checked;
        };

        div.getBalloonDisableOnClick = function () {
          return boxClick.checked;
        };

        div.getDisableBalloonOnMouseMove = function () {
          return boxMove.checked;
        };

        div.getBalloonState = function () {
          var state = {
            BalloonEnable: boxClick.checked || boxMove.checked,
            DisableBalloonOnClick: !boxClick.checked,
            DisableBalloonOnMouseMove: !boxMove.checked
          };
          var value = window.tinyMCE && window.tinyMCE.get(textareaID) ? window.tinyMCE.get(textareaID).getContent() : balloonText.value;
          if (value !== defaultBalloonText()) state.Balloon = value;
          return state;
        };

        return div;
      };

      var _labelEditorId = 0;

      var createFilter = function createFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, ulParent, treeviewFlag) {
        var templateStyle = {};
        $.extend(true, templateStyle, _mapHelper.makeStyle(parentStyle));
        var zoomPropertiesControl = new nsGmx$1.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom); // var filterInput = _textarea([_t(parentStyle.Filter || '')], [['dir','className','inputStyle'],['css','overflow','auto'],['css','margin','1px 0px'],['css','width','260px'],['css','height','40px']]),

        var liMinZoom = zoomPropertiesControl.getMinLi(),
            liMaxZoom = zoomPropertiesControl.getMaxLi(),
            ulfilterExpr = _ul([_li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']])]),
            liLabel = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulLabel = _ul([liLabel]),
            liBalloon = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulBalloon = _ul([liBalloon]),
            liStyle = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulStyle = _ul([liStyle]);
     // currently we don't support clustring

        /*if (geometryType == 'point')
        {
        	clusterControl = new nsGmx.ClusterParamsControl(liClusters, parentStyle.clusters);
        	$(clusterControl).change(function()
        	{
        		var filterNum = getOwnChildNumber(ulParent.parentNode.parentNode.parentNode),
        				filter = globalFlashMap.layers[elemCanvas.parentNode.gmxProperties.content.properties.name].filters[filterNum];
        
        		if (clusterControl.isApplyCluster())
        		{
        			filter.setClusters(clusterControl.getClusterStyle());
        		}
        		else
        		{
        			filter.delClusters();
        		}
        	})
        
        	clusterCheckbox = _checkbox(clusterControl.isApplyCluster(), 'checkbox');
        	clusterCheckbox.style.marginTop = '2px';
        	clusterCheckbox.onchange = function()
        	{
        		clusterControl.applyClusters(this.checked);
        	}
        
        	if (!clusterControl.isApplyCluster())
        	{
        		ulClusters.style.display = 'none';
        		ulClusters.className = 'hiddenTree';
        	}
        }*/
        // zoom


        $(zoomPropertiesControl).change(function () {
          var filterNum = getOwnChildNumber(ulParent.parentNode.parentNode.parentNode),
              layer = nsGmx$1.gmxMap.layersByID[elemCanvas.parentNode.gmxProperties.content.properties.name],
              style = layer.getStyle(filterNum);
          var newStyle = $.extend(true, {}, style, {
            MinZoom: this.getMinZoom(),
            MaxZoom: this.getMaxZoom()
          });
          layer.setStyle(newStyle, filterNum);
        }); // label

        var fontSizeInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'labelParamName', 'FontSize'], ['css', 'width', '26px'], ['attr', 'value', templateStyle.label && templateStyle.label.size || '12']]),
            xShiftInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'labelParamName', 'XSfift'], ['css', 'width', '26px'], ['attr', 'value', templateStyle.labelAnchor && templateStyle.labelAnchor[0] || '0']]),
            yShiftInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'labelParamName', 'FontSize'], ['css', 'width', '26px'], ['attr', 'value', templateStyle.labelAnchor && -templateStyle.labelAnchor[1] || '0']]),
            checkedLabelColor = typeof templateStyle.label != 'undefined' && typeof templateStyle.label.color != 'undefined' ? templateStyle.label.color : 0x000000,
            checkedLabelHaloColor = typeof templateStyle.label != 'undefined' && typeof templateStyle.label.haloColor != 'undefined' ? templateStyle.label.haloColor : 0xFFFFFF,
            checkedFontSize = typeof templateStyle.label != 'undefined' && typeof templateStyle.label.size != 'undefined' ? templateStyle.label.size : 12,
            checkedXShift = typeof templateStyle.labelAnchor != 'undefined' && _typeof(templateStyle.labelAnchor[0]) ? templateStyle.labelAnchor[0] : 0,
            checkedYShift = typeof templateStyle.labelAnchor != 'undefined' && _typeof(templateStyle.labelAnchor[1]) ? templateStyle.labelAnchor[1] : 0,
            backupLabel = {
          color: checkedLabelColor,
          haloColor: checkedLabelHaloColor,
          size: checkedFontSize,
          dx: checkedXShift,
          dy: checkedYShift
        },
            labelColor = nsGmx$1.Controls.createColorPicker(checkedLabelColor, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex) {
          labelColor.style.backgroundColor = '#' + hex;

          if (typeof templateStyle.label == 'undefined') {
            templateStyle.label = backupLabel;
          }

          templateStyle.label.color = labelColor.hex = parseInt('0x' + hex);
          checkedLabelColor = labelColor.hex = parseInt('0x' + hex);
          nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        }),
            labelHaloColor = nsGmx$1.Controls.createColorPicker(checkedLabelHaloColor, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex) {
          labelHaloColor.style.backgroundColor = '#' + hex;

          if (typeof templateStyle.label == 'undefined') {
            templateStyle.label = backupLabel;
          }

          templateStyle.label.haloColor = labelHaloColor.hex = parseInt('0x' + hex);
          checkedLabelHaloColor = labelHaloColor.hex = parseInt('0x' + hex);
          nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        }),
            layerName = elemCanvas.parentNode.gmxProperties.content.properties.name,
            textareaID = 'labeleditor' + layerName + _labelEditorId++,
            labelText = _textarea(null, [['dir', 'className', 'inputStyle labelEditor'], ['attr', 'placeholder', _gtxt("Пример выражения")], ['css', 'overflow', 'auto'], ['css', 'width', '251px'], ['css', 'height', '80px'], ['dir', 'id', textareaID]]);

        _title(labelColor, _gtxt("Цвет шрифта"));

        _title(labelHaloColor, _gtxt("Цвет обводки"));

        _title(fontSizeInput, _gtxt("Размер шрифта"));

        _title(xShiftInput, _gtxt("Смещение по x"));

        _title(yShiftInput, _gtxt("Смещение по y")); // при загрузке выставим в инпуты значения либо template, либо label


        if (templateStyle.labelTemplate) {
          $(labelText).val(templateStyle.labelTemplate);
        } else if (templateStyle.label && templateStyle.label.field) {
          $(labelText).val('[' + templateStyle.label.field + ']');
        }

        if (attrs) {
          var keys = {};
          attrs.forEach(function (attr) {
            keys[attr] = true;
          });
        } // при изменении значения текстового поля меняется labelTemplate
        // если оно равно какому-либо атрибуту, он утанавливается в значение field
        // если же как-то отличается, то перечень атрибутов устанавливается на '';


        var updateLabelText = function updateLabelText() {
          // соберем все значения в квадратных скобках
          var matches = this.value.match(/\[([^\]]+)\]/ig);
          var str = this.value;

          if (matches) {
            for (var i = 0, len = matches.length; i < len; i++) {
              var key1 = matches[i],
                  key = key1.substr(1, key1.length - 2); // отсеиваем случаи, когда в textArea содержится единственный [атрибут]

              if (matches.length === 1 && matches[0] === str && key in keys) {
                // в label передается templateStyle.label.field
                delete templateStyle.labelTemplate;

                if (typeof templateStyle.label == 'undefined') {
                  templateStyle.label = backupLabel;
                  templateStyle.label.field = key;
                } else {
                  templateStyle.label.field = key;
                }

                nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
                return;
              } // в других случаях в label передается templateStyle.labelTemplate
              // если внтутри квадратных скобок оказывается какой-то произвольный текст


              if (!(key in keys)) {
                str = str.replace(key1, '');
              }
            }
          }

          if (!str) {
            if (!this.value) {
              delete templateStyle.labelTemplate;
              delete templateStyle.label;
            } else {
              templateStyle.labelTemplate = this.value;
            }
          } else {
            if (typeof templateStyle.label == 'undefined') {
              templateStyle.label = backupLabel;
            }

            templateStyle.labelTemplate = str;
          }

          nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        };

        labelText.onkeyup = updateLabelText;

        fontSizeInput.onkeyup = function () {
          if (typeof templateStyle.label == 'undefined') {
            templateStyle.label = backupLabel;
          }

          templateStyle.label.size = Number(this.value);
          checkedFontSize = Number(this.value);
          nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        };

        xShiftInput.onkeyup = function () {
          if (typeof templateStyle.labelAnchor == 'undefined') {
            templateStyle.labelAnchor = [backupLabel.dx, backupLabel.dy];
          }

          templateStyle.labelAnchor[0] = Number(this.value);
          checkedXShift = Number(this.value);
          nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
          layer.setStyle(templateStyle);
        };

        yShiftInput.onkeyup = function () {
          if (typeof templateStyle.labelAnchor == 'undefined') {
            templateStyle.labelAnchor = [backupLabel.dx, backupLabel.dy];
          }

          templateStyle.labelAnchor[1] = -Number(this.value);
          checkedYShift = -Number(this.value);
          nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        };

        var suggestWidget = new nsGmx$1.SuggestWidget(attrs ? attrs : [], [labelText], '[suggest]', updateLabelText.bind(labelText));

        var divAttr = _div([_t(_gtxt("Атрибут >")), suggestWidget.el], [['dir', 'className', 'suggest-link-container']]);

        divAttr.onclick = function () {
          if (suggestWidget.el.style.display == 'none') $(suggestWidget.el).fadeIn(300);
          return true;
        }; // var suggestCanvas = _table([_tbody([_tr([_td([_div([divAttr],[['css','position','relative']])])])])],[['css','margin','0px 3px']]);


        _(liLabel.lastChild, [_table([_tbody([_tr([_td([_t(_gtxt("Цвет шрифта"))], [['css', 'width', '100px']]), _td([labelColor])]), _tr([_td([_t(_gtxt("Цвет обводки"))], [['css', 'width', '100px']]), _td([labelHaloColor])]), _tr([_td([_t(_gtxt("Размер шрифта"))], [['css', 'width', '100px']]), _td([fontSizeInput])]), _tr([_td([_t(_gtxt("Смещение по x"))], [['css', 'width', '100px']]), _td([xShiftInput])]), _tr([_td([_t(_gtxt("Смещение по y"))], [['css', 'width', '100px']]), _td([yShiftInput])]), _tr([_td([labelText], [['attr', 'colspan', 4]])]), _tr([_td([divAttr])])])])]);

        if (typeof templateStyle.label == 'undefined') {
          ulLabel.style.display = 'none';
          ulLabel.className = 'hiddenTree';
        } // filter


        var filterEditor = createFilterEditor(parentStyle.Filter, attrs, elemCanvas);

        _(ulfilterExpr.lastChild.lastChild, [filterEditor]);

        if (typeof parentStyle.Filter == 'undefined' || filterEditor.childNodes.length == 1) {
          ulfilterExpr.style.display = 'none';
          ulfilterExpr.className = 'hiddenTree';
        } // balloon


        var balloonEditor = createBalloonEditor(parentStyle, attrs, elemCanvas, elemCanvas.parentNode.gmxProperties.content.properties.identityField);

        _(liBalloon.lastChild, [balloonEditor]);

        if (typeof parentStyle.Balloon == 'undefined') {
          ulBalloon.style.display = 'none';
          ulBalloon.className = 'hiddenTree';
        }

        var bindChangeEvent = function bindChangeEvent() {
          $(resObject).change(function () {
            nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
          });
        }; // common


        var symbolsTitle = _div();

        if (nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN)) {
          var styleLibIcon = makeImageButton('img/stylelib-main.png', 'img/stylelib-main.png');
          styleLibIcon.style.verticalAlign = 'middle';
          styleLibIcon.style.marginLeft = '5px';
          styleLibIcon.title = _gtxt('Библиотека стилей');

          _(symbolsTitle, [_span([_t(_gtxt("Символика"))], [['css', 'fontSize', '12px']]), styleLibIcon]);

          styleLibIcon.onclick = function () {
            nsGmx$1.showStyleLibraryDialog('select', geometryType.toUpperCase()).done(function (activeStyleManager) {
              $(activeStyleManager).change(function () {
                var styleFromLib = this.getActiveStyle();

                if (styleFromLib) {
                  templateStyle = styleFromLib;
                  $(liStyle.lastChild).empty();
                  resObject = createStyleEditor(liStyle.lastChild, templateStyle, geometryType, isWindLayer);
                  bindChangeEvent();
                  nsGmx$1.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
                }
              });
            });
          };
        } else {
          _(symbolsTitle, [_span([_t(_gtxt("Символика"))], [['css', 'fontSize', '12px']])]);
        }

        _(ulParent, [liMinZoom, liMaxZoom, _li([_div([_span([_t(_gtxt("Фильтр"))], [['css', 'fontSize', '12px']])]), ulfilterExpr]), _li([_div([_span([_t(_gtxt("Подпись"))], [['css', 'fontSize', '12px']])]), ulLabel]), _li([_div([_span([_t(_gtxt("Балун"))], [['css', 'fontSize', '12px']])]), ulBalloon]), _li([symbolsTitle, ulStyle])]);
        /*if (geometryType == 'point')
        {
        	_(ulParent, [_li([
        		_div([clusterCheckbox,
        		_span([_t(_gtxt("Кластеризация"))],[['css','fontSize','12px'], ['css', 'marginLeft', '4px']])]),
        		ulClusters
        	])])
        }*/


        if (treeviewFlag) $(ulParent).treeview(); // styles

        var isWindLayer = typeof elemCanvas.parentNode.gmxProperties != 'undefined' && elemCanvas.parentNode.gmxProperties.content.properties.description && String(elemCanvas.parentNode.gmxProperties.content.properties.description).toLowerCase().indexOf('карта ветра') == 0;
        var resObject = createStyleEditor(liStyle.lastChild, templateStyle, geometryType, isWindLayer);
        bindChangeEvent();

        ulParent.parentNode.parentNode.parentNode.getStyle = function () {
          return templateStyle;
        };

        ulParent.parentNode.parentNode.parentNode.getClusterStyle = function () {
          return null;
        };

        ulParent.parentNode.parentNode.parentNode.removeColorPickers = function () {
          $(liStyle.lastChild).find(".colorSelector").each(function () {
            $('#' + $(this).data("colorpickerId")).remove();
          });
          $('#' + $(labelColor).data("colorpickerId")).remove();
        };
      };

      var updateFilterMoveButtons = function updateFilterMoveButtons(filter) {
        var num = getOwnChildNumber(filter),
            upButton = $(filter).find("[filterMoveButton='up']")[0],
            downButton = $(filter).find("[filterMoveButton='down']")[0],
            removeButton = $(filter).find("[filterMoveButton='remove']")[0];
        if (num == 0 || filter.parentNode.childNodes.length == 1) upButton.style.visibility = 'hidden';else upButton.style.visibility = 'visible';
        if (num == filter.parentNode.childNodes.length - 1) downButton.style.visibility = 'hidden';else downButton.style.visibility = 'visible';
        if (num == 0) removeButton.style.visibility = 'hidden';else removeButton.style.visibility = 'visible';
      };

      var attachLoadingFilterEvent = function attachLoadingFilterEvent(filterCanvas, layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas) {
        $(filterCanvas.firstChild.firstChild.firstChild).bind('click', function () {
          var ulFilterParams = window._abstractTree.getChildsUl(filterCanvas.firstChild.firstChild);

          if (!ulFilterParams.loaded) {
            ulFilterParams.loaded = true;
            createFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, ulFilterParams, true);

            _mapHelper.updateTinyMCE(filterCanvas);
          }
        });
      };

      var createFilterHeader = function createFilterHeader(filtersCanvas, elem, elemCanvas) {
        var addButton = makeLinkButton(_gtxt('Добавить стиль'));

        addButton.onclick = function () {
          if (!_layersTree.getLayerVisibility($(elemCanvas.parentNode).find('input[type="checkbox"]')[0])) {
            _layersTree.treeModel.setNodeVisibility(elemCanvas.parentNode.gmxProperties, true);
          }

          var lastStyle = elemCanvas.parentNode.gmxProperties.content.properties.styles[elemCanvas.parentNode.gmxProperties.content.properties.styles.length - 1],
              newStyle = {},
              defaultStyle = {
            fill: {
              color: 0x0FFFFFF,
              opacity: 20
            },
            outline: {
              color: 255,
              thickness: 1
            }
          },
              layer = nsGmx$1.gmxMap.layersByID[elem.name];
          lastStyle = lastStyle || {}; //копируем состояние балунов с последнего стиля

          newStyle.Balloon = lastStyle.Balloon || '';
          newStyle.BalloonEnable = !!lastStyle.BalloonEnable;
          newStyle.DisableBalloonOnClick = !!lastStyle.DisableBalloonOnClick;
          newStyle.DisableBalloonOnMouseMove = !!lastStyle.DisableBalloonOnMouseMove; //TODO: вернуть правильные начальные параметры
          //globalFlashMap.balloonClassObject.setBalloonFromParams(newFilter, newStyle);

          newStyle.MinZoom = lastStyle.MinZoom || 1;
          newStyle.MaxZoom = lastStyle.MaxZoom || 21;
          newStyle.RenderStyle = defaultStyle;
          layer.setStyles(layer.getStyles().concat(newStyle));
          var filter = createLoadingFilter(layer, layer.getStyles().length - 1, newStyle, elem.GeometryType.toLowerCase(), elem.attributes, elemCanvas, false);

          _(filtersCanvas, [filter]);

          updateFilterMoveButtons(filter);

          if (filtersCanvas.childNodes.length >= 2) {
            updateFilterMoveButtons(filtersCanvas.childNodes[filtersCanvas.childNodes.length - 2]);
          }

          $(filter.firstChild).treeview();
          attachLoadingFilterEvent(filter, layer, layer.getStyles().length - 1, newStyle, elem.GeometryType.toLowerCase(), elem.attributes, elemCanvas, false);
        };

        addButton.style.marginLeft = '10px';
        return _div([addButton], [['css', 'height', '20px'], ['css', 'padding', '5px']]);
      };

      var swapFilters = function swapFilters(div, firstNum, filterCanvas) {
        var layerName = div.gmxProperties.content.properties.name,
            layer = nsGmx$1.gmxMap.layersByID[layerName],
            filters = layer.getStyles(),
            newFilters = [];

        for (var i = 0; i < filters.length; i++) {
          if (i < firstNum || i > firstNum + 1) newFilters.push(filters[i]);else if (i == firstNum) newFilters.push(filters[i + 1]);else if (i == firstNum + 1) newFilters.push(filters[i - 1]);
        }

        layer.setStyles(newFilters);
        $(filterCanvas.childNodes[firstNum]).before(filterCanvas.childNodes[firstNum + 1]);
        updateFilterMoveButtons(filterCanvas.childNodes[firstNum]);
        updateFilterMoveButtons(filterCanvas.childNodes[firstNum + 1]);
      };

      var createLoadingFilter = function createLoadingFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, openedFlag) {
        var templateStyle = {},
            nameInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'paramName', 'Name'], ['css', 'width', '210px'], ['attr', 'value', parentStyle.Name || '']]),
            ulFilterParams = _ul(),
            liFilter = _li([_div([nameInput]), ulFilterParams]),
            ulFilter = _ul([liFilter]),
            filterCanvas = _div([ulFilter], [['dir', 'className', 'filterCanvas']]);

        $.extend(true, templateStyle, _mapHelper.makeStyle(parentStyle));

        _title(nameInput, _gtxt("Имя фильтра"));

        filterCanvas.getStyle = function () {
          return templateStyle;
        };

        filterCanvas.getClusterStyle = function () {
          return parentStyle.clusters;
        };

        filterCanvas.getFilter = function () {
          return parentStyle.Filter;
        };

        filterCanvas.getBalloon = function () {
          return parentStyle.Balloon;
        };

        filterCanvas.getBalloonEnable = function () {
          return typeof parentStyle.BalloonEnable != 'undefined' ? parentStyle.BalloonEnable : true;
        };

        filterCanvas.getBalloonDisableOnClick = function () {
          return parentStyle.DisableBalloonOnClick;
        };

        filterCanvas.getDisableBalloonOnMouseMove = function () {
          return parentStyle.DisableBalloonOnMouseMove;
        };

        filterCanvas.getBalloonState = function () {
          var state = {
            BalloonEnable: !parentStyle.DisableBalloonOnMouseMove || !parentStyle.DisableBalloonOnClick,
            DisableBalloonOnClick: parentStyle.DisableBalloonOnClick,
            DisableBalloonOnMouseMove: parentStyle.DisableBalloonOnMouseMove,
            Balloon: parentStyle.Balloon
          };
          return state;
        };

        filterCanvas.addFilterParams = function (filterParams) {
          filterParams.Name = nameInput.value;
          filterParams.MinZoom = parentStyle.MinZoom;
          filterParams.MaxZoom = parentStyle.MaxZoom;
        };

        filterCanvas.removeColorPickers = function () {};

        if (!openedFlag) {
          ulFilterParams.loaded = false;
          ulFilterParams.style.display = 'none';
          ulFilterParams.className = 'hiddenTree';
        } else {
          ulFilterParams.loaded = true;
          createFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, ulFilterParams, false);
        }

        var moveUp = makeImageButton('img/up.png', 'img/up_a.png'),
            moveDown = makeImageButton('img/down.png', 'img/down_a.png');

        moveUp.onclick = function () {
          this.src = 'img/up.png';
          var firstNum = getOwnChildNumber(this.parentNode.parentNode.parentNode.parentNode) - 1;
          swapFilters(elemCanvas.parentNode, firstNum, this.parentNode.parentNode.parentNode.parentNode.parentNode);
        };

        moveDown.onclick = function () {
          this.src = 'img/down.png';
          var firstNum = getOwnChildNumber(this.parentNode.parentNode.parentNode.parentNode);
          swapFilters(elemCanvas.parentNode, firstNum, this.parentNode.parentNode.parentNode.parentNode.parentNode);
        };

        moveUp.style.margin = '0px 1px -3px 2px';
        moveDown.style.margin = '0px 1px -3px 2px';
        moveUp.setAttribute('filterMoveButton', 'up');
        moveDown.setAttribute('filterMoveButton', 'down');

        _title(moveUp, _gtxt("Переместить фильтр вверх"));

        _title(moveDown, _gtxt("Переместить фильтр вниз"));

        _(liFilter.firstChild, [moveDown, moveUp]);

        var remove = makeImageButton('img/closemin.png', 'img/close_orange.png');

        remove.onclick = function () {
          var num = getOwnChildNumber(filterCanvas);
          var filtersParent = filterCanvas.parentNode;
          filterCanvas.removeNode(true);
          updateFilterMoveButtons(filtersParent.childNodes[num - 1]);
          var styles = layer.getStyles().slice();
          styles.splice(styleIndex, 1);
          layer.setStyles(styles);
        };

        remove.setAttribute('filterMoveButton', 'remove');
        remove.style.width = '16px';
        remove.style.height = '16px';
        remove.style.margin = '0px 1px -3px 2px';

        _title(remove, _gtxt("Удалить фильтр"));

        _(liFilter.firstChild, [remove]);

        return filterCanvas;
      };

      var showStyle = function showStyle(elem) {
        var div = $(elem).find("[fade]")[0];
        $(div).fadeIn(300);
      };

      var hideStyle = function hideStyle(elem) {
        var div = $(elem).find("[fade]")[0];
        $(div).fadeOut(300);
      }; //возвращает стили, которые в данный момент введены в DOM-элементе filterCanvas
      //использует структуру DOM-дерева


      var updateStyles = function updateStyles(filterCanvas) {
        var styles = [];

        for (var i = 0; i < filterCanvas.childNodes.length; i++) {
          var filter = filterCanvas.childNodes[i],
              newFilterStyle = {};
          if (!window._abstractTree.getChildsUl(filter.firstChild.firstChild).childNodes.length) filter.addFilterParams(newFilterStyle);else {
            $(filter).find("[paramName]").each(function () {
              newFilterStyle[this.getAttribute('paramName')] = this.value;
            });
          }
          var filterValueElem = $(filter).find("[filterTable]").length > 0 ? $(filter).find("[filterTable]")[0] : filter,
              filterValue = filterValueElem.getFilter();
          if (filterValue != '' && filterValue != null) newFilterStyle.Filter = filterValue;
          var balloonValueElem = $(filter).find("[balloonTable]").length > 0 ? $(filter).find("[balloonTable]")[0] : filter; //var balloonValue = balloonValueElem.getBalloon();

          $.extend(newFilterStyle, balloonValueElem.getBalloonState());
          if (newFilterStyle.Filter == '') delete newFilterStyle.Filter;
          if (newFilterStyle.Name == '') delete newFilterStyle.Name;
          newFilterStyle.MinZoom = Number(newFilterStyle.MinZoom);
          newFilterStyle.MaxZoom = Number(newFilterStyle.MaxZoom);
          if (isNaN(newFilterStyle.MinZoom)) newFilterStyle.MinZoom = 1;
          if (isNaN(newFilterStyle.MinZoom)) newFilterStyle.MinZoom = 21;
          newFilterStyle.RenderStyle = filter.getStyle();
          var clusterStyle = filter.getClusterStyle();
          if (clusterStyle) newFilterStyle.clusters = clusterStyle;
          styles.push(newFilterStyle);
        }

        return styles;
      };

      var createStyleEditor = function createStyleEditor(parent, templateStyle, geometryType, isWindLayer) {
        var markerSizeParent = _tr(),
            outlineParent = _tr(),
            fillParent = _tr(),
            iconParent = _tr(),
            outlineTitleTds = [],
            fillTitleTds = [],
            iconTitleTds = [],
            outlineTds = [],
            fillTds = [],
            iconTds = [],
            inputUrl,
            fillToggle,
            outlineToggle,
            iconToggle,
            showIcon,
            showMarker,
            // hideIcon,
        angle,
            scale,
            resObject = {};

        _(parent, [_table([_tbody([outlineParent, markerSizeParent, fillParent, iconParent])])]);

        var fillStyleControl = new FillStyleControl(templateStyle, {
          showSelectors: geometryType !== 'point'
        });
        fillStyleControl.setVisibleSelectors(typeof templateStyle.fill != 'undefined');
        $(fillStyleControl).change(function () {
          var fillStyle = fillStyleControl.getFillStyle();
          templateStyle.fill = fillStyle;
          $(resObject).change();
        });

        showIcon = function showIcon() {
          hideStyle(outlineParent);
          hideStyle(fillParent);
          fillStyleControl.setVisibleSelectors(false);
          fillParent.style.display = 'none';
          showStyle(iconParent);
          templateStyle.marker = {};
          templateStyle.marker.image = inputUrl.value();
          templateStyle.marker.center = true;
          delete templateStyle.outline;
          delete templateStyle.fill;

          if (geometryType == "point") {
            if (isWindLayer) {
              if (angle.value != '') templateStyle.marker.angle = angle.value;
              if (scale.value != '') templateStyle.marker.scale = scale.value;
              templateStyle.marker.color = $(iconParent).find(".colorSelector")[0].hex;
            }

            hideStyle(markerSizeParent);
            markerSizeParent.style.display = 'none';
          }

          if (geometryType != "linestring") {
            fillToggle.disabled = true;
          }

          $(resObject).change();
        };

        showMarker = function showMarker() {
          showStyle(outlineParent);
          showStyle(markerSizeParent);
          markerSizeParent.style.display = '';
          hideStyle(iconParent);

          if (geometryType != "linestring") {
            fillParent.style.display = '';

            if (fillToggle.checked) {
              showStyle(fillParent);
              fillStyleControl.setVisibleSelectors(true);
            }

            if (geometryType == "point") {
              templateStyle.marker = {};
              templateStyle.marker.size = Number($(markerSizeParent).find(".inputStyle").val());
            }

            templateStyle.fill = fillStyleControl.getFillStyle();
            fillToggle.disabled = false;
          }

          if (geometryType != "point" && typeof templateStyle.marker != 'undefined') delete templateStyle.marker;
          templateStyle.outline = {};
          templateStyle.outline.thickness = Number($(outlineParent).find(".inputStyle")[0].value);
          templateStyle.outline.color = $(outlineParent).find(".colorSelector")[0].hex;
          templateStyle.outline.opacity = $($(outlineParent).find(".ui-slider")[0]).slider('option', 'value');
          $(resObject).change();
        };

        outlineToggle = _checkbox(geometryType == "point" && typeof templateStyle.marker != 'undefined' && typeof templateStyle.marker.image == 'undefined' || geometryType != "point" && (typeof templateStyle.marker == 'undefined' || typeof templateStyle.marker != 'undefined' && typeof templateStyle.marker.image == 'undefined'), 'radio');

        outlineToggle.onclick = function () {
          showMarker();
          iconToggle.checked = false;
          this.checked = true;
        };

        outlineTitleTds.push(_td([outlineToggle], [['css', 'width', '20px'], ['css', 'height', '24px']]));
        outlineTitleTds.push(_td([_t(_gtxt("Граница"))], [['css', 'width', '70px']]));
        var outlineColor = nsGmx$1.Controls.createColorPicker(templateStyle.outline && typeof templateStyle.outline.color != 'undefined' ? templateStyle.outline.color : 0x0000FF, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex) {
          outlineColor.style.backgroundColor = '#' + hex;
          templateStyle.outline = templateStyle.outline || {};
          templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);
          $(resObject).change();
        });
        if (templateStyle.outline && typeof templateStyle.outline.color != 'undefined') outlineColor.hex = templateStyle.outline.color;else outlineColor.hex = 0x0000FF;
        outlineTds.push(_td([outlineColor], [['css', 'width', '40px']]));
        var divSlider = nsGmx$1.Controls.createSlider(templateStyle.outline && typeof templateStyle.outline.opacity != 'undefined' ? templateStyle.outline.opacity : 100, function (event, ui) {
          templateStyle.outline = templateStyle.outline || {};
          templateStyle.outline.opacity = ui.value;
          $(resObject).change();
        });
        outlineTds.push(_td([divSlider], [['css', 'width', '100px'], ['css', 'padding', '4px 5px 3px 5px']]));
        var outlineThick = nsGmx$1.Controls.createInput(templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined' ? templateStyle.outline.thickness : 2, function () {
          templateStyle.outline = templateStyle.outline || {};
          templateStyle.outline.thickness = Number(this.value);
          $(resObject).change();
          return true;
        });

        _title(outlineThick, _gtxt("Толщина линии"));

        outlineTds.push(_td([outlineThick], [['css', 'width', '30px']]));

        var dashInput = _input(null, [['attr', 'value', templateStyle.outline && typeof templateStyle.outline.dashes != 'undefined' ? templateStyle.outline.dashes : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '140px']]),
            dashSelect = nsGmx$1.Utils._select(null, [['dir', 'className', 'selectStyle'], ['css', 'width', '50px'], ['css', 'fontSize', '12px'], ['css', 'fontWeight', 'bold']]),
            borderValues = {
          "1": "",
          "2": "4,4",
          "3": "2,2",
          "4": "6,3,2,3",
          "5": "6,3,2,3,2,3",
          "6": "2,4",
          "7": "6,6",
          "8": "7,6,2,6",
          "9": "8,4,8,4,2,4"
        },
            dashSelector = _div(null, [['dir', 'className', 'colorSelector']]),
            dashTable = _table(null, [['css', 'position', 'absolute'], ['css', 'left', '-1px'], ['css', 'top', '-57px'], ['css', 'zIndex', 2]]),
            dashedTds = [],
            dashFunc = function dashFunc() {
          var arr = dashInput.value.split(","),
              correct = true;

          if (arr.length % 2 == 0) {
            for (var i = 0; i < arr.length; i++) {
              arr[i] = Number(arr[i]);

              if (isNaN(arr[i]) || arr[i] <= 0) {
                correct = false;
                break;
              }
            }
          } else correct = false;

          templateStyle.outline = templateStyle.outline || {};

          if (correct) {
            templateStyle.outline.dashes = arr;
          } else if (templateStyle.outline.dashes) {
            delete templateStyle.outline.dashes;
          }

          $(resObject).change();
        };

        if (geometryType != "point") {
          var dashTrs = [];

          for (var i = 1; i <= 7; i += 3) {
            var dashTds = [];

            for (var j = i; j <= i + 2; j++) {
              var dashTd = _td([_img(null, [['attr', 'src', 'img/dash' + j + '.png']])], [['css', 'border', '1px solid #000000'], ['css', 'cursor', 'pointer']]);

              (function (j) {
                dashTd.onclick = function (e) {
                  dashSelector.style.backgroundImage = 'url(img/dash' + j + '.png)';
                  dashInput.value = borderValues[String(j)];
                  dashFunc();
                  $(dashTable).fadeOut(500);
                  stopEvent(e);
                };
              })(j);

              dashTds.push(dashTd);
            }

            dashTrs.push(_tr(dashTds));
          }

          _(dashTable, [_tbody(dashTrs)]);

          _(dashSelector, [dashTable]);

          dashSelector.onclick = function () {
            $(dashTable).fadeIn(500);
          };

          dashInput.onfocus = dashSelector.onblur = function () {
            $(dashTable).fadeOut(500);
          };

          dashTable.style.display = 'none';
          dashedTds.push(_td([dashSelector]));
          dashedTds.push(_td([dashInput], [['attr', 'colSpan', 2]]));

          for (var borderValue in borderValues) {
            if (borderValues[borderValue] == dashInput.value) {
              dashSelector.style.backgroundImage = 'url(img/dash' + borderValue + '.png)';
              break;
            }
          }

          dashSelect.style.marginLeft = '2px';

          dashInput.onkeyup = function () {
            dashFunc();
            return true;
          };
        } else dashedTds = [_td(), _td(), _td()];

        if (geometryType != "linestring") {
          fillToggle = _checkbox(typeof templateStyle.fill != 'undefined', 'checkbox');

          fillToggle.onclick = function () {
            fillStyleControl.setVisibleSelectors(this.checked);

            if (this.checked) {
              templateStyle.fill = fillStyleControl.getFillStyle();
              showStyle(fillParent);
              $(resObject).change();
            } else {
              hideStyle(fillParent);
              delete templateStyle.fill; // if (elemCanvas.nodeName == 'DIV')
              // $(elemCanvas).find(".fillIcon")[0].style.backgroundColor = "#FFFFFF";

              $(resObject).change();
            }
          };

          fillTitleTds.push(_td([fillToggle], [['css', 'width', '20px'], ['css', 'height', '24px']])); //fillTitleTds.push(_td([_t(_gtxt("Заливка"))],[['css','width','70px']]));

          fillTitleTds.push(_td([fillStyleControl.getSelector()[0]], [['css', 'width', '70px']]));
          var checkedFillColor = typeof templateStyle.fill != 'undefined' && typeof templateStyle.fill.color != 'undefined' ? templateStyle.fill.color : 0xFFFFFF,
              checkedFillOpacity = typeof templateStyle.fill != 'undefined' && typeof templateStyle.fill.opacity != 'undefined' ? templateStyle.fill.opacity : 0,
              fillColor = nsGmx$1.Controls.createColorPicker(checkedFillColor, function (colpkr) {
            $(colpkr).fadeIn(500);
            return false;
          }, function (colpkr) {
            $(colpkr).fadeOut(500);
            return false;
          }, function (hsb, hex) {
            fillColor.style.backgroundColor = '#' + hex;
            templateStyle.fill.color = fillColor.hex = parseInt('0x' + hex); // if (elemCanvas.nodeName == 'DIV')
            // $(elemCanvas).find(".fillIcon")[0].style.backgroundColor = '#' + hex;

            $(resObject).change();
          }),
              fillSlider = nsGmx$1.Controls.createSlider(checkedFillOpacity, function (event, ui) {
            templateStyle.fill.opacity = ui.value;
            $(resObject).change();
          });
          fillColor.hex = checkedFillColor;
          fillTds.push(_td([fillColor], [['css', 'width', '40px']]));
          fillTds.push(_td([fillSlider], [['css', 'width', '100px'], ['css', 'padding', '4px 5px 3px 5px']]));
        }

        iconToggle = _checkbox(templateStyle.marker && typeof templateStyle.marker.image != 'undefined', 'radio');

        iconToggle.onclick = function () {
          showIcon();
          outlineToggle.checked = false;
          this.checked = true;
        };

        iconTitleTds.push(_td([iconToggle], [['css', 'width', '20px'], ['css', 'height', '24px'], ['attr', 'vAlign', 'top'], ['css', 'paddingTop', '5px']]));
        iconTitleTds.push(_td([_t(_gtxt("Маркер URL"))], [['css', 'width', '70px'], ['attr', 'vAlign', 'top'], ['css', 'paddingTop', '5px']]));
        inputUrl = new window.mapHelper.ImageInputControl(typeof templateStyle.marker != 'undefined' && templateStyle.marker.image ? templateStyle.marker.image : '');
        $(inputUrl).change(function () {
          if (inputUrl.value() != '') {
            showIcon();
            outlineToggle.checked = false;
            iconToggle.checked = true;
          }

          if (typeof templateStyle.marker == 'undefined') templateStyle.marker = {};
          templateStyle.marker.image = inputUrl.value();
          $(resObject).change();
        });

        if (geometryType == "point") {
          var markerSizeInput = nsGmx$1.Controls.createInput(templateStyle.marker && templateStyle.marker.size || 3, function () {
            templateStyle.marker = templateStyle.marker || {};
            templateStyle.marker.size = Number(this.value);
            $(resObject).change();
            return true;
          });

          _title(markerSizeInput, _gtxt("Размер точек"));

          var markerSizeTds = [_td(), _td([_t(_gtxt("Размер"))]), _td([markerSizeInput], [['attr', 'fade', true]])];

          _(markerSizeParent, markerSizeTds, [['attr', 'fade', true]]);

          if (isWindLayer) {
            var markerColor = nsGmx$1.Controls.createColorPicker(templateStyle.marker && typeof templateStyle.marker.color != 'undefined' ? templateStyle.marker.color : 0xFF00FF, function (colpkr) {
              $(colpkr).fadeIn(500);
              return false;
            }, function (colpkr) {
              $(colpkr).fadeOut(500);
              return false;
            }, function (hsb, hex) {
              markerColor.style.backgroundColor = '#' + hex;
              templateStyle.marker = templateStyle.marker || {};
              templateStyle.marker.color = markerColor.hex = parseInt('0x' + hex);
              $(resObject).change();
            });
            if (templateStyle.marker && typeof templateStyle.marker.color != 'undefined') markerColor.hex = templateStyle.marker.color;else markerColor.hex = 0xFF00FF;
            scale = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'value', templateStyle.marker && templateStyle.marker.scale ? templateStyle.marker.scale : ''], ['css', 'width', '68px']]);

            scale.onkeyup = function () {
              templateStyle.marker = templateStyle.marker || {};
              if (this.value != '') templateStyle.marker.scale = this.value;else delete templateStyle.marker.scale;
              $(resObject).change();
            };

            _title(scale, _gtxt("Масштаб"));

            angle = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'value', templateStyle.marker && templateStyle.marker.angle ? templateStyle.marker.angle : ''], ['css', 'width', '68px']]);

            angle.onkeyup = function () {
              templateStyle.marker = templateStyle.marker || {};
              if (this.value != '') templateStyle.marker.angle = this.value;else delete templateStyle.marker.angle;
              $(resObject).change();
            };

            _title(angle, _gtxt("Угол поворота"));

            iconTds.push(_td([_table([_tbody([_tr([_td([inputUrl.getControl()], [['attr', 'colSpan', 3]])]), _tr([_td([markerColor], [['css', 'paddingLeft', '1px']]), _td([angle]), _td([scale], [['css', 'paddingRight', '3px']])])])])]));
          } else iconTds.push(_td([inputUrl.getControl()]));
        } else if (geometryType == "polygon" || geometryType == "linestring") {
          //	hide(iconParent);
          iconTds.push(_td([inputUrl.getControl()]));
          if (geometryType == "linestring") hide(fillParent);
        }

        _(outlineParent, outlineTitleTds.concat(_td([_div([_table([_tbody([_tr(outlineTds), _tr(dashedTds)])])], [['attr', 'fade', true]])]))); //_(fillParent, fillTitleTds.concat(_td([_div([_table([_tbody([_tr(fillTds)])])],[['attr','fade',true]])])));


        var topPadding = geometryType === "point" ? "0px" : "10px";
        fillTitleTds = fillTitleTds.concat(_td([fillStyleControl.getControls()[0]], [['attr', 'fade', true], ['css', 'paddingTop', topPadding]]));

        _(fillParent, fillTitleTds);

        _(iconParent, iconTitleTds.concat(_td([_div([_table([_tbody([_tr(iconTds)])])], [['attr', 'fade', true]])])));

        if (templateStyle.marker && typeof templateStyle.marker.image != 'undefined') {
          $(outlineParent).find("[fade]")[0].style.display = 'none';
          $(fillParent).find("[fade]")[0].style.display = 'none';
          $(iconParent).find("[fade]")[0].style.display = '';
        } else {
          $(outlineParent).find("[fade]")[0].lastChild.style.display = '';
          $(fillParent).find("[fade]")[0].style.display = '';
          $(iconParent).find("[fade]")[0].style.display = 'none';
        }

        if (geometryType != "linestring" && typeof templateStyle.fill == 'undefined') $(fillParent).find("[fade]")[0].style.display = 'none';
        return resObject;
      };

      var LayerStylesEditor = function LayerStylesEditor(div, divStyles, openedStyleIndex) {
        var elemProperties = div.gmxProperties.content.properties,
            parentIcon = $(div).children("[styleType]")[0],
            filtersCanvas = _div(null, [['css', 'marginLeft', '10px']]),
            filterHeader = createFilterHeader(filtersCanvas, elemProperties, parentIcon),
            layer = nsGmx$1.gmxMap.layersByID[elemProperties.name],
            layerStyles = layer.getStyles();

        for (var i = 0; i < layerStyles.length; i++) {
          var filter = createLoadingFilter(layer, i, elemProperties.styles[i], elemProperties.GeometryType, elemProperties.attributes, parentIcon, i == openedStyleIndex);

          _(filtersCanvas, [filter]);

          $(filter.firstChild).treeview();
          attachLoadingFilterEvent(filter, layer, i, elemProperties.styles[i], elemProperties.GeometryType, elemProperties.attributes, parentIcon);
        }

        for (var _i = 0; _i < filtersCanvas.childNodes.length; _i++) {
          updateFilterMoveButtons(filtersCanvas.childNodes[_i]);
        }

        _(divStyles, [filterHeader, filtersCanvas]);

        this.getUpdatedStyles = function () {
          return updateStyles(filtersCanvas);
        };

        this.removeColorPickers = function () {
          for (var _i2 = 0; _i2 < filtersCanvas.childNodes.length; _i2++) {
            filtersCanvas.childNodes[_i2].removeColorPickers();
          }
        };

        this.getStyleCount = function () {
          return filtersCanvas.childNodes.length;
        };

        this.setAllFilters = function () {
          $(filtersCanvas).find("[filterTable]").each(function () {
            this.setFilter();
          });
        };
      };

      var createStylesDialog = function createStylesDialog(elem, treeView, openedStyleIndex) {
        var div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + elem.LayerID + "']")[0],
            elemProperties = div.gmxProperties.content.properties,
            mapName = elemProperties.mapName,
            layerName = elemProperties.name;

        if (typeof window._mapHelper.layerStylesHash[layerName] !== 'undefined') {
          return;
        }

        window._mapHelper.layerStylesHash[layerName] = true;
        var pos = nsGmx$1.Utils.getDialogPos(div, true, 390);

        var updateFunc = function updateFunc() {
          var _styles = elemProperties.styles;
          elemProperties.styles = styleEditor.getUpdatedStyles();

          for (var i = 0; i < elemProperties.styles.length; i++) {
            if (_styles[i] && _styles[i]._MinZoom) {
              elemProperties.styles[i]._MinZoom = _styles[i]._MinZoom;
            }
          }

          treeView.findTreeElem(div).elem.content.properties = elemProperties;
        };

        var attributesHash = {};

        for (var i = 0; i < elemProperties.attributes.length; i++) {
          attributesHash[elemProperties.attributes[i]] = [];
        }

        _mapHelper.attrValues[mapName] = _mapHelper.attrValues[mapName] || {};
        _mapHelper.attrValues[mapName][layerName] = new nsGmx$1.LazyAttributeValuesProviderFromServer(attributesHash, layerName);

        var closeFunc = function closeFunc() {
          updateFunc();
          var newStyles = styleEditor.getUpdatedStyles(),
              multiStyleParent = $(div).children('[multiStyle]')[0],
              parentIcon = $(div).children("[styleType]")[0];
          delete window._mapHelper.layerStylesHash[layerName];
          styleEditor.removeColorPickers();
          var multiFiltersFlag = parentIcon.getAttribute('styleType') == 'multi' && styleEditor.getStyleCount() > 1,
              // было много стилей и осталось
          colorIconFlag = parentIcon.getAttribute('styleType') == 'color' && styleEditor.getStyleCount() == 1 && typeof newStyles[0].RenderStyle.marker != 'undefined' && typeof newStyles[0].RenderStyle.marker.image == 'undefined'; // была не иконка и осталась

          if (!multiFiltersFlag && !colorIconFlag) {
            var newIcon = _mapHelper.createStylesEditorIcon(newStyles, elemProperties.GeometryType.toLowerCase());

            $(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
          }

          $(multiStyleParent).empty();

          _mapHelper.createMultiStyle(elemProperties, treeView, multiStyleParent); // gmxCore.loadModule('TinyMCELoader', 'http://' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function() {
          // 	$('.balloonEditor', divDialog).each(function() {
          // 		tinyMCE.execCommand("mceRemoveControl", true, $(this).attr('id'));
          // 	})
          // })


          $('.balloonEditor', divDialog).each(function () {
            tinyMCE.execCommand("mceRemoveControl", true, $(this).attr('id'));
          });
          return false;
        };

        if (div.gmxProperties.content.properties.styles.length == 1) {
          openedStyleIndex = 0;
        } else if (typeof openedStyleIndex === 'undefined') {
          openedStyleIndex = -1;
        }

        var styleContainer = _div();

        var styleEditor = new LayerStylesEditor(div, styleContainer, openedStyleIndex);
        styleEditor.setAllFilters();
        var divDialog = showDialog(_gtxt('Стили слоя [value0]', elem.title), styleContainer, 350, 470, pos.left, pos.top, null, function () {
          closeFunc();
          delete styleDialogs[elemProperties.name];
        });
        styleDialogs[elemProperties.name] = {
          updateFunc: updateFunc
        };
        if (openedStyleIndex > 0) styleContainer.parentNode.scrollTop = 58 + openedStyleIndex * 32;

        _mapHelper.updateTinyMCE(styleContainer);
      };

      var styleDialogs = {};

      var updateAllStyles = function updateAllStyles() {
        for (var name in styleDialogs) {
          styleDialogs[name].updateFunc();
        }
      };

      window.gmxCore.addModule('LayerStylesEditor', {
        LayerStylesEditor: LayerStylesEditor,
        createStyleEditor: createStyleEditor,
        createStylesDialog: createStylesDialog,
        updateAllStyles: updateAllStyles
      });
    })(nsGmx$1.Utils._);

    /** Менеджер дополнительных данных карты. Данные собираются и используются набором сборщиков данных, каждый из которых имеет свой уникальный id.
    @class userObjectsManager
    @memberOf nsGmx 
    */
    nsGmx$1.userObjectsManager = {
      _data: {},
      _collectors: {},

      /**
       Устанавливает данные, которые потом могут быть использованы поставщиками данных
      @method
      */
      setData: function setData(data) {
        this._data = data;
      },

      /**
       Возвращает собранные данные
      @method
      */
      getData: function getData() {
        return this._data;
      },

      /**
       Собирает данные со всех сборщиков данных. Собранные данные доступны через метод getData
       @method
      */
      collect: function collect() {
        for (var id in this._collectors) {
          if ('collect' in this._collectors[id]) {
            var data = this._collectors[id].collect();

            if (data !== null) {
              this._data[id] = data;
            }
          }
        }
      },

      /**
      Вызывает метод load() у всех поставщиков данных, для которых есть данные.
       После вызова метода данные для данного загрузчика будут удалены (чтобы предотвратить множественную загрузку)
      @method
      */
      load: function load(dataCollectorNames) {
        var collectors = {};

        if (dataCollectorNames) {
          if (typeof dataCollectorNames === 'string') dataCollectorNames = [dataCollectorNames];

          for (var dc = 0; dc < dataCollectorNames.length; dc++) {
            var name = dataCollectorNames[dc];
            if (name in this._collectors) collectors[name] = this._collectors[name];
          }
        } else collectors = this._collectors;

        for (var id in collectors) {
          if (id in this._data && 'load' in collectors[id]) {
            collectors[id].load(this._data[id]);
            delete this._data[id];
          }
        }
      },

      /**
      Добавляет новый сборщик данных. Если в момент добавления есть какие-нибудь данные для загрузчика, они будут ему сразу же переданы
      @method
       @param collectorId {String} - уникальный идентификатор сборщика данных
       @param collector {Object} - сборщик данных. Должен иметь следующие методы:<br/>
           collect()->Object - возвращает собранные данные. Если данных нет, нужно вернуть null
           load(data)->void - передаёт существующие данные загрузчику
      */
      addDataCollector: function addDataCollector(collectorId, collector) {
        this._collectors[collectorId] = collector;

        if (collectorId in this._data && 'load' in collector) {
          collector.load(this._data[collectorId]);
          delete this._data[collectorId];
        }
      }
    };

    //Отображение закладок карты в левой панели

    nsGmx$1.Controls = nsGmx$1.Controls || {};

    nsGmx$1.Controls.LanguageSelector = function (container) {
      var LANGUAGES = [{
        lang: 'rus',
        title: 'rus'
      }, {
        lang: 'eng',
        title: 'eng'
      }],
          lang = null,
          _this = this;

      var template = Handlebars.compile('<div class = "language-container">' + '{{#langs}}' + '<span data-lang = "{{lang}}" class="language-item">{{title}}</span>' + '{{/langs}}' + '</div>');
      $(container).empty().append($(template({
        langs: LANGUAGES
      })));

      var update = function update() {
        var newLang = $(this).data('lang'),
            prevLang = lang;

        if (newLang !== prevLang) {
          lang = newLang;
          $(this).addClass('language-selected').siblings().removeClass('language-selected');
          $(_this).trigger('change', [prevLang, newLang]);
        }
      };

      $(container).find('span').click(update);
      update.bind($(container).find('span')[0])();

      this.getLang = function () {
        return lang;
      };
    };

    var queryTabs = function queryTabs() {
      this.builded = false;
      this.tabsCanvas = null;
      this.tabs = [];
    };

    queryTabs.prototype = new leftMenu();

    queryTabs.prototype.load = function () {
      if (!this.builded) {
        var _this = this;

        this.tabsCanvas = _div(null, [['dir', 'className', 'tabsCanvas']]);
        this.workCanvas.appendChild(this.tabsCanvas);

        for (var i = 0; i < this.tabs.length; i++) {
          this.draw(this.tabs[i]);
        }

        this.builded = true;
        $(this.tabsCanvas).sortable({
          axis: 'y',
          tolerance: 'pointer',
          containment: 'parent'
        });
        $(this.tabsCanvas).bind('sortupdate', function () {
          var orderedTabs = [];
          $(_this.tabsCanvas).children().each(function () {
            orderedTabs.push(this.tabInfo);
          });
          _this.tabs = orderedTabs;
        });
        this.leftPanelItem.hide();
      }
    };

    queryTabs.prototype.add = function (tabInfo, tabIndex) {
      var isNew = typeof tabIndex === 'undefined';
      tabInfo = tabInfo || {
        name_rus: '',
        description_rus: '',
        name_eng: '',
        description_eng: ''
      };

      if (typeof tabInfo.name_rus === 'undefined') {
        tabInfo.name_rus = tabInfo.name;
      }

      if (typeof tabInfo.description_rus === 'undefined') {
        tabInfo.description_rus = tabInfo.description;
      }

      var uiTemplate = Handlebars.compile('<div class = "addtabs-container">' + '<div class = "addtabs-info">{{i "Название"}}</div>' + '<input class = "addtabs-title-input inputStyle" value="{{title}}"><br>' + '<div class = "addtabs-info">{{i "Описание"}}</div>' + '<textarea class = "addtabs-title-description inputStyle">{{description}}</textarea><br>' + '<button class = "addtabs-create">{{buttonTitle}}</button>' + '<div class = "addtabs-lang-placeholder"></div>' + '</div>');
      var titleLoc = {
        rus: tabInfo.name_rus,
        eng: tabInfo.name_eng
      };
      var descrLoc = {
        rus: tabInfo.description_rus,
        eng: tabInfo.description_eng
      };
      var ui = $(uiTemplate({
        title: titleLoc.rus,
        description: descrLoc.rus,
        buttonTitle: isNew ? _gtxt('Создать') : _gtxt('Изменить')
      })),
          titleInput = $('.addtabs-title-input', ui);

      var updateDataLoc = function updateDataLoc(lang) {
        titleLoc[lang] = titleInput.val();
        descrLoc[lang] = $('.addtabs-title-description', ui).val();
      };

      var langControl = new nsGmx$1.Controls.LanguageSelector(ui.find('.addtabs-lang-placeholder'));
      $(langControl).change(function (event, prevLang, newLang) {
        updateDataLoc(prevLang);
        titleInput.val(titleLoc[newLang]);
        $('.addtabs-title-description', ui).val(descrLoc[newLang]);
      });
      titleInput.keyup(function (e) {
        $(this).toggleClass('error', this.value == '');

        if (e.keyCode == 13) {
          createTab();
          return false;
        }

        return true;
      });
      titleInput.focus();

      var createTab = function createTab() {
        updateDataLoc(langControl.getLang());

        var mapState = window._mapHelper.getMapState(),
            tab = {
          name: titleLoc.rus || titleLoc.eng,
          description: descrLoc.rus || descrLoc.eng,
          name_rus: titleLoc.rus,
          description_rus: descrLoc.rus,
          name_eng: titleLoc.eng,
          description_eng: descrLoc.eng,
          state: mapState
        };

        if (isNew) {
          _this.tabs.push(tab);
        } else {
          _this.tabs[tabIndex] = tab;
        }

        _this.draw(tab, tabIndex);

        removeDialog(dialogDiv);
      },
          _this = this;

      $('.addtabs-create', ui).click(createTab);
      var dialogDiv = showDialog(_gtxt("Имя закладки"), ui[0], 280, 230, false, false);
    };

    queryTabs.prototype.draw = function (tabInfo, tabIndex) {
      var selectValLoc = function selectValLoc(paramName) {
        var lang = nsGmx$1.Translations.getLanguage();
        return tabInfo[paramName + '_' + lang] || tabInfo[paramName];
      };

      var tmpl = Handlebars.compile('<div class="canvas">' + '<div class="buttonLink tabName" title="{{description}}">{{name}}</div>' + '<div class="gmx-icon-edit"></div>' + '<div class="gmx-icon-close"></div>' + '</div>');
      var canvas = $(tmpl({
        name: selectValLoc('name'),
        description: selectValLoc('description')
      }))[0];

      var _this = this;

      canvas.tabInfo = tabInfo;
      $('.tabName', canvas).click(this.show.bind(this, tabInfo.state));
      $('.gmx-icon-close', canvas).click(function () {
        var index = getOwnChildNumber(canvas);

        _this.tabs.splice(index, 1);

        canvas.removeNode(true);
      });
      $('.gmx-icon-edit', canvas).click(function () {
        var index = getOwnChildNumber(canvas);

        _this.add(_this.tabs[index], index);
      }).toggle(_queryMapLayers.currentMapRights() === "edit");

      if (typeof tabIndex === 'undefined') {
        $(this.tabsCanvas).append(canvas);
      } else {
        $(this.tabsCanvas).find('.canvas').eq(tabIndex).replaceWith(canvas);
      }
    };

    queryTabs.prototype.show = function (state) {
      var parsedState = {},
          lmap = nsGmx$1.leafletMap,
          gmxDrawing = lmap.gmxDrawing;
      $.extend(true, parsedState, state);
      var pos = parsedState.position;
      lmap.setView(L.Projection.Mercator.unproject(L.point(pos.x, pos.y)), 17 - pos.z);

      for (var i = 0; i < state.drawnObjects.length; i++) {
        parsedState.drawnObjects[i].geometry = L.gmxUtil.geometryToGeoJSON(state.drawnObjects[i].geometry, true);
      }

      lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(parsedState.mode)); //удаляем все фичи

      gmxDrawing.getFeatures().slice(0).forEach(gmxDrawing.remove.bind(gmxDrawing));

      for (var _i = 0; _i < parsedState.drawnObjects.length; _i++) {
        //старый формат - число, новый - строка
        var rawColor = parsedState.drawnObjects[_i].color,
            color = (typeof rawColor === 'number' ? '#' + L.gmxUtil.dec2hex(rawColor) : rawColor) || '#0000FF',
            thickness = parsedState.drawnObjects[_i].thickness || 2,
            opacity = parsedState.drawnObjects[_i].opacity || 80;
        gmxDrawing.addGeoJSON(parsedState.drawnObjects[_i].geometry, {
          lineStyle: {
            color: color,
            weight: thickness,
            opacity: opacity / 100
          }
        });
      }

      _queryMapLayers.applyState(parsedState.condition, parsedState.mapStyles);

      if (typeof parsedState.customParamsCollection !== 'undefined') window._mapHelper.customParamsManager.loadParams(parsedState.customParamsCollection);

      if (parsedState.openPopups) {
        for (var l in parsedState.openPopups) {
          var layer = nsGmx$1.gmxMap.layersByID[l];

          if (layer && layer.addPopup) {
            parsedState.openPopups[l].forEach(layer.addPopup.bind(layer));
          }
        }
      }
    };

    var _queryTabs = new queryTabs();

    nsGmx$1.userObjectsManager.addDataCollector('tabs', {
      collect: function collect() {
        if (!_queryTabs.tabs.length) return null;
        var tabs = [];

        for (var i = 0; i < _queryTabs.tabs.length; i++) {
          var tab = {};
          $.extend(tab, _queryTabs.tabs[i]);
          tabs.push(tab);
        }

        return tabs;
      },
      load: function load(data) {
        if (!data || !data.length) return;
        $('#left_mapTabs').remove();
        _queryTabs.builded = false;
        _queryTabs.tabs = data;
        window.mapHelp.tabs.load('mapTabs');
      }
    });

    (function (_) {
      var queryExternalMaps = function queryExternalMaps() {
        this.maps = [];
        this.loadedMaps = {};
      };

      queryExternalMaps.prototype = new leftMenu();

      queryExternalMaps.prototype.load = function () {
        if (!this.builded) {
          var hostButton = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]),
              nameButton = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]),
              loadButton = makeButton(_gtxt("Загрузить")),
              addMap = makeLinkButton(_gtxt("Добавить карту")),
              paramsTable = _table([_tbody([_tr([_td([_t(_gtxt("Хост"))], [['css', 'colSpan', 2], ['css', 'paddingTop', '3px']])]), _tr([_td([hostButton]), _td()]), _tr([_td([_t(_gtxt("Имя"))], [['css', 'colSpan', 2]])]), _tr([_td([nameButton]), _td([loadButton])])])], [['css', 'margin', '3px 0px 0px 10px']]),
              _this = this;

          _(this.workCanvas, [_div([addMap], [['css', 'margin', '5px 0px 5px 10px']]), paramsTable]);

          paramsTable.style.display = 'none';
          hostButton.value = window.serverBase;

          addMap.onclick = function () {
            if (paramsTable.style.display == 'none') paramsTable.style.display = '';else paramsTable.style.display = 'none';
          };

          loadButton.onclick = function () {
            if (hostButton.value == '') inputError(hostButton);
            if (nameButton.value == '') inputError(nameButton);
            if (hostButton.value == '' || nameButton.value == '') return;

            _this.addMapElem(hostButton.value, nameButton.value);

            nameButton.value = '';
          };

          this.mapsCanvas = _div(null, [['dir', 'className', 'drawingObjectsCanvas externalMapsCanvas'], ['css', 'paddingLeft', '0px'], ['attr', 'id', 'externalMapsCanvas']]);

          _(this.workCanvas, [this.mapsCanvas]);

          this.builded = true;

          for (var i = 0; i < this.maps.length; ++i) {
            this.addMapElem(this.maps[i].hostName, this.maps[i].mapName, true);
          }
        }
      };

      queryExternalMaps.prototype.addMapElem = function (hostName, mapName, silent) {
        this.createWorkCanvas('externalMaps');
        this.load();

        var mapElem = _div(),
            div = _div(null, [['css', 'position', 'relative'], ['css', 'margin', '2px 0px 2px 14px']]),
            remove = $('<div class="gmx-icon-close"></div>'),
            mapInfo,
            _this = this;

        for (var i = 0; i < this.maps.length; i++) {
          var map = this.maps[i];

          if (map.hostName === hostName && map.mapName === mapName) {
            if (map.container) {
              return;
            }

            mapInfo = map;
            break;
          }
        }

        if (!mapInfo) {
          mapInfo = {
            hostName: hostName,
            mapName: mapName
          };
          this.maps.push(mapInfo);
        }

        mapInfo.container = div;
        div.hostName = hostName;
        div.mapName = mapName;

        _(div, [mapElem, remove[0]]);

        _(this.mapsCanvas, [div]);

        this.addMap(hostName, mapName, mapElem, silent);
        remove.click(function () {
          div.removeNode(true);
          if (!mapElem.extLayersTree) return;
          mapElem.extLayersTree.treeModel.forEachLayer(function (layer) {
            var name = layer.properties.name;
            if (nsGmx$1.layersByID[name].external) _queryMapLayers.removeLayer(name);
          });

          for (var i = 0; i < _this.maps.length; i++) {
            var map = _this.maps[i];

            if (map.hostName === hostName && map.mapName === mapName) {
              _this.maps.splice(i, 1);

              break;
            }
          }
        });
      };

      queryExternalMaps.prototype.addMap = function (hostName, mapName, parent, silent) {
        var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px'], ['css', 'width', '16px'], ['css', 'height', '16px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]); // var _this = this;


        _(parent, [loading]);

        this.loadMap(hostName, mapName, function (gmxMap) {
          if (gmxMap == null) {
            loading.parentNode.parentNode.removeNode(true);
            silent || showErrorMessage(_gtxt("Невозможно загрузить карту [value0] с домена [value1]", mapName, hostName), true);
            return;
          }

          var extLayersTree = new window.layersTree({
            showVisibilityCheckbox: true,
            allowActive: false,
            allowDblClick: true
          });
          var tree = extLayersTree.drawTree(gmxMap.rawTree, 2);
          $(tree).treeview();
          extLayersTree.runLoadingFuncs();
          loading.removeNode(true);

          _(parent, [tree]); //добавляем перетаскивание в основную карту только если доп. карта с того же домена


          if (hostName === _layersTree.treeModel.getMapProperties().hostName) _queryMapLayers.addDraggable(parent);
          parent.extLayersTree = extLayersTree;
        });
      };

      queryExternalMaps.prototype.loadMap = function (hostName, mapName, callback) {
        var _this = this;

        L.gmx.loadMap(mapName, {
          hostName: hostName,
          leafletMap: nsGmx$1.leafletMap,
          apiKey: window.apiKey,
          srs: nsGmx$1.leafletMap.options.srs || '',
          isGeneralized: window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true,
          skipTiles: nsGmx$1.leafletMap.options.skipTiles || ''
        }).then(function (gmxMap) {
          for (var i = 0; i < gmxMap.layers.length; i++) {
            var layer = gmxMap.layers[i];
            var id = layer.getGmxProperties().name;
            layer.external = true;

            if (!(id in nsGmx$1.gmxMap.layersByID)) {
              nsGmx$1.gmxMap.addLayer(layer);
            }
          }

          if (gmxMap.properties.Copyright) {
            var copyrightLayer = {
              options: {
                attribution: gmxMap.properties.Copyright
              },
              onAdd: function onAdd() {},
              onRemove: function onRemove() {}
            };
            copyrightLayer.addTo(nsGmx$1.leafletMap);
          }

          gmxMap.properties.hostName = hostName;
          callback(gmxMap);
          $(_queryExternalMaps).triggerHandler('map_loaded', gmxMap);

          for (var _i = 0; _i < _this.maps.length; _i++) {
            var map = _this.maps[_i];

            if (map.hostName === hostName && map.mapName === mapName) {
              map.tree = gmxMap.layers;
              break;
            }
          }
        }, function () {
          callback(null);
          $(_queryExternalMaps).triggerHandler('map_loaded', null);
        });
      };

      var _queryExternalMaps = new queryExternalMaps();

      window._queryExternalMaps = _queryExternalMaps;
      nsGmx$1.userObjectsManager.addDataCollector('externalMaps', {
        collect: function collect() {
          if (!_queryExternalMaps.workCanvas) return;
          var value = [];
          $(_queryExternalMaps.workCanvas.lastChild).children("div").each(function () {
            value.push({
              hostName: this.hostName,
              mapName: this.mapName
            });
          });
          if (!value.length) return null;
          return value;
        },
        load: function load(data) {
          if (!data || !data.length) return;
          $('#left_externalMaps').remove();
          _queryExternalMaps.builded = false;
          _queryExternalMaps.maps = data;
          window.mapHelp.externalMaps.load('externalMaps');
        }
      });
    })(nsGmx$1.Utils._);

    var _$2 = nsGmx$1.Utils._;
    /**
    * @namespace DrawingObjects
    * @description SDK для редактирования объектов на карте
    */

    nsGmx$1.Translations.addText('rus', {
      drawingObjects: {
        editStyleTitle: 'Редактировать стиль',
        removeObject: 'Удалить',
        pointTitle: 'точка',
        lineTitle: 'линия',
        polygonTitle: 'многоугольник',
        rectangleTitle: 'прямоугольник',
        removeAll: 'Очистить',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Введите имя файла для скачивания',
        download: 'Скачать файл',
        downloadRaster: 'Скачать фрагмент растра',
        noRectangleError: 'Выберите область рамкой на карте',
        noRasterError: 'К прямоугольнику не подходит ни одного растрового слоя',
        edit: {
          border: 'Граница',
          color: 'Цвет',
          transparency: 'Прозрачность',
          lineWidth: 'Толщина линии',
          description: 'Описание',
          title: 'Редактирование стиля объекта'
        }
      }
    });
    nsGmx$1.Translations.addText('eng', {
      drawingObjects: {
        editStyleTitle: 'Edit style',
        removeObject: 'Delete',
        pointTitle: 'point',
        lineTitle: 'line',
        polygonTitle: 'polygon',
        rectangleTitle: 'rectangle',
        removeAll: 'Delete',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Enter file name to download',
        download: 'Download file',
        downloadRaster: 'Download fragment of raster',
        noRectangleError: 'Select region using frame',
        noRasterError: 'No one raster layer fit the rectangle',
        edit: {
          border: 'Outline',
          color: 'Color',
          transparency: 'Transparency',
          lineWidth: 'Line thickness',
          description: 'Description',
          title: 'Object style editing'
        }
      }
    });

    var setDrawingFeatureStyle = function setDrawingFeatureStyle(drawingFeature, templateStyle) {
      var color = '#' + L.gmxUtil.dec2hex(templateStyle.outline.color),
          opacity = templateStyle.outline.opacity / 100;
      drawingFeature.setOptions({
        lineStyle: {
          color: color,
          opacity: opacity,
          weight: templateStyle.outline.thickness
        },
        pointStyle: {
          color: color,
          opacity: opacity
        }
      });
    };

    var CreateDrawingStylesEditorIcon = function CreateDrawingStylesEditorIcon(style, type) {
      var icon = nsGmx$1.Controls.createGeometryIcon(style, type);

      _title(icon, _gtxt('drawingObjects.editStyleTitle'));

      return icon;
    };

    var CreateDrawingStylesEditor = function CreateDrawingStylesEditor(parentObject, style, elemCanvas) {
      var templateStyle = {};
      var jQueryDialog = null;
      $.extend(true, templateStyle, style);

      elemCanvas.onclick = function () {
        if (jQueryDialog) {
          return;
        }

        var canvas = _div(null, [['css', 'marginTop', '10px']]),
            outlineParent = _tr(),
            outlineTitleTds = [],
            outlineTds = [];

        outlineTitleTds.push(_td([_t(_gtxt('drawingObjects.edit.border'))], [['css', 'width', '70px']]));
        var outlineColor = nsGmx$1.Controls.createColorPicker(templateStyle.outline.color, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex) {
          outlineColor.style.backgroundColor = '#' + hex;
          templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);
          $(elemCanvas).find(".borderIcon")[0].style.borderColor = '#' + hex;
          setDrawingFeatureStyle(parentObject, templateStyle);
        });
        outlineColor.hex = templateStyle.outline.color;

        _title(outlineColor, _gtxt('drawingObjects.edit.color'));

        outlineTds.push(_td([outlineColor], [['css', 'width', '40px']]));
        var divSlider = nsGmx$1.Controls.createSlider(templateStyle.outline.opacity, function (event, ui) {
          templateStyle.outline.opacity = ui.value;
          setDrawingFeatureStyle(parentObject, templateStyle);
        });

        _title(divSlider, _gtxt('drawingObjects.edit.transparency'));

        outlineTds.push(_td([divSlider], [['css', 'width', '100px'], ['css', 'padding', '4px 5px 3px 5px']]));

        var outlineThick = nsGmx$1.Controls.createInput(templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined' ? templateStyle.outline.thickness : 2, function () {
          templateStyle.outline.thickness = Number(this.value);
          setDrawingFeatureStyle(parentObject, templateStyle);
          return true;
        }),
            closeFunc = function closeFunc() {
          var newIcon = CreateDrawingStylesEditorIcon(templateStyle, parentObject.toGeoJSON().geometry.type.toLowerCase());
          CreateDrawingStylesEditor(parentObject, templateStyle, newIcon);
          $(elemCanvas).replaceWith(newIcon);
          $(canvas).find(".colorSelector").each(function () {
            $('#' + $(this).data("colorpickerId")).remove();
          });
        };

        _title(outlineThick, _gtxt('drawingObjects.edit.lineWidth'));

        outlineTds.push(_td([outlineThick], [['css', 'width', '30px']]));

        _$2(outlineParent, outlineTitleTds.concat(_td([_div([_table([_tbody([_tr(outlineTds)])])], [['attr', 'fade', true]])])));

        var text = _input(null, [['attr', 'value', parentObject.options.title || ""], ['dir', 'className', 'inputStyle'], ['css', 'width', '180px']]);

        $(text).on('keyup', function (evt) {
          if (evt.keyCode === 13) {
            $(jQueryDialog).dialog('destroy');
            return;
          }

          parentObject.setOptions({
            title: this.value
          });
          $(parentObject).triggerHandler('onEdit', [parentObject]);
          return true;
        });

        _$2(canvas, [_table([_tbody([_tr([_td([_t(_gtxt('drawingObjects.edit.description'))], [['css', 'width', '70px']]), _td([text])])])]), _br(), _table([_tbody([outlineParent])])]);

        var pos = nsGmx$1.Utils.getDialogPos(elemCanvas, false, 80);
        jQueryDialog = showDialog(_gtxt('drawingObjects.edit.title'), canvas, 280, 130, pos.left, pos.top, false, closeFunc);
        $(jQueryDialog).addClass('drawing-object-leaflet-id-' + parentObject._leaflet_id);
      };

      elemCanvas.getStyle = function () {
        return templateStyle;
      };
    };
    /** Конструктор
     @class Коллекция нарисованных объектов
     @memberOf DrawingObjects
     @param oInitMap Карта, из которой будут добавляться объекты в коллекцию
    */


    var DrawingObjectCollection = function DrawingObjectCollection() {
      var _objects = []; //{item:, editID: , removeID: }

      var _this = this;

      var onEdit = function onEdit(drawingObject) {
        /** Вызывается при изменении объекта в коллекции
        @name DrawingObjects.DrawingObjectCollection.onEdit
        @event
        @param {drawingObject} drawingObject изменённый объект*/
        $(_this).triggerHandler('onEdit', [drawingObject]);
      };

      var onRemove = function onRemove(drawingObject) {
        _this.Remove(drawingObject);
      };
      /** Возвращает элемент по номеру
      @param {int} index № объекта в коллекции*/


      this.Item = function (index) {
        return _objects[index].item;
      };
      /** Возвращает количество элементов в коллекции*/


      this.Count = function () {
        return _objects.length;
      };
      /** Добавляет объект в коллекцию
      @param {drawingObject} drawingObject Добавляемый объект*/


      this.Add = function (drawingObject) {
        var editID = drawingObject.on('edit', function () {
          onEdit(drawingObject);
        });
        var removeID = drawingObject.on('remove', function () {
          onRemove(drawingObject);
        });

        _objects.push({
          item: drawingObject,
          editID: editID,
          removeID: removeID
        });
        /** Вызывается при добавлении объекта в коллекцию
        @name DrawingObjects.DrawingObjectCollection.onAdd
        @event
        @param {drawingObject} drawingObject добавленный объект*/


        $(this).triggerHandler('onAdd', [drawingObject]);
      };
      /** Удаляет объект из коллекции
      @param {int} index индекс удаляемого объекта*/


      this.RemoveAt = function (index) {
        /** Вызывается при удалении объекта из коллекции
        @name DrawingObjects.DrawingObjectCollection.onRemove
        @event
        @param {int} index индекс удаляённого объекта*/
        $(this).triggerHandler('onRemove', [index]);
      };
      /** Удаляет объект из коллекции
      @param {drawingObject} drawingObject удаляемый объект*/


      this.Remove = function (drawingObject) {
        for (var i = 0; i < _objects.length; i++) {
          if (_objects[i].item === drawingObject) this.RemoveAt(i);
        }
      };
      /** Получить индекс объекта в коллекции. null, если объект не найден
      @param {drawingObject} drawingObject объект, индекс которого мы хотим найти*/


      this.getIndex = function (drawingObject) {
        for (var i = 0; i < _objects.length; i++) {
          if (_objects[i].item === drawingObject) return i;
        }

        return null;
      };
    };
    /** Конструктор
     @class Строка с описанием объекта и ссылкой на него
     @description К строке биндится контекстное меню типа "DrawingObject"
     @memberOf DrawingObjects
     @param {L.Map} oInitMap Карта Leaflet
     @param oInitContainer Объект, в котором находится контрол (div)
     @param drawingObject Объект для добавления на карту
     @param options дополнительные параметры
     @param {bool} [options.allowDelete=true] рисовать ли крестик удаления объекта
     @param {bool} [options.editStyle=true] нужна ли возможность редактировать стили
     @param {function(DrawingObject)} [options.click] ф-ция, которая будет вызвана при клике на объекте.
            По умолчанию - центрирование карты на объекте.
    */


    var DrawingObjectInfoRow = function DrawingObjectInfoRow(oInitMap, oInitContainer, drawingObject, options) {
      var defaultClickFunction = function defaultClickFunction(obj) {
        var geom = obj.toGeoJSON().geometry;
        var coords = geom.coordinates;

        if (geom.type == "Point") {
          _map.setView([coords[1], coords[0]], Math.max(14, _map.getZoom()));
        } else {
          _map.fitBounds(drawingObject.getBounds());
        }
      };

      var _options = $.extend({
        allowDelete: true,
        editStyle: true,
        click: defaultClickFunction
      }, options);

      var _drawingObject = drawingObject;

      var _this = this;

      var _map = oInitMap;

      var _canvas = _div(null, [['dir', 'className', 'drawingObjectsItemCanvas']]);

      var _title = _span(null, [['dir', 'className', 'drawingObjectsItemTitle']]);

      var _text = _span(null, [['dir', 'className', 'drawingObjectsItemTitle']]);

      var _summary = _span(null, [['dir', 'className', 'summary']]);

      if (_options.click) {
        _canvas.onclick = function (e) {
          if (e.target !== remove && (!_options.editStyle || e.target !== icon)) {
            _options.click(_drawingObject);
          }
        };
      }

      var lineOptions = _drawingObject.options.lineStyle || L.GmxDrawing.utils.defaultStyles.lineStyle;
      var icon = null;

      var geom = _drawingObject.toGeoJSON().geometry;

      if (_options.editStyle) {
        if (geom.type == "Point") {
          icon = _img(null, [['attr', 'src', (window.gmxJSHost || '') + 'img/flag_min.png'], ['dir', 'className', 'colorIcon']]);
        } else {
          var regularDrawingStyle = {
            outline: {
              color: parseInt('0x' + lineOptions.color.split('#')[1]),
              thickness: lineOptions.weight,
              opacity: lineOptions.opacity * 100
            }
          };
          icon = CreateDrawingStylesEditorIcon(regularDrawingStyle, geom.type.toLowerCase());
          CreateDrawingStylesEditor(_drawingObject, regularDrawingStyle, icon);
        }
      } else icon = _span(null, [['dir', 'className', geom.type + (L.gmxUtil.isRectangle(geom.coordinates) ? ' RECTANGLE' : '')]]);

      var remove = _span();

      if (_options.allowDelete) {
        remove.setAttribute('title', _gtxt('drawingObjects.removeObject'));
        remove.className = 'gmx-icon-close';

        remove.onclick = function () {
          $(_this).triggerHandler('onRemove', [_drawingObject]);
        };
      }

      _$2(_canvas, [_span([icon, _title, _text, _summary], [['dir', 'className', 'drawingObjectsItem']]), remove]);

      _$2(oInitContainer, [_canvas]);

      this._mouseOverHandler = function () {
        $(_canvas).addClass('drawingObjectsActiveItemCanvas');
      };

      this._mouseOutHandler = function () {
        $(_canvas).removeClass('drawingObjectsActiveItemCanvas');
      };

      _drawingObject.on('mouseover', this._mouseOverHandler);

      _drawingObject.on('mouseout', this._mouseOutHandler);
      /** Обновляет информацию о геометрии */


      this.UpdateRow = function () {
        var summary = _drawingObject.getSummary(),
            text = _drawingObject.options.title,
            type = _drawingObject.getType();

        $(_title).empty();
        $(_text).empty();
        $(_summary).empty();

        if (type === 'Point') {
          _$2(_title, [_t(_gtxt('drawingObjects.pointTitle'))]);

          _$2(_summary, [_t("(" + summary + ")")]);
        } else if (type === 'Polyline' || type === 'MultiPolyline') {
          _$2(_title, [_t(_gtxt('drawingObjects.lineTitle'))]);

          _$2(_summary, [_t("(" + summary + ")")]);
        } else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle') {
          _$2(_title, [_t(type === 'Rectangle' ? _gtxt('drawingObjects.rectangleTitle') : _gtxt('drawingObjects.polygonTitle'))]);

          _$2(_summary, [_t("(" + summary + ")")]);
        }

        _$2(_text, [_t(text ? text.replace(/<[^<>]*>/g, " ") : "")]);

        if (text) _title.style.display = 'none';else _title.style.display = '';
      };
      /** Удаляет строчку */


      this.RemoveRow = function () {
        if (_canvas.parentNode) _canvas.parentNode.removeChild(_canvas);
        if (_drawingObject === null) return;

        _drawingObject.off('edit', this.UpdateRow);

        _drawingObject.off('remove', this.RemoveRow);

        _drawingObject.off('mouseover', this._mouseOverHandler);

        _drawingObject.off('mouseout', this._mouseOutHandler);

        _drawingObject = null;
      };
      /** Удаляет строчку */


      this.getContainer = function () {
        return _canvas;
      };

      if (nsGmx$1 && nsGmx$1.ContextMenuController) {
        nsGmx$1.ContextMenuController.bindMenuToElem(_title, 'DrawingObject', function () {
          return true;
        }, {
          obj: _drawingObject
        });
      }

      this.getDrawingObject = function () {
        return _drawingObject;
      };

      _drawingObject.on('edit', this.UpdateRow);

      _drawingObject.on('remove', this.RemoveRow);

      this.UpdateRow();
    };
    /** Конструктор
     @class Контрол для отображения коллекции пользовательских объектов
     @memberOf DrawingObjects
     @param oInitMap Карта
     @param {documentElement} oInitContainer Объект, в котором находится контрол (div)
     @param {DrawingObjects.DrawingObjectCollection} oInitDrawingObjectCollection Коллекция пользовательских объектов
     @param {Object} options Дополнительные параметры.Включает все доп. параметры DrawingObjectInfoRow
     @param {bool} [options.showButtons=true] показывать ли кнопки под списком
     @param {selectedIndex} [options.selectedIndex=null] индекс выбранного элемента
    */


    var DrawingObjectList = function DrawingObjectList(oInitMap, oInitContainer, oInitDrawingObjectCollection, options) {
      var _options = $.extend({
        showButtons: true,
        selectedIndex: null
      }, options);

      var _this = this;

      var _rows = [];
      var _containers = [];
      var _map = oInitMap;
      var _collection = oInitDrawingObjectCollection;

      var _divList = _div(null, [['dir', 'className', 'DrawingObjectList']]);

      var _divButtons = _div();
      /** Добавляет объект в "список объектов на карте"
      @param {drawingObject} drawingObject добавляемый объект */


      var add = function add(drawingObject) {
        var divRow = _div();

        _$2(_divList, [divRow]);

        var row = new DrawingObjectInfoRow(_map, divRow, drawingObject, options);

        _containers.push(divRow);

        _rows.push(row);

        $(row).bind('onRemove', function () {
          drawingObject.remove();
        });
        if (_collection.Count() == 1 && _options.showButtons) show(_divButtons);
        /** В списке мышь переместилась над объект
        @name DrawingObjects.DrawingObjectList.mouseover
        @event
        @param {drawingObject} drawingObject объект, над которым находится мышь*/

        /** В списке мышь переместилась с объекта
        @name DrawingObjects.DrawingObjectList.mouseout
        @event
        @param {drawingObject} drawingObject объект, с которого переместилась мышь*/

        $(divRow).bind({
          mouseover: function mouseover() {
            $(_this).triggerHandler('mouseover', [drawingObject]);
          },
          mouseout: function mouseout() {
            $(_this).triggerHandler('mouseout', [drawingObject]);
          }
        });
      };

      var onRemove = function onRemove(event, index) {
        if (_collection.Count() == 0) hide(_divButtons);

        var removedDiv = _containers.splice(index, 1)[0];

        _rows.splice(index, 1);

        removedDiv.parentNode && removedDiv.parentNode.removeChild(removedDiv);

        if (index === _selectedIndex) {
          _selectedIndex = null;
        } else if (index < _selectedIndex) {
          _selectedIndex--;
        }
      };

      $(_collection).bind('onRemove', onRemove);
      $(_collection).bind('onAdd', function (event, drawingObject) {
        add(drawingObject);
      });

      for (var i = 0; i < _collection.Count(); i++) {
        add(_collection.Item(i));
      }
      /** Очищает список пользовательских объектов*/


      this.Clear = function () {
        while (_collection.Count() > 0) {
          _collection.Item(0).remove();
        }

        _selectedIndex = null;
      };
      /** Возвращает div, в котором находится кнопка "Очистить" и который не виден при пустой коллекции */


      this.GetDivButtons = function () {
        return _divButtons;
      };

      var delAll = makeLinkButton(_gtxt('drawingObjects.removeAll'));
      delAll.onclick = this.Clear;

      _$2(_divButtons, [_div([delAll])]);

      _$2(oInitContainer, [_divList, _divButtons]);

      if (_collection.Count() == 0 || !_options.showButtons) hide(_divButtons);
      var _selectedIndex = null;
      /** Устанавливает выбранный элемент списка пользовательских объектов.
          null - нет активного. Неправильные индексы игнорируются. К контейнеру выбранного элемента добавляется класс drawingObjectsSelectedItemCanvas
      */

      this.setSelection = function (selectedIndex) {
        var isValidIndex = !!_rows[selectedIndex] || selectedIndex === null;

        if (selectedIndex === _selectedIndex || !isValidIndex) {
          return _selectedIndex;
        }

        if (_rows[_selectedIndex]) {
          $(_rows[_selectedIndex].getContainer()).removeClass('drawingObjectsSelectedItemCanvas');
        }

        if (_rows[selectedIndex]) {
          $(_rows[selectedIndex].getContainer()).addClass('drawingObjectsSelectedItemCanvas');
        }

        _selectedIndex = selectedIndex;
        return _selectedIndex;
      };
      /** Возвращает индекс выбранного элемента списка пользовательских объектов, null - если нет выбранного*/


      this.getSelection = function () {
        return _selectedIndex;
      };

      this.setSelection(_options.selectedIndex);
    };
    /** Конструктор
     @memberOf DrawingObjects
     @class Встраивает список объектов на карте в геомиксер*/


    var DrawingObjectGeomixer = function DrawingObjectGeomixer() {
      var _this = this;

      var oMap = null;
      var gmxMap = null;
      var oMenu = new leftMenu();

      var oListDiv = _div(null, [['dir', 'className', 'DrawingObjectsLeftMenu']]);

      var bVisible = false;
      var oCollection = null;
      /** Вызывается при скрывании меню*/

      this.Unload = function () {
        bVisible = false;
      };
      /** Загружает меню*/


      this.Load = function () {
        if (oMenu != null) {
          var alreadyLoaded = oMenu.createWorkCanvas("DrawingObjects", this.Unload);
          if (!alreadyLoaded) _$2(oMenu.workCanvas, [oListDiv]);
        }

        bVisible = true;
      };

      var fnAddToCollection = function fnAddToCollection(ev) {
        var feature = ev.object;

        if (!nsGmx$1.DrawingObjectCustomControllers || !nsGmx$1.DrawingObjectCustomControllers.isHidden(feature)) {
          oCollection.Add(feature);
        }
      };

      var checkDownloadVisibility = function checkDownloadVisibility() {
        var isAnyRectangle = false,
            isNonPolygon = false;

        for (var i = 0; i < oCollection.Count(); i++) {
          var feature = oCollection.Item(i);
          var geom = feature.toGeoJSON().geometry;
          isAnyRectangle = isAnyRectangle || L.gmxUtil.isRectangle(geom.coordinates);
          isNonPolygon = isNonPolygon || geom.type !== 'Polygon';
        }

        $(downloadContainer).toggle(oCollection.Count() > 0);
        $(downloadRaster).toggle(gmxMap.properties.CanDownloadRasters && isAnyRectangle);
        $(downloadGpx).toggle(isNonPolygon);
      };

      var downloadFormat = null;
      var downloadShp = makeLinkButton(_gtxt('drawingObjects.downloadShp'));

      downloadShp.onclick = function () {
        downloadFormat = 'Shape';
        downloadNameContainer.toggle();
      };

      downloadShp.style.margin = '0px 3px';
      var downloadGeoJSON = makeLinkButton(_gtxt('drawingObjects.downloadGeoJSON'));

      downloadGeoJSON.onclick = function () {
        downloadFormat = 'GeoJSON';
        downloadNameContainer.toggle();
      };

      downloadGeoJSON.style.margin = '0px 3px';
      var downloadGpx = makeLinkButton(_gtxt('drawingObjects.downloadGpx'));

      downloadGpx.onclick = function () {
        downloadFormat = 'gpx';
        downloadNameContainer.toggle();
      };

      downloadGpx.style.margin = '0px 3px';
      var downloadCsv = makeLinkButton(_gtxt('drawingObjects.downloadCsv'));

      downloadCsv.onclick = function () {
        downloadFormat = 'csv_wkt';
        downloadNameContainer.toggle();
      };

      downloadCsv.style.margin = '0px 3px';
      var downloadNameInput = $('<input/>', {
        title: _gtxt('drawingObjects.downloadNameTitle')
      }).val('markers').addClass('inputStyle');
      downloadNameInput.keyup(function (e) {
        if (e.keyCode == 13) {
          downloadNameButton.click();
        }
      });
      var downloadNameButton = $('<input/>', {
        type: 'button'
      }).val(_gtxt('drawingObjects.download')).addClass('btn').click(function () {
        downloadMarkers(downloadNameInput.val(), downloadFormat);
        downloadNameContainer.hide();
        downloadFormat = null;
      });
      var downloadNameContainer = $('<div/>').append(downloadNameInput, downloadNameButton).hide();
      var downloadRasterOptions = $('<div class="drawingObjectsDownloadRaster">' + '<label><input type="radio" name="rasterFormat" checked value="univers">jpeg + georefernce</label>' + '<label><input type="radio" name="rasterFormat" value="garmin">kmz (Garmin Custom Maps)</label>' + '<button id="downloadRaster" class="btn">' + _gtxt('drawingObjects.download') + '</button>' + '</div>').hide();
      $('#downloadRaster', downloadRasterOptions).click(function () {
        var checkInfo = checkRasterLayer();

        if (checkInfo) {
          var bounds = checkInfo.bounds,
              layer = checkInfo.layer,
              format = $('input:checked', downloadRasterOptions).val(),
              temporalParam = "",
              props = layer.getGmxProperties();

          if (props.Temporal) {
            var dateInterval = layer.getDateInterval();

            if (dateInterval) {
              var dateBeginStr = nsGmx$1.Utils.convertFromServer('date', dateInterval.beginDate / 1000),
                  dateEndStr = nsGmx$1.Utils.convertFromServer('date', dateInterval.endDate / 1000);
              temporalParam = "&StartDate=" + encodeURIComponent(dateBeginStr) + "&EndDate=" + encodeURIComponent(dateEndStr);
            }
          }

          var truncate9 = function truncate9(x) {
            return ("" + x).substring(0, 9);
          };

          window.location.href = window.location.protocol + "//" + props.hostName + "/DownloadLayer.ashx" + "?t=" + props.name + "&MinX=" + truncate9(bounds.getWest()) + "&MinY=" + truncate9(bounds.getSouth()) + "&MaxX=" + truncate9(bounds.getEast()) + "&MaxY=" + truncate9(bounds.getNorth()) + "&Format=" + format + temporalParam;
        }
      });
      var downloadRaster = makeLinkButton(_gtxt('drawingObjects.downloadRaster'));

      downloadRaster.onclick = function () {
        if (downloadRasterOptions.find(':visible').length || checkRasterLayer()) {
          downloadRasterOptions.toggle();
        }
      };

      var downloadContainer = _div();
      /** Встраивает список объектов на карте в геомиксер*/


      this.Init = function (leafletMap, initGmxMap) {
        oMap = leafletMap;
        gmxMap = initGmxMap;
        oCollection = new DrawingObjectCollection(leafletMap);
        $(oCollection).bind('onAdd', function () {
          if (!bVisible) _this.Load();
        });
        $(oCollection).bind('onRemove', function () {
          oCollection.Count() || oMenu.leftPanelItem.close();
        });
        var lmap = nsGmx$1.leafletMap,
            gmxDrawing = lmap.gmxDrawing,
            features = gmxDrawing.getFeatures();
        features.map(function (ret) {
          fnAddToCollection(ret);
        });
        lmap.gmxDrawing.on('add', fnAddToCollection);
        $(oCollection).bind('onRemove onAdd', checkDownloadVisibility);
        var oDrawingObjectList = new DrawingObjectList(oMap, oListDiv, oCollection);

        _$2(downloadContainer, [_div([_span([_t(_gtxt('drawingObjects.download'))], [['css', 'fontSize', '12px']]), downloadShp, downloadGeoJSON, downloadGpx, downloadCsv]), downloadNameContainer[0], _div([downloadRaster]), downloadRasterOptions[0]]);

        _$2(oDrawingObjectList.GetDivButtons(), [downloadContainer]);

        checkDownloadVisibility();
      };
      /** Скачивает shp файл*/


      var downloadMarkers = function downloadMarkers(fileName, format) {
        var geoms = [];

        for (var i = 0; i < oCollection.Count(); i++) {
          geoms.push(oCollection.Item(i).toGeoJSON());
        }

        nsGmx$1.Utils.downloadGeometry(geoms, {
          fileName: fileName,
          format: format
        });
      };
      /** Скачивает растровые слои*/


      var checkRasterLayer = function checkRasterLayer() {
        var obj = false;

        for (var i = 0; i < oCollection.Count(); i++) {
          var elem = oCollection.Item(i);

          if (elem.getType() == 'Rectangle') {
            obj = elem;
          }
        }

        if (!obj) {
          showErrorMessage(_gtxt('drawingObjects.noRectangleError'), true);
          return;
        }

        var bounds = obj.getBounds(),
            center = bounds.getCenter(),
            layer = false;

        var testPolygon = function testPolygon(polygon, latlng) {
          var testRing = function testRing(ring, x, y) {
            var isInside = false;

            for (var j = 0; j < ring.length - 1; j++) {
              var x1 = ring[j][0],
                  y1 = ring[j][1],
                  x2 = ring[j + 1][0],
                  y2 = ring[j + 1][1];
              if (y1 >= y != y2 >= y && x1 + (x2 - x1) * (y - y1) / (y2 - y1) > x) isInside = !isInside;
            }

            return isInside;
          };

          for (var j = 0; j < polygon.length; j++) {
            if (testRing(polygon[j], latlng.lng, latlng.lat) != (j == 0)) return false;
          }

          return true;
        };

        for (var iLayerN = 0; iLayerN < gmxMap.layers.length; iLayerN++) {
          var l = gmxMap.layers[iLayerN],
              props = l.getGmxProperties(),
              layerBounds = l.getBounds && l.getBounds(),
              isProperType = props.type == "Raster" || props.IsRasterCatalog;

          if (isProperType && oMap.hasLayer(l) && layerBounds && layerBounds.isValid() && layerBounds.contains(center)) {
            var geom = l.getGeometry(),
                coords = geom.coordinates,
                bIsPolygonBad = false;

            if (geom.type === "Polygon" && !testPolygon(coords, center)) {
              bIsPolygonBad = true;
            } else if (geom.type == "MultiPolygon") {
              bIsPolygonBad = true;

              for (var k = 0; k < coords.length; k++) {
                if (testPolygon(coords[k], center)) {
                  bIsPolygonBad = false;
                  break;
                }
              }
            }

            if (!bIsPolygonBad && l && (!layer || props.MaxZoom > layer.getGmxProperties().MaxZoom)) {
              layer = l;
            }
          }
        }

        if (!layer) {
          showErrorMessage(_gtxt('drawingObjects.noRasterError'), true);
          return;
        }

        return {
          bounds: bounds,
          layer: layer
        };
      };
    };

    var publicInterface = {
      DrawingObjectCollection: DrawingObjectCollection,
      DrawingObjectInfoRow: DrawingObjectInfoRow,
      DrawingObjectList: DrawingObjectList,
      DrawingObjectGeomixer: DrawingObjectGeomixer
    };
    window.gmxCore.addModule("DrawingObjects", publicInterface);

    (function (_) {
      //params:
      //  properties - свойства слоя по умолчанию
      //  layers - список слоёв по умолчанию
      var createMultiLayerEditorNew = function createMultiLayerEditorNew(layersTree, params) {
        params = params || {};
        doCreateMultiLayerEditor(params.properties || {}, params.layers || [], null, layersTree);
      }; //получает с сервера информацию о мультислое и рисует диалог редактирования его настроек


      var createMultiLayerEditorServer = function createMultiLayerEditorServer(elemProperties, div, layersTree) {
        sendCrossDomainJSONRequest(window.serverBase + "MultiLayer/GetMultiLayerFullInfo.ashx?MultiLayerID=" + elemProperties.MultiLayerID, function (response) {
          if (!parseResponse(response)) return;
          var elemPropertiesFull = $.extend(true, response.Result.Properties, elemProperties);
          doCreateMultiLayerEditor(elemPropertiesFull, response.Result.Layers, div, layersTree);
        });
      };

      var doCreateMultiLayerEditor = function doCreateMultiLayerEditor(elemProperties, layers, div, layersTree) {
        var isReadonly = div && _queryMapLayers.layerRights(div.gmxProperties.content.properties.name) !== 'edit';

        var commonLayersListDiv = _div(null, [['css', 'height', '100%'], ['css', 'width', '100%']]);

        var selectedLayersDiv = _div(null, [['css', 'height', '100%'], ['css', 'margin', '10px 0px 0px 0px']]);

        var selectedLayersTable = new nsGmx$1.ScrollTable({
          height: div ? 255 : 280
        });

        if (!isReadonly) {
          var suggestLayersControl = new nsGmx$1.LayerManagerControl(commonLayersListDiv, 'multilayers', {
            fixType: ['raster', 'catalog'],
            enableDragging: false,
            onclick: function onclick(context) {
              selectedLayersTable.getDataProvider().addOriginalItem(context.elem);
              suggestLayersControl.disableLayers(context.elem.name);
            }
          });
        }

        var uiSelectedRowTemplate = Handlebars.compile('<tr>' + '<td><div class="gmx-icon-{{iconClass}}"></div></td>' + '<td><div class="multilayer-row-title-outer"><div class="multilayer-row-title-inner" title="{{title}}">{{title}}</div></div></td>' + '{{#unless isReadonly}}' + '<td><div class="gmx-icon-downtriangle"></div></td>' + '<td><div class="gmx-icon-uptriangle"></div></td>' + '<td class="multilayer-row-td"><div class="gmx-icon-recycle"></div></td>' + '{{/unless}}' + '</tr>');
        selectedLayersTable.createTable(selectedLayersDiv, 'selectedLayersTables', 0, isReadonly ? [_gtxt("Тип"), _gtxt("Имя")] : [_gtxt("Тип"), _gtxt("Имя"), "", "", ""], isReadonly ? ['5%', '95%'] : ['5%', '80%', '5%', '5%', '5%'], function (layer) {
          var ui = $(uiSelectedRowTemplate({
            title: layer.title,
            iconClass: layer.type == "Vector" ? 'vector' : 'raster',
            isReadonly: isReadonly
          }));

          var _this = this;

          ui.find('.gmx-icon-recycle').click(function () {
            _this.getDataProvider().filterOriginalItems(function (elem) {
              return elem.LayerID != layer.LayerID;
            });

            suggestLayersControl.enableLayers(layer.name);
          });
          ui.find('.gmx-icon-downtriangle').click(function () {
            var vals = _this.getDataProvider().getOriginalItems();

            for (var i = 0; i < vals.length - 1; i++) {
              if (vals[i].LayerID === layer.LayerID) {
                vals.splice(i, 1);
                vals.splice(i + 1, 0, layer);

                _this.getDataProvider().setOriginalItems(vals);

                break;
              }
            }
          });
          ui.find('.gmx-icon-uptriangle').click(function () {
            var vals = _this.getDataProvider().getOriginalItems();

            for (var i = 1; i < vals.length; i++) {
              if (vals[i].LayerID === layer.LayerID) {
                vals.splice(i, 1);
                vals.splice(i - 1, 0, layer);

                _this.getDataProvider().setOriginalItems(vals);

                break;
              }
            }
          });
          ui.children().each(function (i, elem) {
            elem.style.width = _this._fields[i].width;
          });
          return ui[0];
        }, {});
        selectedLayersTable.getDataProvider().setOriginalItems(layers);

        var propertiesDiv = _div(null, [['css', 'width', '100%'], ['css', 'height', '100%']]);

        var shownProperties = [];

        var title = _input(null, [['attr', 'fieldName', 'title'], ['attr', 'value', elemProperties.title || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

        var isCreatedDrawing = false;

        title.onkeyup = function () {
          if (div) {
            var span = $(div).find(".layer")[0];
            $(span).empty();

            _(span, [_t(title.value)]);

            div.gmxProperties.content.properties.title = title.value;
            layersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
          }

          return true;
        };

        var descr = _textarea(null, [['attr', 'fieldName', 'description'], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px'], ['css', 'height', '50px']]);

        descr.value = elemProperties.description || '';

        descr.onkeyup = function () {
          if (div) {
            var span = $(div).find(".layerDescription")[0];
            $(span).empty();
            span.innerHTML = descr.value;
            div.gmxProperties.content.properties.description = descr.value;
            layersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
          }

          return true;
        };

        var borderContainer = _div(),
            shpContainer = _div(null, [['css', 'display', 'none'], ['css', 'margin', '3px']]),
            borderLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
            shpBorderLink = makeImageButton("img/choose2.png", "img/choose2_a.png");

        var borderTr = _tr([_td([_t(_gtxt("Граница")), borderLink, _br(), _t(_gtxt("Из файла")), shpBorderLink], [['css', 'paddingLeft', '5px'], ['css', 'fontSize', '12px']]), _td([borderContainer, shpContainer])]); // var multiObj = null;


        var fileInput = _input(null, [['attr', 'type', 'file'], ['attr', 'name', 'file'], ['attr', 'id', 'upload_shapefile']]);

        fileInput.onchange = function () {
          if (this.value === "") return;
          nsGmx$1.Utils.parseShpFile(postForm).done(function (objs) {
            if (objs.length == 0) {
              showErrorMessage(_gtxt("Загруженный shp-файл пуст"), true);
              return;
            }

            var joinedPolygon = nsGmx$1.Utils.joinPolygons(nsGmx$1._.pluck(objs, 'geometry'));

            if (!joinedPolygon) ; else {
              isCreatedDrawing = true;
              bindPolygon(nsGmx$1.leafletMap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(joinedPolygon))[0]);
            }

            $(borderContainer).show();
            $(shpContainer).hide();
          });
        }; //задаём одновременно и enctype и encoding для корректной работы в IE


        var postForm = _form([fileInput], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);

        $(shpContainer).append(postForm);

        var bindPolygon = function bindPolygon(polygon) {
          $(borderContainer).show();
          $(shpContainer).hide();
          geometryInfoRow && geometryInfoRow.RemoveRow();
          var InfoRow = DrawingObjectInfoRow;
          geometryInfoRow = new InfoRow(nsGmx$1.leafletMap, borderContainer, polygon, {
            editStyle: false
          });
          $(geometryInfoRow).bind('onRemove', function () {
            if (isCreatedDrawing) geometryInfoRow.getDrawingObject().remove();else geometryInfoRow.RemoveRow();
            isCreatedDrawing = false;
            geometryInfoRow = null;
          });
        };

        var geometryInfoRow = null;
        borderLink.style.marginLeft = '3px';
        shpBorderLink.style.marginLeft = '3px';

        borderLink.onclick = function () {
          nsGmx$1.Controls.chooseDrawingBorderDialog('_MultilayerDialog', bindPolygon, {
            geomType: 'POLYGON',
            errorMessage: _gtxt("$$phrase$$_17")
          });
        };

        shpBorderLink.onclick = function () {
          $(borderContainer).hide();
          $(shpContainer).show();
        };

        if (elemProperties.UserBorder) {
          isCreatedDrawing = true;
          bindPolygon(nsGmx$1.leafletMap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(elemProperties.UserBorder, true))[0]);
        }

        shownProperties.push({
          name: _gtxt("Имя"),
          field: 'Title',
          elem: title
        });
        shownProperties.push({
          name: _gtxt("Описание"),
          field: 'Description',
          elem: descr
        });
        div && shownProperties.push({
          name: _gtxt("ID"),
          field: 'Name'
        });
        isReadonly || shownProperties.push({
          tr: borderTr
        });

        var trs = _mapHelper.createPropertiesTable(shownProperties, elemProperties, {
          leftWidth: 70
        });

        _(propertiesDiv, [_table([_tbody(trs)], [['dir', 'className', 'propertiesTable']])]);

        var getUserBorder = function getUserBorder() {
          if (geometryInfoRow && geometryInfoRow.getDrawingObject()) {
            return L.gmxUtil.geoJSONtoGeometry(geometryInfoRow.getDrawingObject().toGeoJSON().geometry, true);
          } else {
            return null;
          }
        };

        var isCreate = div === null;
        var saveButton;

        if (isReadonly) {
          saveButton = _div([_t(_gtxt("Недостаточно прав для редактирования настроек слоя"))], [['css', 'color', 'red']]);
        } else {
          saveButton = makeLinkButton(isCreate ? _gtxt("Создать") : _gtxt("Изменить"));

          saveButton.onclick = function () {
            var errorElems = [];
            if (title.value === '') errorElems.push(title);
            if (!selectedLayersTable.getDataProvider().getOriginalItems().length) errorElems.push(selectedLayersDiv);

            for (var i = 0; i < errorElems.length; i++) {
              inputError(errorElems[i], 2000);
            }

            if (errorElems.length) return;
            var layers = [];
            var selectedItems = selectedLayersTable.getDataProvider().getOriginalItems();

            for (var l = 0; l < selectedItems.length; l++) {
              layers.push({
                LayerID: selectedItems[l].LayerID
              });
            }

            var updateInfo = {
              Properties: {
                MultiLayerID: elemProperties.MultiLayerID,
                Title: title.value,
                Description: descr.value,
                WMSAccess: false,
                UserBorder: getUserBorder()
              },
              Layers: layers,
              LayersChanged: true
            };
            var scriptName = isCreate ? "Insert.ashx" : "Update.ashx";
            sendCrossDomainPostRequest(window.serverBase + "MultiLayer/" + scriptName, {
              WrapStyle: 'window',
              MultiLayerInfo: JSON.stringify(updateInfo)
            }, function (response) {
              if (!parseResponse(response)) return;
              var layerDiv = null;

              if (!isCreate) {
                layerDiv = $(_queryMapLayers.buildedTree).find("[MultiLayerID='" + response.Result.properties.MultiLayerID + "']")[0];
              }

              var newLayerProperties = $.extend(true, response.Result.properties, {
                mapName: layersTree.treeModel.getMapProperties().name,
                hostName: layersTree.treeModel.getMapProperties().hostName,
                visible: isCreate ? true : layerDiv.gmxProperties.content.properties.visible,
                styles: isCreate ? [{
                  MinZoom: response.Result.properties.MinZoom,
                  MaxZoom: response.Result.properties.MaxZoom
                }] : layerDiv.gmxProperties.content.properties.styles
              });
              var layerData = {
                type: 'layer',
                content: {
                  properties: newLayerProperties,
                  geometry: response.Result.geometry
                }
              };
              if (!isCreate) _queryMapLayers.removeLayer(newLayerProperties.name);

              _layersTree.addLayersToMap(layerData);

              var divParent = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0];

              var li = _layersTree.getChildsList(layerData, divParent.gmxProperties, false, true);

              if (isCreate) {
                window._abstractTree.addNode(_queryMapLayers.buildedTree.firstChild, li);

                layersTree.addTreeElem(divParent, 0, layerData);
              } else {
                $(layerDiv.parentNode).replaceWith(li);
                _layersTree.findTreeElem($(li).children("div[MultiLayerID]")[0]).elem = layerData;
              }

              geometryInfoRow && geometryInfoRow.getDrawingObject() && geometryInfoRow.getDrawingObject().remove();

              _queryMapLayers.addSwappable(li);

              _queryMapLayers.addDraggable(li);

              _layersTree.updateListType(li);

              $(jQueryDialog).dialog("destroy");
              jQueryDialog.removeNode(true);
            });
          };
        }

        var divProperties = _div();

        _(divProperties, [_table([_tbody([_tr([_td([_table([_tbody([_tr([_td([propertiesDiv])]), _tr([_td([selectedLayersDiv])])])], [['css', 'width', '100%']])], [['css', 'verticalAlign', 'top'], ['css', 'width', '311px']]), _td([commonLayersListDiv], [['css', 'paddingLeft', '10px']])]), _tr([_td([saveButton], [['attr', 'colSpan', '2']])])])], [['css', 'width', '100%']])], [['attr', 'id', 'properties' + elemProperties.name]]);

        var dialogContainer;

        if (!isCreate) {
          var divStyles = _div(null, [['attr', 'id', 'styles' + elemProperties.name]]);

          var zoomSource = elemProperties.styles && elemProperties.styles[0] || elemProperties;
          var zoomPropertiesControl = new nsGmx$1.ZoomPropertiesControl(zoomSource.MinZoom, zoomSource.MaxZoom),
              liMinZoom = zoomPropertiesControl.getMinLi(),
              liMaxZoom = zoomPropertiesControl.getMaxLi();

          _(divStyles, [_ul([liMinZoom, liMaxZoom])]);

          $(zoomPropertiesControl).change(function () {
            nsGmx$1.gmxMap.layersByID[elemProperties.name].setZoomBounds(this.getMinZoom(), this.getMaxZoom());
            elemProperties.styles = elemProperties.styles || [];
            elemProperties.styles[0] = elemProperties.styles[0] || {};
            elemProperties.styles[0].MinZoom = zoomPropertiesControl.getMinZoom();
            elemProperties.styles[0].MaxZoom = zoomPropertiesControl.getMaxZoom();
            _layersTree.findTreeElem(div).elem.content.properties = elemProperties;
          });
          dialogContainer = _div([_ul([_li([_a([_t(_gtxt("Общие"))], [['attr', 'href', '#properties' + elemProperties.name]])]), _li([_a([_t(_gtxt("Стили"))], [['attr', 'href', '#styles' + elemProperties.name]])])])]);

          _(dialogContainer, [divProperties, divStyles]);

          $(dialogContainer).tabs({
            active: 0
          });
        } else dialogContainer = divProperties;

        var closeFunc = function closeFunc() {
          if (geometryInfoRow && geometryInfoRow.getDrawingObject()) {
            if (isCreatedDrawing) geometryInfoRow.getDrawingObject().remove();else geometryInfoRow.RemoveRow();
            isCreatedDrawing = false;
          }
        };

        if (isReadonly) {
          $(dialogContainer).find('input, textarea').prop('disabled', true);
        }

        var jQueryDialog = showDialog(_gtxt('Мультислой [value0]', elemProperties.title || ''), dialogContainer, isReadonly ? 340 : 900, 530, false, false, null, closeFunc);
      };

      window.gmxCore.addModule('MultiLayerEditor', {
        createMultiLayerEditorServer: createMultiLayerEditorServer,
        createMultiLayerEditorNew: createMultiLayerEditorNew
      });
    })(nsGmx$1.Utils._);

    var _$3 = nsGmx$1.Utils._;
    /** Вспомогательные ф-ции ГеоМиксера
    @namespace _mapHelper
    */

    nsGmx$1.mapHelper = {};
    var mapHelp = {
      mapHelp: {},
      serviceHelp: {},
      tabs: {},
      externalMaps: {}
    };

    var mapHelper = function mapHelper() {
      this.builded = false; //this._treeView = false;

      this.defaultStyles = {
        'point': {
          outline: {
            color: 0x0000FF,
            thickness: 1
          },
          marker: {
            size: 8
          },
          fill: {
            color: 0xFFFFFF,
            opacity: 20
          }
        },
        'linestring': {
          outline: {
            color: 0x0000FF,
            thickness: 1
          }
        },
        'polygon': {
          outline: {
            color: 0x0000FF,
            thickness: 1
          },
          fill: {
            color: 0xFFFFFF,
            opacity: 20
          }
        }
      };
      this.defaultPhotoIconStyles = {
        'point': {
          marker: {
            image: 'api/img/camera18.png',
            center: true
          }
        }
      };
      this.stylesDialogsHash = {};
      this.drawingDialogsHash = {};
      this.layerEditorsHash = {};
      this.layerStylesHash = {};
      this.attrValues = {};
      this.customErrorsHash = {
        "Unable to locate EXIF content": "Unable to locate EXIF content" // контролирует пользовательские объекты, которые являются редактируемыми контурами растровых слоёв.
        // все такие объекты не будут сериализоваться

      };

      this.drawingBorders = function () {
        var _borders = {}; //не будем сериализовать все пользовательские объекты, являющиеся контурами слоёв, так как это временные объекты

        nsGmx$1.DrawingObjectCustomControllers.addDelegate({
          isSerializable: function isSerializable(obj) {
            for (var name in _borders) {
              if (_borders[name] === obj) return false;
            }

            return true;
          }
        });
        return {
          set: function set(name, obj) {
            if (name in _borders) {
              _borders[name].drawingFeature.off('edit', _borders[name].editListener);
            }

            var editListener = function editListener() {
              _borders[name].isChanged = true;
            };

            obj.on('edit', editListener);
            _borders[name] = {
              isChanged: !!_borders[name],
              drawingFeature: obj,
              editListener: editListener
            };
          },
          get: function get(name) {
            return _borders[name] && _borders[name].drawingFeature;
          },
          length: function length() {
            return objLength(_borders);
          },
          //callback(name, obj)
          forEach: function forEach(callback) {
            for (var name in _borders) {
              callback(name, _borders[name].drawingFeature);
            }
          },
          isChanged: function isChanged(name) {
            return !!_borders[name] && _borders[name].isChanged;
          },
          updateBorder: function updateBorder(name, span) {
            if (!_borders[name]) return;

            var geom = _borders[name].drawingFeature.toGeoJSON().geometry,
                areaStr = L.gmxUtil.prettifyArea(L.gmxUtil.geoArea(geom, false));

            if (span) {
              _$3(span, [_t(areaStr)]);

              return;
            }

            if (!$('#drawingBorderDescr' + name).length) return;
            $('#drawingBorderDescr' + name).empty();

            _$3($('#drawingBorderDescr' + name)[0], [_t(areaStr)]);
          },
          //Удаляет объект из списка контуров слоя
          //?removeDrawring {bool, default: false} - удалять ли сам пользовательский объект
          removeRoute: function removeRoute(name, removeDrawing) {
            if (!(name in _borders)) return;

            _borders[name].drawingFeature.off('edit', _borders[name].editListener);

            if (removeDrawing) {
              nsGmx$1.leafletMap.gmxDrawing.remove(_borders[name].drawingFeature);
            }

            delete _borders[name];
            $('#drawingBorderDescr' + name).empty();
          }
        };
      }();

      this.unsavedChanges = false;
    };

    mapHelper.prototype = new leftMenu();
    /** Менеджер кастомных параметров карты.
     * Содержит набор провайдеров доп. параметров, которые могут сохранять и загружать данные из хранилища параметров
     * Данные загружаются один раз. Возможна асинхронная загрузка данных/добавление провайдеров.
     * Порядок вызова провайдеров не определён.
     *
     * @memberOf _mapHelper
     * @name customParamsManager
     */

    mapHelper.prototype.customParamsManager = function () {
      var _providers = [];
      var _params = []; //хранит параметры, которые не были загружены провайдерами

      var loadProviderState = function loadProviderState(provider) {
        if (provider.name in _params && typeof provider.loadState !== 'undefined') {
          provider.loadState(_params[provider.name]);
          delete _params[provider.name];
        }
      };

      return {
        saveParams: function saveParams() {
          if (!_providers.length) return;
          var params = {};

          for (var p = 0; p < _providers.length; p++) {
            if (typeof _providers[p].saveState !== 'undefined') params[_providers[p].name] = _providers[p].saveState();
          }

          return params;
        },
        loadParams: function loadParams(params) {
          _params = params;

          for (var p = 0; p < _providers.length; p++) {
            loadProviderState(_providers[p]);
          }
        },
        //интерфейс провайдера: name, saveState(), loadState(state)
        addProvider: function addProvider(provider) {
          _providers.push(provider);

          loadProviderState(provider);
        },
        isProvider: function isProvider(providerName) {
          return !!nsGmx$1._.findWhere(_providers, {
            name: providerName
          });
        },
        removeProvider: function removeProvider(providerName) {
          _providers = nsGmx$1._.filter(_providers, function (provider) {
            return provider.name !== providerName;
          });
        }
      };
    }();

    mapHelper.prototype.makeStyle = function (style) {
      style = style || {};
      var givenStyle = {};
      if (typeof style.RenderStyle != 'undefined') givenStyle = style.RenderStyle;else if (style.outline || style.marker) givenStyle = style;else {
        if (style.PointSize) givenStyle.marker = {
          size: parseInt(style.PointSize)
        };

        if (style.Icon) {
          var src = style.Icon.indexOf("http://") != -1 || style.Icon.indexOf("https://") != -1 ? style.Icon : window.baseAddress + "/" + style.Icon;
          givenStyle.marker = {
            image: src,
            center: true
          };
        }

        if (style.BorderColor || style.BorderWidth) givenStyle.outline = {
          color: parseColor(style.BorderColor),
          thickness: parseInt(style.BorderWidth || "1")
        };
        if (style.FillColor) givenStyle.fill = {
          color: parseColor(style.FillColor),
          opacity: 100 - parseInt(style.Transparency || "0")
        };
        var label = style.label || style.Label;
        if (label) givenStyle.label = {
          field: label.FieldName,
          color: parseColor(label.FontColor),
          size: parseInt(label.FontSize || "12")
        };
      }
      return givenStyle;
    };

    mapHelper.prototype.getMapStateAsPermalink = function (callback) {
      // сохраняем состояние карты
      var mapState = _mapHelper$1.getMapState(); // туда же сохраним созданные объекты


      nsGmx$1.userObjectsManager.collect();
      mapState.userObjects = JSON.stringify(nsGmx$1.userObjectsManager.getData());
      nsGmx$1.Utils.TinyReference.create(mapState, true).then(callback);
    };

    mapHelper.prototype.reloadMap = function () {
      if (!nsGmx$1.gmxMap) {
        window.location.reload();
      }

      _mapHelper$1.getMapStateAsPermalink(function (permalinkID) {
        createCookie("TempPermalink", permalinkID);
        window.location.replace(window.location.href.split("?")[0] + "?permalink=" + permalinkID + (window.defaultMapID == window.globalMapName ? "" : "&" + window.globalMapName));
      });
    };

    mapHelper.prototype.updateUnloadEvent = function (flag) {
      if (typeof flag != 'undefined') this.unsavedChanges = flag;

      if (this.unsavedChanges) {
        window.onbeforeunload = function () {
          return _gtxt("В дереве слоев остались несохраненные изменения!");
        };
      } else window.onbeforeunload = null;
    };

    mapHelper.prototype.setBalloon = function (filter, template) {
      filter.enableHoverBalloon(function (o) {
        return template.replace(/\[([a-zA-Z0-9_а-яА-Я ]+)\]/g, function () {
          var key = arguments[1];
          if (key == "SUMMARY") return o.getGeometrySummary();else return o.properties[key];
        });
      });
    };

    mapHelper.prototype.updateMapStyles = function (newStyles, name) {
      var layer = nsGmx$1.gmxMap.layersByID[name],
          styles = newStyles.map(nsGmx$1.Utils.prepareGmxLayerStyle);
      layer.setStyles(styles);
    }; //TODO: remove isEditableStyles


    mapHelper.prototype.updateTreeStyles = function (newStyles, div, treeView, isEditableStyles) {
      isEditableStyles = typeof isEditableStyles === 'undefined' || isEditableStyles;

      if (window.newStyles) {
        div.gmxProperties.content.properties.gmxStyles.styles = newStyles;
      } else {
        div.gmxProperties.content.properties.styles = newStyles;
      }

      var multiStyleParent = $(div).children('[multiStyle]')[0];

      var parentIcon = $(div).children("[styleType]")[0],
          newIcon = _mapHelper$1.createStylesEditorIcon(newStyles, div.gmxProperties.content.properties.GeometryType.toLowerCase(), {
        addTitle: isEditableStyles
      });

      $(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
      $(multiStyleParent).empty();

      _mapHelper$1.createMultiStyle(div.gmxProperties.content.properties, treeView, multiStyleParent);
    };

    mapHelper.prototype.restoreTinyReference = function (id, callbackSuccess, errorCallback) {
      window.suppressDefaultPermalink = true;
      nsGmx$1.Utils.TinyReference.get(id).then(function (obj) {
        if (obj.position) {
          var latLngPos = L.Projection.Mercator.unproject(obj.position);
          obj.position.x = latLngPos.lng;
          obj.position.y = latLngPos.lat;
          obj.position.z = 17 - obj.position.z;

          if (obj.drawnObjects) {
            for (var i in obj.drawnObjects) {
              //эта двойная конвертация в действительности просто перевод координат из Меркатора в LatLng
              obj.drawnObjects[i].geometry = L.gmxUtil.geoJSONtoGeometry(L.gmxUtil.geometryToGeoJSON(obj.drawnObjects[i].geometry, true));
            }
          }
        }

        obj.originalReference = id;
        callbackSuccess(obj);
      }, errorCallback);
    };

    mapHelper.prototype.getMapState = function () {
      var lmap = nsGmx$1.leafletMap;

      if (!lmap) {
        return {};
      }

      var drawnObjects = [],
          drawings = lmap.gmxDrawing.saveState(),
          features = drawings.featureCollection.features,
          openPopups = {},
          condition = {
        expanded: {},
        visible: {}
      },
          LayersTreePermalinkParams = {},
          mercCenter = L.Projection.Mercator.project(lmap.getCenter());

      for (var i = 0; i < features.length; i++) {
        if (features[i].properties.exportRect) {
          features.splice(i, 1);
        }
      }

      lmap.gmxDrawing.getFeatures().forEach(function (feature) {
        if (!nsGmx$1.DrawingObjectCustomControllers.isSerializable(feature) || feature.options.exportRect) {
          return;
        }

        var geoJSON = feature.toGeoJSON();
        var elem = {
          properties: geoJSON.properties,
          geometry: L.gmxUtil.geoJSONtoGeometry(geoJSON, true)
        };

        if (elem.geometry.type !== "POINT") {
          var style = feature.getOptions().lineStyle;

          if (style) {
            elem.thickness = style.weight || 2;
            elem.color = style.color;
            elem.opacity = (style.opacity || 0.8) * 100;
          }
        }

        if (lmap.hasLayer(feature.getPopup())) {
          elem.isBalloonVisible = true;
        }

        drawnObjects.push(elem);
      });

      for (var l in nsGmx$1.gmxMap.layersByID) {
        var layer = nsGmx$1.gmxMap.layersByID[l];

        if (layer.getPopups) {
          var popups = layer.getPopups();

          if (popups.length) {
            openPopups[l] = popups;
          }
        }
      }

      this.findTreeElems(_layersTree.treeModel.getRawTree(), function (elem) {
        var props = elem.content.properties;

        if (elem.type == 'group') {
          var groupId = props.GroupID;

          if (!$("div[GroupID='" + groupId + "']").length && !props.changedByViewer) {
            return;
          }

          condition.visible[groupId] = props.visible;
          condition.expanded[groupId] = props.expanded;
        } else if (props.changedByViewer) {
          condition.visible[props.name] = props.visible;
        }
      }); // layers tree permalink params (without server)

      this.findTreeElems(_layersTree.treeModel.getRawTree(), function (elem) {
        var props = elem.content.properties,
            id = elem.type == 'group' ? props.GroupID : props.LayerID;

        if (props.permalinkParams) {
          LayersTreePermalinkParams[id] = props.permalinkParams;
        }
      });
      var dateIntervals = {};

      for (var _l in nsGmx$1.gmxMap.layersByID) {
        var _layer = nsGmx$1.gmxMap.layersByID[_l],
            props = _layer.getGmxProperties(),
            isTemporalLayer = _layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && _layer.setDateInterval;

        if (isTemporalLayer && _layer.getDateInterval) {
          dateIntervals[props.LayerID] = _layer.getDateInterval();
        }
      }

      return {
        mode: lmap.gmxBaseLayersManager.getCurrentID(),
        mapName: window.globalMapName,
        position: {
          x: mercCenter.x,
          y: mercCenter.y,
          z: 17 - lmap.getZoom()
        },
        mapStyles: this.getMapStyles(),
        drawings: drawings,
        drawnObjects: drawnObjects,
        isFullScreen: window.layersShown ? "false" : "true",
        condition: condition,
        LayersTreePermalinkParams: LayersTreePermalinkParams,
        language: window.language,
        customParamsCollection: this.customParamsManager.saveParams(),
        dateIntervals: dateIntervals,
        openPopups: openPopups
      };
    };

    mapHelper.prototype.getMapStyles = function () {
      var styles = {};
      this.findChilds(_layersTree.treeModel.getRawTree(), function (child) {
        if (child.content.properties.type == "Vector" && $("div[LayerID='" + child.content.properties.LayerID + "']").length) styles[child.content.properties.name] = child.content.properties.styles;
      }, true);
      return styles;
    };

    mapHelper.prototype.showPermalink = function () {
      this.createPermalink(function (id) {
        var url = window.location.protocol + "//" + window.location.host + window.location.pathname + "?permalink=" + id + (window.defaultMapID == window.globalMapName ? "" : "&" + window.globalMapName);

        var input = _input(null, [['dir', 'className', 'inputStyle inputFullWidth'], ['attr', 'value', url]]);

        showDialog(_gtxt("Ссылка на текущее состояние карты"), _div([input]), 311, 80, false, false);
        input.select();
      });
    };

    mapHelper.prototype.createExportPermalink = function (params, callback) {
      var mapState = $.extend(this.getMapState(), params),
          def = nsGmx$1.Utils.TinyReference.create(mapState, false);
      def.then(callback);
      return def;
    };

    mapHelper.prototype.createPermalink = function (callback) {
      var mapState = this.getMapState(),
          def = nsGmx$1.Utils.TinyReference.create(mapState, false);
      def.then(callback);
      return def;
    };

    mapHelper.prototype.updateTinyMCE = function (container) {
      // window.gmxCore.loadModule('TinyMCELoader', window.location + '//' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function() {
      //     $('.balloonEditor', container).each(function() {
      //         var id = $(this).attr('id');
      //         if (!tinyMCE.get(id)) {
      //             tinyMCE.execCommand("mceAddControl", true, id);
      //         }
      //     })
      // });
      $('.balloonEditor', container).each(function () {
        var id = $(this).attr('id');

        if (!tinyMCE.get(id)) {
          tinyMCE.execCommand("mceAddControl", true, id);
        }
      });
    }; //event: selected(url)


    mapHelper.ImageSelectionWidget = Backbone.View.extend({
      tagName: 'span',
      className: 'gmx-icon-choose',
      events: {
        'click': function click() {
          var imagesDir = nsGmx$1.AuthManager.getUserFolder() + 'images',
              _this = this;

          sendCrossDomainJSONRequest(window.serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(imagesDir), function (response) {
            if (!parseResponse(response)) return;

            window._fileBrowser.createBrowser(_gtxt("Изображение"), ['jpg', 'jpeg', 'png', 'gif', 'swf'], function (path) {
              var relativePath = path.substring(imagesDir.length);

              if (relativePath[0] == '\\') {
                relativePath = relativePath.substring(1);
              }

              var url = window.serverBase + "GetImage.ashx?usr=" + encodeURIComponent(nsGmx$1.AuthManager.getLogin()) + "&img=" + encodeURIComponent(relativePath);

              _this.trigger('selected', url);
            }, {
              startDir: imagesDir,
              restrictDir: imagesDir
            });
          });
        }
      }
    });

    mapHelper.ImageInputControl = function (initURL) {
      var prevValue = initURL || '';

      var inputUrl = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'value', prevValue], ['css', 'width', '170px']]);

      _title(inputUrl, _gtxt('URL изображения'));

      var _this = this;

      var update = function update() {
        if (inputUrl.value != prevValue) {
          prevValue = inputUrl.value;
          $(_this).change();
        }
      };

      var mainDiv = $('<div/>').append(inputUrl);
      inputUrl.onkeyup = inputUrl.change = update;

      if (nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_UPLOAD_FILES)) {
        var imageSelectionWidget = new mapHelper.ImageSelectionWidget();
        imageSelectionWidget.on('selected', function (url) {
          inputUrl.value = url;
          update();
        });
        mainDiv.append(imageSelectionWidget.el);
      }

      this.getControl = function () {
        return mainDiv[0];
      };

      this.value = function () {
        return inputUrl.value;
      };
    }; //params:
    //  * addTitle {bool, default: true}


    mapHelper.prototype.createStylesEditorIcon = function (parentStyles, type, params) {
      var _params = $.extend({
        addTitle: true
      }, params);

      var icon;

      if ($.isArray(parentStyles) && parentStyles.length > 1) {
        icon = _img(null, [['attr', 'src', 'img/misc.png'], ['css', 'margin', '0px 2px -3px 4px'], ['css', 'cursor', 'pointer'], ['attr', 'styleType', 'multi']]);
      } else {
        var parentStyle = _mapHelper$1.makeStyle(parentStyles[0]);

        var iconUrlProp = window.newStyles ? parentStyle.iconUrl : parentStyle.marker && parentStyle.marker.image;

        if (iconUrlProp) {
          icon = _img(null, [['dir', 'className', 'icon'], ['attr', 'styleType', 'icon']]);

          var fixFunc = function fixFunc() {
            var width = this.width,
                height = this.height,
                scale;

            if (width && height) {
              var scaleX = 14.0 / width;
              var scaleY = 14.0 / height;
              scale = Math.min(scaleX, scaleY);
            } else {
              scale = 1;
              width = height = 14;
            }

            setTimeout(function () {
              icon.style.width = Math.round(width * scale) + 'px';
              icon.style.height = Math.round(height * scale) + 'px';
            }, 10);
          };

          icon.onload = fixFunc;
          icon.src = iconUrlProp;
        } else {
          icon = nsGmx$1.Controls.createGeometryIcon(parentStyle, type);
        }
      }

      if (_params.addTitle) _title(icon, _gtxt("Редактировать стили"));
      icon.geometryType = type;
      return icon;
    };

    mapHelper.prototype.createLoadingLayerEditorProperties = function (div, parent, layerProperties, params) {
      // var elemProperties = div.gmxProperties.content.properties,
      var elemProperties = typeof div === 'string' ? layerProperties : div.gmxProperties.content.properties,
          loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
          type = elemProperties.type; // _this = this;


      if (type == "Vector") {
        nsGmx$1.createLayerEditor(div, type, parent, layerProperties, params);
        return;
      } else if (elemProperties.name) {
        _$3(parent, [loading]);

        sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&LayerName=" + elemProperties.name, function (response) {
          if (!parseResponse(response)) return;
          loading.removeNode(true);
          nsGmx$1.createLayerEditor(div, type, parent, response.Result, params);
        });
      }
    };

    mapHelper.prototype.createNewLayer = function (type) {
      if ($('#new' + type + 'Layer').length) return;

      var parent = _div(null, [['attr', 'id', 'new' + type + 'Layer'], ['css', 'height', '100%']]),
          height = type == 'Vector' ? 340 : 360;

      if (type !== 'Multi') {
        var properties = {
          Title: '',
          Description: '',
          Date: '',
          TilePath: {
            Path: ''
          },
          ShapePath: {
            Path: ''
          }
        };
        var dialogDiv = showDialog(type != 'Vector' ? _gtxt('Создать растровый слой') : _gtxt('Создать векторный слой'), parent, 340, height, false, false);
        nsGmx$1.createLayerEditor(false, type, parent, properties, {
          doneCallback: function doneCallback() {
            removeDialog(dialogDiv);
          }
        });
      } else {
        //мультислой
        // var _this = this;
        nsGmx$1.createMultiLayerEditorNew(_layersTree);
      }
    }; // перенос clipLayer из маплетов карты


    mapHelper.prototype.clipLayer = function (layer, props) {
      var sw = L.latLng([props.MinViewY, props.MinViewX]),
          nw = L.latLng([props.MaxViewY, props.MinViewX]),
          ne = L.latLng([props.MaxViewY, props.MaxViewX]),
          se = L.latLng([props.MinViewY, props.MaxViewX]),
          clip = L.polygon([sw, nw, ne, se, sw]);
      layer.addClipPolygon(clip);
    }; // Формирует набор элементов tr используя контролы из shownProperties.
    // Параметры:
    // - shownProperties: массив со следующими свойствами:
    //   * tr - если есть это свойство, то оно помещается в tr, все остальные игнорируются
    //   * name - названия свойства, которое будет писаться в левой колонке
    //   * elem - если есть, то в правую колонку помещается этот элемент
    //   * field - если нет "elem", в правый столбец подставляется layerProperties[field]
    //   * trid - id для DOM элементов. Не применяется, если прямо указано tr
    //   * trclass - class для DOM элементов. Не применяется, если прямо указано tr
    // - layerProperties - просто хеш строк для подстановки в правую колонку
    // - style:
    //   * leftWidth - ширина левой колонки в пикселях
    //   * leftcolumnclass - class для td элементов первого столбца. Не применяется, если прямо указано tr
    //   * rightcolumnclass - class для td элементов второго столбца. Не применяется, если прямо указано tr


    mapHelper.prototype.createPropertiesTable = function (shownProperties, layerProperties, style) {
      var _styles = $.extend({
        leftWidth: 100
      }, style);

      var trs = [];

      for (var i = 0; i < shownProperties.length; i++) {
        var td;

        if (typeof shownProperties[i].tr !== 'undefined') {
          trs.push(shownProperties[i].tr);
          continue;
        }

        if (typeof shownProperties[i].elem !== 'undefined') td = _td([shownProperties[i].elem]);else td = _td([_t(layerProperties[shownProperties[i].field] != null ? layerProperties[shownProperties[i].field] : '')], [['css', 'padding', '0px 3px']]);

        var tdTitle = _td([_t(shownProperties[i].name)], [['css', 'width', _styles.leftWidth + 'px']]);

        var tr = _tr([tdTitle, td]);

        _$3(tdTitle, [], [['dir', 'className', 'propertiesTable-title ' + (_styles.leftcolumnclass || '')]]);

        if (_styles.rightcolumnclass) _$3(td, [], [['dir', 'className', _styles.rightcolumnclass]]);
        if (shownProperties[i].trid) _$3(tr, [], [['attr', 'id', shownProperties[i].trid]]);
        if (shownProperties[i].trclass) _$3(tr, [], [['dir', 'className', shownProperties[i].trclass]]);
        trs.push(tr);
      }

      return trs;
    };

    mapHelper.prototype.createLayerEditor = function (div, treeView, selected) {
      var elemProperties = typeof div === 'string' ? nsGmx$1.gmxMap.layersByID[div].getGmxProperties() : div.gmxProperties.content.properties,
          // var elemProperties = div.gmxProperties.content.properties,
      layerName = elemProperties.name,
          _this = this;

      if (elemProperties.type == "Vector") {
        if (typeof this.layerEditorsHash[layerName] != 'undefined') {
          if (this.layerEditorsHash[layerName] != false) {
            this.layerEditorsHash[layerName].selectTab(selected);
          }

          return;
        }

        this.layerEditorsHash[layerName] = false;

        var mapName = elemProperties.mapName,
            createTabs = function createTabs(layerProperties) {
          var id = 'layertabs' + layerName,
              divProperties = _div(null, [['attr', 'id', 'properties' + id], ['css', 'height', '100%']]),
              // tabMenu,
          additionalTabs = []; // let pos = nsGmx.Utils.getDialogPos(div, true, 390),


          var pos = typeof div === 'string' ? {
            left: 410,
            top: 230
          } : nsGmx$1.Utils.getDialogPos(div, true, 390),
              updateFunc = function updateFunc() {},
              closeFunc = function closeFunc() {
            return false;
          };

          _this.createLoadingLayerEditorProperties(div, divProperties, layerProperties, {
            doneCallback: function doneCallback() {
              $(divDialog).dialog('close');
            },
            additionalTabs: additionalTabs,
            selected: selected,
            createdCallback: function createdCallback(layerEditor) {
              _this.layerEditorsHash[layerName] = layerEditor;
              _this.layerEditorsHash[layerName].closeFunc = closeFunc;
              _this.layerEditorsHash[layerName].updateFunc = updateFunc;
            }
          });

          var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 350, 470, pos.left, pos.top, null, function () {
            delete _this.layerEditorsHash[layerName];
          }); // при сохранении карты сбросим все временные стили в json карты

          divProperties.closeFunc = closeFunc;
          divProperties.updateFunc = updateFunc;
        };

        if (!this.attrValues[mapName]) this.attrValues[mapName] = {};
        sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + layerName, function (response) {
          if (!parseResponse(response)) return;
          var columns = response.Result.Columns;
          var attributesHash = {};

          for (var i = 0; i < columns.length; i++) {
            attributesHash[columns[i].Name] = [];
          }

          _this.attrValues[mapName][layerName] = new nsGmx$1.LazyAttributeValuesProviderFromServer(attributesHash, layerName);
          createTabs(response.Result);
        });
      } else if (elemProperties.type == "Raster") {
        if (elemProperties.LayerID) {
          if (this.layerEditorsHash[layerName]) return;
          this.layerEditorsHash[layerName] = true;

          var id = 'layertabs' + layerName,
              divProperties = _div(null, [['attr', 'id', 'properties' + id], ['css', 'height', '100%']]),
              divStyles = _div(null, [['attr', 'id', 'styles' + id], ['css', 'height', '100%'], ['css', 'overflowY', 'auto']]);

          var layer = nsGmx$1.gmxMap.layersByID[layerName],
              parentStyle = elemProperties.styles && elemProperties.styles[0] || elemProperties;
          var zoomPropertiesControl = new nsGmx$1.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom),
              liMinZoom = zoomPropertiesControl.getMinLi(),
              liMaxZoom = zoomPropertiesControl.getMaxLi();
          $(zoomPropertiesControl).change(function () {
            layer.setZoomBounds(this.getMinZoom(), this.getMaxZoom());
          });

          _$3(divStyles, [_ul([liMinZoom, liMaxZoom])]);

          this.createLoadingLayerEditorProperties(div, divProperties, null, {
            doneCallback: function doneCallback() {
              $(divDialog).dialog('close');
            },
            additionalTabs: [{
              title: _gtxt("Стили"),
              name: 'styles',
              container: divStyles
            }]
          });

          var pos = nsGmx$1.Utils.getDialogPos(div, true, 330),
              closeFunc = function closeFunc() {
            elemProperties.styles = elemProperties.styles || [];
            elemProperties.styles[0] = elemProperties.styles[0] || {};
            elemProperties.styles[0].MinZoom = zoomPropertiesControl.getMinZoom();
            elemProperties.styles[0].MaxZoom = zoomPropertiesControl.getMaxZoom();
            delete _this.layerEditorsHash[layerName];
            treeView.findTreeElem(div).elem.content.properties = elemProperties;

            _this.drawingBorders.removeRoute(layerName, true);

            if ($('#drawingBorderDialog' + layerName).length) removeDialog($('#drawingBorderDialog' + layerName)[0].parentNode);
            return false;
          };

          var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null, closeFunc);
        } else {
          nsGmx$1.createMultiLayerEditorServer(elemProperties, div, treeView);
        }
      } else if (elemProperties.type == "Virtual") {
        var _id = 'layertabs' + layerName;

        var _divProperties = _div(null, [['attr', 'id', 'properties' + _id], ['css', 'height', '100%']]);

        this.createLoadingLayerEditorProperties(div, _divProperties, null, {
          doneCallback: function doneCallback() {
            $(_divDialog).dialog('close');
          }
        }); // var closeFunc = function() {
        //     delete _this.layerEditorsHash[layerName];
        // };

        var _pos = nsGmx$1.Utils.getDialogPos(div, true, 330);

        var _divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), _divProperties, 330, 410, _pos.left, _pos.top, null);
      }
    };

    mapHelper.prototype.createWFSStylesEditor = function (parentObject, style, geometryType, divCanvas) {
      var _this = this,
          templateStyle = {};

      $.extend(true, templateStyle, style);

      var elemCanvas = _mapHelper$1.createStylesEditorIcon([{
        MinZoom: 1,
        MaxZoom: 21,
        RenderStyle: style.regularStyle
      }], geometryType);

      var spanIcon = _span([elemCanvas]);

      spanIcon.onclick = function () {
        var listenerId = parentObject.addListener('onSetStyle', function (style) {
          var newIcon = _this.createStylesEditorIcon([{
            MinZoom: 1,
            MaxZoom: 21,
            RenderStyle: style.regularStyle
          }], geometryType);

          $(spanIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
        });

        var canvasStyles = _div(null, [['css', 'marginTop', '10px']]),
            canvasCharts = _div(null, [['css', 'marginTop', '10px']]),
            closeFunc = function closeFunc() {
          $(canvasStyles).find(".colorSelector").each(function () {
            $('#' + $(this).data("colorpickerId")).remove();
          });
          var layerElemCanvas = $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0];
          layerElemCanvas.graphDataType = $(canvasCharts).find("select")[0].value;
          layerElemCanvas.graphDataProperties = $(canvasCharts).find("input")[0].value;
          parentObject.removeMapStateListener('onSetStyle', listenerId);
        };

        var id = 'wfstabs' + String(Math.random()).substring(2, 9),
            tabMenu = _div([_ul([_li([_a([_t(_gtxt("Стили"))], [['attr', 'href', '#styles' + id]])]), _li([_a([_t(_gtxt("Диаграммы"))], [['attr', 'href', '#graph' + id]])])])]),
            divStyles = _div(null, [['attr', 'id', 'styles' + id]]),
            divGraph = _div(null, [['attr', 'id', 'graph' + id]]);

        _$3(tabMenu, [divStyles, divGraph]);

        window.gmxCore.loadModule('LayerStylesEditor').done(function (module) {
          var resObject = module.createStyleEditor(canvasStyles, templateStyle, geometryType, false);
          $(resObject).change(function () {
            nsGmx$1.Utils.setMapObjectStyle(parentObject, templateStyle);
          });
        });
        canvasStyles.firstChild.style.marginLeft = '0px';

        _$3(divStyles, [canvasStyles]);

        _mapHelper$1.createChartsEditor(canvasCharts, $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0]);

        canvasCharts.firstChild.style.marginLeft = '0px';

        _$3(divGraph, [canvasCharts]);

        var pos = nsGmx$1.Utils.getDialogPos(spanIcon, false, 160);
        showDialog(_gtxt('Редактирование стилей объекта'), tabMenu, 330, 180, pos.left, pos.top, false, closeFunc);
        $(tabMenu).tabs({
          active: 0
        });
      };

      spanIcon.getStyle = function () {
        return templateStyle;
      };

      return spanIcon;
    };

    mapHelper.prototype.createChartsEditor = function (parent, elemCanvas) {
      var graphTypeSel = nsGmx$1.Utils._select([_option([_t(_gtxt("График по времени"))], [['attr', 'value', 'func']]), _option([_t(_gtxt("Круговая"))], [['attr', 'value', 'pie']])], [['dir', 'className', 'selectStyle'], ['css', 'width', '180px']]),
          propertiesMask = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '180px']]);

      switchSelect(graphTypeSel, elemCanvas.graphDataType);
      propertiesMask.value = elemCanvas.graphDataProperties;

      _$3(parent, [_table([_tbody([_tr([_td([_t(_gtxt("Тип"))], [['css', 'width', '100px']]), _td([graphTypeSel])]), _tr([_td([_t(_gtxt("Маска атрибутов"))]), _td([propertiesMask])])])])]);
    };

    mapHelper.prototype.createMultiStyle = function (elem, treeView, multiStyleParent, treeviewFlag, layerManagerFlag) {
      var filters = window.newStyles ? elem.gmxStyles.styles : elem.styles;

      if (filters.length < 2) {
        multiStyleParent.style.display = 'none';
        return;
      }

      multiStyleParent.style.display = '';

      var ulFilters = _ul();

      for (var i = 0; i < filters.length; i++) {
        var checkbox = $('<input type="checkbox" class="multistlye-visibility-checkbox">'),
            // var eye = $('<span class="multistyle-visibility-icon"><svg><use xlink:href="#transparency-eye"></use></svg></span>'),
        icon = this.createStylesEditorIcon([filters[i]], elem.GeometryType.toLowerCase(), {
          addTitle: !layerManagerFlag
        }),
            name = filters[i].Name || filters[i].Filter || 'Без имени ' + (i + 1),
            iconSpan = _span([icon]),
            li = _li([_div([$(checkbox)[0], iconSpan, _span([_t(name)], [['css', 'marginLeft', '3px']])])]);

        $(iconSpan).attr('styleType', $(icon).attr('styleType'));
        $(checkbox).prop('checked', filters[i].MinZoom !== 25);
        bindCheckboxHandler(checkbox, i);

        if (!layerManagerFlag) {
          (function (i) {
            iconSpan.onclick = function () {
              nsGmx$1.createStylesDialog(elem, treeView, i); //_mapHelper.createLayerEditor(multiStyleParent.parentNode, treeView, 'styles', i);
            };
          })(i);
        }

        _$3(ulFilters, [li]);
      }

      function bindCheckboxHandler(checkbox, index) {
        $(checkbox).on('change', function (e) {
          var styleVisibilityProps = {
            elem: elem,
            styleIndex: index,
            show: e.target.checked
          };
          $(_layersTree).triggerHandler('styleVisibilityChange', [styleVisibilityProps]);
        });
      }

      ulFilters.style.display = 'none';
      ulFilters.className = 'hiddenTree';

      _$3(multiStyleParent, [_ul([_li([_div([_t(_gtxt("Стили слоя"))]), ulFilters])])]);

      if (typeof treeviewFlag == 'undefined') $(multiStyleParent.firstChild).treeview();
    };

    mapHelper.prototype.load = function () {
      var _this = this;

      if (!this.builded) {
        var fileName;
        if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.usageFilePrefix !== 'undefined') fileName = window.gmxViewerUI.usageFilePrefix;else fileName = window.gmxJSHost ? window.gmxJSHost + "usageHelp" : "usageHelp";
        fileName += _gtxt("helpPostfix");

        _mapHelper$1._loadHelpTextFromFile(fileName, function (text) {
          var div = _div(null, [['dir', 'className', 'help']]);

          div.innerHTML = text;

          _$3(_this.workCanvas, [div]);
        });

        this.builded = true;
      }
    };

    mapHelper.prototype._loadHelpTextFromFile = function (fileName, callback, num, data) {
      var proceess = function proceess(text) {
        callback(Handlebars.compile(text)({
          gmxVersion: num,
          gmxData: data
        }));
      };

      if (fileName.indexOf("http://") !== 0 || fileName.indexOf("https://") !== 0) $.ajax({
        url: fileName,
        success: proceess
      });else sendCrossDomainJSONRequest(window.serverBase + "ApiSave.ashx?get=" + encodeURIComponent(fileName), function (response) {
        proceess(response.Result);
      });
    };

    mapHelper.prototype.version = function () {
      var div = $("<div class='gmx-about'></div>");
      var fileName;
      if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.helpFilePrefix !== 'undefined') fileName = window.gmxViewerUI.helpFilePrefix;else fileName = window.gmxJSHost ? window.gmxJSHost + "help" : "help";
      fileName += _gtxt("helpPostfix");

      _mapHelper$1._loadHelpTextFromFile(fileName, function (text) {
        div.html(text);
        showDialog(_gtxt("О проекте"), div[0], 500, 300, false, false);
      }, window.nsGmx.GeomixerFrameworkVersion, '');
    };

    mapHelper.prototype.print = function () {
      var centerControl = nsGmx$1.leafletMap.gmxControlsManager.get('center'),
          map = nsGmx$1.leafletMap,
          toggleMode = function toggleMode(isPreviewMode) {
        map.gmxControlsManager.get('hide').setActive(!isPreviewMode);
        window.printMode = isPreviewMode;
        $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', isPreviewMode);
        $('#all').toggleClass('print-preview-all', isPreviewMode);
        $('.ui-dialog').toggle();
        $('.leaflet-gmx-iconSvg-hide').toggle();
        $('.leaflet-control-container').toggle();
      };

      toggleMode(true);
      centerControl.removeFrom ? centerControl.removeFrom(map) : centerControl.remove();
      var ui = $(Handlebars.compile('<div class="print-ui"><span class="print-ui-inner">' + '<button class="print-ui-close">Закрыть</button>' + '<button class="print-ui-print">Печать</button>' + '<span class="layoutContainer">' + '<label><input type="radio" name="layout" value="portrait" checked="true">' + _gtxt('портретная') + '</label>' + '<label><input type="radio" name="layout" value="layout">' + _gtxt('альбомная') + '</label>' + '</span>' + '</span>' + '</div>')());
      var BIG = 1150,
          SMALL = BIG / 1.4142;
      var layout = {
        width: SMALL + 'px',
        height: BIG + 'px'
      };
      ui.find('input[value="portrait"]').click(function () {
        this.checked = true;
        layout.width = SMALL + 'px';
        layout.height = BIG + 'px';
        $('#flash').css({
          width: layout.width,
          height: layout.height
        });
        map.invalidateSize();
      });
      ui.find('input[value="layout"]').click(function () {
        this.checked = true;
        layout.width = BIG + 'px';
        layout.height = SMALL + 'px';
        $('#flash').css({
          width: layout.width,
          height: layout.height
        });
        map.invalidateSize();
      });
      ui.find('.print-ui-print').click(function () {
        window.print();
      });
      ui.find('.print-ui-close').click(function () {
        toggleMode(false);
        centerControl.addTo(map);
        $('#flash').css({
          marginLeft: '0px',
          marginTop: '0px'
        });
        window.resizeAll();
        ui.remove();
      });
      $('body').append(ui);
      $('#flash').css({
        top: '0px',
        left: '0px',
        width: layout.width,
        height: layout.height
      });
      map.invalidateSize();
    }; // экспортный режим редактора


    mapHelper.prototype.exportMap = function (params) {
      var map = nsGmx$1.leafletMap,
          hide = map.gmxControlsManager.get('hide'),
          center = map.gmxControlsManager.get('center');
      hide.setActive(false);
      center.removeFrom ? center.removeFrom(map) : center.remove();
      window.exportMode = true;

      if (params.grid) {
        if (!nsGmx$1.gridManager.gridControl) {
          nsGmx$1.gridManager.setState({
            isActive: true
          });
        }

        var grid = nsGmx$1.gridManager.gridControl;
        params.exportBounds && grid.setFixBounds(L.latLngBounds(params.exportBounds._southWest, params.exportBounds._northEast));
      } else {
        nsGmx$1.gridManager.setState(false);
      }

      $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', true);
      $('#all').toggleClass('print-preview-all', true);

      if (params.controls) {
        $('.gmx-slider-control').hide();
        var cs = nsGmx$1.leafletMap.gmxControlsManager.getAll();

        for (var key in cs) {
          if (!(key in params.controls)) {
            nsGmx$1.leafletMap.removeControl(cs[key]);
          }
        }
      } else {
        $('.leaflet-control-container').hide();
      } // $('#leftContent').mCustomScrollbar({live:"off"});


      var exportCssParams = {
        top: '0px',
        left: '0px',
        width: '100%',
        height: '100%'
      };
      $('#flash').css(exportCssParams);
      map.invalidateSize();
    }; //вызывает callback для всех слоёв поддерева treeElem. Параметры: callback(layerInfo, visibilityFlag)


    mapHelper.prototype.findChilds = function (treeElem, callback, flag) {
      var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

      if (childsArr) {
        for (var i = 0; i < childsArr.length; i++) {
          var child = childsArr[i];
          if (child.type == 'group') this.findChilds(child, callback, flag && child.content.properties.visible);else callback(child, flag && child.content.properties.visible);
        }
      }
    };

    mapHelper.prototype.findTreeElems = function (treeElem, callback, flag) {
      var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

      for (var i = 0; i < childsArr.length; i++) {
        var child = childsArr[i];

        if (child.type == 'group') {
          callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
          this.findTreeElems(child, callback, flag && child.content.properties.visible, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list);
        } else callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
      }
    };
    /**
     *  Модифицирует объекты внутри векторного слоя, отправляя изменения на сервер и информируя об этом API
     *
     * @memberOf _mapHelper
     * @name modifyObjectLayer
     * @function
     * @param {String} layerName Имя слоя
     * @param {Object[]} objs Массив описания объектов. Каждое описание представляет из себя объект:
     *
     *  * id {String} ID объекта слоя, над которым производятся изменения (только для модификации и удаления)
     *  * geometry Описание геометрии (вставка и изменение). GeoJSON
     *  * source: {rc: <name КР-источника>, rcobj: <id объекта внутри КР>}
     *  * properties Свойства объекта (вставка и изменение)
     *  * action {'delete'|'insert'|'update'} Производимое действие. Если не указано, то вычисляется следующим образом:
     *    * Если не указан id, то вставка
     *    * Если указан id, то модифицируем
     *    * Для удаления объекта нужно явно прописать параметр
     * @param {String} [crs='EPSG:3395'] Название системы координат геометрии объектов. Поддерживаются 3395, 4326, 3857
     * @return {jQuery.Deferred} Ресолвится в соответствии с ответом сервера
    */


    mapHelper.prototype.modifyObjectLayer = function (layerName, objs, crs) {
      var def = $.Deferred();
      $.each(objs, function (i, obj) {
        obj.action = obj.action || (obj.id ? 'update' : 'insert');
      });
      var params = {
        WrapStyle: 'window',
        LayerName: layerName,
        objects: JSON.stringify(objs)
      };

      if (crs) {
        params.geometry_cs = crs;
      }

      sendCrossDomainPostRequest(window.serverBase + "VectorLayer/ModifyVectorObjects.ashx", params, function (addResponse) {
        if (!parseResponse(addResponse)) {
          def.reject();
          return;
        }

        var mapLayer = nsGmx$1.gmxMap.layersByID[layerName];

        if (mapLayer) {
          L.gmx.layersVersion.chkVersion(mapLayer);
        }

        def.resolve();
      });
      return def.promise();
    };
    /** Запросить с сервера объекты векторного слоя
     * @memberOf _mapHelper
     * @name searchObjectLayer
     * @function
     * @param {String} layerName ID векторного слоя
     * @param {Object} options Параметры запроса
     * @param {String} [options.query] SQL-подобное выражение для выборки объектов
     * @param {Boolean} [options.includeGeometry=false] Возвращать ли геометрию с сервера или нет
     * @param {Object} [options.border=null] GeoJSON для ограничения выборки по геометрии
     * @param {Number} [options.page=0] номер страницы результатов (0 - результаты с самого первого)
     * @param {Number} [options.pagesize=100000] максимальное кол-во объектов в ответе
     * @return {jQuery.Deferred} Promise, который ресолвится массивом найденных объектов. Каждый объект имеет свойства properties и, возможно, geometry
    */


    mapHelper.prototype.searchObjectLayer = function (layerName, options) {
      options = options || {};
      var def = $.Deferred();
      var requestParams = {
        WrapStyle: 'message',
        layer: layerName
      };

      if (options.query) {
        requestParams.query = options.query;
      }

      if (options.includeGeometry) {
        requestParams.geometry = true;
      }

      if (options.border) {
        requestParams.border = JSON.stringify(options.border);
      }

      requestParams.page = options.page || 0;
      requestParams.pagesize = options.pagesize || 100000;
      sendCrossDomainPostRequest(window.serverBase + "VectorLayer/Search.ashx", requestParams, function (response) {
        if (!parseResponse(response)) {
          def.reject(response);
          return;
        }

        var values = response.Result.values;
        var fields = response.Result.fields;
        var objects = [];

        for (var i = 0; i < values.length; i++) {
          var obj = {
            properties: {}
          };

          for (var p = 0; p < values[i].length; p++) {
            if (fields[p] === 'geomixergeojson') {
              obj.geometry = values[i][p];
            } else {
              obj.properties[fields[p]] = values[i][p];
            }
          }

          objects.push(obj);
        }

        def.resolve(objects);
      });
      return def.promise();
    };
    /** Скачать векторный слой с сервера
     * @memberOf _mapHelper
     * @name downloadVectorLayer
     * @function
     * @param {Object} params Параметры запроса
     * @param {String} params.name ID векторного слоя, который нужно скачать
     * @param {String} params.host хост, с которого будем скачивать слой
     * @param {String} [params.format=Shape] В каком формате хотим получить (Shape, Tab, gpx, csv, csv_wkt, excel, kml или несколько через запятую)
     * @param {String} [params.query] SQL запрос для сохранения выборки данных вместо всех данных слоя
     * @param {Array} [params.columns] Атрибуты, которые нужно скачать. Массив объектов с ключами {Value, Alias}
    */


    mapHelper.prototype.downloadVectorLayer = function (params) {
      var requestParams = {
        t: params.name
      };

      if (params.format) {
        requestParams.format = params.format;
      }

      if (params.query) {
        requestParams.query = params.query;
      }

      if (params.columns) {
        requestParams.columns = JSON.stringify(params.columns);
      }

      sendCrossDomainPostRequest(window.location.protocol + "//" + params.host + "/" + "DownloadLayer.ashx", requestParams); // if (window.FormData) {
      //
      // 	var form = document.createElement("form");
      // 	form.style.display = 'none';
      // 	form.setAttribute('enctype', 'multipart/form-data');
      // 	form.name = 'uploadFile';
      //
      // 	var hiddenParamsDiv = document.createElement("div");
      // 	hiddenParamsDiv.style.display = 'none';
      //
      // 	for (var paramName in requestParams) {
      // 		var input = document.createElement("input");
      // 		var value = typeof requestParams[paramName] !== 'undefined' ? requestParams[paramName] : '';
      //
      // 		input.setAttribute('type', 'hidden');
      // 		input.setAttribute('name', paramName);
      // 		input.setAttribute('value', value);
      //
      // 		hiddenParamsDiv.appendChild(input)
      // 	}
      //
      //     form.appendChild(hiddenParamsDiv);
      //
      // 	var formData = new FormData(form);
      //
      //
      // 	var xhr = new XMLHttpRequest();
      // 	// :attachment; filename="suda_15062017_Sentinel_poly.zip";
      // 	xhr.open('POST', /*"http://" + /*params.host*/ window.serverBase + /*"/" + */"DownloadLayer.ashx");
      //
      // 	// xhr.setRequestHeader('Content-Disposition', 'attachment');
      // 	xhr.onload = function () {
      // 		if (xhr.status === 200) {
      // 			// var blob = new Blob([xhr.response], {type: "application/zip"});
      // 			var blob = xhr.response;
      // 			console.log(xhr);
      // 			console.log(blob);
      // 			saveData(blob, params.name);
      // 		}
      // 	}
      //
      // 	xhr.withCredentials = true;
      // 	xhr.responseType = "blob";
      // 	xhr.send(formData);
      //
      // 	function saveData(blob, name) {
      // 		var url = window.URL.createObjectURL(blob),
      // 		a = document.createElement("a");
      // 		console.log(url);
      // 		document.body.appendChild(a);
      // 		a.style = "display: none";
      // 		a.href = url;
      // 		a.download = name;
      // 		// a.click();
      // 		window.URL.revokeObjectURL(url);
      // 	};
      // }
    };

    var _mapHelper$1 = new mapHelper();

    window._mapHelper = _mapHelper$1;
    window.mapHelper = mapHelper;

    mapHelp.mapHelp.load = function () {
      var alreadyLoaded = _mapHelper$1.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _mapHelper$1.load();
    };

    mapHelp.mapHelp.unload = function () {};

    mapHelp.serviceHelp.load = function () {
      var alreadyLoaded = _serviceHelper.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _serviceHelper.load();
    };

    mapHelp.serviceHelp.unload = function () {};

    var serviceHelper = function serviceHelper() {
      this.builded = false;
    };

    serviceHelper.prototype = new leftMenu();

    serviceHelper.prototype.load = function () {
      var _this = this;

      if (!this.builded) {
        var fileName;
        if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.servicesFilePrefix !== 'undefined') fileName = window.gmxViewerUI.servicesFilePrefix;else fileName = window.gmxJSHost ? window.gmxJSHost + "servicesHelp" : "servicesHelp";
        fileName += _gtxt("helpPostfix");

        _mapHelper$1._loadHelpTextFromFile(fileName, function (text) {
          var div = _div(null, [['dir', 'className', 'help']]);

          div.innerHTML = text;

          _$3(_this.workCanvas, [div]);
        });

        this.builded = true;
      }
    };

    var _serviceHelper = new serviceHelper();

    window._serviceHelper = _serviceHelper;

    mapHelp.tabs.load = function () {
      var alreadyLoaded = _queryTabs.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryTabs.load();
    };

    mapHelp.tabs.unload = function () {};

    mapHelp.externalMaps.load = function () {
      var alreadyLoaded = window._queryExternalMaps.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) window._queryExternalMaps.load();
    };

    mapHelp.externalMaps.unload = function () {}; //Динамически подгружаемые части вьюера
    //Редактирование мультислоя


    nsGmx$1.createMultiLayerEditorServer = window.gmxCore.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorServer');
    nsGmx$1.createMultiLayerEditorNew = window.gmxCore.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorNew'); //Редактирование карты и группы

    nsGmx$1.addSubGroup = window.gmxCore.createDeferredFunction('GroupEditor', 'addSubGroup');
    nsGmx$1.createGroupEditor = window.gmxCore.createDeferredFunction('GroupEditor', 'createGroupEditor');
    nsGmx$1.createMapEditor = window.gmxCore.createDeferredFunction('GroupEditor', 'createMapEditor'); //Редактирование свойств слоя

    nsGmx$1.createLayerEditor = window.gmxCore.createDeferredFunction('LayerEditor', 'createLayerEditor'); //Редактирование стилей векторного слоя

    nsGmx$1.createStylesDialog = window.gmxCore.createDeferredFunction('LayerStylesEditor', 'createStylesDialog'); //Библиотека стилей

    nsGmx$1.showStyleLibraryDialog = window.gmxCore.createDeferredFunction('StyleLibrary', 'showStyleLibraryDialog');

    (function ($) {
      $.extend(nsGmx$1, {
        ROLE_ADMIN: 'admin',
        ROLE_USER: 'user',
        ROLE_GUEST: 'guest',
        ROLE_UNAUTHORIZED: undefined,
        ACTION_CREATE_LAYERS: 'createData',
        // Создавать новые слои (векторные и растровые)
        ACTION_CREATE_MAP: 'createMap',
        // Cоздавать новые карты
        ACTION_SAVE_MAP: 'saveMap',
        // Сохранять карту (нужны права редактирования на карту)
        ACTION_CHANGE_MAP_TYPE: 'changeType',
        // Менять тип карты (публичная/открытая/закрытая и т.п.)
        ACTION_SEE_OPEN_MAP_LIST: 'openMap',
        // Видеть список публичных карт
        ACTION_SEE_PRIVATE_MAP_LIST: 'privateMap',
        // Видеть спискок всех карт
        ACTION_SEE_MAP_RIGHTS: 'seeRights',
        // Видеть и редактировать права пользователей (для объектов, владельцем которых является)
        ACTION_SEE_FILE_STRUCTURE: 'seeFiles',
        // Видеть всю файловую структуру сервера, а не только свою дом. директорию
        ACTION_SEE_ALL_USERS: 'seeUsers',
        // Видеть список всех пользователей
        ACTION_SEE_USER_FULLNAME: 'seeUserFullname',
        // Видеть полные имена и логины пользователей (а не только псевдонимы)
        ACTION_UPLOAD_FILES: 'uploadFiles' // Загружать файлы на сервер через web-интерфейс

      });
      var _actions = {};
      _actions[nsGmx$1.ROLE_ADMIN] = {};
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CREATE_LAYERS] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CREATE_MAP] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SAVE_MAP] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_PRIVATE_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CHANGE_MAP_TYPE] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_MAP_RIGHTS] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_FILE_STRUCTURE] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_ALL_USERS] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_USER_FULLNAME] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_UPLOAD_FILES] = true;
      _actions[nsGmx$1.ROLE_USER] = {};
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_CREATE_LAYERS] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_CREATE_MAP] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SAVE_MAP] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SEE_MAP_RIGHTS] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_UPLOAD_FILES] = true;
      _actions[nsGmx$1.ROLE_GUEST] = {};
      _actions[nsGmx$1.ROLE_GUEST][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_GUEST][nsGmx$1.ACTION_SAVE_MAP] = true;
      nsGmx$1.AuthManager = new function () {
        var _userInfo = null;

        var _this = this;

        this.getLogin = function () {
          if (!_userInfo) return null;
          return _userInfo.Login || null;
        };

        this.getNickname = function () {
          if (!_userInfo) return null;
          return _userInfo.Nickname || null;
        };

        this.getFullname = function () {
          if (!_userInfo) return null;
          return _userInfo.FullName || null;
        };

        this.getUserFolder = function () {
          if (!_userInfo) return null;
          return _userInfo.Folder;
        };

        this.isRole = function (role) {
          return _userInfo && _userInfo.Role === role;
        };

        this.canDoAction = function (action) {
          return _userInfo && _userInfo.Role in _actions && action in _actions[_userInfo.Role];
        };

        this.isAccounts = function () {
          return _userInfo && _userInfo.IsAccounts;
        };

        this.isLogin = function () {
          return _userInfo && _userInfo.Login !== false && _userInfo.Role !== this.ROLE_UNAUTHORIZED;
        };

        this.setUserInfo = function (userInfo) {
          _userInfo = $.extend({}, {
            IsAccounts: false,
            Role: this.ROLE_UNAUTHORIZED
          }, userInfo);
          $(this).triggerHandler('change');
        };

        this.checkUserInfo = function (callback, errorCallback) {
          //var isTokenUsed = false;
          var _processResponse = function _processResponse(response) {
            var resOk = parseResponse(response);
            !resOk && errorCallback && errorCallback();

            if (response.Result == null || !resOk) {
              // юзер не авторизован
              _this.setUserInfo({
                Login: false
              });
            } else {
              _this.setUserInfo(response.Result);
            }

            resOk && callback && callback();
          };

          for (var iProvider = 0; iProvider < checkProviders.length; iProvider++) {
            if (checkProviders[iProvider].canAuth()) {
              checkProviders[iProvider].doAuth(callback, errorCallback);
              return;
            }
          }

          sendCrossDomainJSONRequest(window.serverBase + 'User/GetUserInfo.ashx?WrapStyle=func', function (response) {
            if (response.Status === 'ok' && !response.Result && window.mapsSite && window.gmxAuthServer) {
              var callbackPath = location.href.match(/(.*)\//)[0] + 'oAuthCallback.html';
              nsGmx$1.Utils.login(callbackPath, window.serverBase + 'oAuth/', function (userInfo) {
                _processResponse({
                  Status: 'ok',
                  Result: userInfo || null
                });
              }, null, true);
            } else {
              doAuthServerLogin(response.Result && response.Result.Token);

              _processResponse(response);
            }
          });
        };

        this.login = function (login, password, callback, errorCallback) {
          sendCrossDomainPostRequest(window.serverBase + "Login.ashx", {
            WrapStyle: 'message',
            login: login,
            pass: password
          }, function (response) {
            if (response.Status == 'ok' && response.Result) {
              _this.setUserInfo(response.Result);

              doAuthServerLogin(response.Result && response.Result.Token);
              callback && callback();
            } else {
              if (response.Status === 'auth' && 'Result' in response && _typeof(response.Result) === 'object' && 'ExceptionType' in response.Result && response.Result.ExceptionType.indexOf('System.ArgumentException') == 0) {
                errorCallback && errorCallback({
                  emailWarning: true,
                  message: response.Result.Message
                });
              }

              errorCallback && errorCallback({
                emailWarning: false
              });
            }
          });
        };

        this.logout = function (callback) {
          sendCrossDomainJSONRequest(window.serverBase + "Logout.ashx?WrapStyle=func&WithoutRedirection=1", function (response) {
            if (!parseResponse(response)) return;

            if (_this.isAccounts() && window.gmxAuthServer) {
              sendCrossDomainJSONRequest(window.gmxAuthServer + "Handler/Logout", function () {
                //TODO: check result
                _this.setUserInfo({
                  Login: false
                });

                callback && callback();
              }, 'callback');
            } else {
              _this.setUserInfo({
                Login: false
              });

              callback && callback();
            }
          });
        };

        this.changePassword = function (oldPass, newPass, callback, errorCallback) {
          sendCrossDomainJSONRequest(window.serverBase + "ChangePassword.ashx?WrapStyle=func&old=" + encodeURIComponent(oldPass) + "&new=" + encodeURIComponent(newPass), function (response) {
            if (response.Status == 'ok' && response.Result) callback && callback();else {
              var msg = response.ErrorInfo && typeof response.ErrorInfo.ErrorMessage != 'undefined' ? response.ErrorInfo.ErrorMessage : null;
              errorCallback && errorCallback(msg);
            }
          });
        };
      }();
      var checkProviders = [];

      var doAuthServerLogin = function doAuthServerLogin(token) {
        if (token && window.mapsSite && window.gmxAuthServer) {
          sendCrossDomainJSONRequest(window.gmxAuthServer + 'Handler/Me?token=' + encodeURIComponent(token), function () {//console.log(response);
          }, 'callback');
        }
      }; //canAuth() -> bool
      //doAuth(callbackSuccess, callbackError)


      nsGmx$1.AuthManager.addCheckUserMethod = function (provider) {
        checkProviders.push(provider);
      };
    })(jQuery);

    nsGmx$1.GmxWidgetMixin = {
      getContainer: function getContainer() {
        return this.el || this._container;
      },
      appendTo: function appendTo(el) {
        el = el[0] || el;
        el.appendChild(this.getContainer());
      },
      show: function show() {
        var el = this.getContainer();
        el.style.display = this._previousStyleDisplayValue !== 'none' && this._previousStyleDisplayValue || 'block';
        delete this._previousStyleDisplayValue;
      },
      hide: function hide() {
        var el = this.getContainer();
        this._previousStyleDisplayValue = el.style.display;
        el.style.display = 'none';
      },
      _terminateMouseEvents: function _terminateMouseEvents(el) {
        el = el || this.getContainer();
        L.DomEvent.disableClickPropagation(el);
        el.addEventListener('mousewheel', L.DomEvent.stopPropagation);
        el.addEventListener('mousemove', L.DomEvent.stopPropagation);
      }
    };
    nsGmx$1.GmxWidget = Backbone.View.extend(nsGmx$1.GmxWidgetMixin);

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.DropdownMenuWidget = {};
    nsGmx$1.Templates.DropdownMenuWidget["dropdownMenuWidget"] = "<div class=\"dropdownMenuWidget ui-widget\">\n" + "    {{#each items}}\n" + "    <div class=\"dropdownMenuWidget-item{{#if className}} {{className}}{{/if}}\">\n" + "        <a\n" + "            {{#if id}}id=\"{{id}}\"{{/if}}\n" + "            {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" + "            {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" + "            class=\"dropdownMenuWidget-itemAnchor{{#if newWindow}} dropdownMenuWidget-itemAnchor_newWindow{{/if}}\"\n" + "        >\n" + "            {{#if icon}}\n" + "                <img src=\"{{icon}}\" />\n" + "            {{/if}}\n" + "            {{#if fonticon}}\n" + "                <i class=\"{{fonticon}}\"></i>\n" + "            {{/if}}\n" + "            {{#if title}}\n" + "                <span>{{title}}</span>\n" + "                {{#if dropdown}}<i class=\"icon-angle-down\"></i>{{/if}}\n" + "            {{/if}}\n" + "        </a>\n" + "        {{#if dropdown}}\n" + "            <div class=\"dropdownMenuWidget-itemDropdown\">\n" + "                <ul class=\"dropdownMenuWidget-dropdownMenu\">\n" + "                    {{#each dropdown}}\n" + "                        <li class=\"dropdownMenuWidget-dropdownMenuItem{{#if className}} {{className}}{{/if}}\">\n" + "                            {{#if newWindow}}<div class=\"ui-icon ui-icon-newwin dropdownMenuWidget-dropdownMenuIcon\"></div>{{/if}}\n" + "                            <a\n" + "                                {{#if id}}id=\"{{id}}\"{{/if}}\n" + "                                {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" + "                                {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" + "                                class=\"dropdownMenuWidget-dropdownItemAnchor{{#if newWindow}} dropdownMenuWidget-dropdownItemAnchor_newWindow{{/if}}\"\n" + "                            >\n" + "                                {{#if icon}}\n" + "                                    <img src=\"{{icon}}\" />\n" + "                                {{/if}}\n" + "                                {{#if title}}\n" + "                                    <span>{{title}}</span>\n" + "                                {{/if}}\n" + "                            </a>\n" + "                        </li>\n" + "                    {{/each}}\n" + "                </ul>\n" + "            </div>\n" + "        {{/if}}\n" + "    </div>\n" + "    {{/each}}\n" + "</div>\n" + "";
    nsGmx$1.Templates.DropdownMenuWidget["anchor"] = "<a \n" + "    {{#if id}}id=\"{{id}}\"{{/if}}\n" + "    {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" + "    {{#if newWindow}}target=\"_blank\" class=\"dropdownMenuWidget-anchor_newWindow\"{{/if}}\n" + ">\n" + "    {{#if icon}}\n" + "        <img src=\"{{icon}}\" />\n" + "    {{/if}}\n" + "    {{#if title}}\n" + "        <span>{{title}}</span>\n" + "    {{/if}}\n" + "</a>";
    nsGmx$1.PlainTextWidget = nsGmx$1.GmxWidget.extend({
      initialize: function initialize(txt) {
        this.setText(txt);
        this.$el.on('click', function () {
          this.trigger('click');
        }.bind(this));
      },
      getText: function getText() {
        return this.$el.html();
      },
      setText: function setText(txt) {
        this.$el.html(txt);
      }
    }); // <String>options.title
    // <String>options.className
    // <String>options.trigger (hover|click|manual)
    // <String>options.direction (down|up)
    // <Boolean>options.adjustWidth
    // <Boolean>options.showTopItem

    nsGmx$1.DropdownWidget = nsGmx$1.GmxWidget.extend({
      className: 'dropdownWidget dropdownWidget-item',
      options: {
        title: '',
        trigger: 'hover',
        direction: 'down',
        adjustWidth: true,
        showTopItem: true,
        titleClassName: ''
      },
      initialize: function initialize(options) {
        this.options = _.extend(this.options, options);
        this.$titleContainer = $('<div>').addClass('dropdownWidget-dropdownTitle').addClass(options.titleClassName).html(this.options.title).appendTo(this.$el);
        this.$dropdownContainer = $('<div>').addClass('dropdownWidget-dropdown').hide().appendTo(this.$el);
        this.$dropdownTitle = $('<div>').addClass('dropdownWidget-item dropdownWidget-dropdownTitle').addClass(options.titleClassName).html(this.options.title).appendTo(this.$dropdownContainer);

        if (!this.options.showTopItem) {
          this.$dropdownTitle.hide();
        }

        if (this.options.trigger === 'hover') {
          this.$dropdownTitle.addClass('ui-state-disabled');
          this.$titleContainer.on('mouseover', function () {
            this.expand();
          }.bind(this));
          this.$dropdownContainer.on('mouseleave', function () {
            this.collapse();
          }.bind(this));
        } else if (this.options.trigger === 'click') {
          this.$titleContainer.on('click', function () {
            this.expand();
          }.bind(this));
          this.$dropdownTitle.on('click', function () {
            this.collapse();
          }.bind(this));
        }

        if (this.options.direction === 'up') {
          this.$el.addClass('dropdownWidget_direction-up');
        } else {
          this.$el.addClass('dropdownWidget_direction-down');
        }

        this._items = {};
      },
      addItem: function addItem(id, inst, position) {
        this._items[id] = inst;
        var $container = $('<div>').addClass('dropdownWidget-item dropdownWidget-dropdownItem').attr('data-id', id).attr('data-position', position).on('click', function (je) {
          this.trigger('item', $(je.currentTarget).attr('data-id'));
          this.trigger('item:' + $(je.currentTarget).attr('data-id'));

          if (this.options.trigger === 'click') {
            this.collapse();
          }
        }.bind(this));
        $container.append(inst.el);
        this.$dropdownContainer.append($container);

        this._sortItems();
      },
      setTitle: function setTitle(title) {
        this.$titleContainer.html(title);
        this.$dropdownTitle.html(title);
      },
      toggle: function toggle() {
        this._expanded ? this.collapse() : this.expand();
        this._expanded = !this._expanded;
      },
      expand: function expand() {
        this.$dropdownContainer.css('min-width', this.$el.width());
        this.$dropdownContainer.show();
        this.trigger('expand');
      },
      collapse: function collapse() {
        this.$dropdownContainer.hide();
        this.trigger('collapse');
      },
      reset: function reset() {
        this.collapse();
      },
      _sortItems: function _sortItems() {
        var containerEl = this.$dropdownContainer[0];
        var items = Array.prototype.slice.call(containerEl.children);
        var titleEl = items.splice(items.indexOf($(containerEl).find('.dropdownWidget-dropdownTitle')[0]), 1);

        while (items.length) {
          var maxPositionIndex = items.indexOf(_.max(items, function (el) {
            return el.getAttribute('data-position') / 1;
          }));
          $(containerEl).prepend(items.splice(maxPositionIndex, 1)[0]);
        }

        if (this.options.direction === 'up') {
          $(containerEl).append(titleEl);
        } else {
          $(containerEl).prepend(titleEl);
        }
      }
    });

    nsGmx$1.DropdownMenuWidget = function () {
      var DropdownMenuWidget = function DropdownMenuWidget(options) {
        var h = Handlebars.create();
        h.registerPartial('anchor', nsGmx$1.Templates.DropdownMenuWidget.anchor);
        this._view = $(h.compile(nsGmx$1.Templates.DropdownMenuWidget.dropdownMenuWidget)({
          items: options.items
        }));

        this._view.find('.dropdownMenuWidget-itemDropdown').hide(); // var mouseTimeout = options.mouseTimeout || 100;


        this._view.find('.dropdownMenuWidget-item').each(function () {
          var mouseIsOver = false;
          $(this).on('mouseenter', function (je) {
            mouseIsOver = true;
            setTimeout(function () {
              if (mouseIsOver) {
                $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').show();
              }
            }, 100);
          });
          $(this).on('mouseleave', function (je) {
            mouseIsOver = false;
            $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').hide();
          });
        });
      };

      DropdownMenuWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      return DropdownMenuWidget;
    }();

    nsGmx$1.HeaderWidget = function () {

      var SocialShareWidget = function SocialShareWidget(socials) {
        this._view = Handlebars.compile(nsGmx$1.Templates.HeaderWidget.socials)(socials);
      };

      SocialShareWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      var HeaderWidget = function HeaderWidget(options) {
        var addDots = function addDots(item) {
          if (!item.icon && !item.className) {
            item.className = item.className + ' headerWidget-menuDot';
          }

          return item;
        };

        var h = Handlebars.create();
        this._view = $(h.compile(nsGmx$1.Templates.HeaderWidget.layout)(options));

        if (nsGmx$1.DropdownMenuWidget) {
          new nsGmx$1.DropdownMenuWidget({
            items: options.leftLinks && options.leftLinks.map(addDots)
          }).appendTo(this._view.find('.headerWidget-leftLinksContainer'));
          new nsGmx$1.DropdownMenuWidget({
            items: options.rightLinks && options.rightLinks.map(addDots)
          }).appendTo(this._view.find('.headerWidget-rightLinksContainer'));
        } else {
          console.warn('DropdownMenuWidget not found');
        }

        new SocialShareWidget(options.socials).appendTo(this._view.find('.headerWidget-socialsContainer'));

        this._view.find(".headerWidget-authContainer").hide();

        this._view.find(".headerWidget-menuContainer").hide();

        this._view.find(".headerWidget-searchContainer").hide();

        this._view.find(".headerWidget-languageContainer").hide();

        if (!options.socials) {
          this._view.find(".headerWidget-socialsContainer").hide();
        }
      };

      HeaderWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      HeaderWidget.prototype.getAuthPlaceholder = function () {
        return this._view.find(".headerWidget-authContainer").show();
      };

      HeaderWidget.prototype.getMenuPlaceholder = function () {
        return this._view.find(".headerWidget-menuContainer").show();
      };

      HeaderWidget.prototype.getSearchPlaceholder = function () {
        return this._view.find(".headerWidget-searchContainer").show();
      };

      HeaderWidget.prototype.getLanguagePlaceholder = function () {
        return this._view.find(".headerWidget-languageContainer").show();
      };

      HeaderWidget.prototype.getSocialsPlaceholder = function () {
        return this._view.find(".headerWidget-socialsContainer");
      };

      return HeaderWidget;
    }();

    nsGmx$1.Translations.addText('rus', {
      header: {
        'langRu': 'Ru',
        'langEn': 'En'
      }
    });
    nsGmx$1.Translations.addText('eng', {
      header: {
        'langRu': 'Ru',
        'langEn': 'En'
      }
    });
    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.HeaderWidget = {};
    nsGmx$1.Templates.HeaderWidget["layout"] = "<div class=\"headerWidget\">\n" + "    <div class=\"headerWidget-left\">\n" + "        <div class=\"headerWidget-logoContainer\">\n" + "            <img class=\"headerWidget-logo\" src=\"{{logo}}\" />\n" + "        </div>\n" + "    </div>\n" + "    <div class=\"headerWidget-right\">\n" + "        <div class=\"headerWidget-bar headerWidget-controlsBar\">\n" + "            <div class=\"headerWidget-barTable headerWidget-controlsBarTable\">\n" + "                <div class=\"headerWidget-barCell headerWidget-menuContainer\"></div>\n" + "                <div class=\"headerWidget-barCell headerWidget-authContainer\"></div>\n" + "                <div class=\"headerWidget-barCell headerWidget-languageContainer\"></div>\n" + "            </div>\n" + "        </div>\n" + "    </div>\n" + "</div>\n" + "";
    nsGmx$1.Templates.HeaderWidget["socials"] = "<div class=\"headerWidget-socialIcons\">\n" + "    {{#if vk}}\n" + "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{vk}}\" target=\"_blank\"><i class=\"icon-vk\"></i></a></div>\n" + "    {{/if}}\n" + "    {{#if facebook}}\n" + "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{facebook}}\" target=\"_blank\"><i class=\"icon-facebook\"></i></a></div>\n" + "    {{/if}}\n" + "    {{#if twitter}}\n" + "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{twitter}}\" target=\"_blank\"><i class=\"icon-twitter\"></i></a></div>\n" + "    {{/if}}\n" + "</div>";

    nsGmx$1.LanguageWidget = function () {
      var LanguageWidget = function LanguageWidget() {
        this._view = $(Handlebars.compile(nsGmx$1.Templates.LanguageWidget.layout)({
          eng: nsGmx$1.Translations.getLanguage() === 'eng',
          rus: nsGmx$1.Translations.getLanguage() === 'rus'
        }));

        if (nsGmx$1.Translations.getLanguage() !== 'eng') {
          this._view.find('.languageWidget-item_eng').click(function () {
            nsGmx$1.Translations.updateLanguageCookies('eng'); // присвоение url не работает, если есть #

            window.location.reload(false);
          });
        }

        if (nsGmx$1.Translations.getLanguage() !== 'rus') {
          this._view.find('.languageWidget-item_rus').click(function () {
            nsGmx$1.Translations.updateLanguageCookies('rus');
            window.location.reload(false);
          });
        }
      };

      LanguageWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      return LanguageWidget;
    }();

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.LanguageWidget = {};
    nsGmx$1.Templates.LanguageWidget["layout"] = "<div class=\"languageWidget ui-widget\">\n" + "    <div class=\"languageWidget-item languageWidget-item_rus\"><span class=\"{{^rus}}link languageWidget-link{{/rus}}{{#rus}}languageWidget-disabled{{/rus}}\">Ru</span></div>\n" + "    <div class=\"languageWidget-item languageWidget-item_eng\"><span class=\"{{^eng}}link languageWidget-link{{/eng}}{{#eng}}languageWidget-disabled{{/eng}}\">En</span></div>\n" + "</div>";

    function each(o, cb) {
      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          cb(o[p], p, o);
        }
      }
    }

    function find(ar, cb) {
      if (ar.length) {
        for (var i = 0; i < ar.length; i++) {
          if (cb(ar[i])) {
            return ar[i];
          }
        }
      } else {
        for (var p in ar) {
          if (ar.hasOwnProperty(p) && cb(ar[p])) {
            return ar[p];
          }
        }
      }
    }

    function first(o) {
      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          return o[p];
        }
      }
    }

    function length(o) {
      var length = 0;

      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          length++;
        }
      }

      return length;
    }

    function prepend(parent, el) {
      if (parent.children.length) {
        parent.insertBefore(el, parent.children[0]);
      } else {
        parent.appendChild(el);
      }
    }

    var IconLayers = L.Control.extend({
      includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
      _getActiveLayer: function _getActiveLayer() {
        if (this._activeLayerId) {
          return this._layers[this._activeLayerId];
        } else if (length(this._layers)) {
          return first(this._layers);
        } else {
          return null;
        }
      },
      _getPreviousLayer: function _getPreviousLayer() {
        var activeLayer = this._getActiveLayer();

        if (!activeLayer) {
          return null;
        } else if (this._previousLayerId) {
          return this._layers[this._previousLayerId];
        } else {
          return find(this._layers, function (l) {
            return l.id !== activeLayer.id;
          }.bind(this)) || null;
        }
      },
      _getInactiveLayers: function _getInactiveLayers() {
        var ar = [];
        var activeLayerId = this._getActiveLayer() ? this._getActiveLayer().id : null;
        var previousLayerId = this._getPreviousLayer() ? this._getPreviousLayer().id : null;
        each(this._layers, function (l) {
          if (l.id !== activeLayerId && l.id !== previousLayerId) {
            ar.push(l);
          }
        });
        return ar;
      },
      _arrangeLayers: function _arrangeLayers() {
        var behaviors = {};

        behaviors.previous = function () {
          var layers = this._getInactiveLayers();

          if (this._getActiveLayer()) {
            layers.unshift(this._getActiveLayer());
          }

          if (this._getPreviousLayer()) {
            layers.unshift(this._getPreviousLayer());
          }

          return layers;
        };

        return behaviors[this.options.behavior].apply(this, arguments);
      },
      _getLayerCellByLayerId: function _getLayerCellByLayerId(id) {
        var els = this._container.getElementsByClassName('leaflet-iconLayers-layerCell');

        for (var i = 0; i < els.length; i++) {
          if (els[i].getAttribute('data-layerid') == id) {
            return els[i];
          }
        }
      },
      _createLayerElement: function _createLayerElement(layerObj) {
        var el = L.DomUtil.create('div', 'leaflet-iconLayers-layer');

        if (layerObj.title) {
          var titleContainerEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitleContainer');
          var titleEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitle');
          var checkIconEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerCheckIcon');
          titleEl.innerHTML = layerObj.title;
          titleContainerEl.appendChild(titleEl);
          el.appendChild(titleContainerEl);
          el.appendChild(checkIconEl);
        }

        if (layerObj.icon) {
          el.setAttribute('style', 'background-image: url(\'' + layerObj.icon + '\')');
        }

        return el;
      },
      _createLayerElements: function _createLayerElements() {
        var currentRow, layerCell;

        var layers = this._arrangeLayers();

        var activeLayerId = this._getActiveLayer() && this._getActiveLayer().id;

        for (var i = 0; i < layers.length; i++) {
          if (i % this.options.maxLayersInRow === 0) {
            currentRow = L.DomUtil.create('div', 'leaflet-iconLayers-layersRow');

            if (this.options.position.indexOf('bottom') === -1) {
              this._container.appendChild(currentRow);
            } else {
              prepend(this._container, currentRow);
            }
          }

          layerCell = L.DomUtil.create('div', 'leaflet-iconLayers-layerCell');
          layerCell.setAttribute('data-layerid', layers[i].id);

          if (i !== 0) {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_hidden');
          }

          if (layers[i].id === activeLayerId) {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_active');
          }

          if (this._expandDirection === 'left') {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandLeft');
          } else {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandRight');
          }

          layerCell.appendChild(this._createLayerElement(layers[i]));

          if (this.options.position.indexOf('right') === -1) {
            currentRow.appendChild(layerCell);
          } else {
            prepend(currentRow, layerCell);
          }
        }
      },
      _onLayerClick: function _onLayerClick(e) {
        e.stopPropagation();
        var layerId = e.currentTarget.getAttribute('data-layerid');
        var layer = this._layers[layerId];
        this.setActiveLayer(layer.layer);
        this.expand();
      },
      _attachEvents: function _attachEvents() {
        each(this._layers, function (l) {
          var e = this._getLayerCellByLayerId(l.id);

          if (e) {
            e.addEventListener('click', this._onLayerClick.bind(this));
          }
        }.bind(this));

        var layersRowCollection = this._container.getElementsByClassName('leaflet-iconLayers-layersRow');

        var onMouseEnter = function (e) {
          e.stopPropagation();
          this.expand();
        }.bind(this);

        var onMouseLeave = function (e) {
          e.stopPropagation();
          this.collapse();
        }.bind(this);

        var stopPropagation = function stopPropagation(e) {
          e.stopPropagation();
        }; //TODO Don't make functions within a loop.


        for (var i = 0; i < layersRowCollection.length; i++) {
          var el = layersRowCollection[i];
          el.addEventListener('mouseenter', onMouseEnter);
          el.addEventListener('mouseleave', onMouseLeave);
          el.addEventListener('mousemove', stopPropagation);
        }
      },
      _render: function _render() {
        this._container.innerHTML = '';

        this._createLayerElements();

        this._attachEvents();
      },
      _switchMapLayers: function _switchMapLayers() {
        if (!this._map) {
          return;
        }

        var activeLayer = this._getActiveLayer();

        var previousLayer = this._getPreviousLayer();

        if (previousLayer) {
          this._map.removeLayer(previousLayer.layer);
        } else {
          each(this._layers, function (layerObject) {
            var layer = layerObject.layer;

            this._map.removeLayer(layer);
          }.bind(this));
        }

        if (activeLayer) {
          this._map.addLayer(activeLayer.layer);
        }
      },
      options: {
        position: 'bottomleft',
        // one of expanding directions depends on this
        behavior: 'previous',
        // may be 'previous', 'expanded' or 'first'
        expand: 'horizontal',
        // or 'vertical'
        autoZIndex: true,
        // from L.Control.Layers
        maxLayersInRow: 5,
        manageLayers: true
      },
      initialize: function initialize(layers, options) {
        if (!L.Util.isArray(arguments[0])) {
          // first argument is options
          options = layers;
          layers = [];
        }

        L.setOptions(this, options);
        this._expandDirection = this.options.position.indexOf('left') != -1 ? 'right' : 'left';

        if (this.options.manageLayers) {
          this.on('activelayerchange', this._switchMapLayers, this);
        }

        this.setLayers(layers);
      },
      onAdd: function onAdd(map) {
        this._container = L.DomUtil.create('div', 'leaflet-iconLayers');
        L.DomUtil.addClass(this._container, 'leaflet-iconLayers_' + this.options.position);

        this._render();

        map.on('click', this.collapse, this);

        if (this.options.manageLayers) {
          this._switchMapLayers();
        }

        return this._container;
      },
      onRemove: function onRemove(map) {
        map.off('click', this.collapse, this);
      },
      setLayers: function setLayers(layers) {
        this._layers = {};
        layers.map(function (layer) {
          var id = L.stamp(layer.layer);
          this._layers[id] = L.extend(layer, {
            id: id
          });
        }.bind(this));

        if (this._container) {
          this._render();
        }
      },
      setActiveLayer: function setActiveLayer(layer) {
        var l = layer && this._layers[L.stamp(layer)];

        if (!l || l.id === this._activeLayerId) {
          return;
        }

        this._previousLayerId = this._activeLayerId;
        this._activeLayerId = l.id;

        if (this._container) {
          this._render();
        }

        this.fire('activelayerchange', {
          layer: layer
        });
      },
      expand: function expand() {
        this._arrangeLayers().slice(1).map(function (l) {
          var el = this._getLayerCellByLayerId(l.id);

          L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_hidden');
        }.bind(this));
      },
      collapse: function collapse() {
        this._arrangeLayers().slice(1).map(function (l) {
          var el = this._getLayerCellByLayerId(l.id);

          L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_hidden');
        }.bind(this));
      }
    }); // var iconLayers = function(layers, options) {
    //     return new IconLayers(layers, options);
    // };
    // iconLayers.Constructor = IconLayers;
    // window.L.control.iconLayers = iconLayers;
    // window.L.Control.IconLayers = window.L.control.iconLayers.Constructor;

    window.L.Control.IconLayers = IconLayers;

    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.1
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2014 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    (function ($) {
      // ===============================

      var Tooltip = function Tooltip(element, options) {
        this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null;
        this.init('tooltip', element, options);
      };

      Tooltip.VERSION = '3.3.1';
      Tooltip.TRANSITION_DURATION = 150;
      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };

      Tooltip.prototype.init = function (type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);
        var triggers = this.options.trigger.split(' ');

        for (var i = triggers.length; i--;) {
          var trigger = triggers[i];

          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }

        this.options.selector ? this._options = $.extend({}, this.options, {
          trigger: 'manual',
          selector: ''
        }) : this.fixTitle();
      };

      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS;
      };

      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);

        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }

        return options;
      };

      Tooltip.prototype.getDelegateOptions = function () {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value;
        });
        return options;
      };

      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (self && self.$tip && self.$tip.is(':visible')) {
          self.hoverState = 'in';
          return;
        }

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        clearTimeout(self.timeout);
        self.hoverState = 'in';
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show();
        }, self.options.delay.show);
      };

      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        clearTimeout(self.timeout);
        self.hoverState = 'out';
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide();
        }, self.options.delay.hide);
      };

      Tooltip.prototype.show = function () {
        var that = this;

        if (this.hasContent() && this.enabled) {
          this._toBeShown = true;

          this._preloadImages().then(function () {
            if (that._toBeShown) {
              that.doShow();
            }
          });
        }
      };

      Tooltip.prototype._preloadImages = function () {
        var that = this;
        var $images = $('<div>').html(that.getContent()).find('img');
        var srcs = Array.prototype.slice.apply($images).map(function (el) {
          return el.src;
        });
        var promises = srcs.map(function (src) {
          return $.Deferred(function (def) {
            var img = new Image();
            img.addEventListener('load', function () {
              def.resolve();
            });
            img.addEventListener('error', function () {
              def.reject();
            });
            img.src = src;
          }).promise();
        });
        return $.when.apply(null, promises);
      };

      Tooltip.prototype.doShow = function () {
        var e = $.Event('show.bs.' + this.type);
        this.$element.trigger(e);
        var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
        if (e.isDefaultPrevented() || !inDom) return;
        var that = this;
        var $tip = this.tip();
        var tipId = this.getUID(this.type);
        this.setContent();
        $tip.attr('id', tipId);
        this.$element.attr('aria-describedby', tipId);
        if (this.options.animation) $tip.addClass('fade');
        var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
        var autoToken = /\s?auto?\s?/i;
        var autoPlace = autoToken.test(placement);
        if (autoPlace) placement = placement.replace(autoToken, '') || 'top';
        $tip.detach().css({
          top: 0,
          left: 0,
          display: 'block'
        }).addClass(placement).data('bs.' + this.type, this);
        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
        var pos = this.getPosition();
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (autoPlace) {
          var orgPlacement = placement;
          var $container = this.options.container ? $(this.options.container) : this.$element.parent();
          var containerDim = this.getPosition($container);
          placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < containerDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > containerDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < containerDim.left ? 'right' : placement;
          $tip.removeClass(orgPlacement).addClass(placement);
        }

        var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
        this.applyPlacement(calculatedOffset, placement);

        var complete = function complete() {
          var prevHoverState = that.hoverState;
          that.$element.trigger('shown.bs.' + that.type);
          that.hoverState = null;
          if (prevHoverState == 'out') that.leave(that);
        };

        $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
      };

      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight; // manually read margins because getBoundingClientRect includes difference

        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10); // we must check for NaN for ie 8/9

        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top = offset.top + marginTop;
        offset.left = offset.left + marginLeft; // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0

        $.offset.setOffset($tip[0], $.extend({
          using: function using(props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }
        }, offset), 0);
        $tip.addClass('in'); // check to see if placing tip in new offset caused the tip to resize itself

        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left;else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };

      Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
        this.arrow().css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isHorizontal ? 'top' : 'left', '');
      };

      Tooltip.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };

      Tooltip.prototype.hide = function (callback) {
        var that = this;
        var $tip = this.tip();
        var e = $.Event('hide.bs.' + this.type);
        this._toBeShown = false;

        function complete() {
          if (that.hoverState != 'in') $tip.detach();
          that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          callback && callback();
        }

        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass('in');
        $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
      };

      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;

        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };

      Tooltip.prototype.hasContent = function () {
        return this.getTitle();
      };

      Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == 'BODY';
        var elRect = el.getBoundingClientRect();

        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
          });
        }

        var elOffset = isBody ? {
          top: 0,
          left: 0
        } : $element.offset();
        var scroll = {
          scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
          width: $(window).width(),
          height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };

      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
          top: pos.top + pos.height,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'top' ? {
          top: pos.top - actualHeight,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'left' ? {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left - actualWidth
        } :
        /* placement == 'right' */
        {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left + pos.width
        };
      };

      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = {
          top: 0,
          left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);

        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;

          if (topEdgeOffset < viewportDimensions.top) {
            // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;

          if (leftEdgeOffset < viewportDimensions.left) {
            // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.width) {
            // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }

        return delta;
      };

      Tooltip.prototype.getTitle = function () {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
        return title;
      };

      Tooltip.prototype.getUID = function (prefix) {
        do {
          prefix += ~~(Math.random() * 1000000);
        } while (document.getElementById(prefix));

        return prefix;
      };

      Tooltip.prototype.tip = function () {
        return this.$tip = this.$tip || $(this.options.template);
      };

      Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
      };

      Tooltip.prototype.enable = function () {
        this.enabled = true;
      };

      Tooltip.prototype.disable = function () {
        this.enabled = false;
      };

      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      };

      Tooltip.prototype.toggle = function (e) {
        var self = this;

        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);

          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }

        self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
      };

      Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
        });
      }; // TOOLTIP PLUGIN DEFINITION
      // =========================


      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = _typeof(option) == 'object' && option;
          var selector = options && options.selector;
          if (!data && option == 'destroy') return;

          if (selector) {
            if (!data) $this.data('bs.tooltip', data = {});
            if (!data[selector]) data[selector] = new Tooltip(this, options);
          } else if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));

          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tooltip;
      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip; // TOOLTIP NO CONFLICT
      // ===================

      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old;
        return this;
      };
    })(jQuery);
    /* ========================================================================
     * Bootstrap: popover.js v3.3.1
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2014 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */


    (function ($) {
      // ===============================

      var Popover = function Popover(element, options) {
        this.init('popover', element, options);
      };

      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');
      Popover.VERSION = '3.3.1';
      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      }); // NOTE: POPOVER EXTENDS tooltip.js
      // ================================

      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
      Popover.prototype.constructor = Popover;

      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS;
      };

      Popover.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);
        $tip.removeClass('fade top bottom left right in'); // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.

        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
      };

      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent();
      };

      Popover.prototype.getContent = function () {
        var $e = this.$element;
        var o = this.options;
        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };

      Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.arrow');
      };

      Popover.prototype.tip = function () {
        if (!this.$tip) this.$tip = $(this.options.template);
        return this.$tip;
      }; // POPOVER PLUGIN DEFINITION
      // =========================


      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = _typeof(option) == 'object' && option;
          var selector = options && options.selector;
          if (!data && option == 'destroy') return;

          if (selector) {
            if (!data) $this.data('bs.popover', data = {});
            if (!data[selector]) data[selector] = new Popover(this, options);
          } else if (!data) $this.data('bs.popover', data = new Popover(this, options));

          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.popover;
      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover; // POPOVER NO CONFLICT
      // ===================

      $.fn.popover.noConflict = function () {
        $.fn.popover = old;
        return this;
      };
    })(jQuery);

    nsGmx$1.Translations.addText('rus', {
      gmxIconLayers: {
        zoominpls: 'Приблизьте карту, чтобы активировать слой',
        zoomoutpls: 'Отдалите карту, чтобы активировать слой'
      }
    });
    nsGmx$1.Translations.addText('eng', {
      gmxIconLayers: {
        zoominpls: 'Zoom in to enable layer',
        zoomoutpls: 'Zoom out to enable layer'
      }
    });
    window.L.Control.GmxIconLayers = window.L.Control.IconLayers.extend({
      _updateLayers: function _updateLayers() {
        var lang = nsGmx$1.Translations.getLanguage();
        lang = lang || 'rus';
        var blm = this._baseLayersManager;
        var layers = blm.getActiveIDs().map(function (id) {
          var layer = blm.get(id);

          if (!layer) {
            return null;
          } else {
            return {
              layer: layer,
              icon: layer.options.icon,
              title: layer.options[lang]
            };
          }
        }).filter(function (e) {
          return e;
        });
        this.setLayers(layers);
        this.setActiveLayer(blm.get(blm.getCurrentID()));

        this._updateDisabledLayers();
      },
      _updateDisabledLayers: function _updateDisabledLayers() {
        this._disabledLayerIds = this._map ? this._baseLayersManager.getActiveIDs().map(function (id) {
          return this._baseLayersManager.get(id);
        }.bind(this)).filter(function (l) {
          return !!l && (this._map.getZoom() < l.options.minZoom || this._map.getZoom() > l.options.maxZoom);
        }.bind(this)).map(function (l) {
          return L.stamp(l) + '';
        }) : [];

        this._updateDisabledLayersStyle();
      },
      _updateDisabledLayersStyle: function _updateDisabledLayersStyle() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];
        Array.prototype.slice.call(els).map(function (el) {
          var elId = el.getAttribute('data-layerid');

          if (this._disabledLayerIds.indexOf(elId) + 1) {
            L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_disabled');
          } else {
            L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_disabled');
          }
        }.bind(this));
      },
      _updatePopoversContent: function _updatePopoversContent() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];
        var defaultTemplate = new $.fn.popover.Constructor().getDefaults().template;

        function createPopover(el, text) {
          $(el).popover({
            viewport: {
              selector: this._map && this._map.getContainer(),
              padding: 10
            },
            container: this._map && this._map.getContainer(),
            content: text,
            trigger: 'manual',
            placement: this.options.position.indexOf('bottom') != -1 ? 'top' : 'bottom',
            html: true,
            template: $(defaultTemplate).css('pointer-events', 'none')[0].outerHTML
          });

          if (el.mouseIsOver) {
            $(el).popover('show');
          }
        }

        Array.prototype.slice.call(els).map(function (el) {
          var elId = el.getAttribute('data-layerid');
          var layerEl = el.getElementsByClassName('leaflet-iconLayers-layer')[0];
          var layer = this._layers[elId].layer;

          if (layer.options.maxZoom && this._map && this._map.getZoom() > layer.options.maxZoom) {
            $(layerEl).popover('destroy');
            createPopover.call(this, layerEl, nsGmx$1.Translations.getText('gmxIconLayers.zoomoutpls'));
          } else if (layer.options.minZoom && this._map && this._map.getZoom() < layer.options.minZoom) {
            $(layerEl).popover('destroy');
            createPopover.call(this, layerEl, nsGmx$1.Translations.getText('gmxIconLayers.zoominpls'));
          } else if (layer.options.description) {
            $(layerEl).popover('destroy');
            createPopover.call(this, layerEl, layer.options.description);
          } else {
            $(layerEl).popover('destroy');
          }
        }.bind(this));
      },
      _createLayerElement: function _createLayerElement(layerObj) {
        var el = L.Control.IconLayers.prototype._createLayerElement.call(this, layerObj);

        var shutterEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerShutter');
        $(el).prepend(shutterEl);
        el.addEventListener('mouseover', function (e) {
          e.currentTarget.mouseIsOver = true;
          $(e.currentTarget).popover('show');
        });
        el.addEventListener('mouseout', function (e) {
          e.currentTarget.mouseIsOver = false;
          $(e.currentTarget).popover('hide');
        });
        return el;
      },
      _render: function _render() {
        L.Control.IconLayers.prototype._render.apply(this, arguments);

        this._updateDisabledLayers();

        this._updatePopoversContent();
      },
      _onLayerClick: function _onLayerClick(e) {
        e.stopPropagation();
        $(e.currentTarget).find('.leaflet-iconLayers-layer').popover('hide');
        var layerId = e.currentTarget.getAttribute('data-layerid');

        if (this._disabledLayerIds.indexOf(layerId) === -1) {
          var layer = this._layers[layerId];
          this.setActiveLayer(layer.layer);
        }

        this.expand();
      },
      initialize: function initialize(gmxBaseLayersManager, options) {
        L.Control.IconLayers.prototype.initialize.call(this, [], L.extend(options || {}, {
          manageLayers: false
        }));
        this._baseLayersManager = gmxBaseLayersManager;

        this._updateLayers();

        this.on('activelayerchange', function (le) {
          this._baseLayersManager.setCurrentID(le.layer.id);
        }.bind(this));

        this._baseLayersManager.on('baselayeradd', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayerremove', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayeractiveids', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayerchange', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayerlayerschange', this._updateLayers.bind(this));
      },
      onAdd: function onAdd() {
        var container = L.Control.IconLayers.prototype.onAdd.apply(this, arguments);

        this._map.on('zoomend', function () {
          this._updateDisabledLayers();

          this._updatePopoversContent();
        }.bind(this));

        return container;
      }
    });

    var DateInterval = Backbone.Model.extend({
      initialize: function initialize() {
        if (!('dateBegin' in this.attributes) && !('dateEnd' in this.attributes)) {
          this.set(DateInterval.getUTCDayBoundary());
        }
      },
      saveState: function saveState() {
        return {
          version: '1.1.0',
          dateBegin: +this.attributes.dateBegin,
          dateEnd: +this.attributes.dateEnd
        };
      },
      loadState: function loadState(state) {
        if (!state.version || state.version === '1.1.0' || state.version === '1.0.0') {
          this.set({
            dateBegin: new Date(state.dateBegin),
            dateEnd: new Date(state.dateEnd)
          });
        } else {
          throw 'Unknown state version';
        }
      }
    }, {
      //number of milliseconds in one day
      MS_IN_DAY: 24 * 3600 * 1000,
      //set time to UTC midnight
      toMidnight: function toMidnight(date) {
        return new Date(date - date % DateInterval.MS_IN_DAY);
      },
      getUTCDayBoundary: function getUTCDayBoundary(date) {
        date = date || new Date();
        var midnight = DateInterval.toMidnight(date);
        return {
          dateBegin: midnight,
          dateEnd: new Date(midnight.valueOf() + DateInterval.MS_IN_DAY)
        };
      },
      // 24+n interval
      defaultFireDateInterval: function defaultFireDateInterval() {
        var now = new Date(),
            lastMidnight = DateInterval.toMidnight(now),
            dateEnd = new Date(now - 1 - (now - 1) % (3600 * 1000) + 3600 * 1000),
            //round to the nearest hour greater then 'now'
        isTooSmall = dateEnd - lastMidnight < 12 * 3600 * 1000,
            dateBegin = new Date(isTooSmall ? lastMidnight - nsGmx$1.DateInterval.MS_IN_DAY : lastMidnight.valueOf());
        return {
          dateBegin: dateBegin,
          dateEnd: dateEnd
        };
      }
    });
    nsGmx$1.DateInterval = DateInterval;

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.CalendarWidget = {};
    nsGmx$1.Templates.CalendarWidget["CalendarWidget"] = "<table>\n" + "    <tr>\n" + "        <td><div class = \"CalendarWidget-iconScrollLeft ui-helper-noselect icon-left-open\"></div></td>\n" + "        <td class = \"CalendarWidget-inputCell\"><input class = \"gmx-input-text CalendarWidget-dateBegin\"></td>\n" + "        <td class = \"CalendarWidget-inputCell CalendarWidget-onlyMaxVersion\"><input class = \"gmx-input-text CalendarWidget-dateEnd\"></td>\n" + "        <td><div class = \"CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open\" ></div></td>\n" + "        <td><div class = \"CalendarWidget-iconMore {{moreIconClass}}\" title = \"{{moreIconTitle}}\"></div></td>\n" + "        <td><div class = \"CalendarWidget-forecast\" hidden>{{forecast}}</div></td>\n" + "    </tr><tr>\n" + "        <td></td>\n" + "        <td class = \"CalendarWidget-dateBeginInfo\"></td>\n" + "        <td class = \"CalendarWidget-dateEndInfo\"></td>\n" + "        <td></td>\n" + "        <td></td>\n" + "    </tr>\n" + "</table>\n" + "<div class=\"CalendarWidget-footer\"></div>\n" + "";

    (function ($) {

      var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations),
          toMidnight = nsGmx$1.DateInterval.toMidnight;
      /** Параметры календаря
       * @typedef nsGmx.CalendarWidget~Parameters
       * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
       * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
       * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
       * @property {String} [dateFormat='dd.mm.yy'] формат даты
       * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
       * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
       * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
       * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
       * @property {String|DOMNode} [container] куда добавлять календарик
       * @property {String} [buttonImage] URL иконки для активации календариков
       */

      /** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
       @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
                    затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
                    Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
       @alias nsGmx.CalendarWidget
       @extends nsGmx.GmxWidget
       @class
       @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
      */


      var Calendar = nsGmx$1.GmxWidget.extend({
        tagName: 'div',
        className: 'CalendarWidget ui-widget',
        template: Handlebars.compile(nsGmx$1.Templates.CalendarWidget.CalendarWidget),
        events: {
          'click .CalendarWidget-iconMore': 'toggleMode',
          'click .CalendarWidget-iconScrollLeft': function clickCalendarWidgetIconScrollLeft() {
            this._shiftDates(-1);
          },
          'click .CalendarWidget-iconScrollRight': function clickCalendarWidgetIconScrollRight() {
            this._shiftDates(1);
          }
        },
        initialize: function initialize(options) {
          options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
          }, options);
          this._dateMin = options.dateMin;
          this._dateMax = options.dateMax;
          this._dateInterval = options.dateInterval;
          this.$el.html(this.template({
            moreIconClass: options.minimized ? 'icon-calendar' : 'icon-calendar-empty',
            moreIconTitle: options.minimized ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'),
            forecast: _gtxt('CalendarWidget.forecast')
          }));
          this._moreIcon = this.$('.CalendarWidget-iconMore').toggle(!!options.showSwitcher);
          this._dateBegin = this.$('.CalendarWidget-dateBegin');
          this._dateEnd = this.$('.CalendarWidget-dateEnd');
          this._dateInputs = this._dateBegin.add(this._dateEnd);

          this._dateInputs.datepicker({
            onSelect: function (dateText, inst) {
              this._selectFunc(inst.input);

              this._updateModel();
            }.bind(this),
            showAnim: 'fadeIn',
            changeMonth: true,
            changeYear: true,
            minDate: this._dateMin ? Calendar.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar.toUTC(this._dateMax) : null,
            dateFormat: options.dateFormat,
            defaultDate: Calendar.toUTC(this._dateMax || new Date()),
            showOn: options.buttonImage ? 'both' : 'focus',
            buttonImageOnly: true
          }); //устанавливаем опцию после того, как добавили календарик в canvas


          if (options.buttonImage) {
            this._dateInputs.datepicker('option', 'buttonImage', options.buttonImage);
          }

          this.$('.CalendarWidget-onlyMaxVersion').toggle(!options.minimized);
          options.dateBegin && this._dateBegin.datepicker('setDate', Calendar.toUTC(options.dateBegin));
          options.dateEnd && this._dateEnd.datepicker('setDate', Calendar.toUTC(options.dateEnd));

          if (options.container) {
            if (typeof options.container === 'string') $('#' + options.container).append(this.$el);else $(options.container).append(this.$el);
          }

          this.setMode(options.minimized ? Calendar.SIMPLE_MODE : Calendar.ADVANCED_MODE);

          this._updateWidget();

          this._dateInterval.on('change', this._updateWidget, this); //for backward compatibility


          this.canvas = this.$el;
        },
        _shiftDates: function _shiftDates(delta) {
          var dateBegin = this.getDateBegin(),
              dateEnd = this.getDateEnd();

          if (!dateBegin || !dateEnd) {
            return;
          }

          var shift = (dateEnd - dateBegin + nsGmx$1.DateInterval.MS_IN_DAY) * delta,
              newDateBegin = new Date(dateBegin.valueOf() + shift),
              newDateEnd = new Date(dateEnd.valueOf() + shift);

          if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) && (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd))) {
            this._dateBegin.datepicker('setDate', Calendar.toUTC(newDateBegin));

            this._dateEnd.datepicker('setDate', Calendar.toUTC(newDateEnd));

            this._updateModel();
          }
        },
        _selectFunc: function _selectFunc(activeInput) {
          var begin = this._dateBegin.datepicker('getDate');

          var end = this._dateEnd.datepicker('getDate');

          if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
          } else if (this._curMode === Calendar.SIMPLE_MODE) {
            //либо установлена только одна дата, либо две, но отличающиеся
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
              this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }
          }
        },
        _updateModel: function _updateModel() {
          var dateBegin = this.getDateBegin(),
              dateEnd = this.getDateEnd();

          this._dateInterval.set({
            dateBegin: dateBegin ? toMidnight(dateBegin) : null,
            dateEnd: dateEnd ? toMidnight(dateEnd.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY) : null
          });
        },
        _updateWidget: function _updateWidget() {
          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY;

          if (!dateBegin || !dateEnd) {
            return;
          }

          var isValid = !(dateBegin % dayms) && !(dateEnd % dayms);
          var newDateBegin = Calendar.toUTC(dateBegin),
              newDateEnd;

          if (isValid) {
            newDateEnd = Calendar.toUTC(new Date(dateEnd - dayms));

            if (dateEnd - dateBegin > dayms) {
              this.setMode(Calendar.ADVANCED_MODE);
            }
          } else {
            newDateEnd = Calendar.toUTC(dateEnd);
            this.setMode(Calendar.ADVANCED_MODE);
          } //если мы сюда пришли после выбора интервала в самом виджете, вызов setDate сохраняет фокус на input-поле
          //возможно, это какая-то проблема jQueryUI.datepicker'ов.
          //чтобы этого избежать, явно проверяем, нужно ли изменять дату


          var prevDateBegin = this._dateBegin.datepicker('getDate'),
              prevDateEnd = this._dateEnd.datepicker('getDate');

          if (!prevDateBegin || prevDateBegin.valueOf() !== newDateBegin.valueOf()) {
            this._dateBegin.datepicker('setDate', newDateBegin);
          }

          if (!prevDateEnd || prevDateEnd.valueOf() !== newDateEnd.valueOf()) {
            this._dateEnd.datepicker('setDate', newDateEnd);
          }
        },
        //public interface

        /** Закрыть все открытые datepicker'ы.
         * @return {nsGmx.CalendarWidget} this
         */
        reset: function reset() {
          this._dateInputs.datepicker('hide');

          return this;
        },

        /** Сериализация состояния виджета
         * @return {Object} Сериализованное состояние
         */
        saveState: function saveState() {
          return {
            version: '1.1.0',
            vismode: this.getMode()
          };
        },

        /** Восстановить состояние виджета по сериализованным данным
         * @param {Object} data Сериализованное состояние календарика
         */
        loadState: function loadState(data) {
          this.setMode(data.vismode);
        },

        /** Получить начальную дату
         * @return {Date} начальная дата
         */
        getDateBegin: function getDateBegin() {
          return Calendar.fromUTC(this._dateBegin.datepicker('getDate'));
        },

        /** Получить конечную дату
         * @return {Date} конечная дата
         */
        getDateEnd: function getDateEnd() {
          return Calendar.fromUTC(this._dateEnd.datepicker('getDate'));
        },

        /** Получить верхнюю границу возможных дат периода
         * @return {Date} верхняя граница возможных периодов
         */
        getDateMax: function getDateMax() {
          return this._dateMax;
        },

        /** Получить нижнуюю границу возможных дат периода
         * @return {Date} нижняя граница возможных периодов
         */
        getDateMin: function getDateMin() {
          return this._dateMin;
        },

        /** Установить нижнуюю границу возможных дат периода
         * @param {Date} dateMin нижняя граница возможных периодов
         */
        setDateMin: function setDateMin(dateMin) {
          this._dateMin = dateMin;

          this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar.toUTC(dateMin) : null);
        },

        /** Установить верхнюю границу возможных дат периода
         * @param {Date} dateMax верхняя граница возможных периодов
         */
        setDateMax: function setDateMax(dateMax) {
          var titleContainer = this.$('.CalendarWidget-forecast');
          this._dateMax = dateMax;

          if (dateMax) {
            var utcDate = Calendar.toUTC(dateMax);

            this._dateInputs.datepicker('option', 'maxDate', utcDate);

            if (dateMax > new Date()) {
              $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' + ('0' + dateMax.getDate()).slice(-2) + '.' + ('0' + (dateMax.getMonth() + 1)).slice(-2) + '.' + dateMax.getFullYear());
              $(titleContainer).show();
            } else {
              $(titleContainer).hide();
            }
          } else {
            this._dateInputs.datepicker('option', 'maxDate', null);
          }
        },
        setSwitcherVisibility: function setSwitcherVisibility(isVisible) {
          this._moreIcon && this._moreIcon.toggle(isVisible);
        },
        getDateInterval: function getDateInterval() {
          return this._dateInterval;
        },
        getMode: function getMode() {
          return this._curMode;
        },
        setMode: function setMode(mode) {
          if (this._curMode === mode) {
            return this;
          }

          this.reset();
          this._curMode = mode;
          var isSimple = mode === Calendar.SIMPLE_MODE;
          this.$('.CalendarWidget-onlyMaxVersion').toggle(!isSimple);

          this._moreIcon.toggleClass('icon-calendar', isSimple).toggleClass('icon-calendar-empty', !isSimple).attr('title', isSimple ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'));

          var dateBegin = this._dateBegin.datepicker('getDate'),
              dateEnd = this._dateEnd.datepicker('getDate');

          if (isSimple && dateBegin && dateEnd && dateBegin.valueOf() !== dateEnd.valueOf()) {
            this._selectFunc(this._dateEnd);

            this._updateModel();
          }

          this.trigger('modechange');
          return this;
        },
        toggleMode: function toggleMode() {
          this.setMode(this._curMode === Calendar.SIMPLE_MODE ? Calendar.ADVANCED_MODE : Calendar.SIMPLE_MODE);
        }
      }, {
        /* static methods */
        fromUTC: function fromUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() - timeOffset);
        },
        toUTC: function toUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() + timeOffset);
        },
        SIMPLE_MODE: 1,
        ADVANCED_MODE: 2
      });
      nsGmx$1.CalendarWidget = Calendar;
    })(jQuery);

    nsGmx$1.Translations.addText("rus", {
      CalendarWidget: {
        ExtendedViewTitle: "Выбор периода",
        MinimalViewTitle: "Свернуть",
        UTC: "Всемирное координированное время",
        forecast: "прогноз",
        tooltip: "доступны прогнозные данные до"
      }
    });
    nsGmx$1.Translations.addText("eng", {
      CalendarWidget: {
        ExtendedViewTitle: "Period selection",
        MinimalViewTitle: "Minimize",
        UTC: "Coordinated Universal Time",
        forecast: "forecast",
        tooltip: "forecast data is available up to"
      }
    });
    /** Контрол для задания диапазона дат с логикой работы, взятой с сайта fires.ru.
     @description Основное отличае в логине формировании интервала на основе выбранных в календариках дат.
                  Работает так же, как и обычный виджет ({@link nsGmx.CalendarWidget}) за исключением ситуации, когда dateEnd попадает в текущие UTC сутки.
                  В этом случае, dateEnd устанавливается равном началу следующего часа. Далее, если длина выбранного интервала меньше 12 часов, начало интервала смещается на сутки назад.
                  Кроме формирования интервала, этот виджет показывает пользователю дополнительную информацию о выбранном интервале.
     @alias nsGmx.FireCalendarWidget
     @class
     @param {nsGmx.CalendarWidget~Parameters} params Параметры календаря
    */

    (function ($) {

      var toMidnight = nsGmx$1.DateInterval.toMidnight;
      nsGmx$1.Translations.addText("rus", {
        FireCalendarWidget: {
          timeTitlePrefix: 'За ',
          timeTitleLastPrefix: 'За последние ',
          timeTitlePostfix: 'ч (UTC)'
        }
      });
      nsGmx$1.Translations.addText("eng", {
        FireCalendarWidget: {
          timeTitlePrefix: 'For ',
          timeTitleLastPrefix: 'For last ',
          timeTitlePostfix: 'h (UTC)'
        }
      });

      function f(n) {
        return n < 10 ? '0' + n : n;
      }

      function getStr(hours, minutes) {
        return f(hours) + ":" + f(minutes);
        /*+ ":" + f(time.seconds)*/
      }

      var FireCalendarWidget = nsGmx$1.CalendarWidget.extend({
        initialize: function initialize(options) {
          options = $.extend({
            dateMax: new Date()
          }, options);
          nsGmx$1.CalendarWidget.prototype.initialize.call(this, options);

          this._dateInterval.on('change', this._updateInfo, this);

          this.on('modechange', this._updateInfo, this);
          this.on('modechange', this._updateModel, this);

          this._updateInfo();
        },
        _updateModel: function _updateModel() {
          var dateBegin = this.getDateBegin(),
              origDateEnd = this.getDateEnd(),
              now = new Date(),
              lastMidnight = toMidnight(now),
              dateEnd;

          if (lastMidnight <= origDateEnd) {
            //last day
            dateEnd = new Date(now - 1 - (now - 1) % (3600 * 1000) + 3600 * 1000); //round to the nearest hour greater then 'now'

            if (dateEnd - toMidnight(dateBegin) < 12 * 3600 * 1000 && this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE) {
              dateBegin = new Date(dateBegin - nsGmx$1.DateInterval.MS_IN_DAY);
            }
          } else {
            //previous days
            dateEnd = new Date(origDateEnd.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY);
          }

          this._dateInterval.set({
            dateBegin: toMidnight(dateBegin),
            dateEnd: dateEnd
          });
        },
        _updateWidget: function _updateWidget() {
          var dateBegin = +this._dateInterval.get('dateBegin'),
              dateEnd = +this._dateInterval.get('dateEnd');

          if (!dateBegin || !dateEnd) {
            return;
          }

          var currentDayMode = toMidnight(new Date()) < dateEnd;

          if (currentDayMode && this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE && dateEnd - dateBegin < 2 * nsGmx$1.DateInterval.MS_IN_DAY) {
            this._dateBegin.datepicker("setDate", nsGmx$1.CalendarWidget.toUTC(new Date()));

            this._dateEnd.datepicker("setDate", nsGmx$1.CalendarWidget.toUTC(new Date()));
          } else if (nsGmx$1.CalendarWidget1) {
            nsGmx$1.CalendarWidget1.prototype._updateWidget.call(this);
          } else {
            nsGmx$1.CalendarWidget.prototype._updateWidget.call(this);
          }
        },
        _updateInfo: function _updateInfo() {
          var isSimpleMode = this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE;
          this.$('.CalendarWidget-footer').toggle(isSimpleMode);
          this.$('.CalendarWidget-dateBeginInfo, .CalendarWidget-dateEndInfo').toggle(!isSimpleMode);

          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd');

          if (!dateBegin || !dateEnd) {
            return;
          }

          var hours = Math.ceil((dateEnd - dateBegin) / 3600000);

          if (isSimpleMode) {
            var hoursStr = hours > 24 ? "24+" + (hours - 24) : hours;
            var prefix = hours === 24 ? _gtxt("FireCalendarWidget.timeTitlePrefix") : _gtxt("FireCalendarWidget.timeTitleLastPrefix");
            this.$('.CalendarWidget-footer').html(prefix + hoursStr + _gtxt("FireCalendarWidget.timeTitlePostfix"));
          } else {
            var dateEndToShow = hours % 24 === 0 ? new Date(+dateEnd - 1) : dateEnd; //hack to show 23:59 instead of 00:00

            this.$('.CalendarWidget-dateBeginInfo').text(getStr(dateBegin.getUTCHours(), dateBegin.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
            this.$('.CalendarWidget-dateEndInfo').text(getStr(dateEndToShow.getUTCHours(), dateEndToShow.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
          }
        }
      }, {
        defaultFireDateInterval: function defaultFireDateInterval() {
          var now = new Date(),
              lastMidnight = toMidnight(now),
              dateEnd = new Date(now - 1 - (now - 1) % (3600 * 1000) + 3600 * 1000),
              //round to the nearest hour greater then 'now'
          isTooSmall = dateEnd - lastMidnight < 12 * 3600 * 1000,
              dateBegin = new Date(isTooSmall ? lastMidnight - nsGmx$1.DateInterval.MS_IN_DAY : lastMidnight.valueOf());
          return {
            dateBegin: dateBegin,
            dateEnd: dateEnd
          };
        }
      });
      nsGmx$1.FireCalendarWidget = FireCalendarWidget;
    })(jQuery);

    (function ($) {

      var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations),
          toMidnight = nsGmx$1.DateInterval.toMidnight;

      nsGmx$1.Translations.addText("rus", {
        CalendarWidget: {
          ShowIconTitle: "Выбрать дату",
          createDateInterval: "Задать интервал",
          resetDateInterval: "Сбросить интервал",
          selectDateInterval: "Применить",
          hour: "ч.",
          from: "с",
          to: "до"
        }
      });
      nsGmx$1.Translations.addText("eng", {
        CalendarWidget: {
          ShowIconTitle: "Select date",
          createDateInterval: "Create date interval",
          resetDateInterval: "Reset date interval",
          selectDateInterval: "Select date interval",
          hour: "h.",
          from: "from",
          to: "to"
        }
      });
      var template = '' + '<div>' + '<div class = "CalendarWidget-row CalendarWidget-dates">' + // dates block
      '<span class = "CalendarWidget-iconScrollLeft icon-left-open"></span>' + '<span class = "CalendarWidget-dates-outside">' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputBegin">' + '<input class = "CalendarWidget-dateBegin">' + '</span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle">-</span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputEnd">' + '<input class = "CalendarWidget-dateEnd">' + '</span>' + '</span>' + '<span class = "CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open"></span>' + // space between dates and time
      '<span class = "CalendarWidget-space"></span>' + // times block
      '<span class = "CalendarWidget-timeicon"><img src="img/time-icon-01.svg"></img></span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeBegin"><input class = "CalendarWidget-timeInput CalendarWidget-timeBegin" value={{hourBegin}} ></span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle CalendarWidget-inputCell-inputTimeMiddle">-</span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeEnd"><input class = "CalendarWidget-timeInput CalendarWidget-timeEnd" value={{hourEnd}}></span>' + '</div>' + '</div>';
      /** Параметры календаря
       * @typedef nsGmx.CalendarWidget~Parameters
       * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
       * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
       * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
       * @property {String} [dateFormat='dd.mm.yy'] формат даты
       * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
       * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
       * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
       * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
       * @property {String|DOMNode} [container] куда добавлять календарик
       * @property {String} [buttonImage] URL иконки для активации календариков
       */

      /** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
       @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
                    затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
                    Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
       @alias nsGmx.CalendarWidget
       @extends nsGmx.GmxWidget
       @class
       @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
      */

      var CalendarModel = window.Backbone.Model.extend({
        defaults: {
          dailyFilter: true
        }
      });
      var Calendar1 = window.Backbone.View.extend({
        tagName: 'div',
        model: new CalendarModel(),
        className: 'CalendarWidget ui-widget',
        template: Handlebars.compile(template),
        events: {
          'click .CalendarWidget-dates-outside .CalendarWidget-inputCell': function clickCalendarWidgetDatesOutsideCalendarWidgetInputCell(e) {
            e.stopPropagation();
            this.showCalendar(e);
            $(e.target).focus();
          },
          'keydown .CalendarWidget-dateBegin': function keydownCalendarWidgetDateBegin(e) {
            this.manuallyChangeDateInterval(e, 'begin');
          },
          'keydown .CalendarWidget-dateEnd': function keydownCalendarWidgetDateEnd(e) {
            this.manuallyChangeDateInterval(e, 'end');
          },
          'click .CalendarWidget-iconScrollLeft': function clickCalendarWidgetIconScrollLeft() {
            this._shiftDates(-1);
          },
          'click .CalendarWidget-iconScrollRight': function clickCalendarWidgetIconScrollRight() {
            this._shiftDates(1);
          },
          'keydown .CalendarWidget-inputCell-inputTimeBegin': function keydownCalendarWidgetInputCellInputTimeBegin(e) {
            this.jumpByArrow(e, 'left');
          },
          'keydown .CalendarWidget-inputCell-inputTimeEnd': function keydownCalendarWidgetInputCellInputTimeEnd(e) {
            this.jumpByArrow(e, 'right');
          }
        },
        initialize: function initialize(options) {
          var _this = this;

          options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
          }, options);
          this._dateMin = options.dateMin;
          this._dateMax = options.dateMax;
          this._dateInterval = options.dateInterval;
          this._opened = false;
          $.datepicker.setDefaults({
            onSelect: function (dateText, inst) {
              this._selectFunc(inst.input);
            }.bind(this),
            minDate: this._dateMin ? Calendar1.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar1.toUTC(this._dateMax) : null,
            changeMonth: true,
            changeYear: true,
            dateFormat: 'dd.mm.yy',
            defaultDate: Calendar1.toUTC(this._dateMax || new Date()),
            buttonImageOnly: true,
            constrainInput: true
          });
          this.calendarTemplates = {
            beginTemplate: Handlebars.compile('' + '<div class="outside-calendar-container">' + '<div class="begin-outside-calendar">' + '</div>' + '<div class="time-container begin-time-container">' + '</div>' + '<div class="time-placeholder begin-time-placeholder" hidden>' + '</div>' + '<span class="calendar-button createdateinterval-button">' + '{{i "CalendarWidget.createDateInterval"}}' + '</span>' + '<span class="calendar-button resetdateinterval-button" hidden>' + '{{i "CalendarWidget.resetDateInterval"}}' + '</span>' + '</div>'),
            endTemplate: Handlebars.compile('' + '<div class="outside-calendar-container">' + '<div class="end-outside-calendar">' + '</div>' + '<div class="time-container end-time-container">' + '</div>' + '<div class="time-placeholder end-time-placeholder" hidden>' + '</div>' + '<span class="calendar-button selectdateinterval-button disabled">' + '{{i "CalendarWidget.selectDateInterval"}}' + '</span>' + '</div>')
          };

          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              hourBegin = Calendar1.getTime(dateBegin, 'begin'),
              hourEnd = Calendar1.getTime(dateEnd, 'end');

          this.$el.html(this.template({
            showCalendarIconClass: 'icon-calendar-empty',
            showCalendarIconTitle: _gtxt('CalendarWidget.ShowIconTitle'),
            hourBegin: hourBegin,
            hourEnd: hourEnd
          })); // если есть контейнер, куда прикреплять виджет календаря

          if (options.container) {
            if (typeof options.container === 'string') $('#' + options.container).append(this.$el);else $(options.container).append(this.$el);
          }

          this._updateWidget();

          this._dateInterval.on('change', this._updateWidget, this);

          this.listenTo(this.model, 'change:dailyFilter', this.enableDailyFilter);
          $('#leftMenu').on('click', function (e) {
            if (e.target.className !== 'CalendarWidget-show-calendar-icon icon-calendar-empty' && e.target.className !== 'layers-before' && !(e.target.className instanceof SVGAnimatedString) && e.target.className.indexOf('CalendarWidget-timeInput') === -1 && e.target.className !== 'calendar-container') {
              $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
              _this._opened = false;
            }
          });
          this.$('.CalendarWidget-timeInput').on('blur', this._selectTime.bind(this)); //for backward compatibility

          this.canvas = this.$el;
        },
        manuallyChangeDateInterval: function manuallyChangeDateInterval(e, type) {
          if (e.keyCode !== 13) return;
          e.preventDefault();
          e.stopPropagation();

          var value = $(e.target).val(),
              beginInput = this.$('.CalendarWidget-dateBegin')[0],
              endInput = this.$('.CalendarWidget-dateEnd')[0],
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              // endMidnight = (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()),
          oneDayPeriod,
              parsed;

          try {
            parsed = $.datepicker.parseDate('dd.mm.yy', value);
          } catch (e) {
            return;
          } // handle errors and too large values


          if (!parsed || parsed < this._dateMin || parsed > this._dateMax) {
            return;
          }

          parsed = nsGmx$1.CalendarWidget1.fromUTC(parsed);
          oneDayPeriod = parsed.valueOf() === dateBegin.valueOf();
          oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

          if (type === 'begin') {
            this._dateBegin.datepicker('setDate', parsed);

            if (parsed > new Date(dateEnd.valueOf() - dayms)) {
              this._dateEnd.datepicker('setDate', parsed);

              $(endInput).val(e.target.value);

              this._selectFunc(endInput);
            }

            this._dateInterval.set({
              dateBegin: new Date(parsed.valueOf()),
              dateEnd: new Date(parsed.valueOf() + dayms)
            });
          } else {
            this._dateEnd.datepicker('setDate', parsed);

            if (parsed < dateBegin) {
              this._dateBegin.datepicker('setDate', parsed);

              $(beginInput).val(e.target.value);

              this._selectFunc(beginInput);

              this._dateInterval.set({
                dateBegin: new Date(parsed.valueOf()),
                dateEnd: new Date(parsed.valueOf() + dayms)
              });
            } else if (parsed > dateBegin) {
              this._dateInterval.set({
                dateEnd: new Date(parsed.valueOf() + dayms)
              });
            }
          }

          this._selectFunc(e.target);

          this.showCalendar(e);
        },
        enableDailyFilter: function enableDailyFilter() {
          var dailyFilter = this.model.get('dailyFilter'),
              timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
              timeEndValue = this.$('.CalendarWidget-timeEnd').val();

          if (dailyFilter) {
            if (Number(timeBeginValue) >= Number(timeEndValue)) {
              this.$('.CalendarWidget-timeBegin').addClass('error');
              this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
              this.$('.CalendarWidget-timeEnd').addClass('error');
            } else {
              this.$('.CalendarWidget-timeBegin').removeClass('error');
              this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
              this.$('.CalendarWidget-timeEnd').removeClass('error');
            }
          } else {
            this.$('.CalendarWidget-timeBegin').removeClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
            this.$('.CalendarWidget-timeEnd').removeClass('error');
          }

          this.$('.CalendarWidget-timeBegin').trigger('blur');
          this.$('.CalendarWidget-timeEnd').trigger('blur');
        },
        _selectTime: function _selectTime(e) {
          var match = this._checkValue(e.target.value);

          if (!match) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
          } // $(e.target).removeClass('error');
          // var isBegin = $(e.target).hasClass('CalendarWidget-timeBegin'),
          //     dayms = nsGmx.DateInterval.MS_IN_DAY,


          var dailyFilter = this.model.get('dailyFilter'),
              timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
              timeEndValue = this.$('.CalendarWidget-timeEnd').val(),
              msBeginInputValue = Calendar1.convertTimeValueToMs(timeBeginValue),
              msEndInputValue = Calendar1.convertTimeValueToMs(timeEndValue),
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              hourBegin = Calendar1.getTime(dateBegin, 'begin'),
              hourEnd = Calendar1.getTime(dateEnd, 'end'),
              msBegin = Calendar1.convertTimeValueToMs(hourBegin),
              msEnd = Calendar1.convertTimeValueToMs(hourEnd),
              newDateBegin = new Date(dateBegin.valueOf() + (msBeginInputValue - msBegin)),
              newDateEnd = new Date(dateEnd.valueOf() + (msEndInputValue - msEnd));

          if (dailyFilter && Number(timeBeginValue) >= Number(timeEndValue)) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
          }

          if (newDateBegin.valueOf() >= newDateEnd.valueOf()) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
          } else {
            this.$('.CalendarWidget-timeBegin').removeClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
            this.$('.CalendarWidget-timeEnd').removeClass('error');
          }

          this._dateInterval.set({
            dateBegin: newDateBegin,
            dateEnd: newDateEnd
          });
        },
        _checkValue: function _checkValue(value) {
          var hours = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24'],
              match = false;

          for (var i = 0; i < hours.length; i++) {
            if (value === hours[i]) {
              match = true;
            }
          }

          return match;
        },
        showCalendar: function showCalendar() {
          var _this = this,
              // beginInput = this.$('.CalendarWidget-dateBegin')[0],
          // endInput = this.$('.CalendarWidget-dateEnd')[0],
          dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              oneDayPeriod = dateEnd.valueOf() - dateBegin.valueOf() === dayms,
              endMidnight = dateEnd.valueOf() === toMidnight(dateEnd).valueOf();

          this.beginCalendar = $(this.calendarTemplates.beginTemplate({
            oneDayPeriod: oneDayPeriod
          }));
          this.endCalendar = $(this.calendarTemplates.endTemplate({}));
          var createIntervalButton = $('.createdateinterval-button', this.beginCalendar),
              resetIntervalButton = $('.resetdateinterval-button', this.beginCalendar),
              selectIntervalButton = $('.selectdateinterval-button', this.endCalendar),
              beginDialogOptions = {
            dialogClass: "calendar-outside begin-calendar",
            draggable: false,
            resizable: false,
            width: 224.8,
            height: 280,
            position: [372, 105],
            resizeFunc: function resizeFunc() {
              return false;
            },
            closeFunc: function closeFunc() {
              _this._dateBegin.datepicker("destroy");
            }
          },
              endDialogOptions = {
            dialogClass: "calendar-outside end-calendar",
            draggable: false,
            resizable: false,
            width: 224.8,
            height: 280,
            position: [610, 105],
            resizeFunc: function resizeFunc() {
              return false;
            },
            closeFunc: function closeFunc() {
              _this._dateEnd.datepicker("destroy");
            }
          };

          if (this._opened) {
            $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
            this._opened = false;
          }

          oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);
          this._dateBegin = $('.begin-outside-calendar', this.beginCalendar);
          this._dateEnd = $('.end-outside-calendar', this.endCalendar);
          this._dateInputs = this._dateBegin.add(this._dateEnd);

          this._dateInputs.datepicker();

          this._dateInputs.datepicker('option', 'minDate', Calendar1.toUTC(this._dateMin));

          this._dateInputs.datepicker('option', 'maxDate', Calendar1.toUTC(this._dateMax));

          this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));

          this._dateEnd.datepicker('setDate', oneDayPeriod || endMidnight ? Calendar1.toUTC(new Date(dateEnd.valueOf() - dayms)) : Calendar1.toUTC(dateEnd));

          $(this.beginCalendar).dialog(beginDialogOptions);
          this._opened = true;

          if (this.getMode() === Calendar1.ADVANCED_MODE) {
            $(createIntervalButton).toggle(false);
            $(resetIntervalButton).toggle(true);
            $(this.endCalendar).dialog(endDialogOptions);
            this._opened = true;
          } // кнопки в первом календаре


          $(createIntervalButton).on('click', function () {
            // var begin = _this._dateInterval.get('dateBegin'),
            //     end = _this._dateInterval.get('dateEnd');
            _this.setMode(Calendar1.ADVANCED_MODE);

            $(_this.endCalendar).dialog(endDialogOptions);
            _this._opened = true;
            $(this).toggle(false);
            $(resetIntervalButton).toggle(true);
          });
          $(resetIntervalButton).on('click', function () {
            var dateBegin = toMidnight(_this._dateInterval.get('dateBegin'));

            _this.setMode(Calendar1.SIMPLE_MODE);

            _this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));

            _this._dateEnd.datepicker('setDate', Calendar1.toUTC(dateBegin));

            $(".calendar-outside.end-calendar .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;
            $(this).toggle(false);
            $(createIntervalButton).toggle(true);

            _this._dateInterval.set({
              dateBegin: dateBegin,
              dateEnd: new Date(dateBegin.valueOf() + dayms)
            });
          }); // кнопка во втором календаре

          $(selectIntervalButton).on('click', function () {
            _this._updateModel();

            _this.setActive(true);

            _this._enableCreateIntervalButton();

            $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;
          });
        },
        _enableCreateIntervalButton: function _enableCreateIntervalButton(e) {
          // var dayms = nsGmx.DateInterval.MS_IN_DAY,
          var selectIntervalButton = $('.selectdateinterval-button'),
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              beginTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeBegin', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeBegin').val()),
              endTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeEnd', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeEnd').val()),
              calendarDateBegin = this.getDateBegin(),
              calendarDateEnd = this.getDateEnd(),
              newDateBegin = new Date(calendarDateBegin.valueOf() + beginTimeValue),
              newDateEnd = new Date(calendarDateEnd.valueOf() + endTimeValue); // если даты в итоге не поменялись или вторая дата больше первой


          if (newDateBegin.valueOf() === dateBegin.valueOf() && newDateEnd.valueOf() === dateEnd.valueOf() || newDateBegin.valueOf() >= newDateEnd.valueOf()) {
            $(selectIntervalButton).addClass('disabled');
          } else {
            $(selectIntervalButton).removeClass('disabled');
          }
        },
        _shiftDates: function _shiftDates(delta) {
          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              dailyFilter = this.model.get('dailyFilter'),
              shift;

          if (!dateBegin || !dateEnd) {
            return;
          }

          if (dailyFilter) {
            var diff = toMidnight(dateEnd) - toMidnight(dateBegin);
            shift = diff ? diff * delta : dayms * delta;
          } else {
            shift = (dateEnd - dateBegin) * delta;
          }

          var newDateBegin = new Date(dateBegin.valueOf() + shift),
              newDateEnd = new Date(dateEnd.valueOf() + shift);

          if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) && (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd))) {
            this._dateInterval.set({
              dateBegin: newDateBegin ? newDateBegin : null,
              dateEnd: newDateEnd ? newDateEnd : null
            });
          }
        },
        _selectFunc: function _selectFunc(activeInput) {
          var begin = this.getDateBegin(),
              end = this.getDateEnd(); // dayms = nsGmx.DateInterval.MS_IN_DAY,
          // selectIntervalButton = $('.selectdateinterval-button');

          if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
          }

          if (this._curMode === Calendar1.SIMPLE_MODE) {
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
              this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }

            this._dateInterval.set({
              dateBegin: begin ? begin : null,
              dateEnd: end ? new Date(begin.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY) : null
            });
          } else if (this._curMode === Calendar1.ADVANCED_MODE) {
            this._enableCreateIntervalButton();
          }
        },
        _updateModel: function _updateModel() {
          // получаем значения с дейтпикеров и переводим их в локальное время
          var dateBegin = this.getDateBegin(),
              dateEnd = this.getDateEnd(),
              // значение часов
          beginTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeBegin').val()),
              endTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeEnd').val()); //var  dayms = nsGmx.DateInterval.MS_IN_DAY;
          // если второй день захвачен полностью
          //var fullDay = endTimeValue === dayms;
          // добавим время к часам (в локальном времени)

          dateBegin = new Date(dateBegin.valueOf() + beginTimeValue);
          dateEnd = new Date(dateEnd.valueOf() + endTimeValue);

          this._dateInterval.set({
            dateBegin: dateBegin ? dateBegin : null,
            dateEnd: dateEnd ? dateEnd : null
          });
        },
        _updateWidget: function _updateWidget() {
          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              hourBegin = Calendar1.getTime(dateBegin, 'begin'),
              hourEnd = Calendar1.getTime(dateEnd, 'end'),
              beginInput = this.$('.CalendarWidget-dateBegin')[0],
              endInput = this.$('.CalendarWidget-dateEnd')[0],
              timeBegin = this.$('.CalendarWidget-timeBegin')[0],
              timeEnd = this.$('.CalendarWidget-timeEnd')[0],
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              newDateEnd;

          if (!dateBegin || !dateEnd) {
            return;
          }

          var newDateBegin = Calendar1.toUTC(dateBegin);
          newDateEnd = Calendar1.toUTC(new Date(dateEnd)); // если календарь показывает ровно один день,
          // прибавляем 24 часа к первой дате, чтобы получить сутки

          if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
            newDateEnd = Calendar1.toUTC(new Date(dateEnd - dayms));
          }

          $(beginInput).val(Calendar1.formatDate(newDateBegin));
          $(endInput).val(Calendar1.formatDate(newDateEnd));
          $(timeBegin).val(Calendar1.prefixTimeValue(hourBegin));
          $(timeEnd).val(Calendar1.prefixTimeValue(hourEnd));
          this.enableDailyFilter && this.enableDailyFilter();
        },
        setActive: function setActive(value) {
          var active = this.active;

          if (value !== active) {
            this.active = value;
          }

          if (this.active) {
            this.$el.removeClass('gmx-disabled');
          } else {
            this.$el.addClass('gmx-disabled');
          }
        },
        jumpByArrow: function jumpByArrow(e, type) {
          var target = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input') : this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input'),
              source = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input') : this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input'),
              sourceElem = $(source).get(0),
              strEnd;

          switch (type) {
            case 'left':
              if (e.key === 'ArrowRight' && e.target.value.length === e.target.selectionEnd) {
                $(target).blur();
                $(source).focus();
                strEnd = sourceElem.value.length || 0;
                setTimeout(function () {
                  sourceElem.setSelectionRange(strEnd, strEnd);
                }, 0);
              }

              break;

            case 'right':
              if (e.key === 'ArrowLeft' && e.target.selectionStart === 0) {
                $(target).blur();
                $(source).focus();
                strEnd = sourceElem.value.length || 0;
                setTimeout(function () {
                  sourceElem.setSelectionRange(strEnd, strEnd);
                }, 0);
              }

              break;

            default:
              return;
          }
        },
        //public interface

        /** Закрыть все открытые datepicker'ы.
         * @return {nsGmx.CalendarWidget} this
         */
        reset: function reset() {
          this._dateInputs.datepicker('hide');

          return this;
        },

        /** Сериализация состояния виджета
         * @return {Object} Сериализованное состояние
         */
        saveState: function saveState() {
          return {
            version: '1.1.0',
            vismode: this.getMode()
          };
        },

        /** Восстановить состояние виджета по сериализованным данным
         * @param {Object} data Сериализованное состояние календарика
         */
        loadState: function loadState(data) {
          this.setMode(data.vismode);
        },

        /** Получить начальную дату
         * @return {Date} начальная дата
         */
        getDateBegin: function getDateBegin() {
          return this._dateBegin ? Calendar1.fromUTC(this._dateBegin.datepicker('getDate')) : this.getDateInterval().get('dateBegin');
        },

        /** Получить конечную дату
         * @return {Date} конечная дата
         */
        getDateEnd: function getDateEnd() {
          return this._dateEnd ? Calendar1.fromUTC(this._dateEnd.datepicker('getDate')) : this.getDateInterval().get('dateEnd');
        },

        /** Получить верхнюю границу возможных дат периода
         * @return {Date} верхняя граница возможных периодов
         */
        getDateMax: function getDateMax() {
          return this._dateMax;
        },

        /** Получить нижнуюю границу возможных дат периода
         * @return {Date} нижняя граница возможных периодов
         */
        getDateMin: function getDateMin() {
          return this._dateMin;
        },

        /** Установить нижнуюю границу возможных дат периода
         * @param {Date} dateMin нижняя граница возможных периодов
         */
        setDateMin: function setDateMin(dateMin) {
          this._dateMin = dateMin;

          this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar1.toUTC(dateMin) : null);
        },

        /** Установить верхнюю границу возможных дат периода
         * @param {Date} dateMax верхняя граница возможных периодов
         */
        setDateMax: function setDateMax(dateMax) {
          // var titleContainer = this.$('.CalendarWidget-forecast');
          this._dateMax = dateMax;

          if (dateMax) {
            var utcDate = Calendar1.toUTC(dateMax);

            if (this._dateInputs) {
              this._dateInputs.datepicker('option', 'maxDate', utcDate);
            }
          } else if (this._dateInputs) {
            this._dateInputs.datepicker('option', 'maxDate', null);
          }
        },
        setSwitcherVisibility: function setSwitcherVisibility(isVisible) {
          this._showCalendarIcon && this._showCalendarIcon.toggle(isVisible);
        },
        getDateInterval: function getDateInterval() {
          return this._dateInterval;
        },
        getMode: function getMode() {
          return this._curMode;
        },
        setMode: function setMode(mode) {
          if (this._curMode === mode) {
            return this;
          }

          this._curMode = mode;
        }
      }, {
        /* static methods */
        // date показывает в utc
        // нужно вычесть отрицательную разницу
        // utc 13:00
        // 13:00 - (-3 часа) = 16:00
        // locale 16:00
        // return locale date
        fromUTC: function fromUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() - timeOffset);
        },
        toUTC: function toUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() + timeOffset);
        },
        formatDate: function formatDate(date) {
          var d = new Date(date),
              month = '' + (d.getMonth() + 1),
              day = '' + d.getDate(),
              year = d.getFullYear();
          if (month.length < 2) month = '0' + month;
          if (day.length < 2) day = '0' + day;
          return [day, month, year].join('.');
        },
        convertTimeValueToMs: function convertTimeValueToMs(value) {
          var ms = Number(value) * 1000 * 3600;
          return ms;
        },
        getTime: function getTime(date, position) {
          var dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              offset,
              hours;

          if (position === 'begin') {
            offset = date.valueOf() - toMidnight(date).valueOf();
          } else if (date.valueOf() === toMidnight(date).valueOf()) {
            offset = dayms;
          } else {
            offset = date.valueOf() - toMidnight(date).valueOf();
          }

          hours = offset / (3600 * 1000);
          return hours;
        },
        prefixTimeValue: function prefixTimeValue(value) {
          value = Number(value);
          return value < 10 ? '0' + value : String(value);
        },
        SIMPLE_MODE: 1,
        ADVANCED_MODE: 2
      });
      nsGmx$1.CalendarWidget1 = Calendar1;
    })(jQuery);

    // COMMON CalendarWidget

    (function ($) {
      nsGmx$1.Translations.addText("rus", {
        CommonCalendarWidget: {
          Timeline: "Таймлайн",
          select: "Выберите мультивременной слой",
          sync: "Единый интервал для слоев",
          daily: "посуточно",
          on: "Включить синхронизацию слоев",
          off: "Выключить синхронизацию слоев",
          all: "Интервал для всех слоев"
        }
      });
      nsGmx$1.Translations.addText("eng", {
        CommonCalendarWidget: {
          Timeline: "Timeline",
          select: "Select temporal layer",
          sync: "Single date interval",
          daily: "daily",
          on: "Layers sync on",
          off: "Layers sync off",
          all: "Интервал для всех слоев"
        }
      });
      var toMidnight = nsGmx$1.DateInterval.toMidnight,
          dayms = nsGmx$1.DateInterval.MS_IN_DAY;
      var calendarWidgetTemplate = '' + '<div class="commoncalendar-container">' + '<div class="calendar-layers-container">' + '<div class="calendar-container">' + '<div class="calendar-widget-container"></div>' + '</div>' + '</div>' + '<div class="sync-switch-container switch-container">' + '<label class="sync-switch switch">' + '<input type="checkbox"' + '{{#if synchronyzed}}checked{{/if}}' + '>' + '<div class="sync-switch-slider switch-slider round"></div>' + '</label>' + '<span class="sync-switch-slider-description">{{i "CommonCalendarWidget.sync"}}</span>' + '<label class="daily-switch">' + '<input type="checkbox"' + '{{#if dailyFilter}}checked{{/if}}' + '>' + '{{i "CommonCalendarWidget.daily"}}' + '</label>' + '</div>' + '<div class="unsync-layers-container" style="display: none">' + '<select class="layersList">' + '{{#each this.layers}}' + '<option value="{{this.layer}}"' + '{{#if this.current}} selected="selected"{{/if}}>' + '{{this.layer}}' + '</option>' + '{{/each}}' + '</select>' + '</div>' + '</div>';
      var CommonCalendarModel = Backbone.Model.extend({
        defaults: {
          active: true,
          currentLayer: null,
          calendar: null,
          isAppended: false,
          unbindedTemporalLayers: {},
          dailyFiltersHash: {},
          dailyFilter: true,
          synchronyzed: true
        }
      });
      var CommonCalendar = Backbone.View.extend({
        tagName: 'div',
        model: new CommonCalendarModel(),
        className: 'CommonCalendarWidget ui-widget',
        template: Handlebars.compile(calendarWidgetTemplate),
        events: {
          'change .sync-switch': 'toggleSync',
          'change .daily-switch': 'toggleDailyFilter',
          'change .layersList': 'changeCurrentLayer'
        },
        initialize: function initialize() {
          var _this = this;

          this.$el.html(this.template({
            synchronyzed: _this.model.get('synchronyzed'),
            layers: _this.model.get('visibleTemporalLayers'),
            dailyFilter: _this.model.get('dailyFilter')
          })); //for backward compatibility

          this.canvas = this.$el;
          this.dateInterval = new nsGmx$1.DateInterval();
          this.listenTo(this.model, 'change:synchronyzed', this.updateSync);
          this.listenTo(this.model, 'change:dailyFilter', function () {
            this.handleFiltersHash();
            this.applyDailyFilter();
          }.bind(this));
          this.dateInterval.on('change', function () {
            _this.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            if (_this.model.get('dailyFilter')) {
              _this.applyDailyFilter();
            }
          });

          this._fillFiltersHash();
        },
        _fillFiltersHash: function _fillFiltersHash(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var dailyFiltersHash = {};

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties(),
                layerID = props.LayerID,
                isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

            if (isTemporalLayer) {
              dailyFiltersHash[layerID] = true;
            }

            this.model.set('dailyFiltersHash', dailyFiltersHash);
          }
        },
        _clearFiltersHash: function _clearFiltersHash(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var dailyFiltersHash = {};

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties(),
                layerID = props.LayerID,
                isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

            if (isTemporalLayer) {
              dailyFiltersHash[layerID] = false;
            }

            this.model.set('dailyFiltersHash', dailyFiltersHash);
          }
        },
        setDateInterval: function setDateInterval(dateBegin, dateEnd, layer) {
          if (layer) {
            this.setCurrentLayer(layer);
          }

          var oldBegin = this.dateInterval.get('dateBegin').valueOf(),
              oldEnd = this.dateInterval.get('dateEnd').valueOf();

          if (oldBegin === dateBegin.valueOf() && oldEnd === dateEnd.valueOf()) {
            this.updateTemporalLayers();
            this.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            if (this.model.get('dailyFilter')) {
              this.applyDailyFilter();
            }

            this.trigger('change:dateInterval');
          } else {
            this.dateInterval.set({
              dateBegin: dateBegin,
              dateEnd: dateEnd
            });
          }

          if (this.dateInterval.get('dailyFilter')) {
            this.applyDailyFilter();
          }
        },
        setCurrentLayer: function setCurrentLayer(layer) {
          var props = layer.getGmxProperties();
          this.model.set('currentLayer', props.LayerID);
        },
        changeCurrentLayer: function changeCurrentLayer(e) {
          var _this = this,
              layerID = e.target.value;

          _this.model.set('currentLayer', layerID);
        },
        log: function log() {
          var f = function f(list) {
            var layers = nsGmx$1.gmxMap.layers;

            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i],
                  props = layer.getGmxProperties(),
                  t = props.title,
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval,
                  _int = layer.getDateInterval();

              if (isTemporalLayer && _int) {
                var b = _int.beginDate.toString(),
                    e = _int.endDate.toString();

                list.push({
                  title: t,
                  beginDate: b,
                  endDate: e
                });
              }
            }

            console.table(list);
          };

          f([]);
        },
        getDateInterval: function getDateInterval() {
          return this.dateInterval;
        },
        get: function get() {
          var attrs = this.model.toJSON(),
              _this = this,
              calendar;

          if (!attrs.calendar) {
            calendar = new nsGmx$1.CalendarWidget1({
              minimized: false,
              dateMin: new Date(2000, 1, 1),
              dateMax: new Date(Date.now() + dayms) > _this.dateInterval.get('dateEnd') ? new Date(Date.now() + dayms) : _this.dateInterval.get('dateEnd'),
              dateInterval: _this.dateInterval
            });
            this.dateInterval.on('change', this.updateTemporalLayers.bind(this, null));
            this.model.set('calendar', calendar);
            this.updateTemporalLayers();
          }

          return this.model.get('calendar');
        },
        replaceCalendarWidget: function replaceCalendarWidget(newCalendar) {
          this._calendar = newCalendar; //заменим виджет перед деревом слоёв

          if (this._isAppended) {
            var doChange = function doChange() {
              var calendarDiv = $('<div class="commoncalendar-container"></div>').append(newCalendar.canvas); // special for steppe project

              if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                _queryMapLayers.getContainerAfter().find('.commoncalendar-container').replaceWith(calendarDiv);
              } else {
                _queryMapLayers.getContainerBefore().find('.commoncalendar-container').replaceWith(calendarDiv);
              }
            }; //явная проверка, так как хочется быть максимально синхронными в этом методе


            if (_queryMapLayers.loadDeferred.state() === 'resolved') {
              doChange();
            } else {
              _queryMapLayers.loadDeferred.then(doChange);
            }
          }
        },
        show: function show() {
          var calendarDiv = this.$('.calendar-widget-container'),
              calendarCanvas = this.get().canvas;
          $(_queryMapLayers.getContainerBefore()).append(calendarCanvas[0]);

          var doAdd = function () {
            calendarDiv.append(calendarCanvas);
            var commonCanvas = this.canvas; // special for steppe Project

            if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
              _queryMapLayers.getContainerAfter().append(commonCanvas);
            } else {
              _queryMapLayers.getContainerBefore().append(commonCanvas);
            }

            this.model.set('isAppended', true);
          }.bind(this);

          if (!this.model.get('isAppended')) {
            //явная проверка, так как хочется быть максимально синхронными в этом методе
            if (_queryMapLayers.loadDeferred.state() === 'resolved') {
              doAdd();
            } else {
              _queryMapLayers.loadDeferred.then(doAdd);
            }
          }

          return this;
        },
        hide: function hide() {
          var attrs = this.model.toJSON();
          attrs._isAppended && $(this.get().canvas).hide();
          this.model.set('isAppended', true);
          return this;
        },
        bindLayer: function bindLayer(layerName) {
          var attrs = this.model.toJSON(),
              unbindedTemporalLayers = attrs.unbindedTemporalLayers,
              clone = {}; // clone object

          for (var variable in unbindedTemporalLayers) {
            if (unbindedTemporalLayers.hasOwnProperty(variable)) {
              clone[variable] = unbindedTemporalLayers[variable];
            }
          }

          delete clone[layerName];
          this.model.set('unbindedTemporalLayers', clone);
          this.updateTemporalLayers();
        },
        unbindLayer: function unbindLayer(layerName) {
          var attrs = this.model.toJSON(),
              layer = nsGmx$1.gmxMap.layersByID[layerName];

          if (!layer) {
            return;
          }

          var unbindedTemporalLayers = attrs.unbindedTemporalLayers,
              clone = {};
          layer.removeLayerFilter({
            id: 'dailyFilter'
          }); // clone object

          for (var variable in unbindedTemporalLayers) {
            if (unbindedTemporalLayers.hasOwnProperty(variable)) {
              clone[variable] = unbindedTemporalLayers[variable];
            }
          }

          clone[layerName] = true;
          this.model.set('unbindedTemporalLayers', clone);
          this.updateTemporalLayers([layer]);
        },
        _updateOneLayer: function _updateOneLayer(layer, dateBegin, dateEnd) {
          var props = layer.getGmxProperties();

          if (props.maxShownPeriod) {
            var msecPeriod = props.maxShownPeriod * 24 * 3600 * 1000;
            var newDateBegin = new Date(Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
            layer.setDateInterval(newDateBegin, dateEnd);
          } else {
            layer.setDateInterval(dateBegin, dateEnd);
          }
        },
        updateTemporalLayers: function updateTemporalLayers(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var attrs = this.model.toJSON(),
              synchronyzed = attrs.synchronyzed,
              dateBegin = this.dateInterval.get('dateBegin'),
              dateEnd = this.dateInterval.get('dateEnd'),
              currentLayer = attrs.currentLayer,
              layersMaxDates = [],
              maxDate = null,
              localeDate;

          if (!attrs.calendar) {
            return;
          }

          if (synchronyzed) {
            for (var i = 0, len = layers.length; i < len; i++) {
              var layer = layers[i],
                  props = layer.getGmxProperties(),
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.setDateInterval;

              if (isTemporalLayer && !(props.name in attrs.unbindedTemporalLayers)) {
                if (props.DateEnd) {
                  if (typeof props.DateEnd === "string") {
                    localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
                  } else if (typeof props.DateEnd === "number") {
                    localeDate = new Date(props.DateEnd);
                  }

                  layersMaxDates.push(localeDate);
                }

                this._updateOneLayer(layer, dateBegin, dateEnd);
              }
            }
          } else if (currentLayer && !(currentLayer in attrs.unbindedTemporalLayers)) {
            currentLayer = nsGmx$1.gmxMap.layersByID[currentLayer];

            this._updateOneLayer(currentLayer, dateBegin, dateEnd);
          } else {
            return;
          }

          if (layersMaxDates.length > 0) {
            layersMaxDates.sort(function (a, b) {
              return b - a;
            });
            maxDate = new Date(layersMaxDates[0]);

            if (maxDate > attrs.calendar.getDateMax()) {
              attrs.calendar.setDateMax(nsGmx$1.CalendarWidget.fromUTC(new Date(maxDate.valueOf() + dayms)));
            }

            this.model.set('calendar', attrs.calendar);
          }
        },
        onDateIntervalChanged: function onDateIntervalChanged(e) {
          var attrs = this.model.toJSON(),
              currentLayer = attrs.currentLayer,
              layer = e.target,
              props,
              dateInterval,
              dateBegin,
              dateEnd;

          if (!currentLayer) {
            return;
          }

          props = layer.getGmxProperties();
          var layerID = props.LayerID;

          if (layerID in attrs.unbindedTemporalLayers) {
            return;
          }

          if (layerID === currentLayer) {
            if (props.maxShownPeriod) {
              return;
            }

            dateInterval = layer.getDateInterval();
            dateBegin = dateInterval.beginDate;
            dateEnd = dateInterval.endDate;
            this.setDateInterval(dateBegin, dateEnd, layer);
          }
        },
        updateVisibleTemporalLayers: function updateVisibleTemporalLayers(layers) {
          var _this = this,
              attrs = this.model.toJSON(),
              currentLayer = attrs.currentLayer,
              layersList = this.$('.layersList'),
              temporalLayers = [],
              str = '';

          $.widget("ui.temporallayersmenu", $.ui.selectmenu, {
            _renderItem: function _renderItem(ul, item) {
              var li = $("<li>");

              if (item.value) {
                var l = nsGmx$1.gmxMap.layersByID[item.value],
                    props = l.getGmxProperties(),
                    di = l.getDateInterval && l.getDateInterval(),
                    dateBegin,
                    dateEnd,
                    hourBegin,
                    hourEnd,
                    newDateBegin,
                    newDateEnd,
                    str = '';

                if (di) {
                  var now = new Date(),
                      dateBeginToMidnight = new Date(now - now % dayms); // dateBegin = di.beginDate;
                  // dateEnd = di.endDate);

                  dateBegin = di.beginDate || dateBeginToMidnight;
                  dateEnd = di.endDate || new Date(dateBeginToMidnight.valueOf() + dayms);
                  hourBegin = nsGmx$1.CalendarWidget1.prefixTimeValue(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin'));
                  hourEnd = nsGmx$1.CalendarWidget1.prefixTimeValue(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end'));
                  newDateBegin = nsGmx$1.CalendarWidget1.toUTC(dateBegin);
                  newDateEnd = nsGmx$1.CalendarWidget1.toUTC(dateEnd); // если календарь показывает ровно один день,
                  // прибавляем 24 часа к первой дате, чтобы получить сутки

                  if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
                    newDateEnd = nsGmx$1.CalendarWidget1.toUTC(new Date(dateEnd - dayms));
                  }

                  str = '<span class=\'layerslist-title\'>' + props.title + '</span>' + ' ' + '<span class=\'layerslist-dates-times\'>' + nsGmx$1.CalendarWidget1.formatDate(newDateBegin) + ' - ' + nsGmx$1.CalendarWidget1.formatDate(newDateEnd) + ' | ' + hourBegin + '-' + hourEnd + '</span>';
                }

                $(li).html(str);
                $(li).prop('layerID', item.value);
                return li.appendTo(ul);
              }
            },
            _renderMenu: function _renderMenu(ul, items) {
              var that = this;
              $.each(items, function (index, item) {
                that._renderItemData(ul, item);
              });
            }
          });

          if ($(layersList).temporallayersmenu("instance")) {
            $(layersList).temporallayersmenu("destroy");
          }

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];

            if (layer.getGmxProperties) {
              var props = layer.getGmxProperties(),
                  isVisible = props.visible,
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

              if (isTemporalLayer && isVisible) {
                temporalLayers.push(layer);
              }
            }
          }

          for (var _i = 0; _i < temporalLayers.length; _i++) {
            var _layer = temporalLayers[_i],
                _props = _layer.getGmxProperties(),
                layerID = _props.LayerID;

            str += '<option value=' + layerID + '>' + _props.title + '</option>';
          }

          $(layersList).html(str);

          if (currentLayer) {
            this.$('.layersList option').each(function () {
              if ($(this).val() === currentLayer) {
                $(this).prop("selected", true);
              }
            }); // установим текщим первый слой из списка
          } else if (!currentLayer && temporalLayers.length) {
            var _props2 = temporalLayers[0].getGmxProperties(),
                _layerID = _props2.LayerID;

            this.$('.layersList option[value="' + _layerID + '"]').prop("selected", true);
          }

          $(layersList).temporallayersmenu({
            change: function change(e) {
              var layerID = $(e.currentTarget).prop('layerID'),
                  layer = nsGmx$1.gmxMap.layersByID[layerID],
                  filters = layer._gmx.dataManager._filtersView,
                  layerFilters = filters[layerID],
                  dateBegin,
                  dateEnd;
              var dateInterval = layer.getDateInterval();

              if (dateInterval.beginDate && dateInterval.endDate) {
                dateBegin = dateInterval.beginDate;
                dateEnd = dateInterval.endDate;
              } else {
                dateInterval = new nsGmx$1.DateInterval();
                dateBegin = dateInterval.get('dateBegin');
                dateEnd = dateInterval.get('dateEnd');
              }

              if (layerFilters) {
                if ('screen_dailyFilter' in layerFilters) {
                  _this.$('.daily-switch input').prop("checked", true);
                } else {
                  _this.$('.daily-switch input').prop("checked", false);
                }
              }

              _this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);

              _this.setDateInterval(dateBegin, dateEnd, layer);
            }
          });
        },
        toggleSync: function toggleSync() {
          this.model.set('synchronyzed', !this.model.get('synchronyzed'));
        },
        setSyncMode: function setSyncMode(value) {
          this.model.set('synchronyzed', Boolean(value));
        },
        updateSync: function updateSync() {
          var _this = this,
              layers = nsGmx$1.gmxMap.layers,
              attrs = this.model.toJSON(),
              synchronyzed = attrs.synchronyzed,
              currentLayer = attrs.currentLayer,
              listContainer = this.$('.unsync-layers-container'),
              dateBegin,
              dateEnd;

          if (synchronyzed) {
            dateBegin = _this.dateInterval.get('dateBegin');
            dateEnd = _this.dateInterval.get('dateEnd');

            _this.setDateInterval(dateBegin, dateEnd);

            this.model.set('currentLayer', null);
            this.model.set('currentLayer', null);
            this.$('.sync-switch input').prop("checked", true);
            $(listContainer).hide();
          } else if (currentLayer) {
            return;
          } else {
            var temporalLayers = [];
            this.$('.sync-switch input').prop("checked", false);
            $(listContainer).show();
            this.updateVisibleTemporalLayers(layers);

            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i];

              if (layer.getGmxProperties) {
                var props = layer.getGmxProperties(),
                    isVisible = props.visible,
                    isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

                if (isTemporalLayer && isVisible) {
                  temporalLayers.push(layer);
                }
              }
            }

            if (!temporalLayers.length) {
              this.model.set('currentLayer', null);
            } else {
              var _props3 = temporalLayers[0].getGmxProperties(),
                  layerID = _props3.LayerID;

              this.model.set('currentLayer', layerID);
            }
          }
        },
        toggleDailyFilter: function toggleDailyFilter() {
          var attrs = this.model.toJSON(),
              calendar = attrs.calendar;
          calendar.model.set('dailyFilter', !this.model.get('dailyFilter'));
          this.model.set('dailyFilter', !this.model.get('dailyFilter'));
        },
        setDailyFilter: function setDailyFilter(active) {
          var attrs = this.model.toJSON(),
              calendar = attrs.calendar;
          calendar.model.set('dailyFilter', active);
          this.model.set('dailyFilter', active);
        },
        handleFiltersHash: function handleFiltersHash() {
          var attrs = this.model.toJSON(),
              currentLayer = attrs.currentLayer,
              dailyFilter = attrs.dailyFilter,
              dailyFiltersHash = attrs.dailyFiltersHash;

          if (dailyFilter) {
            if (currentLayer) {
              dailyFiltersHash[currentLayer] = true;
            } else {
              this._fillFiltersHash();
            }
          } else if (currentLayer) {
            dailyFiltersHash[currentLayer] = false;
          } else {
            this._clearFiltersHash();
          }
        },
        applyDailyFilter: function applyDailyFilter(layers) {
          var temporalLayers = layers || nsGmx$1.gmxMap.layers,
              _this = this,
              attrs = this.model.toJSON(),
              dailyFilter = attrs.dailyFilter,
              dailyFiltersHash = attrs.dailyFiltersHash,
              synchronyzed = attrs.synchronyzed,
              currentLayer = attrs.currentLayer,
              dateInterval = this.dateInterval,
              dateBegin = this.dateInterval.get('dateBegin'),
              dateEnd = this.dateInterval.get('dateEnd'),
              hourBegin = Number(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
              hourEnd = Number(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;

          if (synchronyzed) {
            temporalLayers = nsGmx$1.gmxMap.layers;
          }

          if (!synchronyzed && !currentLayer) {
            return;
          }

          for (var i = 0; i < temporalLayers.length; i++) {
            var l = temporalLayers[i],
                p = l.getGmxProperties && l.getGmxProperties(),
                layerName = void 0;

            if (!p) {
              continue;
            }

            layerName = p.name;

            if (layerName in attrs.unbindedTemporalLayers) {
              continue;
            }

            (function (x) {
              var layer = temporalLayers[x];

              if (layer.getGmxProperties) {
                var props = layer.getGmxProperties(),
                    isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

                if (isTemporalLayer && layer.getDataManager) {
                  if (layer.getGmxProperties().name === '509762F05B0044D8A7CCC9D3C2383365') ;

                  if (!synchronyzed && layer.getDateInterval()) {
                    dateInterval = layer.getDateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                      dateBegin = dateInterval.beginDate;
                      dateEnd = dateInterval.endDate;
                      hourBegin = Number(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600;
                      hourEnd = Number(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                    }
                  }

                  var dm = layer.getDataManager(),
                      dmOpt = dm.options,
                      fullDays,
                      intervals = [],
                      tmpKeyNum;

                  if (dmOpt.Temporal) {
                    tmpKeyNum = dm.tileAttributeIndexes[dmOpt.TemporalColumnName];
                  }

                  if (hourEnd < dayms) {
                    fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf() + dayms;
                  } else if (hourEnd === dayms) {
                    fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf();
                  }

                  for (var _i2 = 0; _i2 < fullDays; _i2 += dayms) {
                    intervals.push({
                      begin: toMidnight(dateBegin).valueOf() + hourBegin + _i2,
                      end: toMidnight(dateBegin).valueOf() + hourEnd + _i2
                    });
                  }

                  if (dailyFilter && dailyFiltersHash[props.LayerID]) {
                    layer.addLayerFilter(function (item) {
                      var itemDate = item.properties[tmpKeyNum] * 1000,
                          inside = false;

                      for (var j = 0; j < intervals.length; j++) {
                        if (intervals[j].begin <= itemDate && itemDate <= intervals[j].end) {
                          inside = true;
                          break;
                        }
                      } //
                      // if (inside) {
                      //     console.log(layer.getGmxProperties().title + ' / ' + 'loaded');
                      // } else {
                      //     console.log(layer.getGmxProperties().title + ' / ' + 'filtered');
                      // }


                      return inside;
                    }, {
                      id: 'dailyFilter'
                    });

                    _this.$('.daily-switch input').prop("checked", true);
                  } else {
                    layer.removeLayerFilter({
                      id: 'dailyFilter'
                    });

                    _this.$('.daily-switch input').prop("checked", false);
                  }
                }
              }
            })(i);
          }
        }
      });
      nsGmx$1.CommonCalendarWidget = CommonCalendar;
    })(jQuery);

    /** 
    * Контроллёр глобального буфера обмена
    * @memberOf nsGmx
    * @class Синглетон. Позволяет хранить массивы объектов разного типа. Тип объектов - строка. В рамках одного типа объекты упорядочены.
    */

    nsGmx$1.ClipboardController = function () {
      var _clipboard = {};
      return {
        addItem: function addItem(type, item) {
          _clipboard[type] = _clipboard[type] || [];

          _clipboard[type].push(item);
        },
        popItem: function popItem(type) {
          if (typeof _clipboard[type] === 'undefined' || _clipboard[type].length == 0) return null;
          return _clipboard[type].pop();
        },
        //количество объектов данного типа
        getCount: function getCount(type) {
          if (typeof _clipboard[type] === 'undefined') return 0;
          return _clipboard[type].length;
        },
        //получить объект типа type с индексом index. Если index < 0, то индексация с конца (-1 - последний элемент)
        get: function get(type, index) {
          if (typeof _clipboard[type] === 'undefined') return null;
          if (index < 0) index += _clipboard[type].length;
          if (index < 0 || _clipboard[type].length <= index) return null;
          return _clipboard[type][index];
        }
      };
    }();

    var UPDATE_INTERVAL = 2000;

    var sendGmxRequest = function sendGmxRequest(requestType, url, params) {
      var def = $.Deferred();

      var processResponse = function processResponse(response) {
        if (!response.Result || !response.Result.TaskID) {
          if (response.Status === 'ok' && !response.ErrorInfo) {
            def.resolve(response);
          } else {
            parseResponse(response);
            def.reject(response);
          }

          return;
        }

        def.notify(response.Result);
        var taskID = response.Result.TaskID;
        var interval = setInterval(function () {
          sendCrossDomainJSONRequest(window.serverBase + "AsyncTask.ashx?WrapStyle=func&TaskID=" + taskID, function (response) {
            var res = response.Result;

            if (response.Status !== 'ok' || res.ErrorInfo) {
              res.Status = 'error';
              parseResponse(res);
              clearInterval(interval);
              def.reject(res);
            } else if (res.Completed) {
              clearInterval(interval);
              def.resolve(res);
            } else {
              def.notify(res);
            }
          }, null, function () {
            clearInterval(interval);
            def.reject();
          });
        }, UPDATE_INTERVAL);
      };

      if (requestType === 'get') {
        params = params || {};
        var paramStrItems = [];

        for (var p in params) {
          paramStrItems.push(p + '=' + encodeURIComponent(params[p]));
        }

        var sepSym = url.indexOf('?') == -1 ? '?' : '&';
        sendCrossDomainJSONRequest(url + sepSym + paramStrItems.join('&'), processResponse, null, def.reject.bind(def));
      } else if (requestType === 'post') {
        var localParams = $.extend({
          WrapStyle: 'message'
        }, params);
        sendCrossDomainPostRequest(url, localParams, processResponse);
      } else {
        throw 'Wrong request type';
      }

      return def.promise();
    };

    nsGmx$1.asyncTaskManager = {
      sendGmxJSONPRequest: sendGmxRequest.bind(null, 'get'),
      sendGmxPostRequest: sendGmxRequest.bind(null, 'post')
    };

    nsGmx$1.AttrTable = nsGmx$1.AttrTable || {};

    (function () {
      // events: queryChange, columnsChange
      var DefaultSearchParamsManager = function DefaultSearchParamsManager() {
        this._activeColumns = null;
        this._queryTextarea = null; // textArea in search panel

        this._searchValue = ''; // value of this._queryTextarea

        this._valueTextarea = null; // upper textArea in update panel

        this._setValue = ''; // value of this._queryTextarea

        this._updateQueryTextarea = null; // lower textArea in update panel

        this._setUpdateQueryValue = ''; // value of this._updateQueryTextarea

        this._container = null;
        /* SEARCH INSIDE POLYGON */

        this._geometryInfoRow = null;
      };

      DefaultSearchParamsManager.prototype.drawSearchUI = function (container, attributesTable) {
        var info = attributesTable.getLayerInfo(),
            // paramsWidth = 320,
        _this = this;

        this._container = container;
        /* HIDE BUTTON */

        var hideButtonContainer = document.createElement('div'),
            hideButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Скрыть'));
        $(hideButton).addClass('attr-table-hide-button');
        $(hideButtonContainer).addClass('attr-table-hide-button-container');
        $(hideButtonContainer).append(hideButton);

        hideButton.onclick = function () {
          var tableTd = container.nextSibling,
              originalButton = $(tableTd).find('.attr-table-find-button');

          if ($(originalButton).hasClass('gmx-disabled')) {
            $(originalButton).removeClass('gmx-disabled');
          }

          container.style.display = 'none';
          attributesTable.resizeFunc();
        };

        var middleContainer = document.createElement('div');
        $(middleContainer).addClass('attr-table-middle-container');
        /* SEARCH INSIDE POLYGON */

        var geomUIContainer = this.drawGeomUI();
        /*SQL TEXTAREA*/

        this._queryTextarea = nsGmx$1.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['dir', 'className', 'attr-table-query-area'], ['css', 'overflow', 'auto'], ['css', 'width', '300px']]);
        this._queryTextarea.placeholder = '"field1" = 1 AND "field2" = \'value\'';
        this._queryTextarea.value = _this._searchValue;

        this._queryTextarea.oninput = function (e) {
          _this._searchValue = e.target.value;
        };

        var attrNames = [info.identityField].concat(info.attributes, [window._gtxt('gmx_geometry')]);
        var attrHash = {};

        for (var a = 0; a < attrNames.length; a++) {
          attrHash[attrNames[a]] = [];
        }

        var attrProvider = new nsGmx$1.LazyAttributeValuesProviderFromServer(attrHash, info.name);

        var suggestionCallback = function suggestionCallback() {
          $(_this._queryTextarea).trigger('input');
        };

        var attrSuggestWidget = new nsGmx$1.AttrSuggestWidget([this._queryTextarea], attrNames, attrProvider, null, ['attrs', 'operators', 'functions']);
        var suggestCanvas = attrSuggestWidget.el[0];
        $(suggestCanvas).css('margin-right', '9px');

        suggestionCallback = function suggestionCallback() {
          $(this.currentTextArea).trigger('input');
        };

        attrSuggestWidget.setCallback(suggestionCallback);

        container.onclick = function (evt) {
          if (evt.target === container) {
            $(suggestCanvas).find('.suggest-helper').fadeOut(100);
            return true;
          }
        };
        /*CLEAN/SEARCH BUTTONS*/


        var buttonsContainer = document.createElement('div'),
            searchButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Найти')),
            cleanButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Очистить'));
        $(buttonsContainer).addClass('clean-search-buttons-container');
        $(buttonsContainer).append(searchButton);

        searchButton.onclick = function () {
          $(_this).trigger('queryChange');
        };

        $(searchButton).addClass('search-button');
        $(cleanButton).addClass('clean-button');

        cleanButton.onclick = function () {
          _this._queryTextarea.value = '';
          _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
          _this._geometryInfoRow = null;
          _this._searchValue = _this._queryTextarea.value;
          $(_this).trigger('queryChange');
        };
        /*COMPILE*/


        $(container).append(hideButtonContainer);
        $(container).append(middleContainer);

        nsGmx$1.Utils._(middleContainer, [nsGmx$1.Utils._div([nsGmx$1.Utils._span([nsGmx$1.Utils._t(_gtxt('WHERE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '7px 0px 3px 1px']]), cleanButton, this._queryTextarea, suggestCanvas], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);

        $(middleContainer).append(geomUIContainer);
        $(container).append(buttonsContainer);
      };

      DefaultSearchParamsManager.prototype.drawUpdateUI = function (container, attributesTable) {
        var info = attributesTable.getLayerInfo(),
            // paramsWidth = 320,
        _this = this;

        this.currentColumnName = "";
        this._container = container;
        var geomUIContainer = this.drawGeomUI();
        /* HIDE BUTTON */

        var hideButtonContainer = document.createElement('div'),
            hideButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Скрыть'));
        $(hideButton).addClass('attr-table-hide-button');
        $(hideButtonContainer).addClass('attr-table-hide-button-container');
        $(hideButtonContainer).append(hideButton);

        hideButton.onclick = function () {
          var tableTd = container.nextSibling,
              originalButton = $(tableTd).find('.attr-table-find-button');

          if ($(originalButton).hasClass('gmx-disabled')) {
            $(originalButton).removeClass('gmx-disabled');
          }

          container.style.display = 'none';
          attributesTable.resizeFunc();
        };

        var middleContainer = document.createElement('div');
        $(middleContainer).addClass('attr-table-middle-container');
        /* SELECT COLUMN */

        var selectColumnContainer = document.createElement('div'),
            attrsTemplate = Handlebars.compile('<select class="attrs-select selectStyle">' + '{{#each this.attrs}}' + '<option value="{{this}}">' + '{{this}}' + '</option>' + '{{/each}}' + '</select>'),
            attrsUI = $(attrsTemplate({
          attrs: ['---' + window._gtxt("Выберите колонку").toLowerCase() + '---'].concat(info.attributes)
        }))[0];
        hideButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Скрыть'));
        $(selectColumnContainer).append(window._gtxt("Обновить колонку"));
        $(selectColumnContainer).append(attrsUI);

        attrsUI.onchange = function (e) {
          _this.currentColumnName = e.target.value;
        };
        /* VALUE TEXTAREA */


        this._valueTextarea = nsGmx$1.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['dir', 'className', 'attr-table-query-area'], ['css', 'overflow', 'auto'], ['css', 'margin-top', '3px'], ['css', 'width', '300px'], ['css', 'height', '80px']]);
        this._valueTextarea.placeholder = '"field1" = 1 AND "field2" = \'value\'';
        this._valueTextarea.value = _this._setValue;

        this._valueTextarea.oninput = function (e) {
          _this._setValue = e.target.value;
        };
        /* UPDATE QUERY TEXTAREA */


        this._updateQueryTextarea = nsGmx$1.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['dir', 'className', 'attr-table-query-area'], ['css', 'overflow', 'auto'], ['css', 'margin-top', '3px'], ['css', 'width', '300px'], ['css', 'height', '80px']]);
        this._updateQueryTextarea.placeholder = '"field1" = 1 AND "field2" = \'value\'';
        this._updateQueryTextarea.value = _this._setUpdateQueryValue;

        this._updateQueryTextarea.oninput = function (e) {
          _this._setUpdateQueryValue = e.target.value;
        };

        var attrNames = [info.identityField].concat(info.attributes, [window._gtxt('gmx_geometry')]);
        var attrHash = {};

        for (var a = 0; a < attrNames.length; a++) {
          attrHash[attrNames[a]] = [];
        }

        var attrProvider = new nsGmx$1.LazyAttributeValuesProviderFromServer(attrHash, info.name);
        var attrSuggestWidget = new nsGmx$1.AttrSuggestWidget([this._valueTextarea, this._updateQueryTextarea], attrNames, attrProvider, null, ['attrs', 'operators', 'functions']);
        var suggestCanvas = attrSuggestWidget.el[0];
        $(suggestCanvas).css('margin-right', '9px');

        var suggestionCallback = function suggestionCallback() {
          $(this.currentTextArea).trigger('input');
        };

        attrSuggestWidget.setCallback(suggestionCallback);

        this._valueTextarea.onfocus = function (e) {
          attrSuggestWidget.setActiveTextArea(e.target);
        };

        this._updateQueryTextarea.onfocus = function (e) {
          attrSuggestWidget.setActiveTextArea(e.target);
        };

        container.onclick = function (evt) {
          if (evt.target === container) {
            $(suggestCanvas).find('.suggest-helper').fadeOut(100);
            return true;
          }
        };
        /*STATUS BAR*/


        var statusBar = $(Handlebars.compile('<div class="column-update-spinholder">' + '<span class="spinHolder" style="display:none">' + '<img src="img/progress.gif"/>' + '<span class="spinMessage"></span>' + '</span>' + '<span class="spinErrorMessage" style="display:none"></span>' + '</div>')({}))[0];
        /*APPLY BUTTON*/

        var applyButtonContainer = document.createElement('div'),
            applyButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Применить'));
        $(applyButtonContainer).addClass('apply-button-container');
        $(applyButtonContainer).append(applyButton);

        applyButton.onclick = function () {
          var spinHolder = $(statusBar).find('.spinHolder');
          var spinErrorMessage = $(statusBar).find('.spinErrorMessage');
          $(spinErrorMessage).hide();

          if (!_this.currentColumnName || _this.currentColumnName === '---' + window._gtxt("Выберите колонку").toLowerCase() + '---') {
            $(spinErrorMessage).html(window._gtxt('Выберите колонку'));
            $(spinErrorMessage).show();
            return;
          }

          $(spinHolder).show();
          var updateQuery = _this._valueTextarea && _this._valueTextarea.value ? _this._valueTextarea.value : '';
          var whereQuery = _this._updateQueryTextarea && _this._updateQueryTextarea.value ? _this._updateQueryTextarea.value : '';
          whereQuery = _this.addGeomQuery(whereQuery);
          var url = window.serverBase + 'VectorLayer/QueryScalar?sql=' + 'UPDATE ' + '"' + attributesTable.layerName + '"' + 'SET ' + '"' + _this.currentColumnName + '"' + '=' + updateQuery + (whereQuery ? 'WHERE ' + whereQuery : "");
          fetch(url, {
            method: 'POST',
            credentials: 'include',
            mode: 'cors'
          }).then(toJson).then(resCallback)["catch"](catchErr);

          function toJson(res) {
            return res.text();
          }

          function resCallback(res) {
            var json;
            $(spinHolder).hide();
            res = res.substring(1, res.length - 1);
            json = JSON.parse(res);

            if (json.Status === 'error') {
              throw new Error(json.ErrorInfo.ErrorMessage);
            }

            $(attributesTable._serverDataProvider).change();
          }

          function catchErr() {
            $(spinHolder).hide();
            $(spinErrorMessage).html(window._gtxt('Ошибка'));
            $(spinErrorMessage).show();
          }
        };

        $(applyButton).addClass('apply-button');
        /*COMPILE*/

        $(container).append(hideButtonContainer);
        $(container).append(middleContainer);
        $(middleContainer).append(selectColumnContainer);
        $(middleContainer).append(selectColumnContainer);

        nsGmx$1.Utils._(middleContainer, [nsGmx$1.Utils._div([nsGmx$1.Utils._span([nsGmx$1.Utils._t(_gtxt('VALUE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '4px 0px 3px 1px'], ['css', 'display', 'inline-block']]), this._valueTextarea], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);

        nsGmx$1.Utils._(middleContainer, [nsGmx$1.Utils._div([nsGmx$1.Utils._span([nsGmx$1.Utils._t(_gtxt('WHERE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '4px 0px 3px 1px'], ['css', 'display', 'inline-block']]), this._updateQueryTextarea, suggestCanvas], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);

        $(middleContainer).append(geomUIContainer);
        $(middleContainer).append(statusBar);
        $(container).append(applyButtonContainer);
      };

      DefaultSearchParamsManager.prototype.getQuery = function () {
        var query = this._queryTextarea && this._queryTextarea.value,
            drawingObject = this._geometryInfoRow && this._geometryInfoRow.getDrawingObject(),
            geom = drawingObject && drawingObject.toGeoJSON().geometry,
            geomStr = geom ? 'intersects([geomixergeojson], GeometryFromGeoJson(\'' + JSON.stringify(geom) + '\', 4326))' : '',
            resQuery = query && geomStr ? '(' + query + ') AND ' + geomStr : query || geomStr;

        return resQuery;
      };

      DefaultSearchParamsManager.prototype.addGeomQuery = function (query) {
        var drawingObject = this._geometryInfoRow && this._geometryInfoRow.getDrawingObject(),
            geom = drawingObject && drawingObject.toGeoJSON().geometry,
            geomStr = geom ? 'intersects([geomixergeojson], GeometryFromGeoJson(\'' + JSON.stringify(geom) + '\', 4326))' : '',
            resQuery = query && geomStr ? '(' + query + ') AND ' + geomStr : query || geomStr;

        return resQuery;
      };

      DefaultSearchParamsManager.prototype.drawGeomUI = function () {
        var geomUIContainer = document.createElement('div');
        var geomUI = $(Handlebars.compile('<span>' + '<span class="attr-table-geomtitle">{{i "Искать по пересечению с объектом"}}</span>' + '<span class="gmx-icon-choose"></span>' + '<span class="attr-table-geom-placeholder"></span>' + '</span>')());
        $(geomUIContainer).addClass('attr-table-geometry-container');
        $(geomUIContainer).append(geomUI);
        geomUI.find('.gmx-icon-choose').click(onGeometrySelectButtonClick);

        var _this = this;

        function onGeometrySelectButtonClick() {
          nsGmx$1.Controls.chooseDrawingBorderDialog('attrTable', function (drawingObject) {
            _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
            var InfoRow = DrawingObjectInfoRow;
            _this._geometryInfoRow = new InfoRow(nsGmx$1.leafletMap, geomUI.find('.attr-table-geom-placeholder')[0], drawingObject, {
              editStyle: false,
              allowDelete: true
            });
            $(_this._geometryInfoRow).on('onRemove', function () {
              _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
              _this._geometryInfoRow = null;
            });
          }, {
            geomType: null
          });
        }

        return geomUIContainer;
      };

      DefaultSearchParamsManager.prototype.getActiveColumns = function () {
        return this._activeColumns;
      };

      DefaultSearchParamsManager.prototype.resize = function () {};

      nsGmx$1.AttrTable.DefaultSearchParamsManager = DefaultSearchParamsManager;
    })();

    nsGmx$1.AttrTable = nsGmx$1.AttrTable || {};

    (function () {
      /** Провайдер данных для {@link nsGmx.ScrollTable}. Получает данные от сервера в формате ГеоМиксера
      * @alias nsGmx.AttrTable.ServerDataProvider
      * @class
      * @extends nsGmx.ScrollTable.IDataProvider
      */
      var ServerDataProvider = function ServerDataProvider(params) {
        var _params = $.extend({
          defaultSortParam: 'ogc_fid',
          titleToParams: {}
        }, params);

        var _countURL = null,
            _dataURL = null,
            _countParams = null,
            _dataParams = null;

        var _lastCountResult; //IDataProvider interface


        this.getCount = function (callback) {
          if (!_countURL) {
            callback();
            return;
          }

          sendCrossDomainPostRequest(_countURL, _countParams, function (response) {
            if (!window.parseResponse(response)) {
              callback();
              return;
            }

            _lastCountResult = response.Result;
            callback(response.Result);
          });
        };

        this.getItems = function (page, pageSize, sortParam, sortDec, callback) {
          if (!_dataURL) {
            callback();
            return;
          }

          var explicitSortParam = sortParam || sortParam === '' ? _params.titleToParams[sortParam] || sortParam : _params.defaultSortParam;
          var params = $.extend({
            page: page,
            pagesize: pageSize,
            orderby: explicitSortParam,
            orderdirection: sortDec ? 'DESC' : 'ASC'
          }, _dataParams);
          sendCrossDomainPostRequest(_dataURL, params, function (response) {
            if (!window.parseResponse(response)) {
              callback();
              return;
            }

            var fieldsSet = {};

            if (response.Result.fields) {
              for (var f = 0; f < response.Result.fields.length; f++) {
                fieldsSet[response.Result.fields[f]] = {
                  index: f,
                  type: response.Result.types[f]
                };
              }
            }

            var res = [];

            for (var i = 0; i < response.Result.values.length; i++) {
              res.push({
                fields: fieldsSet,
                values: response.Result.values[i]
              });
            }

            callback(res);
          });
        };
        /** Задать endpoint для получения от сервера данных об объекта и их количестве
         * @param {String} countURL URL скрипта для запроса общего количества объектов
         * @param {Object} countParams Параметры запроса для количеством объектов
         * @param {String} dataURL URL скрипта для запроса самих объектов
         * @param {Object} dataParams Параметры запроса самих объектов. К этим параметрам будут добавлены параметры для текущей страницы в формате запросов ГеоМиксера
        */


        this.setRequests = function (countURL, countParams, dataURL, dataParams) {
          _countURL = countURL;
          _countParams = countParams || {};
          _countParams.WrapStyle = 'message';
          _dataURL = dataURL;
          _dataParams = dataParams || {};
          _dataParams.WrapStyle = 'message';
          $(this).change();
        };

        this.serverChanged = function () {
          $(this).change();
        };

        this.getLastCountResult = function () {
          return _lastCountResult;
        };
      };

      nsGmx$1.AttrTable.ServerDataProvider = ServerDataProvider;
    })();

    nsGmx$1.AttrTable = nsGmx$1.AttrTable || {};

    (function () {
      var template = Handlebars.compile('<div class="attrs-table-square-popover">' + '<div class="attrs-table-square-toomuch">Слишком много объектов</div>' + '<div class="attrs-table-square-process">Подсчитываем...</div>' + '<div class="attrs-table-square-result">Площадь: ' + '<span class="attrs-table-square"></span>' + '</div>' + '</div>');

      nsGmx$1.AttrTable.SquareCalc = function (container, layerName, dataProvider, searchParamsManager) {
        var popoverUI = $(template());
        popoverUI.find('.attrs-table-square-toomuch').hide();
        popoverUI.find('.attrs-table-square-result').hide();
        $(container).popover({
          content: popoverUI[0],
          placement: 'left',
          html: true
        });
        $(container).on('shown.bs.popover', function () {
          if (dataProvider.getLastCountResult() > 10000) {
            popoverUI.find('.attrs-table-square-toomuch').show();
            popoverUI.find('.attrs-table-square-process').hide();
            popoverUI.find('.attrs-table-square-result').hide();
            return;
          } else {
            popoverUI.find('.attrs-table-square-toomuch').hide();
            popoverUI.find('.attrs-table-square-process').show();
            popoverUI.find('.attrs-table-square-result').hide();
          }

          sendCrossDomainPostRequest(window.serverBase + 'VectorLayer/Search.ashx', {
            layer: layerName,
            query: searchParamsManager.getQuery(),
            columns: '[{value: "[GeomixerGeoJson]"}]',
            WrapStyle: 'message'
          }, function (response) {
            if (!window.parseResponse(response)) {
              return;
            }

            popoverUI.find('.attrs-table-square-process').hide();
            popoverUI.find('.attrs-table-square-result').show();
            var items = response.Result.values;
            var totalSquare = 0;

            for (var g = 0; g < items.length; g++) {
              totalSquare += L.gmxUtil.geoArea(items[g][0]);
            }

            popoverUI.find('.attrs-table-square').text(L.gmxUtil.prettifyArea(totalSquare));
          });
        });
      };
    })();

    (function () {
      nsGmx$1.AttrTable = nsGmx$1.AttrTable || {};

      var attrsTable = function attrsTable(layerName, layerTitle) {
        this.layerName = layerName;
        this.layerTitle = layerTitle || '';
        this.filterData = null;
        this.activeColumns = null;

        this.resizeFunc = function () {};

        this._updateVersionHandler = null;
        this._isLayerOnMap = this.layerName in nsGmx$1.gmxMap.layersByID;
        this.tableFields = {
          fieldsAsArray: [],
          fieldsAsHash: {},
          titleToField: {},
          init: function init(fieldParams, info) {
            var _this = this;

            this.fieldsAsHash = {};
            this.titleToField = {};
            this.fieldsAsArray = [];

            if (!fieldParams) {
              this.fieldsAsArray = [info.identityField].concat(info.attributes);
              this.fieldsAsArray.forEach(function (name) {
                _this.fieldsAsHash[name] = true;
                _this.titleToField[name] = name;
              });
            } else {
              fieldParams.forEach(function (field) {
                _this.fieldsAsArray.push(field.title);

                _this.fieldsAsHash[field.title] = true;
                _this.titleToField[field.title] = field.name;
              });
            }
          }
        };
      };

      attrsTable.prototype.getLayerInfo = function () {
        return this._layerInfo;
      };

      attrsTable.prototype.getInfo = function (origCanvas, outerSizeProvider, params) {
        if (!origCanvas && $('#attrsTableDialog' + this.layerName).length) {
          return;
        }

        origCanvas && $(origCanvas).empty();

        var canvas = origCanvas || nsGmx$1.Utils._div(null, [['attr', 'id', 'attrsTableDialog' + this.layerName], ['css', 'overflow', 'hidden']]),
            loading = nsGmx$1.Utils._div([nsGmx$1.Utils._img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), nsGmx$1.Utils._t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
            _this = this;

        nsGmx$1.Utils._(canvas, [loading]);

        if (!origCanvas) {
          outerSizeProvider = function outerSizeProvider() {
            return {
              width: canvas.parentNode.parentNode.offsetWidth,
              height: canvas.parentNode.offsetHeight
            };
          };

          nsGmx$1.Utils.showDialog(_gtxt('Таблица атрибутов слоя [value0]', this.layerTitle), canvas, {
            width: 820,
            height: 520,
            resizeFunc: function () {
              this.resizeFunc.apply(this, arguments);
            }.bind(this),
            closeFunc: function closeFunc() {
              if (_this._updateVersionHandler !== null && _this._isLayerOnMap) {
                nsGmx$1.gmxMap.layersByID[_this.layerName].off('versionchange', _this._updateVersionHandler);
              }
            },
            setMinSize: false
          });
        }

        sendCrossDomainJSONRequest(window.serverBase + 'Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=' + this.layerName, function (response) {
          if (!window.parseResponse(response)) {
            return;
          }

          loading.removeNode(true);
          _this._layerInfo = response.Result.properties;
          _this._layerColumns = [{
            Value: 'GeomIsEmpty([geomixergeojson])',
            Alias: '__GeomIsEmpty__'
          }, {
            Value: '[' + response.Result.properties.identityField + ']'
          }];
          var attrs = response.Result.properties.attributes;

          for (var k = 0; k < attrs.length; k++) {
            _this._layerColumns.push({
              Value: '[' + attrs[k] + ']'
            });
          }

          _this.drawDialog(response.Result.properties, canvas, outerSizeProvider, params);
        });
      };

      attrsTable.prototype._updateSearchString = function (query) {
        this._serverDataProvider.setRequests(window.serverBase + 'VectorLayer/Search.ashx', {
          layer: this.layerName,
          query: query,
          count: true
        }, window.serverBase + 'VectorLayer/Search.ashx', {
          layer: this.layerName,
          query: query,
          columns: JSON.stringify(this._layerColumns)
        });
      };
      /*
      * columnsList (extracted from searchParamsManager)
      */


      attrsTable.prototype.createColumnsList = function (paramsManager) {
        var info = this._layerInfo,
            _activeColumns_ = '_activeColumns_' + info.name,
            // paramsWidth = 300,
        columnsList = nsGmx$1.Utils._div(null, [['dir', 'className', 'attrsColumnsList'], ['css', 'overflowY', 'auto']]); //


        var attrTitles = this.tableFields.fieldsAsArray;

        if (!paramsManager._activeColumns) {
          paramsManager._activeColumns = {};

          for (var i = 0; i < attrTitles.length; ++i) {
            paramsManager._activeColumns[attrTitles[i]] = true;
          }
        }

        var presentColumns = false;

        for (var key in paramsManager._activeColumns) {
          if (paramsManager._activeColumns.hasOwnProperty(key)) {
            if (paramsManager._activeColumns[key] === true) {
              presentColumns = true;
              break;
            }
          }
        }

        var showColumnsTemplate = '<div class="attrs-table-show-columns-header">' + '<label title="{{name}}" class="attrs-table-show-columns">' + '<input type="checkbox" class="box attrs-table-show-columns-checkbox" {{#active}}checked{{/active}}></input>' + '{{name}}' + '</label>' + '</div>';
        var selectColumnsUI = $(Handlebars.compile(showColumnsTemplate)({
          active: presentColumns,
          name: window._gtxt('Колонки') + ':'
        })).appendTo(columnsList);
        var rowTemplate = '<label title="{{name}}" class="attrs-table-active-row">' + '<input type="checkbox" class="box attrs-table-active-checkbox" {{#active}}checked{{/active}}></input>' + '{{name}}' + '</label>';
        attrTitles.forEach(function (columnName) {
          var rowUI = $(Handlebars.compile(rowTemplate)({
            active: paramsManager._activeColumns[columnName],
            name: columnName
          })).appendTo(columnsList);
          $('input', rowUI).click(function () {
            paramsManager._activeColumns[columnName] = this.checked;
            $(paramsManager).trigger('columnsChange');
            window.localStorage.setItem(_activeColumns_, JSON.stringify(paramsManager._activeColumns)); // сохранение активных колонок
          });
        });
        $('input', selectColumnsUI).click(function () {
          var checked = this.checked;

          for (var key in paramsManager._activeColumns) {
            if (paramsManager._activeColumns.hasOwnProperty(key)) {
              paramsManager._activeColumns[key] = checked;
              $(paramsManager).trigger('columnsChange');
              $('input', columnsList).each(function () {
                $(this).prop('checked', checked);
              });
            }
          }
        }); // columnsList.onmouseleave = function () {
        //    this.style.display = 'none';
        // }

        return columnsList;
      };

      attrsTable.prototype.drawDialog = function (info, canvas, outerSizeProvider, params) {
        var _this = this;

        var _params = $.extend({
          hideDownload: false,
          hideActions: false,
          hideRowActions: false,
          hideSearchParams: false,
          onClick: null,
          searchParamsManager: new nsGmx$1.AttrTable.DefaultSearchParamsManager()
          /*attributes: [] */

        }, params);

        _params.searchParamsManager._activeColumns = JSON.parse(localStorage.getItem('_activeColumns_' + info.name)); // чтение активных колонок

        var paramsWidth = 300,
            tdParams = nsGmx$1.Utils._td(null, [['css', 'width', paramsWidth + 'px'], ['attr', 'vAlign', 'top']]),
            // tdTable = nsGmx.Utils._td(null, [['attr', 'vAlign', 'top']]),
        findObjectsButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Найти объекты')),
            updateObjectsButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Обновить объекты')),
            addObjectButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Добавить объекты')),
            changeFieldsListButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Изменить колонки')),
            oldCanvasWidth = false;

        var downloadSection = $(Handlebars.compile('<div>' + '<span class="buttonLink attrsDownloadLink" data-format="Shape">{{i "Скачать shp"}}</span>' + '{{#unless isPolygon}}' + '<span class="buttonLink attrsDownloadLink" data-format="gpx">{{i "Скачать gpx"}}</span>' + '{{/unless}}' + '<span class="buttonLink attrsDownloadLink" data-format="csv">{{i "Скачать csv"}}</span>' + '<span class="buttonLink attrsDownloadLink" data-format="geojson">{{i "Скачать geojson"}}</span>' + '<span class="buttonLink createLayerLink">{{i "Создать слой"}}</span>' + '<span class="buttonLink copyObjectsLink">{{i "Копировать объекты"}}</span>' + '{{#if isPolygon}}<span class="buttonLink attrs-table-square-link">{{i "Рассчитать площадь"}}</span>{{/if}}' + '</div>')({
          isPolygon: info.GeometryType === 'polygon'
        }));
        $(findObjectsButton).addClass('attr-table-find-button');
        $(updateObjectsButton).addClass('attr-table-update-button');
        /*temp*/
        // $(updateObjectsButton).addClass('gmx-disabled');

        /*temp end*/

        $(addObjectButton).addClass('attr-table-add-button');
        $(changeFieldsListButton).addClass('attr-table-list-button');

        if (info.Access !== 'edit' && info.Access !== 'editrows') {
          $(updateObjectsButton).addClass('gmx-disabled');
          $(addObjectButton).addClass('gmx-disabled');
          $(changeFieldsListButton).addClass('gmx-disabled');
        }

        downloadSection.find('.attrsDownloadLink').click(function () {
          downloadLayer($(this).data('format'));
        }); // создание слоя из выборки (из атрибутивной таблицы)

        downloadSection.find('.createLayerLink').click(function () {
          sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + info.name, function (response) {
            if (!parseResponse(response)) {
              return;
            }

            createEditorFromSelection(response.Result);

            function createEditorFromSelection(props) {
              var query = _params.searchParamsManager.getQuery(),
                  activeColumns = _params.searchParamsManager.getActiveColumns(),
                  filteredColumns = []; // get columns list from search filter


              props.Columns.forEach(function (col) {
                if (col.Name in activeColumns && activeColumns[col.Name]) {
                  filteredColumns.push(col);
                }
              });

              var parent = nsGmx$1.Utils._div(null, [['attr', 'id', 'new' + 'Vector' + 'Layer'], ['css', 'height', '100%']]),
                  properties = {
                Title: props.Title + ' ' + _gtxt('копия'),
                Copyright: props.Copyright,
                Description: props.Description,
                Date: props.Date,
                MetaProperties: props.MetaProperties,
                TilePath: {
                  Path: ''
                },
                ShapePath: props.ShapePath,
                Columns: filteredColumns,
                IsRasterCatalog: props.IsRasterCatalog,
                SourceType: "file",
                Quicklook: props.Quicklook
              },
                  dialogDiv = nsGmx$1.Utils.showDialog(_gtxt('Создать векторный слой'), parent, 340, 340, false, false),
                  params = {
                copy: true,
                sourceLayerName: info.name,
                query: query,
                doneCallback: function doneCallback() {
                  nsGmx$1.Utils.removeDialog(dialogDiv);
                }
              };

              nsGmx$1.createLayerEditor(false, 'Vector', parent, properties, params);
            }
          });
        });
        downloadSection.find('.copyObjectsLink').click(function () {
          var copyLayerParams = {
            layerName: info.name,
            query: _params.searchParamsManager.getQuery()
          };
          nsGmx$1.ClipboardController.addItem('CopyObjects', copyLayerParams);
          window.showErrorMessage(window._gtxt("Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\""), true, window._gtxt("Объекты скопированы"));
        });
        this.tableFields.init(_params.attributes, info);
        this._serverDataProvider = new nsGmx$1.AttrTable.ServerDataProvider({
          titleToParams: $.extend(this.tableFields.titleToField, {
            '': '__GeomIsEmpty__'
          })
        });
        var squareLink = downloadSection.find('.attrs-table-square-link');
        new nsGmx$1.AttrTable.SquareCalc(squareLink, this.layerName, this._serverDataProvider, _params.searchParamsManager);
        var hostName = window.serverBase.match(/^https?:\/\/(.*)\/$/)[1];

        this._updateSearchString('');

        var searchParamsManager = _params.searchParamsManager;
        $(searchParamsManager).on({
          queryChange: function queryChange() {
            _this.offset = 0;

            _this._updateSearchString(searchParamsManager.getQuery());
          },
          columnsChange: function columnsChange() {
            var columns = searchParamsManager.getActiveColumns ? searchParamsManager.getActiveColumns() : _this.tableFields.fieldsAsHash;

            for (var k in columns) {
              _this.table2.activateField(k, columns[k]);
            }
          }
        });

        var downloadLayer = function downloadLayer(format) {
          var activeColumns = searchParamsManager.getActiveColumns ? searchParamsManager.getActiveColumns() : _this.tableFields.fieldsAsHash,
              columnsForServer = [];

          for (var c in activeColumns) {
            if (activeColumns[c]) {
              columnsForServer.push({
                Value: '[' + _this.tableFields.titleToField[c] + ']',
                Alias: c
              });
            }
          }

          _mapHelper.downloadVectorLayer({
            name: _this.layerName,
            host: hostName,
            format: format,
            query: _params.searchParamsManager.getQuery(),
            columns: columnsForServer
          });
        };

        findObjectsButton.onclick = function () {
          tdParams.innerHTML = '';
          oldCanvasWidth = outerSizeProvider().width;
          searchParamsManager.drawSearchUI(tdParams, _this);

          if (tdParams.style.display === 'none') {
            tdParams.style.display = '';
          } else {
            return;
          }

          resizeFunc();
        };

        findObjectsButton.style.marginRight = '10px';

        if (info.Access === 'edit' || info.Access === 'editrows') {
          updateObjectsButton.onclick = function () {
            if ($(findObjectsButton).hasClass('gmx-disabled')) {
              $(findObjectsButton).removeClass('gmx-disabled');
            }

            tdParams.innerHTML = '';
            oldCanvasWidth = outerSizeProvider().width;
            searchParamsManager.drawUpdateUI(tdParams, _this);

            if (tdParams.style.display === 'none') {
              tdParams.style.display = '';
            } else {
              return;
            }

            resizeFunc();
          };
        }

        updateObjectsButton.style.marginRight = '10px';

        if (info.Access === 'edit' || info.Access === 'editrows') {
          addObjectButton.onclick = function () {
            new nsGmx$1.EditObjectControl(_this.layerName);
          };
        }

        addObjectButton.style.marginRight = '10px';

        if (_params.hideActions) {
          $(addObjectButton).hide();
        }

        if (info.Access === 'edit' || info.Access === 'editrows') {
          changeFieldsListButton.onclick = function () {
            var div;

            if (info.MultiLayerID) {
              div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + info.MultiLayerID + "']")[0];
            } else {
              div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + info.name + "']")[0];
            }

            _mapHelper.createLayerEditor(div, false, 'attrs', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
          };
        }

        changeFieldsListButton.style.marginRight = '10px';
        tdParams.style.display = 'none'; // var name = 'attrsTable' + info.name;

        var attrNames = this.tableFields.fieldsAsArray;
        var fielsWidth = new Array(_params.hideRowActions ? attrNames.length : attrNames.length + 1).join('0').split('0');
        var attrNamesHash = this.tableFields.fieldsAsHash;
        _params.hideDownload && downloadSection.hide();
        this.divTable2 = nsGmx$1.Utils._div(null, [['css', 'overflow', 'auto'], ['dir', 'className', 'attrsTableBody']]);
        var columnsList = this.createColumnsList(_params.searchParamsManager);
        columnsList.style.display = 'none';

        var selectAllItems = nsGmx$1.Utils._checkbox(false, 'checkbox'),
            selectedCount = nsGmx$1.Utils._span([], [['attr', 'class', 'selectedCount']]),
            selectedDelete = nsGmx$1.Utils.makeLinkButton(_gtxt('Удалить')),
            showColumnsListButton = nsGmx$1.Utils.makeLinkButton(_gtxt('Показывать колонки')),
            selectedCopy = nsGmx$1.Utils.makeLinkButton(_gtxt('Скопировать')),
            // selectedDownload = nsGmx.Utils.makeLinkButton(_gtxt('Скачать')),
        selectedCont = nsGmx$1.Utils._span([nsGmx$1.Utils._t('Выбрано объектов:'), selectedCount, selectedDelete, selectedCopy], [['attr', 'class', 'hiddenCommands']]),
            groupBox = nsGmx$1.Utils._div([selectAllItems, nsGmx$1.Utils._span([nsGmx$1.Utils._t('Выделить все на странице')], [['css', 'marginLeft', '5px'], ['css', 'verticalAlign', 'top']]), selectedCont, showColumnsListButton, columnsList], [['attr', 'class', 'attrsSelectedCont']]);

        canvas.onclick = function () {
          if ($(showColumnsListButton).hasClass('hide-columns-list-button')) {
            $(showColumnsListButton).toggleClass('hide-columns-list-button');
            $(showColumnsListButton).html(_gtxt('Показывать колонки'));
          }

          $(columnsList).hide();
        };

        columnsList.onclick = function (e) {
          e.stopPropagation();
        };

        selectAllItems.onchange = function () {
          var table2 = _this.table2;
          table2.getVisibleItems().forEach(function (it) {
            var id = it.values[1];

            if (selectAllItems.checked) {
              _this._selected[id] = true;
            } else {
              delete _this._selected[id];
            }
          });
          chkSelectedCount();
          table2.repaint();
        };

        selectedCount.innerHTML = 0;
        this._selected = {};

        selectedDelete.onclick = function () {
          var remove = nsGmx$1.Utils.makeButton(_gtxt('Удалить'));

          remove.onclick = function () {
            var arr = Object.keys(_this._selected).reduce(function (p, c) {
              p.push({
                action: 'delete',
                id: c
              });
              return p;
            }, []);

            _mapHelper.modifyObjectLayer(_this.layerName, arr).done(function () {
              nsGmx$1.Utils.removeDialog(jDialog);
              clearSelected();
            });
          };

          var offset = $(selectedDelete).offset();
          var jDialog = nsGmx$1.Utils.showDialog(_gtxt('Удалить отмеченные объекты?'), nsGmx$1.Utils._div([remove], [['css', 'textAlign', 'center']]), 280, 75, offset.left + 20, offset.top - 30);
        };

        selectedCopy.onclick = function () {
          var list = '(' + Object.keys(_this._selected).join(',') + ')',
              copyLayerParams = {
            layerName: info.name,
            list: list,
            query: '[gmx_id] IN ' + list
          };
          nsGmx$1.ClipboardController.addItem('CopyObjects', copyLayerParams);
          window.showErrorMessage(list, true, window._gtxt('Объекты скопированы'));
        };

        $(showColumnsListButton).addClass('show-columns-list-button');

        showColumnsListButton.onclick = function (e) {
          e.stopPropagation();
          $(this).toggleClass('hide-columns-list-button');

          if ($(this).hasClass('hide-columns-list-button')) {
            $(this).html(_gtxt('Скрыть колонки'));
            $(columnsList).show();
          } else {
            $(this).html(_gtxt('Показывать колонки'));
            $(columnsList).hide();
          }
        };

        var manageSection = nsGmx$1.Utils._div([findObjectsButton, updateObjectsButton, addObjectButton, changeFieldsListButton], [['css', 'margin', '0px 0px 10px 1px']]);

        var tdTable2 = nsGmx$1.Utils._td([manageSection, groupBox, this.divTable2, downloadSection[0]], [['attr', 'vAlign', 'top']]);

        this.table2 = new nsGmx$1.ScrollTable({
          pagesCount: 10,
          limit: 20
        });
        this.prevLimit = this.table2.limit;

        var chkSelectedCount = function chkSelectedCount() {
          var cnt = Object.keys(_this._selected).length;

          if (cnt) {
            L.DomUtil.removeClass(selectedCont, 'hiddenCommands');
          } else {
            L.DomUtil.addClass(selectedCont, 'hiddenCommands');
          }

          selectedCount.innerHTML = cnt;
        };

        var clearSelected = function clearSelected() {
          _this._selected = {};
          chkSelectedCount();
          selectAllItems.checked = false;
        };

        var drawTableItem2 = function drawTableItem2(elem, curIndex, activeHeaders) {
          var tds = [];

          if (this.limit !== _this.prevLimit) {
            _this.prevLimit = this.limit;
            clearSelected();
          }

          var id = elem.values[elem.fields[info.identityField].index],
              showButton = nsGmx$1.Utils.makeImageButton('img/enlarge-circle.svg', 'img/enlarge-circle.svg'),
              editButton = nsGmx$1.Utils.makeImageButton('img/pen.svg'),
              deleteItem = nsGmx$1.Utils._checkbox(_this._selected[id], 'checkbox'),
              tdControl;

          if (info.Access !== 'edit' && info.Access !== 'editrows') {
            tdControl = nsGmx$1.Utils._td([nsGmx$1.Utils._div([showButton], [['css', 'width', '45px']])], [['css', 'width', '45px']]);
          } else {
            tdControl = nsGmx$1.Utils._td([nsGmx$1.Utils._div([deleteItem, showButton, editButton], [['css', 'width', '47px']])], [['css', 'width', '47px']]);
          }

          editButton.style.marginLeft = showButton.style.marginLeft = '5px';
          editButton.style.width = '12px';

          deleteItem.onchange = function () {
            if (deleteItem.checked) {
              _this._selected[id] = true; // console.log(_this._selected);
            } else {
              delete _this._selected[id];
              selectAllItems.checked = false;
            }

            chkSelectedCount();
          };

          editButton.onclick = function () {
            var id = elem.values[elem.fields[info.identityField].index];
            new nsGmx$1.EditObjectControl(_this.layerName, id);
          };

          showButton.onclick = function () {
            var id = elem.values[elem.fields[info.identityField].index];
            sendCrossDomainJSONRequest(window.serverBase + 'VectorLayer/Search.ashx?WrapStyle=func&layer=' + _this.layerName + '&page=0&pagesize=1&geometry=true&query=' + encodeURIComponent('[' + info.identityField + ']=' + id), function (response) {
              if (!window.parseResponse(response)) {
                return;
              }

              var layer = nsGmx$1.gmxMap.layersByID[_this.layerName],
                  props = layer.getGmxProperties(),
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;
              var columnNames = response.Result.fields;
              var row = response.Result.values[0];

              for (var i = 0; i < row.length; ++i) {
                if (columnNames[i] === 'geomixergeojson' && row[i]) {
                  var fitBoundsOptions = layer ? {
                    maxZoom: layer.options.maxZoom
                  } : {};
                  var geom = L.gmxUtil.geometryToGeoJSON(row[i], true);
                  var bounds = L.gmxUtil.getGeometryBounds(geom);
                  nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]], fitBoundsOptions);

                  if (isTemporalLayer) {
                    var tempColumn = props.TemporalColumnName,
                        index = columnNames.indexOf(tempColumn),
                        dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                        dateBegin,
                        dateEnd,
                        datems;

                    if (index !== -1) {
                      datems = row[index] * 1000;
                      dateBegin = nsGmx$1.DateInterval.toMidnight(new Date(datems));
                      dateEnd = nsGmx$1.DateInterval.toMidnight(new Date(datems + dayms));
                      nsGmx$1.widgets.commonCalendar.setDateInterval(dateBegin, dateEnd, layer);
                    }
                  }
                }
              }
            });
          };

          nsGmx$1.Utils._title(deleteItem, _gtxt('Удалить'));

          nsGmx$1.Utils._title(editButton, _gtxt('Редактировать'));

          nsGmx$1.Utils._title(showButton, _gtxt('Показать'));

          $(showButton).toggle(!elem.values[elem.fields['__GeomIsEmpty__'].index]);

          if (!_params.hideRowActions) {
            tds.push(tdControl);
          }

          for (var j = 0; j < activeHeaders.length; ++j) {
            if (activeHeaders[j] === '') {
              continue;
            }

            var fieldName = _this.tableFields.titleToField[activeHeaders[j]];

            if (fieldName in elem.fields) {
              var valIndex = elem.fields[fieldName].index,
                  td = nsGmx$1.Utils._td();

              nsGmx$1.Utils._(td, [nsGmx$1.Utils._t(nsGmx$1.Utils.convertFromServer(elem.fields[fieldName].type, elem.values[valIndex]))]);

              if (elem.fields[fieldName].type === 'integer') {
                td.style.textAlign = 'right';
              }

              tds.push(td);
            } else {
              tds.push(nsGmx$1.Utils._td());
            }
          }

          var tr = nsGmx$1.Utils._tr(tds);

          if (curIndex % 2 !== 0) {
            tr.className = 'odd';
          }

          if (_params.onClick) {
            tr.onclick = function () {
              _params.onClick(elem);
            };

            tr.style.cursor = 'pointer';
          }

          return tr;
        };

        var tableFields = _params.hideRowActions ? attrNames : [''].concat(attrNames);
        this.table2.setDataProvider(this._serverDataProvider);
        this.table2.createTable(this.divTable2, 'attrs', 0, tableFields, fielsWidth, drawTableItem2, $.extend(attrNamesHash, {
          '': true
        }), true);

        if (_params.searchParamsManager._activeColumns) {
          var obj = _params.searchParamsManager._activeColumns;

          for (var key in obj) {
            this.table2.activateField(key, obj[key]);
          }
        }

        nsGmx$1.Utils._(canvas, [nsGmx$1.Utils._table([nsGmx$1.Utils._tbody([nsGmx$1.Utils._tr([tdParams, tdTable2])])], ['css', 'width', '100%'])]);

        var tbl = $(this.divTable2).find('#attrsTableParent')[0]; // var ths = $(this).find('th');

        if (L.Browser.ie || L.Browser.gecko) {
          var lastSTop = tbl.scrollTop;

          tbl.onscroll = function () {
            var stop = this.scrollTop;
            var ths = $(this).find('th');

            if (stop < lastSTop) {
              $(ths).each(function () {
                $(this).css('transitionDelay', '0s');
                $(this).css('transform', "");
              });
            }

            lastSTop = stop;
            var translate = "translate(0," + stop + "px)";
            $(ths).each(function () {
              $(this).css('transitionDelay', '0.25s');
              $(this).css('transform', translate);
            });
          };
        } else {
          tbl.onscroll = function () {
            var translate = "translate(0," + this.scrollTop + "px)";
            var ths = $(this).find('th');
            $(ths).each(function () {
              $(this).css('transform', translate);
            });
          };
        }

        var resizeFunc = function resizeFunc() {
          var dialogWidth = oldCanvasWidth || outerSizeProvider().width;
          oldCanvasWidth = false;
          canvas.childNodes[0].style.width = dialogWidth - 21 - 10 + 'px';
          tdTable2.style.width = dialogWidth - tdParams.offsetWidth - 21 - 10 + 'px';
          _this.divTable2.style.width = dialogWidth - tdParams.offsetWidth - 21 - 10 + 'px';
          var dialogHeight = outerSizeProvider().height;
          _this.divTable2.style.height = dialogHeight - 14 - 25 - 10 - 30 + 'px';

          _this.table2.updateHeight(parseInt(_this.divTable2.style.height));

          _params.searchParamsManager.resize && _params.searchParamsManager.resize({
            width: tdParams.offsetWidth,
            height: _this.divTable2.offsetHeight
          });
        };

        this.resizeFunc = resizeFunc;
        resizeFunc();

        if (this._isLayerOnMap) {
          this._updateVersionHandler = function () {
            _this._serverDataProvider.serverChanged();
          };

          nsGmx$1.gmxMap.layersByID[this.layerName].on('versionchange', this._updateVersionHandler);
        }
      };

      var attrsTableHash = function attrsTableHash() {
        this.hash = {};
        this.hooks = [];
        this._hookID = 0;
      };

      attrsTableHash.prototype.create = function (name, canvas, outerSizeProvider, params) {
        params = params || {};
        this.hooks.forEach(function (hookInfo) {
          params = hookInfo.hook(params, name) || params;
        });

        if (name in this.hash) {
          this.hash[name].getInfo(canvas, outerSizeProvider, params);
        } else {
          var title = nsGmx$1.gmxMap.layersByID[name] ? nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title : '';
          var newAttrsTable = new attrsTable(name, title);
          newAttrsTable.getInfo(canvas, outerSizeProvider, params);
          this.hash[name] = newAttrsTable;
        }

        return this.hash[name];
      };

      attrsTableHash.prototype.addHook = function (paramsHook) {
        var id = 'id' + this._hookID++;
        this.hooks.push({
          id: id,
          hook: paramsHook
        });
        return id;
      };

      attrsTableHash.prototype.removeHook = function (hookID) {
        for (var i = 0; i < this.hooks.length; i++) {
          if (this.hooks[i].id === hookID) {
            this.hooks.splice(i, 1);
            return;
          }
        }
      };

      window._attrsTableHash = new attrsTableHash();
      /** Менеджер поискового интерфейса таблицы атрибутов.
          Используется в таблице атрибутов для задания кастомизированного интерфейса поиска объектов слоя.
          Генерирует события queryChange и columnsChange
        @typedef IAttrTableSearchManager
        @memberOf nsGmx
        @prop {function(container, attrTable)} render Ф-ция для отрисовки кастомизированного интерфейса в контейнере. Параметры: container, attrTable
        @prop {function(): String} getQuery Получить SQL запрос за данными
        @prop {function(): Object} getActiveColumns Получить хеш с описанием активности колонок (имя колонки -> true/false)
        @prop {function(dims)} resize Ф-ция для реакции на изменения размера диалога. dims - целевые размеры контейнера (width, height)
      */

      /** Показать таблицу атрибутов векторного слоя
        @func createAttributesTable
        @memberOf nsGmx
        @param {String} layerName ID слоя
        @param {DOMElement} canvas Контейнер, куда поместить таблицу атрибутов. Если не указано, будет создан новый диалог
        @param {function} outerSizeProvider Ф-ция для определения текущих размеров контейнера. Должна возвращать объект с полями width и height. Применяется только если указан canvas.
        @param {Object} params Дополнительные параметры
        @param {Boolean} [params.hideDownload=false] Скрыть секцию с вариантами скачивания данных
        @param {Boolean} [params.hideActions=false] Скрыть секцию с добавлением объекта
        @param {Boolean} [params.hideRowActions=false] Скрыть столбец таблицы с действиями над отдельными объектами
        @param {Boolean} [params.hideSearchParams=false] Скрыть секцию с параметрами поиска
        @param {function} [params.onClick] Ф-ция, которая будет вызываться при клике на строчке таблицы. Первым параметром передаётся объект, по которому кликнули
        @param {Array} [params.attributes] Массив, определяющий, какие атрибуты показывать. Каждый элемент - объект с полями "name" (исходное название атрибута) и title (как отображать в таблице).
                       Если атрибута нет в массиве, он не будет показан в таблице. Если массив не указан, показываются все атрибуты
        @param {nsGmx.IAttrTableSearchManager} [params.searchParamsManager] Менеджер UI для поиска в таблице атрибутов
        @return Интерфейс для управления таблицей атрибутов
      */

      nsGmx$1.createAttributesTable = window._attrsTableHash.create.bind(window._attrsTableHash);
      /** Добавить хук для изменения параметров при вызове таблицы атрибутов
        @func addAttributesTableHook
        @memberOf nsGmx
        @param {function(params, layerName):Object} paramsHook Хук, который вызывается при каждом вызове диалога редактирования.
               Первый параметр - параметры диалога (можно модифицировать), второй - ID слоя).
        @return {String} ID добавленного хука
      */

      nsGmx$1.addAttributesTableHook = function (paramsHook) {
        return window._attrsTableHash.addHook(paramsHook);
      };
      /** Удаляет хук параметров
        @func removeAttributesTableHook
        @memberOf nsGmx
        @param {String} hookID ID хука для удаления
      */


      nsGmx$1.removeAttributesTableHook = function (hookID) {
        window._attrsTableHash.removeHook(hookID);
      };
    })();

    (function () {

      nsGmx$1.Translations.addText('rus', {
        security: {
          ownerName: 'Владелец',
          defAccess: 'Доступ для всех',
          access: {
            empty: ' ',
            no: 'нет доступа',
            view: 'просмотр',
            linkview: 'просмотр по ссылке',
            edit: 'редактирование',
            editrows: 'редактирование объектов',
            preview: 'предпросмотр'
          },
          share: {
            'public': 'публичный',
            'private': 'частный'
          },
          addHeaderLabel: 'Введите пользователя или группу',
          addOkText: 'Добавить',
          select: {
            'selectedLayers': 'Выделено слоев для назначения прав: '
          }
        }
      });
      nsGmx$1.Translations.addText('eng', {
        security: {
          ownerName: 'Owner',
          defAccess: 'Public access',
          access: {
            empty: ' ',
            no: 'no access',
            view: 'view only',
            linkview: 'direct link view only',
            edit: 'edit',
            editrows: 'edit objects',
            preview: 'preview'
          },
          share: {
            'public': 'public',
            'private': 'private'
          },
          addHeaderLabel: 'Enter user or group',
          addOkText: 'Add',
          select: {
            'selectedLayers': 'Selected'
          }
        }
      });
      var usersHash = {};
      var currentSelectedItem = null;
      var autocompleteLabelTemplate = Handlebars.compile('<a class="security-autocomplete-item">' + '{{#if showIcon}}<span class="{{#if IsGroup}}security-group-icon{{else}}security-user-icon{{/if}}"></span>{{/if}}' + "<span>{{Nickname}}{{#if Login}}\xA0({{Login}}){{/if}}</span>" + '</a>'); //на input вешается autocomplete со списком пользователей.
      //кроме того, по нажатию enter происходит генерация события enterpress

      var wrapUserListInput = function wrapUserListInput(input, options) {
        input.on('keydown', function (event) {
          if (event.keyCode === 13) {
            //setTimeout нужен чтобы autocomplete не дописывал выбранное значение в input после того, как мы его очистим
            setTimeout(function () {
              $(this).trigger('enterpress');
            }.bind(this), 0);
          }
        });
        input.autocomplete({
          source: function source(request, cbResponse) {
            security.findUsers(request.term, {
              maxRecords: 7,
              type: options && options.type
            }).then(function (userInfos) {
              cbResponse(userInfos.map(function (userInfo) {
                usersHash[userInfo.Nickname] = userInfo;
                return {
                  login: userInfo.Login,
                  value: userInfo.Nickname,
                  label: '',
                  isGroup: userInfo.IsGroup
                };
              }));
            }, cbResponse.bind(null, []));
          },
          select: function select(event, ui) {
            currentSelectedItem = ui.item;
          }
        });

        $(input).data("ui-autocomplete")._renderItem = function (ul, item) {
          // var isGroup = item.isGroup,
          var userInfo = usersHash[item.value],
              templateParams = $.extend({
            showIcon: options && options.showIcon
          }, userInfo);
          return $('<li></li>').append($(autocompleteLabelTemplate(templateParams))).appendTo(ul);
        };
      };

      var SecurityOwnerWidget = function SecurityOwnerWidget(securityInfo, container) {
        var ui = $(SecurityOwnerWidget._template({
          ownerName: securityInfo.Owner
        })).appendTo(container);
        $('.security-owner-cancel', ui).click(function () {
          $('.changeOwnerLink', ui).click();
        });
        $('.changeOwnerLink', ui).click(function () {
          $(this).toggle();
          $('.security-owner-container', ui).toggle();
          $('.security-owner-input', ui).val('').focus();
        });
        var ownerAddInput = $('.security-owner-input', ui);
        ownerAddInput.on('enterpress', function () {
          $('.security-owner-ok', ui).click();
        });
        wrapUserListInput(ownerAddInput, {
          type: 'User'
        });
        $('.security-owner-ok', ui).click(function () {
          var input = $('.security-owner-input', ui),
              name = input.val();

          var doChangeUser = function doChangeUser(user) {
            $('.changeOwnerLink', ui).text(user.Nickname);
            securityInfo.NewOwnerID = user.UserID;
            $('.changeOwnerLink', ui).click();
          };

          if (name in usersHash) {
            doChangeUser(usersHash[name]);
          } else {
            security.findUsers(name, {
              maxRecords: 1
            }).then(function (userInfos) {
              if (userInfos[0] && userInfos[0].Nickname.toLowerCase() === name.toLowerCase()) {
                doChangeUser(userInfos[0]);
              } else {
                inputError(input[0]);
              }
            }, inputError.bind(null, input[0]));
          }
        });
      };

      SecurityOwnerWidget._template = Handlebars.compile('<div class = security-owner>' + '<span>{{i "security.ownerName"}}: </span>' + '<span class="buttonLink changeOwnerLink security-owner-change">{{ownerName}}</span>' + '<div class="security-owner-container ui-front" style="display:none">' + '<input class="security-owner-input inputStyle">' + '<button class="security-owner-ok">Сменить</button>' + '<button class="security-owner-cancel">Отмена</button>' + '</div>' + '</div>'); // @param {String[]} options.accessTypes массив прав доступа

      var SecurityUserListWidget = function SecurityUserListWidget(securityInfo, container, options) {
        var _this = this;

        this.options = options;
        var ui = $(SecurityUserListWidget._template()).appendTo(container);
        var sortFuncs = {};

        var genSortFunction = function genSortFunction(field) {
          return [function (a, b) {
            if (a[field] > b[field]) return 1;else if (a[field] < b[field]) return -1;else return 0;
          }, function (a, b) {
            if (a[field] < b[field]) return 1;else if (a[field] > b[field]) return -1;else return 0;
          }];
        };

        sortFuncs[_gtxt('Псевдоним')] = genSortFunction('Nickname');
        sortFuncs[_gtxt('Полное имя')] = genSortFunction('FullName');
        sortFuncs[_gtxt('Доступ')] = genSortFunction('Access');
        var fieldNames = [_gtxt("Псевдоним"), _gtxt("Полное имя"),
        /*_gtxt("Роль"),*/
        _gtxt("Доступ"), ""];
        var fieldWidthes = ['35%', '35%', '25%', '5%'];
        this._securityTable = new nsGmx$1.ScrollTable({
          limit: 500,
          showFooter: false
        });
        this.securityUsersProvider = new nsGmx$1.ScrollTable.StaticDataProvider();
        this.securityUsersProvider.setSortFunctions(sortFuncs);

        this._securityTable.setDataProvider(this.securityUsersProvider);

        this._securityTable.createTable($('.access-table-placeholder', ui)[0], 'securityTable', 0, fieldNames, fieldWidthes, function (arg) {
          return SecurityUserListWidget._drawMapUsers.call(this, arg, _this);
        }, sortFuncs);

        var addInput = $('.security-add-input', ui);
        addInput.on('enterpress', function () {
          $('.security-add-ok', ui).click();
        });
        wrapUserListInput(addInput, {
          showIcon: true
        });
        $('.security-add-ok', ui).click(function () {
          var input = $('.security-add-input', ui),
              name = input.val();
          var isEmail = name.indexOf('@') !== -1,
              searchObj = isEmail ? {
            Login: name
          } : {
            Nickname: name
          };

          var addedUsers = _this.securityUsersProvider.getOriginalItems();

          if (currentSelectedItem) {
            if (currentSelectedItem.isGroup) {
              searchObj = {
                Nickname: currentSelectedItem.value
              };
            } else {
              searchObj = {
                Login: currentSelectedItem.login,
                Nickname: currentSelectedItem.value
              };
            }
          }

          if (_.findWhere(addedUsers, searchObj)) {
            inputError(input[0]);
            return;
          }

          var doAddUser = function doAddUser(user) {
            _this._addMapUser(user);

            input.val('').focus();
            currentSelectedItem = null;
          };

          if (name in usersHash) {
            doAddUser(usersHash[name]);
          } else {
            security.findUsers(name).then(function (userInfos) {
              var curUserInfo;

              if (currentSelectedItem) {
                curUserInfo = userInfos.filter(function (ui) {
                  return ui.Login === searchObj.Login;
                });
                if (curUserInfo[0]) doAddUser(curUserInfo[0]);
              } else {
                var isEmail = name.indexOf('@') !== -1;

                if (isEmail) {
                  if (userInfos[0] && userInfos[0].Login.toLowerCase() === name.toLowerCase()) {
                    doAddUser(userInfos[0]);
                  } else {
                    inputError(input[0]);
                  }
                } else if (userInfos[0] && userInfos[0].Nickname.toLowerCase() === name.toLowerCase()) {
                  doAddUser(userInfos[0]);
                } else {
                  inputError(input[0]);
                }
              }
            }, inputError.bind(null, input[0]));
          }
        });
        this.securityUsersProvider.setOriginalItems(securityInfo.Users);
      };

      SecurityUserListWidget.DEFAULT_ACCESS = 'view';

      SecurityUserListWidget.prototype._addMapUser = function (user) {
        var existedUser = $.extend({
          Access: SecurityUserListWidget.DEFAULT_ACCESS
        }, user);
        this.securityUsersProvider.addOriginalItem(existedUser);
      };

      SecurityUserListWidget.prototype.updateHeight = function (height) {
        this._securityTable.updateHeight(height);
      };

      SecurityUserListWidget._userRowTemplate = Handlebars.compile('<tr>' + '<td class="security-row-nickname">' + '<span class="{{#if IsGroup}}security-group-icon{{else}}security-user-icon{{/if}}"></span>' + '<span title="{{Nickname}}">{{Nickname}}</span>' + '</td>' + '<td><div class="security-row-fullname" title="{{Fullname}}">{{Fullname}}</div></td>' + '<td><select class="selectStyle security-row-access">{{#access}}' + '<option value = "{{value}}"{{#if selected}} selected{{/if}}>{{title}}</option>' + '{{/access}}</select></td>' + '<td class="security-row-remove-cell"><div class="gmx-icon-recycle"></div></td>' + '</tr>');

      SecurityUserListWidget._drawMapUsers = function (user, securityScope) {
        var ui = $(SecurityUserListWidget._userRowTemplate({
          Nickname: user.Nickname,
          Fullname: user[user.IsGroup ? 'Description' : 'FullName'],
          IsGroup: user.IsGroup,
          access: securityScope.options.accessTypes.filter(function (type) {
            return type !== 'no';
          }).map(function (type) {
            return {
              title: _gtxt('security.access.' + type),
              value: type,
              selected: type === user.Access
            };
          })
        }));
        var tr = ui[0];
        ui.find('.gmx-icon-recycle').click(function () {
          // уберем пользователя из списка
          securityScope.securityUsersProvider.filterOriginalItems(function (elem) {
            return elem.UserID !== user.UserID;
          });
        });
        ui.find('.security-row-access').change(function () {
          user.Access = this.value;
        });

        for (var i = 0; i < tr.childNodes.length; i++) {
          tr.childNodes[i].style.width = this._fields[i].width;
        }

        attachEffects(tr, 'hover');
        return tr;
      };

      SecurityUserListWidget._template = Handlebars.compile('<div class = "security-userlist">' + '<div class="security-add-container ui-front">' + '<span class="security-access-label">{{i "security.addHeaderLabel"}}: </span>' + '<input class="security-add-input inputStyle">' + '<button class="security-add-ok">{{i "security.addOkText"}}</button>' + '</div>' + '<div class="access-table-placeholder"></div>' + '</div>');

      var security = function security() {
        this.mapTypeSel = null;
        this.mapAccessSel = null;
        this.defaultAccess = null;
        this.getSecurityName = null;
        this.updateSecurityName = null;
        this.propertyValue = null;
        this.title = null;
      };

      var mapSecurity = function mapSecurity() {
        this.getSecurityName = "Map/GetSecurity.ashx";
        this.updateSecurityName = "Map/UpdateSecurity.ashx";
        this.propertyName = "MapID";
        this.dialogTitle = "Редактирование прав доступа карты [value0]";
        this.accessTypes = ['no', 'view', 'linkview', 'edit'];
      };

      mapSecurity.prototype = new security();
      mapSecurity.prototype.constructor = mapSecurity;

      var layerSecurity = function layerSecurity(layerName) {
        var layer = nsGmx$1.gmxMap.layersByID[layerName],
            props = layer.getGmxProperties && layer.getGmxProperties();

        if (!props) {
          return;
        }

        this.getSecurityName = "Layer/GetSecurity.ashx";
        this.updateSecurityName = "Layer/UpdateSecurity.ashx";
        this.propertyName = "LayerID";
        this.dialogTitle = "Редактирование прав доступа слоя [value0]";
        var layerType = props.type;

        if (layerType === 'Raster') {
          this.accessTypes = ['no', 'preview', 'view', 'edit'];
        } else if (layerType === 'Vector') {
          if (props.IsRasterCatalog) {
            this.accessTypes = ['no', 'preview', 'view', 'editrows', 'edit'];
          } else {
            this.accessTypes = ['no', 'view', 'editrows', 'edit'];
          }
        }
      };

      layerSecurity.prototype = new security();
      layerSecurity.prototype.constructor = layerSecurity;

      var multiLayerSecurity = function multiLayerSecurity() {
        this.getSecurityName = 'MultiLayer/GetSecurity.ashx';
        this.updateSecurityName = 'MultiLayer/UpdateSecurity.ashx';
        this.propertyName = 'MultiLayerID';
        this.dialogTitle = 'Редактирование прав доступа слоя [value0]';
        this.accessTypes = ['no', 'view', 'edit'];
      };

      multiLayerSecurity.prototype = new security();
      multiLayerSecurity.prototype.constructor = multiLayerSecurity;

      var layersGroupSecurity = function layersGroupSecurity() {
        this.getSecurityName = 'Map/GetSecurity.ashx';
        this.getGroupSecurityName = 'Layer/GetSecurity.ashx';
        this.updateSecurityName = 'Layer/LayersGroupUpdateSecurity';
        this.propertyName = 'MapID';
        this.groupPropertyName = 'Layers';
        this.mapLayers = [];
        this.mapLayersSecurityArray = [];
        this.selectedLayersSecurityArray = [];
        this.originalItems = [];
        this.dialogTitle = 'Редактирование прав доступа слоев карты [value0]';
        this.accessTypes = ['no', 'view', 'edit'];
      };

      layersGroupSecurity.prototype = new security();
      layersGroupSecurity.prototype.constructor = layersGroupSecurity;

      security.prototype.getSecurityFromServer = function (id) {
        var def = $.Deferred();
        sendCrossDomainJSONRequest(window.serverBase + this.getSecurityName + '?WrapStyle=func&IncludeAdmin=true&' + this.propertyName + '=' + id, function (response) {
          if (!parseResponse(response)) {
            def.reject(response);
            return;
          }

          def.resolve(response.Result);
        });
        return def;
      }; // запрос security группы слоев


      security.prototype.getGroupSecurityFromServer = function (postParams) {
        var def = $.Deferred();
        sendCrossDomainPostRequest(window.serverBase + this.getGroupSecurityName, postParams, function (response) {
          if (!parseResponse(response)) {
            def.reject(response);
            return;
          }

          def.resolve(response.Result);
        });
        return def;
      };

      security.prototype.getRights = function (value, title) {
        // var _this = this;
        this.propertyValue = value;
        this.title = title;
        this.getSecurityFromServer(value).then(this.createSecurityDialog.bind(this));
      }; //ф-ция выделена из-за различий между диалогами прав слоёв и диалога состава группы


      security.prototype.addCustomUI = function (ui, securityInfo) {
        var defAccessTemplate = Handlebars.compile('<div class="security-def-access">{{i "security.defAccess"}}: ' + '<select class="security-defaccess-select selectStyle">' + '{{#defAccessTypes}}' + '<option value="{{value}}"{{#isSelected}} selected{{/isSelected}}>{{title}}</option>' + '{{/defAccessTypes}}' + '</select>' + '</div>');
        $(defAccessTemplate({
          defAccessTypes: this.accessTypes.map(function (type) {
            return {
              value: type,
              title: _gtxt('security.access.' + type),
              isSelected: type === securityInfo.SecurityInfo.DefAccess
            };
          })
        })).appendTo(ui.find('.security-custom-ui'));
      }; //ф-ция выделена из-за различий между диалогами прав слоёв и диалога состава группы


      security.prototype.saveCustomParams = function () {
        this._securityInfo.SecurityInfo.DefAccess = this._ui.find('.security-defaccess-select').val();
      };

      security.prototype._save = function () {
        var si = this._securityInfo;
        si.SecurityInfo.Users = this.securityUserListWidget.securityUsersProvider.getOriginalItems();
        nsGmx$1.widgets.notifications.startAction('securitySave');
        var postParams = {
          WrapStyle: 'window'
        };

        if (this.saveCustomParams()) {
          return;
        }

        postParams.SecurityInfo = JSON.stringify(si.SecurityInfo);
        postParams[this.propertyName] = this.propertyValue;
        sendCrossDomainPostRequest(window.serverBase + this.updateSecurityName, postParams, function (response) {
          if (!parseResponse(response)) {
            nsGmx$1.widgets.notifications.stopAction('securitySave');
            return;
          }

          nsGmx$1.widgets.notifications.stopAction('securitySave', 'success', _gtxt('Сохранено'));
          $(this).trigger('savedone', si);
        });
      };

      security.prototype.createSecurityDialog = function (securityInfo, options) {
        options = $.extend({
          showOwner: true
        }, options);

        var _this = this;

        this._securityInfo = securityInfo;
        var uiTemplate = '<div id="securityDialog" class="security-canvas">' + '<div class="security-header">' + '<button class="security-save">{{i "Сохранить"}}</button>' + '{{#if showOwner}}<div class="security-owner-placeholder"></div>{{/if}}' + '</div>' + '<div class="security-custom-ui"></div>' + '<div class="security-userlist-placeholder"></div>' + '</div>';
        var canvas = this._ui = $(Handlebars.compile(uiTemplate)({
          showOwner: options.showOwner
        }));
        this.addCustomUI(canvas, securityInfo);
        $('.security-save', canvas).click(function () {
          _this._save();
        });

        if (options.showOwner) {
          new SecurityOwnerWidget(securityInfo.SecurityInfo, $('.security-owner-placeholder', canvas));
        }

        this.securityUserListWidget = new SecurityUserListWidget(securityInfo.SecurityInfo, $('.security-userlist-placeholder', canvas), {
          accessTypes: this.accessTypes
        });

        var resize = function resize() {
          var mapTableHeight; // var dialogWidth = canvas[0].parentNode.parentNode.offsetWidth;

          var nonTableHeight = $('.security-header', canvas).height() + $('.security-custom-ui', canvas).height() + $('.security-add-container', canvas).height() + 15;
          mapTableHeight = canvas[0].parentNode.offsetHeight - nonTableHeight - 10;

          _this.securityUserListWidget.updateHeight(mapTableHeight);
        };

        this._dialogDiv = showDialog(_gtxt(this.dialogTitle, this.title), canvas[0], 571, 370, false, false, resize);
        resize();
      }; //делает запрос на сервер и возвращает список пользователей по запросу query
      //options = {maxRecords, type}; type: All / User / Group


      security.findUsers = function (query, options) {
        var def = new L.gmx.Deferred();
        var maxRecordsParamStr = options && options.maxRecords ? '&maxRecords=' + options.maxRecords : '';
        var typeParamStr = '&type=' + (options && options.type || 'All');
        sendCrossDomainJSONRequest(window.serverBase + 'User/FindUser?query=' + encodeURIComponent(query) + maxRecordsParamStr + typeParamStr, function (response) {
          if (!parseResponse(response)) {
            def.reject(response);
            return;
          }

          def.resolve(response.Result);
        });
        return def;
      };

      layersGroupSecurity.prototype._save = function (originalItems) {
        var _this = this;

        if (!_this.selectedLayersSecurityArray.length) {
          return;
        }

        var si = _this._securityInfo,
            addedUsers = _this.securityUserListWidget.securityUsersProvider.getOriginalItems();

        si.SecurityInfo = {
          // Users: [],
          UsersAdd: addedUsers,
          UsersRemove: findRemovedUsers(originalItems, addedUsers)
        };
        nsGmx$1.widgets.notifications.startAction('securitySave');
        var postParams = {
          WrapStyle: 'window'
        };

        if (this.saveCustomParams()) {
          // DefAccess: ''
          return;
        }

        postParams.SecurityInfo = JSON.stringify(si.SecurityInfo);
        postParams[this.groupPropertyName] = this.propertyValue; // Layers: {}

        sendCrossDomainPostRequest(window.serverBase + this.updateSecurityName, postParams, function (response) {
          if (!parseResponse(response)) {
            nsGmx$1.widgets.notifications.stopAction('securitySave');
            return;
          }

          originalItems = [];

          for (var i = 0; i < addedUsers.length; i++) {
            originalItems[i] = addedUsers[i];
          } // обновляем перечень общих пользователей


          _this.originalItems = originalItems; // обновляем права всех выделенных слоев

          updateselectedLayersSecurity(_this.selectedLayersSecurityArray);
          nsGmx$1.widgets.notifications.stopAction('securitySave', 'success', _gtxt('Сохранено'));
          $(this).trigger('savedone', si);
        }); // обновляет массив выделенных слоев с правами после нажатия кнопки "сохранить",
        // затем обновляет массив всех слоев

        function updateselectedLayersSecurity(array) {
          var postParams = {
            WrapStyle: 'window',
            Layers: array.map(function (obj) {
              return obj.ID;
            })
          };

          _this.getGroupSecurityFromServer(postParams).then(updateSecurity);
        } // обновляет права на слои


        function updateSecurity(res) {
          var array = _this.selectedLayersSecurityArray;

          for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < res.length; j++) {
              if (array[i].ID === res[j].ID) {
                var options = {
                  type: array[i].type,
                  multiLayer: !!array[i].MultiLayerID
                };
                array.splice(i, 1, $.extend(res[j], options));
              }
            }
          }

          for (var k = 0; k < array.length; k++) {
            for (var l = 0; l < _this.mapLayersSecurityArray.length; l++) {
              if (array[k].ID === _this.mapLayersSecurityArray[l].ID) {
                _this.mapLayersSecurityArray.splice(l, 1, array[k]);
              }
            }
          }
        } // возвращает массив удаленных пользователей


        function findRemovedUsers(original, changed) {
          return _.difference(original, changed);
        }
      }; // кастомный интерфейс - виджет группового редактирования слоев карты


      layersGroupSecurity.prototype.createSecurityDialog = function (securityInfo, options) {
        var _this = this,
            selectedLayersSecurityArray = this.selectedLayersSecurityArray;

        options = $.extend({
          showOwner: true
        }, options);
        this._securityInfo = securityInfo;
        var uiTemplate = '<div id="securityDialog" class="security-canvas">' + '<div class="security-header">' + '<button class="security-save">{{i "Сохранить"}}</button>' + '{{#if showOwner}}<div class="security-owner-placeholder"></div>{{/if}}' + '</div>' + '<div class="security-custom-ui"></div>' + '<div class="security-counter"></div>' + '<div class="security-default-access"></div>' + '<div class="security-userlist-placeholder"></div>' + '</div>';
        var canvas = this._ui = $(Handlebars.compile(uiTemplate)({
          showOwner: options.showOwner
        }));
        this.addCustomUI(canvas, resize);
        $('.security-save', canvas).click(function () {
          if (_this.groupPropertyName) {
            _this.propertyValue = selectedLayersSecurityArray.map(function (item) {
              return item.ID;
            });
          }

          _this._save(_this.originalItems);
        });

        if (options.showOwner) {
          new SecurityOwnerWidget(securityInfo.SecurityInfo, $('.security-owner-placeholder', canvas));
        }

        this._dialogDiv = showDialog(_gtxt(this.dialogTitle, this.title), canvas[0], 571, 455, false, false, resize);

        function resize() {
          var mapTableHeight,
              nonTableHeight = $('.security-header', canvas).height() + $('.security-custom-ui', canvas).height() + $('.security-counter', canvas).height() + $('.security-default-access', canvas).height() + $('.security-add-container', canvas).height() + 25;
          mapTableHeight = canvas[0].parentNode.offsetHeight - nonTableHeight - 10;

          if (_this.securityUserListWidget) {
            _this.securityUserListWidget.updateHeight(mapTableHeight);
          }
        }

        resize();
      }; // кастомный интерфейс - отдельная функция - дерево слоев для виджета группового редактирования слоев


      layersGroupSecurity.prototype.addCustomUI = function (ui, resizeFunc) {
        var _this = this,
            mapLayers = _this.mapLayers,
            mapLayersSecurityArray = _this.mapLayersSecurityArray,
            selectedLayersSecurityArray = _this.selectedLayersSecurityArray,
            counter = 0,
            actualCounter = {
          counter: counter
        },
            countDiv = $('.security-counter', ui),
            countTemplate = Handlebars.compile('<table class="security-count-table">' + '<tbody>' + '<tr>' + '<td>{{i "security.select.selectedLayers"}}</td>' + '<td>{{counter}}</td>' + '</tr>' + '</tbody>' + '</table>'),
            templateSecurityInfo = {
          Users: []
        },
            tree,
            rawTree,
            drawnTree,
            defAccessDiv = $('.security-default-access', ui),
            defAccessTemplate = Handlebars.compile('<div class="security-def-access">{{i "security.defAccess"}}: ' + '<select class="security-defaccess-select selectStyle">' + '{{#defAccessTypes}}' + '<option value="{{value}}"{{#isSelected}} selected{{/isSelected}}>{{title}}</option>' + '{{/defAccessTypes}}' + '</select>' + '</div>'),
            userList = $('.security-userlist-placeholder', ui),
            getMapLayersRights = function getMapLayersRights(callback) {
          var postParams = {
            WrapStyle: 'window',
            Layers: mapLayers.map(function (layer) {
              return layer.LayerID || layer.MultiLayerID;
            })
          };

          _this.getGroupSecurityFromServer(postParams).then(callback);
        },
            // сохраняем права слоев карты
        saveMapLayersRights = function saveMapLayersRights(res) {
          for (var i = 0; i < res.length; i++) {
            for (var j = 0; j < mapLayers.length; j++) {
              if (res[i].ID === mapLayers[j].LayerID || res[i].ID === mapLayers[j].MultiLayerID) {
                var options = {
                  type: mapLayers[j].type,
                  multiLayer: !!mapLayers[j].MultiLayerID
                };
                mapLayersSecurityArray.push($.extend(res[i], options));
              }
            }
          }
        }; // модификация исходного дерева - остаются только слои с правами на редактирование


        rawTree = window._layersTree.treeModel.cloneRawTree(function (node) {
          var props = node.content.properties;
          props.visible = false;

          if (node.type === 'layer') {
            if (props.Access !== 'edit') {
              return null;
            }

            mapLayers.push(props);
            return node;
          }

          if (node.type === 'group') {
            var children = node.content.children;

            if (!children.length) {
              return null;
            }

            return node;
          }
        }); // создание дерева слоев

        tree = new window.layersTree({
          showVisibilityCheckbox: true,
          allowActive: true,
          allowDblClick: false,
          showStyle: false,
          // обработка различных вариаций прав в группе слоев
          // если выделен один слой, рисуются его права
          // если у выделенных слоев есть юзеры с одинаковыми правами, то рисуются только эти юзеры
          // если у выделенных слоев разные права, рисуется пустой диалог
          // если у выделенных слоев разные дефолтные права, в выпадающий список выбора дефолтных прав проставляется пустое поле
          visibilityFunc: function visibilityFunc(props, isVisible) {
            if (isVisible) {
              counter++;

              for (var i = 0; i < mapLayersSecurityArray.length; i++) {
                if (mapLayersSecurityArray[i].ID === props.LayerID || mapLayersSecurityArray[i].ID === props.MultiLayerID) {
                  selectedLayersSecurityArray.push(mapLayersSecurityArray[i]);
                }
              }

              addLayer();
            }

            if (!isVisible) {
              counter--;

              for (var _i = 0; _i < selectedLayersSecurityArray.length; _i++) {
                if (selectedLayersSecurityArray[_i].ID === props.LayerID || selectedLayersSecurityArray[_i].ID === props.MultiLayerID) {
                  selectedLayersSecurityArray.splice(_i, 1);
                }
              }

              removeLayer();
            } // показываем счетчик выделенных слоев под деревом


            actualCounter.counter = counter;
            $(countDiv).html(countTemplate(actualCounter)); // добавляет слой в дерево слоев

            function addLayer() {
              drawAccess();
              resizeFunc();
            } // убирает слой из дерева слоев


            function removeLayer() {
              if (counter > 0 && selectedLayersSecurityArray.length) {
                drawAccess();
              } else {
                $(defAccessDiv).empty();
                userList.empty();
              }

              resizeFunc();
            } // рисует оба виджета - доступа по умолчанию и списка пользователей для каждого слоя


            function drawAccess() {
              drawDefaultAccess(selectedLayersSecurityArray, defAccessDiv);
              drawUsersList(selectedLayersSecurityArray, userList);
            } // рисует доступ по умолчанию


            function drawDefaultAccess(array, container) {
              var accessTypes, defTemplateJSON;

              if (checkSameLayersType(array)) {
                accessTypes = getAccessTypes(array[0].type);
              } else {
                accessTypes = ['no', 'preview', 'view', 'edit'];
              }

              defTemplateJSON = {
                defAccessTypes: accessTypes.map(function (type) {
                  return {
                    value: type,
                    title: _gtxt('security.access.' + type),
                    isSelected: undefined
                  };
                })
              };
              $(container).empty(); // протавляем значение в выпадающем списке прав по умолчанию

              if (checkSameDefaultAccess(array)) {
                var types = defTemplateJSON.defAccessTypes;

                for (var i = 0; i < types.length; i++) {
                  if (types[i].value === array[0].SecurityInfo.DefAccess) {
                    types[i].isSelected = true;
                  }
                }

                $(defAccessTemplate(defTemplateJSON)).appendTo(ui.find('.security-default-access'));
              } else {
                accessTypes.unshift('empty');
                defTemplateJSON = {
                  defAccessTypes: accessTypes.map(function (type) {
                    return {
                      value: type,
                      title: _gtxt('security.access.' + type),
                      isSelected: type === 'empty'
                    };
                  })
                };
                $(defAccessTemplate(defTemplateJSON)).appendTo(ui.find('.security-default-access'));
              }
            } // рисует список пользователей для каждого слоя


            function drawUsersList(array, container) {
              checkSameUsersAccess(array);
              var accessTypes; // запомним пересечения пользовательских прав для слоев,
              // в случае удаления / добавления пользователей, последующее состояние будет сравниваться с этим

              _this.originalItems = [];

              if (templateSecurityInfo.Users.length) {
                accessTypes = getAccessTypes(array[0].type);

                for (var i = 0; i < templateSecurityInfo.Users.length; i++) {
                  _this.originalItems.push(templateSecurityInfo.Users[i]);
                }
              } else {
                accessTypes = ['no', 'preview', 'view', 'edit'];
              }

              container.empty();
              _this.securityUserListWidget = new SecurityUserListWidget(templateSecurityInfo, container, {
                accessTypes: accessTypes
              });
            } // проверяет, совпадают ли дефолтные права для всех выделенных слоев


            function checkSameDefaultAccess(array) {
              var first = array[0].SecurityInfo.DefAccess;
              return array.every(function (element) {
                return element.SecurityInfo.DefAccess === first;
              });
            } // проверяет, совпадают ли отдельные права для всех выделенных слоев и создает массив пересечений


            function checkSameUsersAccess(array) {
              var userArray = array.map(function (obj) {
                return obj.SecurityInfo.Users;
              });
              templateSecurityInfo.Users = findCommonUsers(userArray); // нахождение одинаковых значений {пользователь: права} во всех слоях

              function findCommonUsers(array) {
                var a = array.sort(sortArraysByLength),
                    first = a[0];

                if (first.length) {
                  for (var i = 1; i < a.length; i++) {
                    first = first.filter(function (obj) {
                      return a[i].find(function (obj2) {
                        return _.isEqual(obj, obj2);
                      });
                    });
                  }
                } else {
                  first = [];
                }

                return first;
              } // сортировка массивов пользователей по длине для оптимизации времени


              function sortArraysByLength(a, b) {
                return a.length - b.length;
              }
            } // проверяет, совпадают ли типы для всех выделенных слоев (вектор/растр)


            function checkSameLayersType(array) {
              var first = array[0].type;
              return array.every(function (element) {
                return element.type === first;
              });
            }

            function getAccessTypes(layerType) {
              var accessTypes;

              if (layerType === 'Raster') {
                accessTypes = ['no', 'preview', 'view', 'edit'];
              } else if (layerType === 'Vector') {
                if (props.IsRasterCatalog) {
                  accessTypes = ['no', 'preview', 'view', 'editrows', 'edit'];
                } else {
                  accessTypes = ['no', 'view', 'editrows', 'edit'];
                }
              }

              return accessTypes;
            }
          }
        });
        drawnTree = tree.drawTree(rawTree, 2);
        getMapLayersRights(saveMapLayersRights);
        $(drawnTree).treeview().appendTo(ui.find('.security-custom-ui'));
        $(countDiv).html(countTemplate(actualCounter));
      };

      nsGmx$1.mapSecurity = mapSecurity;
      nsGmx$1.security = security;
      nsGmx$1.layerSecurity = layerSecurity;
      nsGmx$1.multiLayerSecurity = multiLayerSecurity;
      nsGmx$1.layersGroupSecurity = layersGroupSecurity;
    })();

    (function () {
      //Контроллёр контектных меню и соответствующие пункты всех меню...

      /**
      * Контроллёр контекстных меню.
      * @class
      * @name ContextMenuController
      * @memberOf nsGmx
      *
      * @description Позволяет добавлять элементы контектсного меню разного типа и привязывать меню к отдельным DOM элементам.
      * Возможно динамическое создание меню при клике на объекте. Элементам меню передаётся контекст,
      * указанный при привязке меню к элементу (он так же может создаваться в момент клика на элементе)
      * Каждый элемент меню - отдельный объект, они независимо добавляются в контроллер.
      * При создании меню определённого типа из этого набора выбираются нужные элементы.
      */
      nsGmx$1.ContextMenuController = function () {
        var _menuItems = {};
        var SUGGEST_TIMEOUT = 700; // Показывает контектное меню для конкретного элемента.
        // В Opera меню показывается при наведении на элемент в течении некоторого времени, во всех остальных браузерах - по правому клику.
        // Меню исчезает при потере фокуса
        // Параметры:
        // * elem {DOMElement} - элемент, на который навешивается меню
        // * menuFunc {Function, menuFunc()->DomElement} - функция, создающая меню
        // * checkFunc {Function, checkFunc()->Bool} - если возвращает false, то ничего не показывается...

        var _context = function _context(elem, menuFunc, checkFunc) {
          var menu = null;

          elem.oncontextmenu = function (e) {
            if (typeof checkFunc != 'undefined' && !checkFunc()) return false;
            if (menu && menu.parentNode) menu.parentNode.removeChild(menu);
            menu = menuFunc();
            if (!menu) return false;

            var contextMenu = _div([menu], [['dir', 'className', 'contextMenu'], ['attr', 'id', 'contextMenuCanvas']]);

            var evt = e || window.event;
            hidden(contextMenu);
            document.body.appendChild(contextMenu); // определение координат курсора для ie

            if (evt.pageX == null && evt.clientX != null) {
              var html = document.documentElement;
              var body = document.body;
              evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0);
              evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0);
            }

            if (evt.pageX + contextMenu.clientWidth < getWindowWidth()) contextMenu.style.left = evt.pageX - 5 + 'px';else contextMenu.style.left = evt.pageX - contextMenu.clientWidth + 5 + 'px';
            if (evt.pageY + contextMenu.clientHeight < getWindowHeight()) contextMenu.style.top = evt.pageY - 5 + 'px';else contextMenu.style.top = evt.pageY - contextMenu.clientHeight + 5 + 'px';
            visible(contextMenu);
            var menuArea = contextMenu.getBoundingClientRect();

            contextMenu.onmouseout = function (e) {
              var evt = e || window.event; // определение координат курсора для ie

              if (evt.pageX == null && evt.clientX != null) {
                var html = document.documentElement;
                var body = document.body;
                evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0);
                evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0);
              }

              if (evt.pageX <= menuArea.left || evt.pageX >= menuArea.right || evt.clientY <= menuArea.top || evt.clientY >= menuArea.bottom) {
                menu = null;
                contextMenu.removeNode(true);
              }
            };

            return false;
          };
        };

        var _contextClose = function _contextClose() {
          $('#contextMenuCanvas').remove();
        };

        var _generateMenuDiv = function _generateMenuDiv(type, context) {
          var uiTemplate = Handlebars.compile('<div>' + '{{#menuItems}}' + '{{#if separator}}<div class = "contextMenuSeparator"></div>{{/if}}' + '<div class = "contextMenuItem" data-itemIndex="{{index}}">{{title}}</div>' + '{{/menuItems}}' + '</div>');
          var items = _menuItems[type],
              visibleItems = [];

          for (var e = 0; e < items.length; e++) {
            var menuElem = items[e];

            if (menuElem.isVisible && !menuElem.isVisible(context)) {
              continue;
            }

            visibleItems.push({
              index: e,
              title: typeof menuElem.title === 'function' ? menuElem.title() : menuElem.title,
              separator: menuElem.isSeparatorBefore && menuElem.isSeparatorBefore(context)
            });
          }

          if (visibleItems.length) {
            var ui = $(uiTemplate({
              menuItems: visibleItems
            }));
            ui.find('.contextMenuItem').click(function () {
              var itemIndex = Number($(this).data('itemindex'));
              context.contentMenuArea = getOffsetRect(this);
              context.contentMenuType = type;

              _contextClose();

              _menuItems[type][itemIndex].clickCallback(context);
            });
            return ui[0];
          }

          return null;
        }; //public interface


        return {
          /**
           * Добавляет новый пункт меню
                 * @memberOf nsGmx.ContextMenuController
           * @function
           * @param {nsGmx.ContextMenuController.IContextMenuElem} menuItem Элемент контекстного меню
           * @param {String | String[]} menuType Тип меню (например: "Layer", "Map", "Group"). Если массив, то данный элемент применяется в нескольких типах меню
           */
          addContextMenuElem: function addContextMenuElem(menuItem, menuType) {
            if (typeof menuType === 'string') menuType = [menuType];

            for (var i = 0; i < menuType.length; i++) {
              _menuItems[menuType[i]] = _menuItems[menuType[i]] || [];

              _menuItems[menuType[i]].push(menuItem);
            }
          },

          /**
           * Добавляет к DOM элементу контекстное меню
           * @function
                 * @memberOf nsGmx.ContextMenuController
           * @param {DOMElement} elem Целевой DOM-элемент
           * @param {String} type Тип меню
           * @param {function():Boolean} checkFunc Проверка, показывать ли сейчас меню. Если ф-ция возвращает false, меню не показывается
           * @param {Object|function(context):Object} context Контекст, который будет передан в элемент меню при клике на DOM-элементе.
           *        Если контект - ф-ция, она будет вызвана непосредственно при клике. В контекст при клике будут добавлены элементы contentMenuArea и contentMenuType.
           */
          bindMenuToElem: function bindMenuToElem(elem, type, checkFunc, context) {
            _context(elem, function () {
              if (typeof context === 'function') context = context(); //

              return _generateMenuDiv(type, context);
            }, checkFunc, SUGGEST_TIMEOUT);
          }
        };
      }();
      /** Интерфейс для задания контекстного меню пользователей
      * @class
      * @name nsGmx.ContextMenuController.IContextMenuElem
      */

      /** Нужно ли отображать данный пункт меню для данного элемента и типа дерева. Необязательная (по умолчанию отображается)
      @function
      @name isVisible
      @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      @param {Object} context - контекст, специфический для конкретного типа меню
      */

      /** Нужно ли рисовать перед данным пунктом разделитель (гориз. черту). Необязательная (по умолчанию не рисуется)
      @function
      @name isSeparatorBefore
      @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      @param {Object} context - контекст, специфический для конкретного типа меню
      */

      /** Вызывается при клике по соответствующему пункту меню
      * @function
      * @name clickCallback
      * @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      * @param {object} context - контекст, который был передан при привязке меню к DOM-элементу. В контекст будут добавлены поля:
      *
      *  * contentMenuArea {Object} - координаты верхнего левого угла пункта меню, на которое было нажатие. {left: int, top: int}. Если нужно привязаться к месту текущего клика
      *  * contentMenuType {String}- тип вызванного контекстного меню. Актуально, если элемент меню используется в нескольких типах меню.
      */

      /** Строка или ф-ция, которую нужно отображать в контекстном меню. Если ф-ция, то она будет вызываться при каждом формировании меню и должна возвращать строку.
      @name title
      @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      */
      //Все заголовки элементов меню заданы как ф-ции, так как на момент выполенения этого кода неизвестен выбранный язык системы
      ///////////////////////////////////////////////////////////////////////////////
      /////////////////////////// Контекстное меню слоёв ////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /*
      В контексте типа "Layer" присутствуют следующие атрибуты:
       * layerManagerFlag {int} Тип дерева
       * elem Элемент (слой), для которого стротся меню
       * tree {layersTree} Текущее дерево, внутри которого находится слой
      */


      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Свойства");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && nsGmx$1.AuthManager.isLogin();
        },
        clickCallback: function clickCallback(context) {
          var div;
          if (context.elem.MultiLayerID) div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];else div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];

          _mapHelper.createLayerEditor(div, context.tree, 'main', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Стили");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && context.elem.type === "Vector" && _queryMapLayers.currentMapRights() === "edit";
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createStylesDialog(context.elem, context.tree);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Таблица атрибутов");
        },
        isVisible: function isVisible(context) {
          return !nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_UNAUTHORIZED) && !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.layerRights(context.elem.name) == 'view' || _queryMapLayers.layerRights(context.elem.name) == 'edit' || _queryMapLayers.layerRights(context.elem.name) === 'editrows') && context.elem.type === "Vector";
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createAttributesTable(context.elem.name);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Права доступа");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) && _queryMapLayers.layerRights(context.elem.name) === 'edit';
        },
        clickCallback: function clickCallback(context) {
          if (context.elem.MultiLayerID) {
            var securityDialog = new nsGmx$1.multiLayerSecurity();
            securityDialog.getRights(context.elem.MultiLayerID, context.elem.title);
          } else {
            var _securityDialog = new nsGmx$1.layerSecurity(context.elem.name);

            _securityDialog.getRights(context.elem.name, context.elem.title);
          }
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Скачать");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.currentMapRights() == "view" && nsGmx$1.AuthManager.isLogin()) && context.elem.type == "Vector" && context.tree.treeModel.getMapProperties().CanDownloadVectors;
        },
        clickCallback: function clickCallback(context) {
          _mapHelper.downloadVectorLayer({
            name: context.elem.name,
            host: context.elem.hostName
          });
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Удалить");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && _queryMapLayers.currentMapRights() === "edit";
        },
        clickCallback: function clickCallback(context) {
          _queryMapLayers.removeLayer(context.elem.name);

          var div;
          if (context.elem.MultiLayerID) div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];else div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
          var node = div.parentNode,
              parentTree = node.parentNode;

          _layersTree.removeTreeElem(div);

          node.removeNode(true);

          window._abstractTree.delNode(null, parentTree, parentTree.parentNode);

          _mapHelper.updateUnloadEvent(true);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Добавить снимки");
        },
        isVisible: function isVisible(context) {
          var layerRights = _queryMapLayers.layerRights(context.elem.name);

          return !context.layerManagerFlag && (layerRights === 'edit' || layerRights === 'editrows') && context.elem.type == "Vector" && context.elem.IsRasterCatalog;
        },
        clickCallback: function clickCallback(context) {
          new nsGmx$1.RCAddLayerControl(nsGmx$1.gmxMap, context.elem.name);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Копировать стиль");
        },
        isVisible: function isVisible(context) {
          return context.elem.type == "Vector" && (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
        },
        isSeparatorBefore: function isSeparatorBefore(context) {
          return !context.layerManagerFlag;
        },
        clickCallback: function clickCallback(context) {
          var rawTree = context.tree.treeModel,
              elem;
          if (context.elem.MultiLayerID) elem = rawTree.findElem("MultiLayerID", context.elem.MultiLayerID).elem;else elem = rawTree.findElem("LayerID", context.elem.name).elem;
          nsGmx$1.ClipboardController.addItem('LayerStyle', {
            type: context.elem.GeometryType,
            style: elem.content.properties.styles
          });
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Создать копию слоя");
        },
        isVisible: function isVisible(context) {
          return context.elem.type == "Vector" && (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
        },
        isSeparatorBefore: function isSeparatorBefore() {
          return false;
        },
        clickCallback: function clickCallback(context) {
          sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + context.elem.name, function (response) {
            if (!parseResponse(response)) {
              return;
            }

            createEditorFromSelection(response.Result);

            function createEditorFromSelection(props) {
              var query = '';

              var parent = nsGmx$1.Utils._div(null, [['attr', 'id', 'new' + 'Vector' + 'Layer'], ['css', 'height', '100%']]),
                  properties = {
                Title: props.Title + ' ' + _gtxt('копия'),
                Copyright: props.Copyright,
                Description: props.Description,
                Date: props.Date,
                MetaProperties: props.MetaProperties,
                TilePath: {
                  Path: ''
                },
                ShapePath: props.ShapePath,
                Columns: props.Columns,
                IsRasterCatalog: props.IsRasterCatalog,
                SourceType: "sql",
                Quicklook: props.Quicklook
              },
                  dialogDiv = nsGmx$1.Utils.showDialog(_gtxt('Создать векторный слой'), parent, 340, 340, false, false),
                  params = {
                copy: true,
                sourceLayerName: context.elem.name,
                query: query,
                doneCallback: function doneCallback() {
                  nsGmx$1.Utils.removeDialog(dialogDiv);
                }
              };

              nsGmx$1.createLayerEditor(false, 'Vector', parent, properties, params);
            }
          });
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Вставить объекты");
        },
        isVisible: function isVisible(context) {
          return context.elem.type == "Vector" && (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
        },
        isSeparatorBefore: function isSeparatorBefore() {
          return false;
        },
        clickCallback: function clickCallback(context) {
          var copyLayerParams = nsGmx$1.ClipboardController.get('CopyObjects', -1),
              copyLayerName = copyLayerParams.layerName,
              copyLayerQuery = copyLayerParams.query,
              list = copyLayerParams.list || '';
          var url = window.serverBase + "VectorLayer/Append?LayerName=" + context.elem.name + "&FromLayer=" + copyLayerName + "&Query=" + copyLayerQuery;
          var def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(url);
          def.done(function () {
            showErrorMessage(list, true, window._gtxt('Объекты добавлены'));
          }).fail(function () {
            showErrorMessage(window._gtxt('Вставить объекты не удалось'), true); // console.log(taskInfo);
          }).progress(function () {// console.log(taskInfo);
          });
        }
      }, 'Layer');
      var applyStyleContentMenuItem = {
        title: function title() {
          return _gtxt("Применить стиль");
        },
        isVisible: function isVisible(context) {
          if (context.layerManagerFlag || _queryMapLayers.currentMapRights() !== "edit" || nsGmx$1.ClipboardController.getCount('LayerStyle') === 0) {
            return false;
          }

          if (context.contentMenuType === 'Layer') {
            return context.elem.type == "Vector" && nsGmx$1.ClipboardController.get('LayerStyle', -1).type === context.elem.GeometryType;
          } else {
            //группы
            return true;
          }
        },
        clickCallback: function clickCallback(context) {
          var newStyles = nsGmx$1.ClipboardController.get('LayerStyle', -1).style,
              stylesType = nsGmx$1.ClipboardController.get('LayerStyle', -1).type;

          if (context.contentMenuType === 'Layer') {
            var div;
            if (context.elem.MultiLayerID) div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];else div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
            div.gmxProperties.content.properties.styles = newStyles;

            _mapHelper.updateMapStyles(newStyles, context.elem.name);

            _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
          } else {
            //группа
            var tree = context.tree.treeModel,
                node = tree.findElemByGmxProperties(context.div.gmxProperties).elem;
            tree.forEachLayer(function (layerContent) {
              if (layerContent.properties.type !== "Vector" || layerContent.properties.GeometryType !== stylesType) {
                return;
              }

              layerContent.properties.styles = newStyles;

              _mapHelper.updateMapStyles(newStyles, layerContent.properties.name);

              var div = context.tree.findUITreeElem({
                content: layerContent
              });

              if (div) {
                // div.gmxProperties.content.properties.styles = newStyles;
                _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
              }
            }, node);
          }
        }
      };
      nsGmx$1.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Layer'); ///////////////////////////////////////////////////////////////////////////////
      /////////////////////////// Контекстное меню групп ////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /*
      В контексте типа "Group" присутствуют следующие атрибуты:
       * div {DOMElement} Элемент дерева, для которого стротся меню
       * tree {layersTree} Текущее дерево карты
      */

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Свойства");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createGroupEditor(context.div);
        }
      }, 'Group');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Добавить подгруппу");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.addSubGroup(context.div, context.tree);
        }
      }, 'Group');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Удалить");
        },
        clickCallback: function clickCallback(context) {
          context.tree.removeGroup(context.div);

          _mapHelper.updateUnloadEvent(true);
        }
      }, 'Group');
      nsGmx$1.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Group'); ///////////////////////////////////////////////////////////////////////////////
      /////////////////////////// Контекстное меню карты ////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /*
      В контексте типа "Map" присутствуют следующие атрибуты:
       * div {DOMElement} Элемент дерева, для которого стротся меню
       * tree {layersTree} Текущее дерево карты
      */

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Свойства");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createMapEditor(context.div);
        }
      }, 'Map');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Добавить подгруппу");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.addSubGroup(context.div, context.tree);
        }
      }, 'Map');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Права доступа");
        },
        clickCallback: function clickCallback(context) {
          var securityDialog = new nsGmx$1.mapSecurity();
          securityDialog.getRights(context.tree.treeModel.getMapProperties().MapID, context.tree.treeModel.getMapProperties().title);
        },
        isVisible: function isVisible() {
          return nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) && (_queryMapLayers.currentMapRights() === "edit" || nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN));
        }
      }, 'Map'); //групповое редактирование слоев

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Права доступа к слоям");
        },
        isVisible: function isVisible(context) {
          var treeModel = context.tree.treeModel,
              layersFlag = false,
              layersRights = false;
          treeModel.forEachNode(function (node) {
            if (node.type !== 'group') {
              layersFlag = true;

              if (_queryMapLayers.layerRights(node.content.properties.LayerID) === 'edit') {
                layersRights = true;
              }
            }
          });
          return nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) && layersFlag && layersRights;
        },
        clickCallback: function clickCallback() {
          var securityDialog = new nsGmx$1.layersGroupSecurity(),
              props = _layersTree.treeModel.getMapProperties();

          securityDialog.getRights(props.MapID, props.title);
        }
      }, 'Map');
    })();

    nsGmx$1.GeomixerFrameworkVersion = '05.12.2018';

    (function ($, _) {
      var modulePath = ""; //TODO: вынести переключалку страниц в отдельный модуль

      var appendTranslations = function appendTranslations() {
        _translationsHash.addtext("rus", {
          "Следующие [value0] страниц": "Следующие [value0] страниц",
          "Предыдущие [value0] страниц": "Предыдущие [value0] страниц",
          "Первая страница": "Первая страница",
          "Последняя страница": "Последняя страница"
        });

        _translationsHash.addtext("eng", {
          "Следующие [value0] страниц": "Next [value0] pages",
          "Предыдущие [value0] страниц": "Previous [value0] pages",
          "Первая страница": "First page",
          "Последняя страница": "Last page"
        });
      };
      /** Интерфейс провайдера данных таблицы {@link nsGmx.ScrollTable}
       * @class nsGmx.ScrollTable.IDataProvider
       * @abstract
       */

      /** Получить общее количество объектов
        @method nsGmx.ScrollTable.IDataProvider#getCount
        @param {function(Number)} callback Ф-ция, которую нужно вызвать с общим количеством объектов
      */

      /** Это событие должно генерироваться при любом изменении набора данных. Приведёт к перерисовке таблицы
        @event nsGmx.ScrollTable.IDataProvider#change
      */

      /** Получить массив объектов для отрисовки на странице
        @method nsGmx.ScrollTable.IDataProvider#getItems
        @param {Number} page Номер страницы (нумерация с нуля)
        @param {Number} pageSize Размер страницы
        @param {String} sortParam По какому атрибуту сортировать
        @param {Boolean} sortDec Направление сортировки (true - по убыванию)
        @param {function(Array)} callback Ф-ция, которую нужно вызвать с результирующим массивом объектов. Структура самих объектов определяется провайдером
      */

      /** Получить массив объектов для отрисовки на страницы и общее количество данных за один запрос.
      	Альтернатива раздельным запросам getItems() и getCount(). Можно реализовать либо эту ф-цию, либо две другие
        @method nsGmx.ScrollTable.IDataProvider#getCountAndItems
        @param {Number} page Номер страницы (нумерация с нуля)
        @param {Number} pageSize Размер страницы
        @param {String} sortParam По какому атрибуту сортировать
        @param {Boolean} sortDec Направление сортировки (true - по убыванию)
        @param {function(count:Number, objs:Object[])} callback Ф-ция, которую нужно вызвать с полученным результатом.
      		 Первый параметр - общее количество объектов, второй - массив объектов для данной страницы.
      */

      /** Таблица с разбиением данных по страницам. Сильно кастомизируемый виджет. Поддерживает различные провайдеры данных и рендереры.
       * @class
       * @alias nsGmx.ScrollTable
       */


      var scrollTable = function scrollTable(params) {
        /** Перед перерисовкой данных
         * @event nsGmx.ScrollTable#beforeRedraw
         */

        /** После перерисовки данных
         * @event nsGmx.ScrollTable#redraw
         */

        /** Изменились параметры сортировки
         * @event nsGmx.ScrollTable#sortChange
         */
        this._params = $.extend({
          limit: 50,
          page: 0,
          pagesCount: 10,
          height: '',
          showFooter: true
        }, params);
        this.limit = this._params.limit;
        this.pagesCount = this._params.pagesCount;
        this.start = 0;
        this.reportStart = 0;
        this.drawFunc = null;
        this._requestID = 0;
        this._pageVals = [];
        this._currValsCount = 0;
        this._dataProvider = null; // Переход на предыдущую страницу

        this.next = function () {
          var _this = this,
              button = makeImageButton(modulePath + 'img/next.png', modulePath + 'img/next_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start += _this.pagesCount;
            _this.reportStart = _this.start * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title(button, _gtxt('Следующие [value0] страниц', _this.pagesCount));

          return button;
        }; // Переход на следующую страницу


        this.previous = function () {
          var _this = this,
              button = makeImageButton(modulePath + 'img/prev.png', modulePath + 'img/prev_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start -= _this.pagesCount;
            _this.reportStart = _this.start * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title(button, _gtxt('Предыдущие [value0] страниц', _this.pagesCount));

          return button;
        }; // Переход на первую страницу


        this.first = function () {
          var _this = this,
              button = makeImageButton(modulePath + 'img/first.png', modulePath + 'img/first_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start = 0;
            _this.reportStart = _this.start * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title(button, _gtxt('Первая страница'));

          return button;
        }; // Переход на последнюю страницу


        this.last = function () {
          var _this = this,
              button = makeImageButton(modulePath + 'img/last.png', modulePath + 'img/last_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start = Math.floor(_this._currValsCount / (_this.pagesCount * _this.limit)) * _this.pagesCount;
            _this.reportStart = Math.floor(_this._currValsCount / _this.limit) * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title(button, _gtxt('Последняя страница'));

          return button;
        };

        var _this = this;

        this._status = {
          _state: false,
          start: function start() {
            this._state = true;
            var me = this;
            setTimeout(function () {
              if (me._state) {
                $(_this.statusContainer).siblings().hide();
                $(_this.statusContainer).show();
              }
            }, 100);
          },
          stop: function stop() {
            $(_this.statusContainer).siblings().show();
            $(_this.statusContainer).hide();
            this._state = false;
          }
        };
        this.limitSel = nsGmx$1.Utils._select([_option([_t("10")], [['attr', 'value', 10]]), _option([_t("20")], [['attr', 'value', 20]]), _option([_t("50")], [['attr', 'value', 50]]), _option([_t("100")], [['attr', 'value', 100]]), _option([_t("200")], [['attr', 'value', 200]]), _option([_t("500")], [['attr', 'value', 500]])], [['dir', 'className', 'selectStyle floatRight'], ['css', 'width', '60px']]);
      };
      /** Установка провайдера данных
       @param {nsGmx.ScrollTable.IDataProvider} dataProvider Провайдер данных
       */


      scrollTable.prototype.setDataProvider = function (dataProvider) {
        this._dataProvider = dataProvider;

        this._drawTable();
      };
      /** Получить текущий провайдер данных
       @return {nsGmx.ScrollTable.IDataProvider} Текущий провайдер данных
       */


      scrollTable.prototype.getDataProvider = function () {
        return this._dataProvider;
      };
      /** Изменить активность (видимость) колонки в таблице
        @param {String} name имя колонки
        @param {Boolean} isActive активность (видимость) колонки
      */


      scrollTable.prototype.activateField = function (name, isActive) {
        for (var f = 0; f < this._fields.length; f++) {
          if (this._fields[f].title == name) {
            if (this._fields[f].isActive == isActive) return;
            this._fields[f].isActive = isActive;

            this._drawHeader();

            this._drawRows();
          }
        }
      };

      scrollTable.prototype._getActiveFields = function () {
        var res = [];

        for (var f = 0; f < this._fields.length; f++) {
          if (this._fields[f].isActive) res.push(this._fields[f].title);
        }

        return res;
      };

      scrollTable.prototype._drawRows = function () {
        var trs = [],
            tr;
        $(this).triggerHandler('beforeRedraw');
        $(this.tableBody).empty();

        var activeFields = this._getActiveFields();

        for (var i = 0; i < this._pageVals.length; i++) {
          tr = this.drawFunc(this._pageVals[i], i, activeFields);
          tr && trs.push(tr);
        }

        _(this.tableBody, trs);

        if (this._pageVals.length == 0) _(this.tableBody, [_tr(null, [['css', 'height', '1px'], ['attr', 'empty', true]])]);
        $(this.tableCount).empty();
        this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);

        if (this._currValsCount) {
          var cntStr = this._currValsCount === 100001 ? 'более 100000' : this._currValsCount;

          _(this.tableCount, [_span([_t(this.reportStart + 1 + '-' + Math.min(this.reportStart + this.limit, this._currValsCount)), _span([_t(' ')], [['css', 'margin', '0px 3px']]), _t("(" + cntStr + ")")]), this.statusContainer]);
        } else {
          _(this.tableCount, [_span([_t("0-0"), _span([_t(' ')], [['css', 'margin', '0px 3px']]), _t("(0)")]), this.statusContainer]);
        }

        $(this).triggerHandler('redraw');
      };

      scrollTable.prototype._drawPages = function (end) {
        var _this = this;

        for (var i = this.start + 1; i <= end; i++) {
          // текущий элемент
          if (i - 1 == this.reportStart / this.limit) {
            var el = _span([_t(i.toString())]);

            _(_this.tablePages, [el]);

            $(el).addClass('page');
          } else {
            var link = makeLinkButton(i.toString());
            link.setAttribute('page', i - 1);
            link.style.margin = '0px 2px';

            _(_this.tablePages, [link]);

            link.onclick = function () {
              _this.reportStart = this.getAttribute('page') * _this.limit;

              _this._drawPagesRow(); // мозилла


              _this.tableBody.scrollTop = 0; // ие

              _this.tableParent.scrollTop = 0;
            };
          }
        }
      };

      scrollTable.prototype._updatePageData = function (callback) {
        var _this = this;

        if (this._dataProvider.getCountAndItems) {
          var requestID = this._requestID++;

          this._status.start();

          _this._dataProvider.getCountAndItems(_this.reportStart / _this.limit, _this.limit, _this.currentSortType, _this.currentSortIndex[_this.currentSortType] == 1, function (count, values) {
            if (requestID !== _this._requestID - 1) {
              _this._status.stop();

              return;
            }

            _this._currValsCount = count; //если данных стало слишком мало, мы встанем на первую страницу и перезапросим данные ещё раз

            if (_this.reportStart > _this._currValsCount) {
              requestID = _this._requestID++;
              _this.start = _this.reportStart = 0; //на первую страницу

              _this._dataProvider.getCountAndItems(_this.reportStart / _this.limit, _this.limit, _this.currentSortType, _this.currentSortIndex[_this.currentSortType] == 1, function (count, values) {
                _this._status.stop();

                if (requestID !== _this._requestID - 1) return;
                _this._pageVals = values;
                callback();
              });
            } else {
              _this._status.stop();

              _this._pageVals = values;
              callback();
            }
          });
        } else {
          this._status.start();

          this._dataProvider.getCount(function (count) {
            _this._currValsCount = count; //вообще-то при обновлении данных мы не изменяем текущей страницы
            //однако если данных стало слишком мало, то текущую страницу сохранить нельзя,
            //и мы переключимся на первую

            if (_this.reportStart >= _this._currValsCount) {
              _this.start = _this.reportStart = 0;
            }

            _this._dataProvider.getItems(_this.reportStart / _this.limit, _this.limit, _this.currentSortType, _this.currentSortIndex[_this.currentSortType] == 1, function (values) {
              _this._status.stop();

              _this._pageVals = values || [];
              callback();
            });
          });
        }
      };

      scrollTable.prototype._drawPagesRow = function () {
        var _this = this;

        this._updatePageData(function () {
          // перерисовывем номера страниц
          $(_this.tablePages).empty();

          if (_this._currValsCount > _this.limit) {
            var allPages = Math.ceil(_this._currValsCount / _this.limit);
            var end = _this.start + _this.pagesCount <= allPages ? _this.start + _this.pagesCount : allPages;
            if (_this.start - _this.pagesCount >= 0) _(_this.tablePages, [_this.first(), _this.previous()]);

            _this._drawPages(end);

            if (end + 1 <= allPages) _(_this.tablePages, [_this.next(), _this.last()]);
          }

          _this._drawRows();
        });
      };

      scrollTable.prototype._drawHeader = function () {
        var tds = [],
            _this = this;

        var headerElemFactory = this._isWidthScroll ? _th : _td;

        this._fields.forEach(function (field) {
          if (!field.isActive) return;
          var title = field.title,
              button;

          if (title != '' && field.isSortable) {
            button = makeLinkButton(title);
            button.sortType = title;
          } else button = _t(title);

          var td = headerElemFactory([button], [['css', 'width', field.width]]);

          if (field.isSortable) {
            $(td).click(function () {
              _this.setSortParams(title, 1 - _this.currentSortIndex[title]);
            });
          }

          tds.push(td);
        });

        $(this._tableHeaderRow).empty();

        _(this._tableHeaderRow, tds);
      }; //Если baseWidth == 0, таблица растягивается на весь контейнер по ширине

      /** Нарисовать таблицу
      * @param {Object} params
      * @param {DOMElement} params.parent Контейнер для помещения результата отрисовки
      * @param {String} params.name Уникальное имя таблицы
      * @param {Number} [params.baseWidth] Какой ширины должна быть таблица. Если не указано, будет занимать 100% контейнера
      * @param {String[]} params.fields массив имён колонок
      * @param {String[]} params.fieldsWidths массив с описанием ширины колонок. Описание даётся в терминах css
      * @param {function} params.drawFunc Ф-ция отрисовки одной строки таблицы. На вход - объект для отрисовки (полученный от провайдера). На выходе - "tr" элемент
      * @param {Object} [params.sortableFields] Хеш для указания возможности сортировки колонок (будет включена для всех ключей хеша)
      * @param {Boolean} [params.isWidthScroll] Трубется ли возможность прокрутки данных по горизонтали
      */


      scrollTable.prototype.createTable = function (parent, name, baseWidth, fields, fieldsWidths, drawFunc, sortableFields, isWidthScroll) {
        var params = null; //передача параметров в виде структуры

        if (arguments.length === 1) {
          params = $.extend(true, {
            sortableFields: {}
          }, parent);
        } else {
          params = {
            parent: parent,
            name: name,
            baseWidth: baseWidth,
            fields: fields,
            fieldsWidths: fieldsWidths,
            drawFunc: drawFunc,
            sortableFields: sortableFields,
            isWidthScroll: isWidthScroll
          };
        }

        name = params.name;

        var _this = this;

        this._isWidthScroll = params.isWidthScroll;
        this._fields = [];

        for (var f = 0; f < params.fields.length; f++) {
          this._fields.push({
            title: params.fields[f],
            width: params.fieldsWidths[f],
            isSortable: params.fields[f] in params.sortableFields,
            isActive: true
          });
        }

        this.limitSel = switchSelect(this.limitSel, this.limit);

        this.limitSel.onchange = function () {
          _this.limit = Number(this.value);
          _this.start = 0;
          _this.reportStart = _this.start * _this.limit;

          _this._drawTable();
        };

        this.tableCount = _div();
        this.tableLimit = _div([this.limitSel]);
        this.tablePages = _div(null, [['dir', 'className', 'tablePages']]);
        this.tableBody = _tbody(null, [['attr', 'id', name + 'TableBody']]);
        this._tableHeaderRow = _tr();

        if (this._isWidthScroll) {
          this.tableHeader = _thead([this._tableHeaderRow], [['attr', 'id', name + 'TableHeader'], ['dir', 'className', 'tableHeader']]);
        } //как формировать фиксированный заголовок таблицы, зависит от того, будет ли у таблицы фиксированный размер или нет
        //TODO: убрать возможность задавать фиксированный размер
        else if (params.baseWidth) this.tableHeader = _tbody([this._tableHeaderRow], [['attr', 'id', name + 'TableHeader']]);else this.tableHeader = _tbody([_tr([_td([_table([_tbody([this._tableHeaderRow])])]), _td(null, [['css', 'width', '20px']])])], [['attr', 'id', name + 'TableHeader']]);

        this._drawHeader();

        if (this._isWidthScroll) {
          this.tableParent = _div([_table([this.tableHeader, this.tableBody], [['css', 'width', '100%']])], [['attr', 'id', name + 'TableParent'], ['dir', 'className', 'scrollTable'], ['css', 'width', baseWidth ? baseWidth + 'px' : "100%"], ['css', 'height', this._params.height], ['css', 'overflow', 'auto']]);
        } else {
          this.tableParent = _div([_div([_table([this.tableHeader])], [['dir', 'className', 'tableHeader']]), _div([_table([this.tableBody])], [['dir', 'className', 'tableBody'], ['css', 'height', this._params.height ? this._params.height - 20 + 'px' : ''], ['css', 'width', params.baseWidth ? params.baseWidth + 20 + 'px' : "100%"]])], [['attr', 'id', name + 'TableParent'], ['dir', 'className', 'scrollTable'], ['css', 'height', this._params.height ? this._params.height + 'px' : ''], ['css', 'width', params.baseWidth ? params.baseWidth + 'px' : "100%"]]);
        }

        _(params.parent, [this.tableParent]);

        if (this._params.showFooter) _(params.parent, [_table([_tbody([_tr([_td([this.tableCount], [['css', 'width', '20%']]), _td([this.tablePages]), _td([this.tableLimit], [['css', 'width', '20%']])])])], [['css', 'width', '100%']])]);
        this.drawFunc = params.drawFunc;
        this.start = 0; //Первый номер страницы, показываемый на экране (это не текущая страница!)

        this.reportStart = 0; //Первый номер элемента на текущей странице

        this.currentSortType = null; // сортировка по умолчанию

        for (var _name in params.sortableFields) {
          this.currentSortType = _name;
          break;
        }

        this.currentSortIndex = {};

        for (var _name2 in params.sortableFields) {
          this.currentSortIndex[_name2] = 0;
        }

        if (!this._dataProvider) this.setDataProvider(new scrollTable.StaticDataProvider());
        $(this._dataProvider).change(function () {
          _this._drawTable();
        });

        this._drawTable();
      };

      scrollTable.prototype.updateHeight = function (height) {
        if (this._isWidthScroll) {
          this.tableParent.style.height = height - 40 + 'px';
        } else {
          $(this.tableParent).find('.tableBody').height(height - 20);
          $(this.tableParent).height(height);
        }
      };

      scrollTable.prototype._drawTable = function () {
        if (!this.tableBody) return; //ещё не создана таблица

        this._drawPagesRow();
      };
      /** Выбрать страницу для показа
      @param {Number} page Номер страницы (нумерация с нуля)
      */


      scrollTable.prototype.setPage = function (iPage) {
        if (this.limit * iPage >= this._currValsCount || iPage < 0 || this.reportStart == iPage * this.limit) return;
        this.reportStart = iPage * this.limit;
        this.start = Math.floor(iPage / this.pagesCount) * this.pagesCount;

        this._drawPagesRow();

        this.tableBody.scrollTop = 0;
        this.tableParent.scrollTop = 0;
      };
      /** Получить массив объектов, которые нарисованы в данный момент
       @return {Array} массив объектов в формате провайдера данных
      */


      scrollTable.prototype.getVisibleItems = function () {
        return this._pageVals;
      };
      /** Задать параметры сортровки
       @param {String} sortType Имя колонки для сортировки
       @param {Boolean} sortDirection Направление сортровки (false - по возрастанию, true - по убыванию)
      */


      scrollTable.prototype.setSortParams = function (sortType, sortDirection) {
        this.currentSortType = sortType;
        this.currentSortIndex[this.currentSortType] = sortDirection;
        this.start = 0;
        this.reportStart = this.start * this.limit;

        this._drawTable();

        $(this).triggerHandler('sortChange');
      };
      /** Получить текущее направление сортировки.
       @return {Boolean} false - по возрастанию, true - по убыванию
      */


      scrollTable.prototype.getSortDirection = function () {
        return this.currentSortIndex[this.currentSortType] == 1;
      };
      /** Получить по какой колонке происходит сортровка
       @return Имя колонки
      */


      scrollTable.prototype.getSortType = function () {
        return this.currentSortType;
      };
      /** Перерисовать текущую страницу без перезапроса данных у провайдера */


      scrollTable.prototype.repaint = function () {
        this._drawRows();
      }; ///////////////////////////////////////////////////////////////////////////////

      /** Провайдер данных для {@link nsGmx.ScrollTable}.
      * Хранит статический массив данных, умеет их фильтровать и упорядочивать.
      * @class
      * @extends nsGmx.ScrollTable.IDataProvider
      */


      scrollTable.StaticDataProvider = function (originalData) {
        var _vals = originalData || []; //исходный список элементов


        var _filteredVals = []; //список элементов после фильтрации. Валиден только если _isFiltered == true

        var _isFiltered = false;
        var _predicate = {}; //фильтры. Ф-ции predicate(name, value, items)->filteredItems

        var _filterVals = {}; //значения фильтров

        var _sortFunctions = {};

        var _this = this;

        var _filter = function _filter() {
          if (_isFiltered) return;
          _filteredVals = _vals;

          for (var filterElem in _filterVals) {
            _filteredVals = _predicate[filterElem](filterElem, _filterVals[filterElem], _filteredVals);
          }

          _isFiltered = true;
        };

        var _update = function _update() {
          _isFiltered = false;
          $(_this).change();
        };
        /** синхронный вариант getCount() */


        this.getCountDirect = function () {
          _filter();

          return _filteredVals.length;
        };
        /** синхронный вариант getItems() */


        this.getItemsDirect = function (page, pageSize, sortParam, sortDec) {
          var nMin = page * pageSize;
          var nMax = nMin + pageSize;

          _filter();

          var sortDirIndex = sortDec ? 1 : 0;
          var sortedVals;

          if (_sortFunctions[sortParam]) {
            if (typeof _sortFunctions[sortParam] === 'function') //если нет ф-ции для сортировки в обратном порядке, инвертируем прямую ф-цию
              sortedVals = _filteredVals.sort(function (a, b) {
                return (1 - 2 * sortDirIndex) * _sortFunctions[sortParam](a, b);
              });else sortedVals = _filteredVals.sort(_sortFunctions[sortParam][sortDirIndex]);
          } else sortedVals = _filteredVals;

          nMin = Math.min(Math.max(nMin, 0), sortedVals.length);
          nMax = Math.min(Math.max(nMax, 0), sortedVals.length);
          return sortedVals.slice(nMin, nMax);
        }; //IDataProvider interface


        this.getCount = function (callback) {
          callback(this.getCountDirect());
        };

        this.getItems = function (page, pageSize, sortParam, sortDec, callback) {
          callback(this.getItemsDirect(page, pageSize, sortParam, sortDec, callback));
        };
        /** задание исходных данных */


        this.setOriginalItems = function (items) {
          _vals = items;

          _update();
        };
        /** получение исходных данных */


        this.getOriginalItems = function () {
          return _vals;
        };
        /** Фильтруем исходные данные
        * @param {function(val:Object):Boolean} filterFunction ф-ция для фильтрации. На вход принимает элемент массива данных, возвращает false, если элемент отфильтровывается, иначе true
        */


        this.filterOriginalItems = function (filterFunction) {
          var newOrigData = [];

          for (var i = 0; i < _vals.length; i++) {
            if (filterFunction(_vals[i])) newOrigData.push(_vals[i]);
          }

          _vals = newOrigData;

          _update();
        };
        /** Добавляем новый элемент в исходные данные */


        this.addOriginalItem = function (item) {
          _vals.push(item);

          _update();
        };
        /** Добавляем массив элементов в исходные данные */


        this.addOriginalItems = function (itemArr) {
          _vals = _vals.concat(itemArr);

          _update();
        }; //фильтрация


        this.attachFilterEvents = function (inputField, fieldName, predicate) {
          _predicate[fieldName] = predicate;
          $(inputField).bind('keyup', function () {
            if (_filterVals[fieldName] !== this.value) {
              _filterVals[fieldName] = this.value;

              _update();
            }
          });
          _filterVals[fieldName] = inputField.value;

          _update();
        };
        /** Добавить ф-цию фильтрации исходных данных
        	@param {String} fieldName Имя фильтра
        	@param {function} predicate Ф-ция фильтрации: predicate(name, value, items)->filteredItems
        */


        this.addFilter = function (fieldName, predicate) {
          _predicate[fieldName] = predicate;
        };
        /** Установить значение для фильтра
        	@param {String} fieldName Имя фильтра
        	@param {String} value Значение для фильтрации
        */


        this.setFilterValue = function (fieldName, value) {
          _filterVals[fieldName] = value;

          _update();
        };

        this.attachSelectFilterEvents = function (selectField, fieldName, predicate) {
          _predicate[fieldName] = predicate;

          selectField.onchange = function () {
            _filterVals[fieldName] = this.value;

            _update();
          };

          _filterVals[fieldName] = selectField.value;

          _update();
        };
        /** Задать ф-ции сортировки
         @param {Object} sortFunctions Хеш из ф-ций {Имя столбца -> ф-ция или массив из двух ф-ций}.
        	Если массив из двух ф-ций, то первая используется для сортировки по возрастанию, вторая - по убыванию.
        	Если просто ф-ция, то по убыванию используется инвертная к ней.
        	Формат ф-ции совпадает с ф-цией для sort().
        */


        this.setSortFunctions = function (sortFunctions) {
          _sortFunctions = sortFunctions;
        };
      }; // простое стравнение по атрибутам объекта.
      // Использование: genAttrSort(func(a)->value), genAttrSort(attrName), genAttrSort(attrName1, attrName2)


      scrollTable.StaticDataProvider.genAttrSort = function (attrName1, attrName2) {
        if (typeof attrName1 === 'function') {
          return function (a, b) {
            var av = attrName1(a),
                bv = attrName1(b);
            if (av > bv) return 1;else if (av < bv) return -1;else return 0;
          };
        } else if (attrName2) {
          return function (a, b) {
            var av = a[attrName1][attrName2];
            var bv = b[attrName1][attrName2];
            if (av > bv) return 1;else if (av < bv) return -1;else return 0;
          };
        } else {
          return function (a, b) {
            var av = a[attrName1];
            var bv = b[attrName1];
            if (av > bv) return 1;else if (av < bv) return -1;else return 0;
          };
        }
      }; // //если есть вьюер, добавляем для него переменные в глобальный namespace
      // if ('nsGmx' in window && 'GeomixerFramework' in window.nsGmx)
      // {


      window.scrollTable = scrollTable; //Depricated - use nsGmx

      window.nsGmx.ScrollTable = scrollTable; // }

      window.gmxCore.addModule("ScrollTableControl", {
        ScrollTable: scrollTable
      }, {
        require: ['translations', 'utilities'],
        // css: 'table.css',
        init: function init(module, path) {
          modulePath = path || "";
          appendTranslations();
        }
      });
    })(jQuery, nsGmx$1.Utils._);

    //позволяет загрузить карту, просмотреть слои карты, перетащить слой в текущую карту

    (function (_) {
      nsGmx$1.MapsManagerControl = function () {
        var _this = this;

        this._activeIndex = 0;
        this._mapsTable = new nsGmx$1.ScrollTable();
        this._canvas = _div(null, [['attr', 'id', 'mapsList']]);
        this._mapPreview = null;
        $(this._canvas).append('<div class="gmx-icon-progress"></div>');
        this._dialogDiv = showDialog(_gtxt("Список карт"), this._canvas, 571, 360, 535, 130, this._resize.bind(this));
        sendCrossDomainJSONRequest(window.serverBase + "Map/GetMaps.ashx?WrapStyle=func", function (response) {
          $(_this._canvas).empty();
          if (!parseResponse(response)) return;

          _this._drawMapsDialog(response.Result);
        });
        this._previewMapName = null;
      };

      nsGmx$1.MapsManagerControl.prototype._resize = function () {
        var canvas = this._canvas,
            mapsTable = this._mapsTable,
            mapPreview = this._mapPreview;
        var dialogWidth = canvas.parentNode.parentNode.offsetWidth;
        mapsTable.tableParent.style.width = dialogWidth - 15 - 21 + 'px';
        mapsTable.tableBody.parentNode.parentNode.style.width = dialogWidth + 5 - 21 + 'px';
        mapsTable.tableBody.parentNode.style.width = dialogWidth - 15 - 21 + 'px';
        mapsTable.tablePages.parentNode.parentNode.parentNode.parentNode.style.width = dialogWidth - 12 - 21 + 'px';
        mapsTable.tableParent.style.height = '200px';
        mapsTable.tableBody.parentNode.parentNode.style.height = '170px';

        if (mapPreview) {
          mapPreview.style.height = canvas.parentNode.offsetHeight - canvas.firstChild.offsetHeight - 250 + 'px';
          mapPreview.style.width = dialogWidth + 5 - 21 + 'px';
        }
      };

      nsGmx$1.MapsManagerControl.prototype._drawMapsDialog = function (mapsList) {
        var searchUITemplate = Handlebars.compile('<div class="mapslist-search">' + '<table class="mapslist-search-table"><tr>' + '<td>' + '{{i "Название"}}<input class="inputStyle mapslist-search-name">' + '</td><td>' + '{{i "Владелец"}}<input class="inputStyle mapslist-search-owner">' + '</td>' + '</tr></table>' + '</div>');
        var searchCanvas = $(searchUITemplate())[0];

        var canvas = this._canvas,
            name = 'maps',
            mapsTable = this._mapsTable,
            _this = this;

        var mapNameInput = $('.mapslist-search-name', searchCanvas)[0],
            mapOwnerInput = $('.mapslist-search-owner', searchCanvas)[0];

        _(canvas, [searchCanvas]);

        var tableParent = _div(),
            sortFuncs = {};

        var sign = function sign(n1, n2) {
          return n1 < n2 ? -1 : n1 > n2 ? 1 : 0;
        };

        var sortFuncFactory = function sortFuncFactory(f1, f2) {
          return [function (_a, _b) {
            return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b));
          }, function (_b, _a) {
            return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b));
          }];
        };

        var idFunc = function idFunc(_a) {
          return _a.Name;
        };

        var titleFunc = function titleFunc(_a) {
          return String(_a.Title).toLowerCase();
        };

        var ownerFunc = function ownerFunc(_a) {
          return String(_a.Owner).toLowerCase();
        };

        var dateFunc = function dateFunc(_a) {
          return _a.LastModificationDateTime;
        };

        sortFuncs[_gtxt('Имя')] = sortFuncFactory(titleFunc, idFunc);
        sortFuncs[_gtxt('Владелец')] = sortFuncFactory(ownerFunc, idFunc);
        sortFuncs[_gtxt('Последнее изменение')] = sortFuncFactory(dateFunc, idFunc);
        mapsTable.createTable(tableParent, name, 410, ["", _gtxt("Имя"), _gtxt("Владелец"), _gtxt("Последнее изменение"), ""], ['5%', '55%', '15%', '15%', '5%'], function (map, i) {
          return _this._drawMaps.call(this, map, i, _this);
        }, sortFuncs);
        mapsTable.getDataProvider().setSortFunctions(sortFuncs);

        var inputPredicate = function inputPredicate(value, fieldValue) {
          return !!value && String(value).toLowerCase().indexOf(fieldValue) > -1;
        };

        $([mapNameInput, mapOwnerInput]).bind('keydown', function (event) {
          var numItems = mapsTable.getVisibleItems().length;

          if (event.keyCode === 13) {
            var firstItem = mapsTable.getVisibleItems()[_this._activeIndex];

            firstItem && window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + firstItem.Name);
          }

          if (event.keyCode === 38) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex - 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
          }

          if (event.keyCode === 40) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex + 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
          }
        });
        mapsTable.getDataProvider().attachFilterEvents(mapNameInput, 'Title', function (fieldName, fieldValue, vals) {
          if (fieldValue == "") {
            return vals;
          }

          fieldValue = fieldValue.toLowerCase();
          return vals.filter(function (value) {
            return inputPredicate(value[fieldName], fieldValue) || value['Name'].toLowerCase() === fieldValue;
          });
        });
        mapsTable.getDataProvider().attachFilterEvents(mapOwnerInput, 'Owner', function (fieldName, fieldValue, vals) {
          if (fieldValue == "") {
            return vals;
          }

          fieldValue = fieldValue.toLowerCase();
          return vals.filter(function (value) {
            return inputPredicate(value[fieldName], fieldValue);
          });
        });

        _(canvas, [tableParent]);

        mapsTable.tableHeader.firstChild.childNodes[1].style.textAlign = 'left';

        this._resize();

        mapsTable.getDataProvider().setOriginalItems(mapsList);
        mapNameInput.focus();
      };

      nsGmx$1.MapsManagerControl.prototype._drawMaps = function (map, mapIndex, mapsManager) {
        var name = makeLinkButton(map.Title),
            img_url = map.Name === mapsManager._previewMapName ? 'img/collapse-arrow-se.png' : 'img/collapse-arrow-right.gif',
            load = makeImageButton(img_url, img_url),
            remove = makeImageButton("img/recycle.png", "img/recycle_a.png");

        _title(name, _gtxt("Загрузить"));

        _title(load, _gtxt("Показать"));

        _title(remove, _gtxt("Удалить"));

        name.className = name.className + ' maps-manager-mapname';

        name.onclick = function () {
          window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + map.Name);
        };

        nsGmx$1.ContextMenuController.bindMenuToElem(name, 'MapListItem', function () {
          return true;
        }, {
          name: map.Name
        });

        load.onclick = function () {
          $(mapsManager._mapPreview).empty();

          var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]);

          if (!mapsManager._mapPreview) {
            mapsManager._mapPreview = _div(null, [['css', 'marginTop', '5px'], ['css', 'borderTop', '1px solid #216B9C'], ['css', 'overflowY', 'auto']]);
            $(mapsManager._canvas).append(mapsManager._mapPreview);
            $(mapsManager._dialogDiv).dialog('option', 'height', 550);
            $(mapsManager._dialogDiv).dialog('option', 'minHeight', 550);

            mapsManager._resize();
          }

          _(mapsManager._mapPreview, [loading]); // раз уж мы список получили с сервера, то и карты из этого списка точно нужно загружать с него же...


          mapsManager._loadMapJSON(window.serverBase, map.Name, mapsManager._mapPreview);

          $(mapsManager._mapsTable.getDataProvider()).change();
        };

        remove.onclick = function () {
          if (map.Name == window.defaultMapID) {
            showErrorMessage(_gtxt("$$phrase$$_14"), true);
            return;
          }

          if (map.Name == window.globalMapName) {
            showErrorMessage(_gtxt("$$phrase$$_15"), true);
            return;
          }

          if (confirm(_gtxt("Вы действительно хотите удалить эту карту?"))) {
            var loading = loading = _div([_img(null, [['attr', 'src', 'img/progress.gif']]), _t(_gtxt('удаление...'))], [['css', 'marginLeft', '5px']]);

            $(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr', 'colSpan', 5]])]));
            sendCrossDomainJSONRequest(window.serverBase + "Map/Delete.ashx?WrapStyle=func&MapID=" + map.MapID, function (response) {
              mapsManager._deleteMapHandler(response, map.MapID);
            });
          }
        };

        var date = new Date(map.LastModificationDateTime * 1000);
        var modificationDateString = $.datepicker.formatDate('dd.mm.yy', date); // + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();

        var tr = _tr([_td([load], [['css', 'textAlign', 'center']]), _td([name]), _td([_t(map.Owner)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible maps-manager-owner'], ['dir', 'title', map.Owner]]), _td([_t(modificationDateString)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), _td([remove], [['css', 'textAlign', 'center']])]);

        for (var i = 0; i < tr.childNodes.length; i++) {
          tr.childNodes[i].style.width = this._fields[i].width;
        }

        attachEffects(tr, 'hover');

        if (mapsManager._activeIndex === mapIndex) {
          $(tr).addClass('maps-manager-active');
        }

        return tr;
      };

      nsGmx$1.MapsManagerControl.prototype._deleteMapHandler = function (response, id) {
        if (!parseResponse(response)) return;
        var mapsTable = this._mapsTable;

        if (response.Result == 'deleted') {
          mapsTable.start = 0;
          mapsTable.reportStart = mapsTable.start * mapsTable.limit;
          mapsTable.getDataProvider().filterOriginalItems(function (elem) {
            return elem.MapID != id;
          });
        } else showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
      };

      nsGmx$1.MapsManagerControl.prototype._loadMapJSON = function (host, name, parent) {
        //loadMapJSON(host, name, function(layers)
        this._previewMapName = name;
        var hostName = L.gmxUtil.normalizeHostname(host),
            apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера

        L.gmx.gmxMapManager.getMap(hostName, apiKey, name, window.gmxSkipTiles).then(function (mapInfo) {
          var previewLayersTree = new window.layersTree({
            showVisibilityCheckbox: true,
            allowActive: false,
            allowDblClick: false
          }),
              ul = previewLayersTree.drawTree(mapInfo, 2);
          $(ul).treeview(); //раскрываем группы по клику

          $(ul).click(function (event) {
            if ($(event.target).hasClass('groupLayer')) {
              var clickDiv = $(event.target.parentNode.parentNode.parentNode).children("div.hitarea");
              clickDiv.length && $(clickDiv[0]).trigger('click');
            }
          });
          $(parent).empty();
          var hint = $('<div class="mapslist-hint">' + _gtxt('maplist.hint') + '</div>');

          _(parent, [hint[0], ul]);

          _queryMapLayers.addDraggable(parent);
        });
      };

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return "Открыть в новом окне";
        },
        clickCallback: function clickCallback(context) {
          window.open(window.location.href.split(/\?|#/)[0] + "?" + context.name, '_blank');
        }
      }, 'MapListItem');
    })(nsGmx$1.Utils._);

    (function ($) {

      window._translationsHash.addtext("rus", {
        "pluginsEditor.selectedTitle": "Плагины карты",
        "pluginsEditor.availableTitle": "Доступные плагины",
        "pluginsEditor.add": "Добавить плагин",
        "pluginsEditor.paramsTitle": "Параметры плагина"
      });

      window._translationsHash.addtext("eng", {
        "pluginsEditor.selectedTitle": "Map plugins",
        "pluginsEditor.availableTitle": "Available plugins",
        "pluginsEditor.add": "Add plugin",
        "pluginsEditor.paramsTitle": "Parameter of plugin"
      });

      var MapPlugins = function MapPlugins() {
        var _plugins = [];
        var _params = {}; //вместо массива из одного элемента передаём сам элемент

        var normalizeParams = function normalizeParams(params) {
          var res = {};

          for (var p in params) {
            res[p] = params[p].length === 1 ? params[p][0] : params[p];
          }

          return res;
        };

        this.addPlugin = function (pluginName, pluginParams, onlyParams) {
          _params[pluginName] = pluginParams || _params[pluginName] || {};

          if (!onlyParams && _plugins.indexOf(pluginName) === -1) {
            _plugins.push(pluginName);
          }

          $(this).change();
          return true;
        };

        this.each = function (callback) {
          for (var p = 0; p < _plugins.length; p++) {
            callback(_plugins[p], _params[_plugins[p]] || {});
          }
        };

        this.remove = function (pluginName) {
          var nameIndex = _plugins.indexOf(pluginName);

          if (nameIndex !== -1) {
            _plugins.splice(nameIndex, 1);

            $(this).change();
          }
        };

        this.isExist = function (pluginName) {
          return _plugins.indexOf(pluginName) !== -1;
        };

        this.getPluginParams = function (pluginName) {
          return _params[pluginName];
        };

        this.setPluginParams = function (pluginName, pluginParams) {
          _params[pluginName] = pluginParams;
          $(this).change();
        }; //обновляем используемость и параметры плагинов


        this.updateGeomixerPlugins = function () {
          for (var p = 0; p < _plugins.length; p++) {
            var plugin = nsGmx$1.pluginsManager.getPluginByName(_plugins[p]),
                lazyLoad = plugin && plugin.lazyLoad;
            nsGmx$1.pluginsManager.setUsePlugin(_plugins[p], !lazyLoad);
          }

          for (var _p in _params) {
            nsGmx$1.pluginsManager.updateParams(_p, normalizeParams(_params[_p]));
          }
        };

        this.load = function (data, version) {
          if (version === 1) {
            _plugins = data;
            _params = {};
          } else if (version === 2) {
            _plugins = [];
            _params = {};

            for (var p = 0; p < data.length; p++) {
              _plugins.push(data[p].name);

              _params[data[p].name] = data[p].params;
            }
          } else if (version === 3) {
            _plugins = data.plugins; //поддержка ошибки, которая прокралась в базу...

            if ($.isArray(data.params) && data.params.length === 0) {
              _params = {};
            } else {
              _params = data.params;
            }
          }
        };

        this.save = function (version) {
          if (version === 1) {
            return _plugins;
          } else if (version === 2) {
            var res = [];

            _plugins.forEach(function (name) {
              res.push({
                name: name,
                params: _params[name]
              });
            });

            return res;
          } else if (version === 3) {
            return {
              plugins: _plugins,
              params: _params
            };
          }
        };
      };

      var GeomixerPluginsWidget = function GeomixerPluginsWidget(container, mapPlugins) {
        var template = Handlebars.compile('<div class="pluginsEditor-allPlugins-container">' + '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.availableTitle"}}</div>' + '<div class="pluginEditor-treePlaceholder"></div>' + '<div class="pluginEditor-controls">' + '<input class="inputStyle inputFullWidth pluginEditor-pluginInput"><br>' + '<button class="pluginEditor-addButton">{{i "pluginsEditor.add"}}</button>' + '</div>' + '</div>');
        var lang = window.nsGmx.Translations.getLanguage();
        var DEFAULT_GROUP_NAME = {
          eng: 'Main',
          rus: 'Основные'
        };
        var _allPluginGroups = {},
            configGroups = window.gmxPluginGroups || [],
            groupByPluginName = [],
            groupOrder = {};
        configGroups.forEach(function (group, index) {
          groupOrder[group[lang]] = index;
          group.plugins.forEach(function (plugin) {
            groupByPluginName[plugin] = group[lang];
          });
        });
        nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
          if (plugin.pluginName && plugin.mapPlugin && (plugin.isPublic || nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN))) {
            var groupName = groupByPluginName[plugin.pluginName] || DEFAULT_GROUP_NAME[lang];
            _allPluginGroups[groupName] = _allPluginGroups[groupName] || {
              groupName: groupName,
              plugins: []
            };

            _allPluginGroups[groupName].plugins.push({
              name: plugin.pluginName,
              isPublic: plugin.isPublic
            }); //_allPlugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});

          }
        }); //по алфавиту

        for (var g in _allPluginGroups) {
          _allPluginGroups[g].plugins.sort(function (a, b) {
            return a.name > b.name ? 1 : -1;
          });
        }

        var isListActive = false;

        var update = function update() {
          $(container).empty();
          var filteredGroups = [];

          for (var g in _allPluginGroups) {
            var plugins = _allPluginGroups[g].plugins.filter(function (plugin) {
              return !mapPlugins.isExist(plugin.name);
            }); //если в группе нет плагинов, не показываем её


            plugins.length && filteredGroups.push({
              groupName: _allPluginGroups[g].groupName,
              plugins: plugins
            });
          } //сохраняем порядок, как в конфиге, default group - первой


          filteredGroups.sort(function (a, b) {
            return groupOrder[a.groupName] - groupOrder[b.groupName];
          });
          var pluginGroupTemplate = Handlebars.compile('<ul class="pluginEditor-pluginsTree ui-helper-noselect">{{#groups}}' + '<li>' + '<div class="pluginEditor-groupTitle">{{groupName}}</div>' + '<ul>{{#plugins}}' + '<li class="pluginEditor-pluginItem ui-helper-noselect" data-plugin-name="{{name}}">{{name}}</li>' + '{{/plugins}}</ul>' + '</li>' + '{{/groups}}</ul>');
          var pluginsTree = $(pluginGroupTemplate({
            groups: filteredGroups
          }));
          pluginsTree.find('.pluginEditor-pluginItem').click(function (e) {
            isListActive = true; // var pluginName = $(this).data('pluginName');

            if (e.ctrlKey) {
              $(this).toggleClass('pluginEditor-activePluginItem');
            } else {
              pluginsTree.find('.pluginEditor-pluginItem').removeClass('pluginEditor-activePluginItem');
              $(this).addClass('pluginEditor-activePluginItem');
            }
          });
          pluginsTree.find('.pluginEditor-groupTitle').click(function () {
            $(this).siblings('.hitarea').click();
          });
          var ui = $(template());
          ui.find('.pluginEditor-treePlaceholder').append(pluginsTree);
          ui.find('.pluginEditor-pluginInput').bind('focus', function () {
            isListActive = false;
          });
          ui.find('.pluginEditor-addButton').click(function () {
            var selected = [];

            if (isListActive) {
              pluginsTree.find('.pluginEditor-activePluginItem').each(function (i, elem) {
                selected.push($(elem).data('pluginName'));
              });
            } else {
              var pluginInput = ui.find('.pluginEditor-pluginInput');

              if (nsGmx$1.pluginsManager.getPluginByName(pluginInput.val())) {
                selected.push(pluginInput.val());
              } else {
                inputError(pluginInput[0]);
              }
            }

            for (var sp = 0; sp < selected.length; sp++) {
              mapPlugins.addPlugin(selected[sp]);
            }
          });
          ui.appendTo(container);
          pluginsTree.treeview();
        };

        $(mapPlugins).change(update);
        update();
      };

      var paramsWidgets = {};

      var MapPluginParamsWidget = function MapPluginParamsWidget(mapPlugins, pluginName) {
        if (paramsWidgets[pluginName]) {
          return;
        }

        var FakeTagMetaInfo = function FakeTagMetaInfo() {
          this.isTag = function () {
            return true;
          };

          this.getTagType = function () {
            return 'String';
          };

          this.getTagDescription = function () {
            return '';
          };

          this.getTagArray = function () {
            return [];
          };

          this.getTagArrayExt = function () {
            return [];
          };
        };

        var fakeTagMetaInfo = new FakeTagMetaInfo();
        var pluginParams = mapPlugins.getPluginParams(pluginName);
        var tagInitInfo = {};

        for (var tagName in pluginParams) {
          tagInitInfo[tagName] = {
            Value: pluginParams[tagName]
          };
        }

        var layerTags = new nsGmx$1.LayerTagsWithInfo(fakeTagMetaInfo, tagInitInfo);
        var container = $('<div/>');
        new nsGmx$1.LayerTagSearchControl(layerTags, container);

        var updateParams = function updateParams() {
          var newParams = {};
          layerTags.eachValid(function (tagid, tag, value) {
            newParams[tag] = newParams[tag] || [];
            newParams[tag].push(value);
          });
          mapPlugins.setPluginParams(pluginName, newParams);
        };

        var dialogDiv = showDialog(_gtxt('pluginsEditor.paramsTitle') + " " + pluginName, container[0], {
          width: 320,
          height: 200,
          closeFunc: function closeFunc() {
            updateParams();
            delete paramsWidgets[pluginName];
          }
        });
        paramsWidgets[pluginName] = {
          update: updateParams,
          closeDialog: function closeDialog() {
            $(dialogDiv).dialog('close');
          }
        };
      };

      var MapPluginsWidget = Backbone.View.extend({
        template: Handlebars.compile('<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.selectedTitle"}}</div>' + '<div class="pluginEditor-currentMapPlugins">' + '{{#plugins}}' + '<div class="pluginEditor-widgetElem">' + '{{#unless isCommon}}' + '<span class="pluginEditor-remove gmx-icon-close" data-plugin-name="{{name}}"></span>' + '{{/unless}}' + '<span class="pluginEditor-edit gmx-icon-edit" data-plugin-name="{{name}}"></span>' + '<span class="pluginEditor-title {{#if isCommon}} pluginEditor-commonPlugin{{/if}}">{{name}}</span>' + '</div>' + '{{/plugins}}' + '</div>'),
        events: {
          'click .gmx-icon-close': function clickGmxIconClose(event) {
            var pluginName = $(event.target).data('pluginName');

            this._mapPlugins.remove(pluginName);
          },
          'click .gmx-icon-edit': function clickGmxIconEdit(event) {
            var pluginName = $(event.target).data('pluginName');
            new MapPluginParamsWidget(this._mapPlugins, pluginName);
          }
        },
        initialize: function initialize(options) {
          this._mapPlugins = options.mapPlugins;
          $(this._mapPlugins).change(this.render.bind(this));
          this.render();
        },
        render: function render() {
          var mapPlugins = this._mapPlugins,
              pluginsToShow = [];
          nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
            if (plugin.pluginName && !plugin.mapPlugin && !mapPlugins.isExist(plugin.pluginName)) {
              pluginsToShow.push({
                name: plugin.pluginName,
                isCommon: true
              });
            }
          });
          mapPlugins.each(function (name) {
            pluginsToShow.push({
              name: name,
              isCommon: false
            });
          });
          pluginsToShow.sort(function (a, b) {
            return a.isCommon != b.isCommon ? Number(b.isCommon) - Number(a.isCommon) : a.name > b.name ? 1 : -1;
          });
          this.$el.empty().append(this.template({
            plugins: pluginsToShow
          }));
        }
      });

      var createPluginsEditor = function createPluginsEditor(container, mapPlugins) {
        var widgetContainer = $('<div/>', {
          'class': 'pluginEditor-widgetContainer'
        });
        var allPluginsContainer = $('<div/>', {
          'class': 'pluginEditor-allContainer'
        });
        new MapPluginsWidget({
          el: widgetContainer,
          mapPlugins: mapPlugins
        });
        new GeomixerPluginsWidget(allPluginsContainer, mapPlugins);
        $(container).append($('<table/>', {
          'class': 'pluginEditor-table'
        }).append($('<tr/>').append($('<td/>', {
          'class': 'pluginEditor-allTD'
        }).append(allPluginsContainer)).append($('<td/>', {
          'class': 'pluginEditor-widgetTD'
        }).append(widgetContainer))));
        return {
          update: function update() {
            for (var name in paramsWidgets) {
              paramsWidgets[name].update();
            }
          },
          closeParamsDialogs: function closeParamsDialogs() {
            for (var name in paramsWidgets) {
              paramsWidgets[name].closeDialog();
            }
          }
        };
      };

      window.gmxCore.addModule('PluginsEditor', {
        createPluginsEditor: createPluginsEditor,
        MapPlugins: MapPlugins
      });
      nsGmx$1.createPluginsEditor = createPluginsEditor;
      _mapHelper.mapPlugins = new MapPlugins(); //Cтарая версия информации о плагинах карты. Поддерживается для обратной совместимости (например, загрузка доп. карт)
      //Формат: {String[]} массив имён плагинов

      nsGmx$1.userObjectsManager.addDataCollector('mapPlugins', {
        load: function load(data) {
          if (data) {
            _mapHelper.mapPlugins.load(data, 1);

            _mapHelper.mapPlugins.updateGeomixerPlugins();
          }
        },
        collect: function collect() {
          return _mapHelper.mapPlugins.save(1);
        }
      }); //Вторая версия информации о плагинах карты.
      //Формат: [{name: pluginName1, params: {param: value, ...}}, ...]

      nsGmx$1.userObjectsManager.addDataCollector('mapPlugins_v2', {
        load: function load(data) {
          if (data) {
            _mapHelper.mapPlugins.load(data, 2);

            _mapHelper.mapPlugins.updateGeomixerPlugins();
          }
        },
        collect: function collect() {
          return _mapHelper.mapPlugins.save(2);
        }
      }); //Третья версия информации о плагинах карты.
      //Формат: {plugins: [name1, ....], params: {name1: {param1: value1, ...}, ...}}

      nsGmx$1.userObjectsManager.addDataCollector('mapPlugins_v3', {
        load: function load(data) {
          if (data) {
            _mapHelper.mapPlugins.load(data, 3);

            _mapHelper.mapPlugins.updateGeomixerPlugins();
          }
        },
        collect: function collect() {
          return _mapHelper.mapPlugins.save(3);
        }
      });
    })(jQuery);

    (function () {
      window.nsGmx.widgets = window.nsGmx.widgets || {};
      nsGmx$1.widgets.notifications = {
        _container: null,
        _actions: [],
        _messagesToShow: [],
        _messageTimer: null,
        _currentStatusClass: '',
        startAction: function startAction(actionId) {
          this._initContainerLazy();

          if (this._actions.indexOf(actionId) === -1) {
            this._actions.push(actionId);

            this._container.find('.notification-process').show();
          }
        },
        //supported statuses: success, failure, warning
        stopAction: function stopAction(actionId, status, message, timeout) {
          var index = this._actions.indexOf(actionId);

          if (index !== -1) {
            this._actions.splice(index, 1);

            this._container.find('.notification-process').toggle(this._actions.length);
          }

          if (message) {
            timeout = typeof timeout !== 'undefined' ? timeout : 1500;

            this._messagesToShow.push({
              text: message,
              status: status,
              timeout: timeout
            });

            this._checkMessages();
          }
        },
        _checkMessages: function _checkMessages() {
          if (this._messageTimer || !this._messagesToShow.length) {
            return;
          }

          var msg = this._messagesToShow.shift();

          var statusClass = 'notification-' + msg.status;

          this._initContainerLazy();

          this._container.find('.notification-message').show().text(msg.text).removeClass(this._currentStatusClass).addClass(statusClass);

          if (msg.timeout) {
            this._messageTimer = setTimeout(function () {
              this._messageTimer = null;

              this._container.find('.notification-message').hide();

              this._checkMessages();
            }.bind(this), msg.timeout);
          }
        },
        _initContainerLazy: function _initContainerLazy() {
          if (this._container) {
            return;
          }

          this._container = $(Handlebars.compile('<div class="notification-container">' + '<span class="notification-process"></span>' + '<span class="notification-message"></span>' + '</div>')()).appendTo($('#flash'));

          this._container.find('.notification-message, .notification-process').hide();
        }
      };
    })();

    (function () {
      /**
      Хранит информацию о тегах: типы и описание
      @memberOf nsGmx
      @class
      @param {Object} initTagsInfo - описание тегов вида tagName: {Type: , Description: }
      */
      var TagMetaInfo = function TagMetaInfo(initTagsInfo) {
        var tags = initTagsInfo || {};

        this.isTag = function (tag) {
          return tag in tags;
        };

        this.getTagType = function (tag) {
          return tag in tags ? tags[tag].Type : null;
        };

        this.getTagDescription = function (tag) {
          return tag in tags ? tags[tag].Description : null;
        };

        this.getTagArray = function () {
          var res = [];

          for (var t in tags) {
            res.push(t);
          }

          return res;
        };

        this.getTagArrayExt = function () {
          var res = [];

          for (var t in tags) {
            res.push({
              name: t,
              type: tags[t].Type,
              desc: tags[t].Description
            });
          }

          return res;
        };
      };

      (function () {
        var def;
        /** Загружает данные о доступных тегах с сервера
        * @memberOf nsGmx.TagMetaInfo
        * @name loadFromServer
        * @function
        * @param {function(tagInfo)} [callback] Ф-ция, которая будет вызвана после загрузки информации о типах.
        * @return {jQuery.Deferred} Будет заресолвен после получения информации о типах
        */

        TagMetaInfo.loadFromServer = function (callback) {
          if (!def) {
            def = $.Deferred();
            sendCrossDomainJSONRequest(window.serverBase + 'Layer/MetaKeys.ashx', function (response) {
              if (!parseResponse(response)) {
                def.resolve();
                return;
              }

              def.resolve(new TagMetaInfo(response.Result));
            });
          }

          callback && def.done(callback);
          return def;
        };
      })();

      var extendClass = function extendClass(base, sub) {
        function ctor() {}

        ctor.prototype = base.prototype;
        sub.prototype = new ctor();
        sub.prototype.constructor = sub;
      };

      var LayerTags = function LayerTags(initTags) {
        /** Вызывается при изменении набора тегов слоя
            @name nsGmx.LayerTags.change
            @event
        */
        this._uniqueID = 1;
        this._tags = {};

        for (var tag in initTags) {
          var values = initTags[tag].Value;

          if (!$.isArray(values)) {
            values = [values];
          }

          for (var i = 0; i < values.length; i++) {
            this.addNewTag(tag, values[i]);
          }
        }
      };

      LayerTags.prototype = {
        _verificationFunctions: {
          'Number': function (_Number) {
            function Number(_x) {
              return _Number.apply(this, arguments);
            }

            Number.toString = function () {
              return _Number.toString();
            };

            return Number;
          }(function (value) {
            return value.length && !isNaN(Number(value));
          }),
          'String': function String() {
            return true;
          },
          'Date': function Date(value) {
            try {
              $.datepicker.parseDate('dd.mm.yy', value);
              return true;
            } catch (e) {
              return false;
            }
          }
        },
        _isValidTypeValue: function _isValidTypeValue(type, value) {
          return !(type in this._verificationFunctions) || this._verificationFunctions[type](value);
        },
        updateTag: function updateTag(id, tag, value, type) {
          var tags = this._tags;
          if (!(id in tags)) return false;

          if (tags[id].tag !== tag || tags[id].value !== value || tags[id].type !== type) {
            tags[id] = {
              tag: tag,
              value: value,
              type: type
            };
            $(this).change();
          }

          return true;
        },
        deleteTag: function deleteTag(id) {
          if (!(id in this._tags)) return;
          delete this._tags[id];
          $(this).change();
        },
        each: function each(callback) {
          var tags = this._tags;

          for (var tagId in tags) {
            callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
          }
        },
        eachValid: function eachValid(callback, allowUnknownTags) {
          var tags = this._tags;

          for (var tagId in tags) {
            if ((allowUnknownTags || this.isValidValue(tagId)) && !this.isEmptyTag(tagId)) callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
          }
        },
        addNewTag: function addNewTag(tag, value, type) {
          if (typeof value === 'undefined' || value === null) {
            value = '';
          }

          var newId = 'id' + ++this._uniqueID;
          this._tags[newId] = {
            tag: tag || '',
            value: value,
            type: type
          };
          $(this).change();
          return newId;
        },
        isTag: function isTag(tagId) {
          return tagId in this._tags;
        },
        isEmptyTag: function isEmptyTag(tagId) {
          var tags = this._tags;
          return tagId in tags && tags[tagId].tag === '' && tags[tagId].value === '';
        },
        isValidValue: function isValidValue(tagId) {
          var tags = this._tags;
          return tagId in tags && this._isValidTypeValue(tags[tagId].type, tags[tagId].value);
        },
        getTag: function getTag(tagId) {
          return this._tags[tagId];
        },
        getTagByName: function getTagByName(tagName) {
          var tags = this._tags;

          for (var tagId in tags) {
            if (tags[tagId].tag == tagName) return tags[tagId];
          }
        },
        getTagIdByName: function getTagIdByName(tagName) {
          var tags = this._tags;

          for (var tagId in tags) {
            if (tags[tagId].tag == tagName) return tagId;
          }
        }
        /**
            Набор тегов (метаданных) слоя из определённого набора тегов
            @memberOf nsGmx
            @class
            @param {nsGmx.TagMetaInfo} tagMetaInfo описание типов тегов
            @param {Object} initTags теги для инициализации. Формат: {tagName: {Value: tagValue}, ...}. tagValue может быть массивом
        */

      };

      var LayerTagsWithInfo = function LayerTagsWithInfo(tagMetaInfo, initTags) {
        // чтобы можно было расширять существующий объект LayerTags
        if (this instanceof LayerTagsWithInfo) {
          LayerTags.call(this, initTags);
        }

        this.getTagMetaInfo = function () {
          return tagMetaInfo;
        };

        this.isKnownTagname = function (tagname) {
          return tagMetaInfo.isTag(tagname);
        };

        this.addNewTag = function (tag, value, type) {
          type = type || tagMetaInfo.getTagType(tag) || '';
          LayerTags.prototype.addNewTag.call(this, tag, value, type);
        };

        this.updateTag = function (id, tag, value) {
          var type = tagMetaInfo.getTagType(tag);
          LayerTags.prototype.updateTag.call(this, id, tag, value, type);
        };
      };

      extendClass(LayerTags, LayerTagsWithInfo);
      /**
          Контрол для задания набора тегов (например, для слоя)
          @memberOf nsGmx
          @class
      */

      var LayerTagSearchControl = function LayerTagSearchControl(layerTags, container, params) {
        var _params = $.extend({
          inputWidth: 130,
          tagHeader: _gtxt('Параметр'),
          valueHeader: _gtxt('Значение')
        }, params);

        var mainTable = $('<table/>', {
          'class': 'layertags-table'
        }).appendTo(container);
        mainTable.append($('<tr/>').append($('<th/>').text(_params.tagHeader)).append($('<th/>').text(_params.valueHeader)).append($('<th/>'))); //добавляем к body элемент с id чтобы добавить к нему jQuery autocomplete и задать стили
        //к текущему виджету добавить нельзя, так как он ещё не добавлен в общее дерево, а виджет ac требует глобального селектора

        if ($('#layertagstable').length == 0) $('body').append($('<div id="layertagstable"></div>'));
        var rows = {}; //ссылки на контролы для каждого элемента

        var rowsVector = []; //в зависимости от типа ввода (type), прикрепляет к valueInput виджет выбора даты, время или даты/время

        var updateInput = function updateInput(valueInput, type) {
          if (type == 'Date') {
            $(valueInput).timepicker('destroy');
            $(valueInput).datetimepicker('destroy');
            $(valueInput).datepicker({
              onSelect: function onSelect() {
                $(this).change();
              },
              changeMonth: true,
              changeYear: true,
              dateFormat: "dd.mm.yy"
            });
          } else if (type == 'DateTime') {
            $(valueInput).timepicker('destroy');
            $(valueInput).datepicker('destroy');
            $(valueInput).datetimepicker({
              changeMonth: true,
              changeYear: true,
              dateFormat: "dd.mm.yy",
              timeFormat: "HH:mm:ss",
              showSecond: true,
              timeOnly: false
            }).addClass('layertags-datetimeinput');
          } else if (type == "Time") {
            $(valueInput).datepicker('destroy');
            $(valueInput).datetimepicker('destroy');
            $(valueInput).timepicker({
              timeOnly: true,
              timeFormat: "HH:mm:ss",
              showSecond: true
            });
          } else {
            $(valueInput).timepicker('destroy');
            $(valueInput).datetimepicker('destroy');
            $(valueInput).datepicker('destroy');
          }
        };

        var validateRow = function validateRow(row) {
          if (!layerTags.isEmptyTag(row.id) && !layerTags.isKnownTagname(row.tag.val())) row.tag.addClass('error');else row.tag.removeClass('error');
          if (!layerTags.isEmptyTag(row.id) && !layerTags.isValidValue(row.id)) row.value.addClass('error');else row.value.removeClass('error');
        };

        var addNewRow = function addNewRow(tagId, tag, value) {
          var tagInput = $('<input/>', {
            'class': 'inputStyle'
          }).val(tag).css('width', _params.inputWidth).autocomplete({
            source: layerTags.getTagMetaInfo().getTagArrayExt(),
            minLength: 0,
            delay: 0,
            appendTo: "#layertagstable",
            select: function select(event, ui) {
              tagInput.val(ui.item.name);
              updateModel(ui.item.name, valueInput.val().trim());
              return false;
            }
          }).bind('click', function () {
            $(tagInput).autocomplete("search", "");
          });

          tagInput.data("ui-autocomplete")._renderItem = function (ul, item) {
            return $("<li/>").append($("<a/>", {
              title: item.desc
            }).text(item.name)).appendTo(ul);
          };

          var valueInput = $('<input/>', {
            'class': 'inputStyle'
          }).val(value).css('width', _params.inputWidth);
          var type = layerTags.getTagMetaInfo().getTagType(tag);
          updateInput(valueInput, type);

          var updateModel = function updateModel() {
            layerTags.updateTag(tagId, tagInput.val().trim(), valueInput.val().trim());
          };

          tagInput.bind('keyup change', updateModel);
          valueInput.bind('keyup change', updateModel);
          var deleteButton = makeImageButton('img/recycle.png', 'img/recycle_a.png');

          deleteButton.onclick = function () {
            layerTags.deleteTag(tagId);
          };

          var tr = $('<tr/>').append($('<td/>').append(tagInput)).append($('<td/>').append(valueInput)).append($('<td/>', {
            'class': 'layertags-delete'
          }).append(deleteButton));
          mainTable.append(tr);
          rows[tagId] = {
            id: tagId,
            tr: tr,
            tag: tagInput,
            value: valueInput,
            type: type
          };
          rowsVector.push(rows[tagId]);
          validateRow(rows[tagId]);
        };

        var moveEmptyLayersToBottom = function moveEmptyLayersToBottom() {
          var lastEmptyId = -1;

          for (var irow = 0; irow < rowsVector.length; irow++) {
            if (layerTags.isEmptyTag(rowsVector[irow].id)) lastEmptyId = irow;
          }

          if (lastEmptyId >= 0 && lastEmptyId < rowsVector.length) {
            var tr = rowsVector[lastEmptyId].tr;
            $(tr).detach();
            mainTable.append(tr);
          }
        };

        $(layerTags).change(function () {
          var isAnyEmpty = false;
          layerTags.each(function (tagId, tag, value) {
            if (tag == '' && value == '') isAnyEmpty = true;
            if (!(tagId in rows)) addNewRow(tagId, tag, value);else {
              if (rows[tagId].tag.val() !== tag) rows[tagId].tag.val(tag);
              if (rows[tagId].value.val() !== value) rows[tagId].value.val(value);
              var type = layerTags.getTagMetaInfo().getTagType(tag);

              if (rows[tagId].type !== type) {
                rows[tagId].type = type;
                updateInput(rows[tagId].value, type);
              }

              validateRow(rows[tagId]);
            }
          });

          for (var tagId in rows) {
            if (!layerTags.isTag(tagId)) {
              rows[tagId].tr.remove();
              delete rows[tagId];
            }
          }

          if (!isAnyEmpty) layerTags.addNewTag();
          moveEmptyLayersToBottom();
        });
        layerTags.addNewTag();
      };

      nsGmx$1.LayerTagSearchControl = LayerTagSearchControl;
      nsGmx$1.LayerTags = LayerTags;
      nsGmx$1.LayerTagsWithInfo = LayerTagsWithInfo;
      nsGmx$1.TagMetaInfo = TagMetaInfo;
    })();

    //Управление показом списка слоёв и поиска по этому списку

    (function (_) {
      var LayersListProvider = function LayersListProvider(filtersProvider) {
        var _this = this;

        $(filtersProvider).change(function () {
          $(_this).change();
        });

        var getQueryText = function getQueryText() {
          var filterStrings = [];
          if (filtersProvider.getTitle() !== '') filterStrings.push("([Title] containsIC '" + filtersProvider.getTitle() + "' or [Name] = GetLayerName('" + filtersProvider.getTitle() + "'))");
          if (filtersProvider.getOwner() !== '') filterStrings.push("[OwnerNickname] containsIC '" + filtersProvider.getOwner() + "'");
          var types = filtersProvider.getTypes();
          var typeFilters = $.map(types, function (type) {
            if (type === 'catalog') {
              return "([LayerType]=LayerTypeCode('vector') AND [IsRasterCatalog]=true)";
            } else if (type) {
              return "[LayerType]=LayerTypeCode('" + type + "')";
            }
          });
          if (typeFilters.length > 0) filterStrings.push('(' + typeFilters.join(' OR ') + ')');
          var dateBegin = filtersProvider.getDateBegin();
          var dateEnd = filtersProvider.getDateEnd();
          dateBegin && filterStrings.push("[DateCreate] >= '" + $.datepicker.formatDate('yy.mm.dd', dateBegin) + "'");
          dateEnd && filterStrings.push("[DateCreate] < '" + $.datepicker.formatDate('yy.mm.dd', dateEnd) + "'");
          var layerTags = filtersProvider.getTags();

          if (layerTags) {
            layerTags.each(function (id, tag, value) {
              if (tag) {
                if (value !== '') filterStrings.push("[" + tag + "] containsIC '" + value + "'");else filterStrings.push("PropertyExist('" + tag + "')");
              }
            });
          }

          return '&query=' + encodeURIComponent(filterStrings.join(' AND '));
        };

        this.getCount = function (callback) {
          var query = getQueryText();
          sendCrossDomainJSONRequest(window.serverBase + 'Layer/Search2.ashx?count=true' + query, function (response) {
            if (!parseResponse(response)) {
              callback();
              return;
            }

            callback(response.Result.count);
          });
        };

        this.getItems = function (page, pageSize, sortParam, sortDec, callback) {
          this.getCountAndItems(page, pageSize, sortParam, sortDec, function (count, items) {
            callback(items);
          });
        };

        this.getCountAndItems = function (page, pageSize, sortParam, sortDec, callback) {
          var sortParams = {};
          sortParams[_gtxt("Имя")] = "title";
          sortParams[_gtxt("Дата создания")] = "datecreate";
          sortParams[_gtxt("Владелец")] = "ownernickname";
          var query = getQueryText();
          sendCrossDomainJSONRequest(window.serverBase + 'Layer/Search2.ashx?page=' + page + '&pageSize=' + pageSize + "&orderby=" + sortParams[sortParam] + " " + (sortDec ? "desc" : "") + query, function (response) {
            if (!parseResponse(response)) {
              callback();
              return;
            }

            callback(response.Result.count, response.Result.layers);
          });
        };
      };

      var drawLayers = function drawLayers(layer, params) {
        var _params = $.extend({
          onclick: function onclick() {
            removeLayerFromList();
          },
          enableDragging: true,
          disabled: false
        }, params);

        var newLayerProperties = {
          properties: layer
        };

        var mapProperties = _layersTree.treeModel.getMapProperties();

        newLayerProperties.properties.mapName = mapProperties.name;
        newLayerProperties.properties.hostName = mapProperties.hostName;
        newLayerProperties.properties.visible = false; // newLayerProperties.properties.type = newLayerProperties.properties.type === 1 ? 'Vector' : 'Raster';

        if (newLayerProperties.properties.type == 'Vector') newLayerProperties.properties.styles = [{
          MinZoom: 1,
          MaxZoom: 20,
          RenderStyle: _mapHelper.defaultStyles[newLayerProperties.properties.GeometryType]
        }];else if (newLayerProperties.properties.type != 'Vector' && !newLayerProperties.properties.MultiLayerID) newLayerProperties.properties.styles = [{
          MinZoom: newLayerProperties.properties.MinZoom,
          MaxZoom: 20
        }];

        var res = _layersTree.drawNode({
          type: 'layer',
          content: newLayerProperties
        }, false, 1),
            icon = res.firstChild.cloneNode(true),
            remove = makeImageButton("img/recycle.png", "img/recycle_a.png"),
            tr,
            tdRemove = layer.Access == 'edit' ? _td([remove], [['css', 'textAlign', 'center']]) : _td(),
            removeLayerFromList = function removeLayerFromList() {
          var active = $(_queryMapLayers.buildedTree).find(".active");
          var gmxProperties = $(res).find("span[dragg]")[0].parentNode.parentNode.gmxProperties;

          if (active.length && (active[0].parentNode.getAttribute('MapID') || active[0].parentNode.getAttribute('GroupID'))) {
            _layersTree.copyHandler(gmxProperties, active[0].parentNode, false, true);
          } else {
            _layersTree.copyHandler(gmxProperties, $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0], false, true);
          }

          $(res).addClass('gmx-disabled');
        },
            _this = this;

        _title(remove, _gtxt("Удалить"));

        res.firstChild.removeNode(true);

        remove.onclick = function () {
          if (confirm(_gtxt("Вы действительно хотите удалить этот слой?"))) {
            var loading = loading = _div([_img(null, [['attr', 'src', 'img/progress.gif']]), _t('удаление...')], [['css', 'marginLeft', '5px']]);

            $(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr', 'colSpan', 5]])]));

            var deleteLayerHandler = function deleteLayerHandler(response) {
              if (!parseResponse(response)) return;
              if (response.Result == 'deleted') $(_this.getDataProvider()).change();else showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
            };

            if (newLayerProperties.properties.MultiLayerID) sendCrossDomainJSONRequest(window.serverBase + "MultiLayer/Delete.ashx?WrapStyle=func&MultiLayerID=" + newLayerProperties.properties.MultiLayerID, deleteLayerHandler);else sendCrossDomainJSONRequest(window.serverBase + "Layer/Delete.ashx?WrapStyle=func&LayerID=" + newLayerProperties.properties.LayerID, deleteLayerHandler);
          }
        };

        var span = $(res).find("span.layer")[0];
        if (_params.disabled) $(span).addClass('invisible');

        if (!_params.disabled && _params.onclick) {
          span.onclick = function () {
            _params.onclick({
              elem: layer,
              scrollTable: _this
            });
          };
        } else {
          span.onclick = null;
          $(span).css('cursor', 'auto');
        }

        span.ondblclick = null;

        if (_params.enableDragging && !params.disabled) {
          $(res).find("span[dragg]").draggable({
            helper: function helper(ev) {
              return _layersTree.dummyNode(ev.target);
            },
            cursorAt: {
              left: 5,
              top: 10
            },
            cursor: 'move',
            delay: 200,
            appendTo: document.body
          });
        }

        var nameDivInternal = _div([res], [['css', 'position', 'absolute'], ['css', 'width', '100%'], ['css', 'padding', "1px 0px"], ['css', 'overflowX', 'hidden'], ['css', 'whiteSpace', 'nowrap']]);

        var nameDiv = _div([nameDivInternal], [['css', 'position', 'relative'], ['css', 'height', '100%']]);

        tr = _tr([_td(), _td([icon], [['css', 'textAlign', 'center']]), _td([nameDiv]), _td([_t(layer.date)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), _td([_t(layer.Owner)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), tdRemove]);

        for (var i = 0; i < tr.childNodes.length; i++) {
          tr.childNodes[i].style.width = this._fields[i].width;
        }

        attachEffects(tr, 'hover');
        return tr;
      };
      /** Внутри контейнера помещает табличку со списком слоёв и контролами для фильтрации
      * @param {HTMLNode} parentDiv Куда помещать контрол
      * @param {String} name Уникальное имя этого инстанса
      * @param {object} params Параметры отображения списка:
      *
      *  * fixType {String | Vector} Какой тип слоёв показывать. 'vector', 'raster', 'multilayer', 'catalog' или ''. Если '', то добавится контрол с выбором типа слоя. Вектор
      *  * enableDragging {Boolean}
      *  * height {Integer} высота всего виджета. Если не указана, то будет применяться дефолтная высота (~460px)
      *  * onclick {function({ elem: , scrollTable: })}
      */


      var LayerManagerControl = function LayerManagerControl(parentDiv, name, params) {
        var _params = $.extend({
          fixType: [],
          height: ''
        }, params);

        if (typeof _params.fixType === 'string') _params.fixType = [_params.fixType];

        var canvas = _div(null, [['attr', 'id', 'layersList']]),
            searchCanvas = _div(null, [['dir', 'className', 'layersSearchCanvas']]);

        var layerName = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '185px']]),
            layerOwner = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '185px']]);

        var typeSel = nsGmx$1.Utils._select([_option([_t(_gtxt("Любой"))], [['attr', 'value', '']]), _option([_t(_gtxt("Векторный"))], [['attr', 'value', 'vector']]), _option([_t(_gtxt("Растровый"))], [['attr', 'value', 'raster']]), _option([_t(_gtxt("Мультислой"))], [['attr', 'value', 'multilayer']]), _option([_t(_gtxt("Каталог растров"))], [['attr', 'value', 'catalog']])], [['dir', 'className', 'selectStyle'], ['css', 'width', '100px']]);

        var calendar = new nsGmx$1.CalendarWidget({
          minimized: false,
          showSwitcher: false,
          dateInterval: new nsGmx$1.DateInterval({
            dateBegin: null,
            dateEnd: null
          })
        }); // calendar.init('layerManager', {
        // minimized: false,
        // showSwitcher: false,
        // dateBegin: null,
        // dateEnd: null
        // });

        var _disabledLayers = {};

        _(searchCanvas, [_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Название"))], [['css', 'fontSize', '12px']])]), _td([layerName])]), _tr([_td([_span([_t(_gtxt("Владелец"))], [['css', 'fontSize', '12px']])]), _td([layerOwner])]), _tr([_td([_span([_t(_gtxt("Период"))], [['css', 'fontSize', '12px']])]), _td([calendar.canvas[0]])]), _tr([_td([_span([_t(_gtxt("Тип"))], [['css', 'fontSize', '12px']])]), _td([typeSel])])])])], [['css', 'marginBottom', '10px']])]);

        $.each(_params.fixType, function (i, type) {
          if (type !== '') $("tr:last", searchCanvas).hide();
        });

        var tableParent = _div();

        var sortColumns = {};
        sortColumns[_gtxt('Имя')] = true;
        sortColumns[_gtxt('Владелец')] = true;
        sortColumns[_gtxt('Дата создания')] = true; // Временно сервер не поддерживает сортировку по типу
        // if (_params.fixType.length > 1 || _params.fixType[0] === '')
        // sortColumns[_gtxt('Тип')] = true;

        var tagsParent = _div(null, [['css', 'height', '100px'], ['css', 'overflow', 'auto']]);

        _(canvas, [_table([_tbody([_tr([_td([searchCanvas], [['css', 'width', '50%']]), _td([tagsParent])])])], [['css', 'width', '100%']])]);

        var LayersFilterParams = function () {
          var prevLayerName, prevLayerOwner;

          layerName.oninput = layerName.onkeyup = function () {
            if (this.value !== prevLayerName) {
              prevLayerName = this.value;
              $(pi).change();
            }
          };

          layerOwner.oninput = layerOwner.onkeyup = function () {
            if (this.value !== prevLayerOwner) {
              prevLayerOwner = this.value;
              $(pi).change();
            }
          };

          typeSel.onchange = function () {
            $(pi).change();
          };

          calendar.getDateInterval().on('change', function () {
            $(pi).change();
          });
          var _layerTags = null;
          var pi = {
            setTags: function setTags(layerTags) {
              _layerTags = layerTags;
              $(_layerTags).change(function () {
                $(pi).change();
              });
            },
            getTitle: function getTitle() {
              return layerName.value;
            },
            getOwner: function getOwner() {
              return layerOwner.value;
            },
            getDateBegin: function getDateBegin() {
              return calendar.getDateInterval().get('dateBegin');
            },
            getDateEnd: function getDateEnd() {
              return calendar.getDateInterval().get('dateEnd');
            },
            getTags: function getTags() {
              return _layerTags;
            },
            getTypes: function getTypes() {
              return _params.fixType.length > 0 ? _params.fixType : [$("option:selected", typeSel).val()];
            }
          };
          return pi;
        }();

        nsGmx$1.TagMetaInfo.loadFromServer(function (tagsInfo) {
          var layerTags = new nsGmx$1.LayerTagsWithInfo(tagsInfo);
          new nsGmx$1.LayerTagSearchControl(layerTags, tagsParent, {
            inputWidth: 115
          });
          LayersFilterParams.setTags(layerTags);
        });
        var layersListProvider = new LayersListProvider(LayersFilterParams);
        var layersTable = new nsGmx$1.ScrollTable({
          height: _params.height ? _params.height - 130 : ''
        });
        layersTable.setDataProvider(layersListProvider);
        layersTable.createTable(tableParent, name, 0, ["", _gtxt("Тип"), _gtxt("Имя"), _gtxt("Дата создания"), _gtxt("Владелец"), ""], ['1%', '5%', '45%', '24%', '20%', '5%'], function (layer) {
          var curParams = $.extend({}, _params, {
            disabled: layer.name in _disabledLayers
          });
          return drawLayers.apply(this, [layer, curParams]);
        }, sortColumns);

        _(canvas, [tableParent]);

        $(parentDiv).empty().append(canvas);
        layerName.focus();

        this.getScrollTable = function () {
          return layersTable;
        };
        /** Деактивировать слои
          @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать неактивными
        */


        this.disableLayers = function (layerNames) {
          if (!$.isArray(layerNames)) layerNames = [layerNames];

          for (var k = 0; k < layerNames.length; k++) {
            _disabledLayers[layerNames[k]] = true;
          }

          layersTable.repaint();
        };
        /** Aктивировать слои
          @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать активными
        */


        this.enableLayers = function (layerNames) {
          if (!$.isArray(layerNames)) layerNames = [layerNames];

          for (var k = 0; k < layerNames.length; k++) {
            delete _disabledLayers[layerNames[k]];
          }

          layersTable.repaint();
        };

        this.resize = function (h) {
          layersTable.updateHeight(h - 130);
        };
      };

      nsGmx$1.LayerManagerControl = LayerManagerControl;
      nsGmx$1.drawLayers = drawLayers;
      window.gmxCore.addModule('LayersManagerControl', {
        LayerManagerControl: LayerManagerControl,
        drawLayers: drawLayers
      });
    })(nsGmx$1.Utils._);

    (function (_) {
      var mapLayers = {
        mapLayers: {}
      };
      window.mapLayers = mapLayers;

      var AbstractTree = function AbstractTree() {};

      AbstractTree.prototype.makeSwapChild = function () {
        var div = _div(null, [['attr', 'swap', true], ['dir', 'className', 'swap'], ['css', 'fontSize', '0px']]);

        return div;
      };

      AbstractTree.prototype.getChildsUl = function (node) {
        var ul = $(node).children("ul");
        if (ul.length > 0) return ul[0];else return false;
      };

      AbstractTree.prototype.toggle = function (box) {
        box.onclick = function () {
          $(this.parentNode).find(">.hitarea").swapClass('collapsable-hitarea', 'expandable-hitarea').swapClass('lastCollapsable-hitarea', 'lastExpandable-hitarea').end().swapClass('collapsable', 'expandable').swapClass('lastCollapsable', 'lastExpandable');
          if ($(this.parentNode).hasClass('expandable') || $(this.parentNode).hasClass('lastExpandable')) hide(_abstractTree.getChildsUl(this.parentNode));else show(_abstractTree.getChildsUl(this.parentNode));
        };
      };

      AbstractTree.prototype.addNode = function (node, newNodeCanvas) {
        var childsUl = _abstractTree.getChildsUl(node);

        if (childsUl) childsUl.insertBefore(newNodeCanvas, childsUl.firstChild);else {
          // если первый потомок
          var newSubTree = _ul([newNodeCanvas]); //_(node, [newSubTree, this.makeSwapChild()]);


          node.insertBefore(newSubTree, node.lastChild);
          newSubTree.loaded = true;

          var div = _div(null, [['dir', 'className', 'hitarea']]);

          if ($(node).hasClass("last")) {
            $(div).addClass('lastCollapsable-hitarea collapsable-hitarea');
            $(node).addClass('lastCollapsable');
          } else {
            $(div).addClass('collapsable-hitarea');
            $(node).addClass('collapsable');
          }

          this.toggle(div);
          node.insertBefore(div, node.firstChild);

          _layersTree.addExpandedEvents(node);

          if ($(newNodeCanvas).hasClass('collapsable')) {
            $(newNodeCanvas).addClass('lastCollapsable');
            $(newNodeCanvas).children('div.hitarea').addClass('lastCollapsable-hitarea');
          }

          if ($(newNodeCanvas).hasClass('expandable')) {
            $(newNodeCanvas).addClass('lastExpandable');
            $(newNodeCanvas).children('div.hitarea').addClass('lastExpandable-hitarea');
          }

          if (!$(newNodeCanvas).hasClass('lastCollapsable') && !$(newNodeCanvas).hasClass('lastExpandable')) $(newNodeCanvas).addClass('last');
        }
        $(_abstractTree.getChildsUl(node)).children(":not(li:last)").each(function () {
          $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
          $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
          $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
        });
      };

      AbstractTree.prototype.delNode = function (node, parentTree, parent) {
        if (parentTree.childNodes.length == 0) {
          // потомков не осталось, удалим контейнеры
          parentTree.removeNode(true);
          parent.firstChild.removeNode(true); // изменим дерево родителя

          $(parent).removeClass("collapsable");
          $(parent).replaceClass("lastCollapsable", "last");
        } // изменим дерево родителя
        else if ($(parentTree).children("li:last").hasClass("collapsable")) {
            $(parentTree).children("li:last").addClass("lastCollapsable");
            $(parentTree).children("li:last").each(function () {
              $(this.firstChild).addClass("lastCollapsable-hitarea");
            });
          } else {
            $(parentTree).children("li:last").addClass("last");
          }
      };

      AbstractTree.prototype.swapNode = function (node, newNodeCanvas) {
        $(node).after(newNodeCanvas);
        $(node.parentNode).children(":not(li:last)").each(function () {
          $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
          $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
          $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
        }); // изменим дерево родителя

        if ($(node.parentNode).children("li:last").hasClass("collapsable")) {
          $(node.parentNode).children("li:last").addClass("lastCollapsable");
          $(node.parentNode).children("li:last").each(function () {
            $(this.firstChild).addClass("lastCollapsable-hitarea");
          });
        } else if ($(node.parentNode).children("li:last").hasClass("expandable")) {
          $(node.parentNode).children("li:last").addClass("lastExpandable");
          $(node.parentNode).children("li:last").each(function () {
            $(this.firstChild).addClass("lastExpandable-hitarea");
          });
        } else $(node.parentNode).children("li:last").addClass("last");
      };

      var _abstractTree = new AbstractTree();

      window._abstractTree = _abstractTree; //renderParams:
      //  * showVisibilityCheckbox {Bool} - показывать или нет checkbox видимости
      //  * allowActive {Bool} - возможен ли в дереве активный элемент
      //  * allowDblClick {Bool} - переходить ли по двойному клику к видимому экстенту слоя/группы
      //  * showStyle {Bool} - показывать ли иконку стилей
      //  * visibilityFunc {function(layerProps, isVisible)} - ф-ция, которая будет выполнена при изменении видимости слоя.
      //    По умолчанию устанавливает видимость соответствующего слоя в API
      //
      //события:
      //  * layerVisibilityChange - при изменении видимости слоя (параметр - элемент дерева с изменившимся слоем)
      //  * addTreeElem - добавили новый элемент дерева (параметр - новый элемент)
      //  * activeNodeChange - изменили активную ноду дерева (парамер - div активной ноды)
      //  * styleVisibilityChange - при изменении видимости стиля слоя

      var layersTree = function layersTree(renderParams) {
        this._renderParams = $.extend({
          showVisibilityCheckbox: true,
          allowActive: true,
          allowDblClick: true,
          showStyle: true,
          visibilityFunc: function visibilityFunc(props, isVisible) {
            if (props.name in nsGmx$1.gmxMap.layersByID) {
              nsGmx$1.leafletMap[isVisible ? 'addLayer' : 'removeLayer'](nsGmx$1.gmxMap.layersByID[props.name]);
            }
          }
        }, renderParams); // тип узла

        this.type = null; // содержимое узла

        this.content = null;
        this.condition = {
          visible: {},
          expanded: {}
        };
        this.mapStyles = {};
        this.groupLoadingFuncs = [];
        this._treeCanvas = null; //контейнер отрисованного дерева слоёв

        this._layerViewHooks = [];
      };

      layersTree.prototype.addLayerViewHook = function (hook) {
        hook && this._layerViewHooks.push(hook);
      };

      layersTree.prototype._applyLayerViewHooks = function (div, layerProps) {
        this._layerViewHooks.forEach(function (hook) {
          hook(div, layerProps);
        });
      }; // layerManagerFlag == 0 для дерева слева
      // layerManagerFlag == 1 для списка слоев
      // layerManagerFlag == 2 для списка карт


      layersTree.prototype.drawTree = function (tree, layerManagerFlag) {
        var permalinkParams = this.LayersTreePermalinkParams;

        if (permalinkParams) {
          var tempTree = new nsGmx$1.LayersTree(tree);
          tempTree.forEachNode(function (elem) {
            var props = elem.content.properties,
                id = elem.type == 'group' ? props.GroupID : props.LayerID;

            if (id in permalinkParams) {
              props.permalinkParams = permalinkParams[id];
            }
          });
          tree = tempTree.getRawTree();
        }

        this._treeCanvas = _ul([this.getChildsList(tree, false, layerManagerFlag, true)], [['dir', 'className', 'filetree']]);
        this.treeModel = new nsGmx$1.LayersTree(tree);
        this._mapTree = tree; //Устарело: используйте this.treeModel для доступа к исходному дереву

        this.treeModel.forEachLayer(function (layerContent) {
          layerContent.properties.initVisible = layerContent.properties.visible;
        });

        var _this = this;

        $(this.treeModel).on('nodeVisibilityChange', function (event, elem) {
          var props = elem.content.properties;

          _this.updateVisibilityUI(elem);

          props.changedByViewer = true;

          if (elem.type === 'layer') {
            _this._renderParams.visibilityFunc(props, props.visible);

            $(_this).triggerHandler('layerVisibilityChange', [elem]);
          }
        });
        nsGmx$1.leafletMap.on('layeradd layerremove', function (event) {
          if (event.layer.getGmxProperties) {
            var name = event.layer.getGmxProperties().name; //добавился именно слой из основной карты, а не просто с таким же ID

            if (event.layer === nsGmx$1.gmxMap.layersByID[name]) {
              var searchRes = _this.treeModel.findElem('name', name);

              if (searchRes && (!layerManagerFlag || layerManagerFlag == 0)) {
                _this.treeModel.setNodeVisibility(searchRes.elem, nsGmx$1.leafletMap.hasLayer(event.layer));
              }
            }
          }
        });
        return this._treeCanvas;
      };

      layersTree.prototype.getChildsList = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        // добавляем новый узел
        var li = _li();

        _(li, [this.drawNode(elem, parentParams, layerManagerFlag, parentVisibility)]);

        if (elem.content && elem.content.children && elem.content.children.length > 0) {
          var childsUl = _ul(); // initExpand - временное свойство, сохраняющее начальное состояние развёрнутости группы.
          // В expanded будет храниться только текущее состояние (не сохраняется)


          if (typeof elem.content.properties.initExpand == 'undefined') elem.content.properties.initExpand = elem.content.properties.expanded;

          if (!elem.content.properties.expanded) {
            childsUl.style.display = 'none';
            childsUl.className = 'hiddenTree';

            if (!layerManagerFlag) {
              childsUl.loaded = false;
              this.addLoadingFunc(childsUl, elem, parentParams, layerManagerFlag);
            } else {
              childsUl.loaded = true;
              var childs = [];

              for (var i = 0; i < elem.content.children.length; i++) {
                childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, true));
              }

              _(childsUl, childs);
            }
          } else {
            childsUl.loaded = true;
            var _childs = [];

            for (var _i = 0; _i < elem.content.children.length; _i++) {
              _childs.push(this.getChildsList(elem.content.children[_i], elem.content.properties, layerManagerFlag, parentVisibility && elem.content.properties.visible));
            }

            _(childsUl, _childs);
          }

          _(li, [childsUl, _abstractTree.makeSwapChild()]);
        } else if (elem.children) {
          if (elem.children.length > 0) {
            var _childs2 = [];

            for (var _i2 = 0; _i2 < elem.children.length; _i2++) {
              _childs2.push(this.getChildsList(elem.children[_i2], elem.properties, layerManagerFlag, true));
            }

            var _childsUl = _ul(_childs2);

            _childsUl.loaded = true;

            _(li, [_childsUl]);
          }

          _(li, [_div()]);

          li.root = true;
        } else _(li, [_abstractTree.makeSwapChild()]); // видимость слоя в дереве


        if (!nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN) && elem.type && elem.type == 'layer' // && typeof invisibleLayers != 'undefined' && invisibleLayers[elem.content.properties.name]
        ) li.style.display = 'none';
        return li;
      };

      layersTree.prototype.addLoadingFunc = function (parentCanvas, elem, parentParams, layerManagerFlag) {
        var func = function func() {
          $(parentCanvas.parentNode.firstChild).bind('click', function () {
            if (!parentCanvas.loaded) {
              parentCanvas.loaded = true;
              var childs = [],
                  grId = $(parentCanvas.parentNode).children("div[GroupID]");

              for (var i = 0; i < elem.content.children.length; i++) {
                childs.push(_this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, _this.getLayerVisibility($(grId).find('input[type="checkbox"]')[0] || $(grId).find('input[type="radio"]')[0])));
              }

              _(parentCanvas, childs);

              if (_queryMapLayers.currentMapRights() == "edit") {
                _queryMapLayers.addDraggable(parentCanvas);

                if (!layerManagerFlag) {
                  _queryMapLayers.addDroppable(parentCanvas);

                  _queryMapLayers.addSwappable(parentCanvas);
                }
              }

              $(parentCanvas).treeview();

              _layersTree.addExpandedEvents(parentCanvas);

              _this.runLoadingFuncs();

              _queryMapLayers.applyState(_this.condition, _this.mapStyles, $(parentCanvas.parentNode).children("div[GroupID]")[0]);
            }
          });
        },
            _this = this;

        this.groupLoadingFuncs.push(func);
      };

      layersTree.prototype.runLoadingFuncs = function () {
        for (var i = 0; i < this.groupLoadingFuncs.length; i++) {
          this.groupLoadingFuncs[i]();
        }

        this.groupLoadingFuncs = [];
      };

      layersTree.prototype.addExpandedEvents = function (parent) {
        var _this = this;

        $(parent).find("div.hitarea").each(function () {
          if (!this.clickFunc) {
            this.clickFunc = true;
            var divClick = this;
            if (divClick.parentNode.parentNode.parentNode.getAttribute("multiStyle")) return;
            $(divClick).bind('click', function () {
              var div = $(divClick.parentNode).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                  treeElem = _this.findTreeElem(div);

              if (!treeElem.parents.length) return;
              var flag = $(divClick).hasClass("expandable-hitarea");
              treeElem.elem.content.properties.expanded = !flag;
            });
          }
        });
      };

      layersTree.prototype.drawNode = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        var div;

        if (elem.type == "layer") {
          // var elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties(): elem.content.properties;
          var elemProperties;

          if (nsGmx$1.gmxMap.layersByID[elem.content.properties.name]) {
            elemProperties = !layerManagerFlag ? nsGmx$1.gmxMap.layersByID[elem.content.properties.name].getGmxProperties() : elem.content.properties;
          } else {
            elemProperties = elem.content.properties;
          }

          var childs = this.drawLayer(elemProperties, parentParams, layerManagerFlag, parentVisibility);
          if (typeof elem.content.properties.LayerID != 'undefined') div = _div(childs, [['attr', 'LayerID', elem.content.properties.LayerID]]);else if (typeof elem.content.properties.MultiLayerID != 'undefined') div = _div(childs, [['attr', 'MultiLayerID', elem.content.properties.MultiLayerID]]);else div = _div(childs, [['attr', 'LayerID', elem.content.properties.name]]);
          div.gmxProperties = elem;
          div.gmxProperties.content.properties = elemProperties;

          this._applyLayerViewHooks(div, elemProperties);
        } else {
          if (elem.properties && elem.properties.MapID) div = _div(this.drawHeaderGroupLayer(elem.properties, parentParams, layerManagerFlag), [['attr', 'MapID', elem.properties.MapID]]);else div = _div(this.drawGroupLayer(elem.content.properties, parentParams, layerManagerFlag, parentVisibility), [['attr', 'GroupID', elem.content.properties.GroupID]]);
          div.gmxProperties = elem;
        }

        div.oncontextmenu = function () {
          return false;
        };

        return div;
      };

      layersTree.prototype.setActive = function (span) {
        $(this._treeCanvas).find(".active").removeClass("active");

        if (span) {
          $(span.parentNode).addClass("active");
          $(this).triggerHandler("activeNodeChange", [span.parentNode.parentNode]);
        } else {
          $(this).triggerHandler("activeNodeChange", [null]);
        }
      };

      layersTree.prototype.getActive = function () {
        var activeDiv = $(this._treeCanvas).find(".active");
        return activeDiv[0] ? activeDiv[0].parentNode : null;
      };

      layersTree.prototype.getMinLayerZoom = function (layer) {
        if (!layer.getStyles) {
          return 1;
        }

        var minLayerZoom = 20,
            styles = layer.getStyles();

        for (var i = 0; i < styles.length; i++) {
          minLayerZoom = Math.min(minLayerZoom, styles[i].MinZoom);
        }

        return minLayerZoom;
      };

      layersTree.prototype.layerZoomToExtent = function (bounds) {
        if (!bounds) return;
        var lmap = nsGmx$1.leafletMap; // var z = lmap.getBoundsZoom(bounds);
        // if (minZoom !== 20) {
        // z = Math.max(z, minZoom);
        // }
        // z = Math.min(lmap.getMaxZoom(), Math.max(lmap.getMinZoom(), z));

        var currentZoom = lmap.getZoom();
        var doubleClickZoom = lmap.getBoundsZoom(bounds);
        var z = Math.min(Math.max(15, currentZoom), doubleClickZoom); //анимация приводит к проблемам из-за бага https://github.com/Leaflet/Leaflet/issues/3249
        //а указать явно zoom в fitBounds нельзя
        //TODO: enable animation!

        lmap.fitBounds(bounds, {
          animation: false,
          maxZoom: z
        }); //если вызывать setZoom всегда, карта начнёт глючить (бага Leaflet?)
        // if (z !== lmap.getZoom()) {
        //     lmap.setZoom(z);
        // }
      };

      layersTree.prototype.drawLayer = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        var box,
            _this = this;

        if (this._renderParams.showVisibilityCheckbox) {
          box = _checkbox(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);
          box.className = 'box layers-visibility-checkbox';
          box.setAttribute('box', 'layer');

          box.onclick = function () {
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
          };
        }

        var span = _span([_t(elem.title)], [['dir', 'className', 'layer'], ['attr', 'dragg', true]]);

        var timer = null,
            clickFunc = function clickFunc() {
          var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;

          $(treeNode).triggerHandler('click', [treeNode]);
          if (_this._renderParams.allowActive) _this.setActive(span);

          if (_this._renderParams.showVisibilityCheckbox) {
            _this.treeModel.setNodeVisibility(treeNode, true);
          }
        },
            dbclickFunc = function dbclickFunc() {
          var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;

          var layer = nsGmx$1.gmxMap.layersByID[elem.name];
          $(treeNode).triggerHandler('dblclick', [treeNode]);

          if (treeNode.content.geometry && layer && layer.getBounds) {
            var minLayerZoom = _this.getMinLayerZoom(layer);

            _this.layerZoomToExtent(layer.getBounds(), minLayerZoom);
          }
        };

        span.onclick = function () {
          if (timer) clearTimeout(timer);
          timer = setTimeout(clickFunc, 200);
        };

        if (this._renderParams.allowDblClick) {
          span.ondblclick = function () {
            if (timer) clearTimeout(timer);
            timer = null;
            clickFunc();
            dbclickFunc();
          };
        }

        disableSelection(span);

        var spanParent = _div([span], [['attr', 'titleDiv', true], ['css', 'display', 'inline'], ['css', 'position', 'relative'], ['css', 'borderBottom', 'none'], ['css', 'paddingRight', '3px']]),
            spanDescr = _span(null, [['dir', 'className', 'layerDescription']]);

        spanDescr.innerHTML = elem.description ? elem.description : '';

        if (layerManagerFlag == 1) {
          var imgIconSrc = elem.type == "Vector" ? 'img/vector.png' : typeof elem.MultiLayerID != 'undefined' ? 'img/multi.png' : 'img/rastr.png';
          if (elem.type == "Alias") imgIconSrc = 'img/shortcut.png';
          return [_img(null, [['attr', 'src', imgIconSrc], ['css', 'marginLeft', '3px']]), spanParent, spanDescr];
        }

        if (this._renderParams.showVisibilityCheckbox && !elem.visible) {
          $(spanParent).addClass("invisible");
        }

        nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Layer', function () {
          return true;
        }, {
          layerManagerFlag: layerManagerFlag,
          elem: elem,
          tree: this
        });

        var borderDescr = _span();

        var count = 0;
        var metaProps = {};

        if (elem.MetaProperties) {
          for (var key in elem.MetaProperties) {
            var tagtype = elem.MetaProperties[key].Type;
            metaProps[key] = nsGmx$1.Utils.convertFromServer(tagtype, elem.MetaProperties[key].Value);
            count++;
          }
        }

        if (count || elem.Legend) {
          _(borderDescr, [_t('i')], [['dir', 'className', 'layerInfoButton']]);

          borderDescr.onclick = function () {
            nsGmx$1.Controls.showLayerInfo({
              properties: elem
            }, {
              properties: metaProps
            });
          };
        }

        if (elem.type == "Vector") {
          var styles;

          if (window.newStyles) {
            if (elem.styles && !elem.gmxStyles) {
              elem.gmxStyles = L.gmx.StyleManager.decodeOldStyles(elem);
            }

            styles = elem.gmxStyles.styles;
          } else {
            styles = elem.styles;
          }

          var icon = _mapHelper.createStylesEditorIcon(styles, elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', {
            addTitle: !layerManagerFlag
          }),
              multiStyleParent = _div(null, [['attr', 'multiStyle', true]]),
              timelineIcon,
              iconSpan = _span([icon]);

          if (styles.length === 1 && elem.name in nsGmx$1.gmxMap.layersByID) {
            var layer = nsGmx$1.gmxMap.layersByID[elem.name];
            layer.on('stylechange', function () {
              if (layer.getStyles().length === 1) {
                var style = L.gmxUtil.toServerStyle(layer.getStyles()[0].RenderStyle);

                var newIcon = _mapHelper.createStylesEditorIcon([{
                  MinZoom: 1,
                  MaxZoom: 21,
                  RenderStyle: style
                }], elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', {
                  addTitle: !layerManagerFlag
                });

                $(iconSpan).empty().append(newIcon);
              }
            });
          }

          $(iconSpan).attr('styleType', $(icon).attr('styleType'));

          _mapHelper.createMultiStyle(elem, this, multiStyleParent, true, layerManagerFlag);

          if (!layerManagerFlag) {
            if (!parentVisibility || !elem.visible) $(multiStyleParent).addClass("invisible");

            iconSpan.onclick = function () {
              if (_queryMapLayers.currentMapRights() == "edit") {
                nsGmx$1.createStylesDialog(elem, _this);
              }
            };

            if (elem.name in nsGmx$1.gmxMap.layersByID) {
              var _layer = nsGmx$1.gmxMap.layersByID[elem.name];

              if (_layer.getGmxProperties) {
                var props = _layer.getGmxProperties();

                if (props.Temporal && (props.IsRasterCatalog || props.Quicklook && props.Quicklook !== 'null')) {
                  timelineIcon = this.CreateTimelineIcon(elem);
                }
              }
            }
          }

          var resElems = [spanParent, spanDescr, borderDescr];

          if (this._renderParams.showStyle) {
            resElems.push(multiStyleParent);
            resElems.unshift(iconSpan);
          }

          this._renderParams.showVisibilityCheckbox && resElems.unshift(box);

          if (timelineIcon) {
            resElems.unshift(timelineIcon);
          }

          return resElems;
        } else if (this._renderParams.showVisibilityCheckbox) {
          return [box, spanParent, spanDescr, borderDescr];
        } else {
          return [spanParent, spanDescr, borderDescr];
        }
      };

      layersTree.prototype.CreateTimelineIcon = function (elem) {
        var conf = {
          disabledSrc: 'img/timeline-icon-disabled.svg',
          enabledSrc: 'img/timeline-icon-enabled.svg',
          addTitle: window._gtxt('Добавить в таймлайн'),
          removeTitle: window._gtxt('Удалить из таймлайна')
        },
            layerID = elem.name,
            icon = nsGmx$1.Utils._img(null, [['attr', 'src', conf.disabledSrc], ['dir', 'className', 'gmx-timeline-icon disabled'], ['dir', 'title', conf.addTitle]]),
            toggleIcon = function toggleIcon(flag) {
          if (flag) {
            icon.src = conf.enabledSrc;
            icon.title = conf.addTitle;
            icon.classList.remove('disabled');
          } else {
            icon.src = conf.disabledSrc;
            icon.title = conf.removeTitle;
            icon.classList.add('disabled');
          }
        }; // TODO: требуется замена jQuery    + не эффективно устанавливается множество хэндлеров


        $(this).on('layerTimelineRemove', function (e, data) {
          if (data.layerID === layerID) {
            toggleIcon(false);
          }
        });
        $(this).on('layerTimelineAdd', function (e, data) {
          if (data.layerID === layerID) {
            toggleIcon(true);
          }
        });
        L.DomEvent.on(icon, 'click', function () {
          var disabled = icon.classList.contains('disabled'),
              tlc = nsGmx$1.timeLineControl,
              layer = nsGmx$1.gmxMap.layersByID[layerID];

          if (disabled) {
            if (!tlc._map) {
              nsGmx$1.leafletMap.addControl(tlc);
            }

            tlc.addLayer(layer);
          } else {
            tlc.removeLayer(layer);
          }
        }, this);
        return icon;
      };

      layersTree.prototype.drawGroupLayer = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        var box,
            _this = this;

        if (this._renderParams.showVisibilityCheckbox) {
          box = _checkbox(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);
          box.className = 'box layers-visibility-checkbox';
          box.setAttribute('box', 'group');

          box.onclick = function () {
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
          };

          if (typeof elem.ShowCheckbox !== 'undefined' && !elem.ShowCheckbox) {
            box.isDummyCheckbox = true;
            box.style.display = 'none';
          }
        }

        var span = _span([_t(elem.title)], [['dir', 'className', 'groupLayer'], ['attr', 'dragg', true]]);

        var timer = null,
            clickFunc = function clickFunc() {
          if (_this._renderParams.allowActive) _this.setActive(span);

          if (_this._renderParams.showVisibilityCheckbox) {
            var div = span.parentNode.parentNode;

            if (div.gmxProperties.content.properties.ShowCheckbox) {
              _this.treeModel.setNodeVisibility(_this.findTreeElem(div).elem, true);
            }

            var clickDiv = $(div.parentNode).children("div.hitarea");
            if (clickDiv.length) $(clickDiv[0]).trigger("click");
          }
        },
            dbclickFunc = function dbclickFunc() {
          var childsUl = _abstractTree.getChildsUl(span.parentNode.parentNode.parentNode);

          if (childsUl) {
            var bounds = new L.LatLngBounds(),
                minLayerZoom = 20;

            _mapHelper.findChilds(_this.findTreeElem(span.parentNode.parentNode).elem, function (child) {
              if (child.type == 'layer' && (child.content.properties.LayerID || child.content.properties.MultiLayerID) && child.content.geometry) {
                var layer = nsGmx$1.gmxMap.layersByID[child.content.properties.name];
                bounds.extend(layer.getBounds());
                minLayerZoom = Math.min(minLayerZoom, _this.getMinLayerZoom(layer));
              }
            });

            _this.layerZoomToExtent(bounds, minLayerZoom);
          }
        };

        span.onclick = function () {
          if (timer) clearTimeout(timer);
          timer = setTimeout(clickFunc, 200);
        };

        if (this._renderParams.allowDblClick) {
          span.ondblclick = function () {
            if (timer) clearTimeout(timer);
            timer = null;
            clickFunc();
            dbclickFunc();
          };
        }

        disableSelection(span);

        var spanParent = _div([span], [['attr', 'titleDiv', true], ['css', 'display', 'inline'], ['css', 'position', 'relative'], ['css', 'borderBottom', 'none'], ['css', 'paddingRight', '3px']]);

        if (this._renderParams.showVisibilityCheckbox && (!parentVisibility || !elem.visible)) {
          $(spanParent).addClass("invisible");
        }

        if (!layerManagerFlag) {
          nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Group', function () {
            return _queryMapLayers.currentMapRights() == "edit";
          }, function () {
            return {
              div: spanParent.parentNode,
              tree: _this
            };
          });
        }

        if (this._renderParams.showVisibilityCheckbox) return [box, spanParent];else return [spanParent];
      };

      layersTree.prototype.drawHeaderGroupLayer = function (elem, parentParams, layerManagerFlag) {
        var span = _span([_t(elem.title)], [['dir', 'className', 'groupLayer']]),
            spanParent = _div([span], [['css', 'display', 'inline'], ['css', 'position', 'relative'], ['css', 'borderBottom', 'none'], ['css', 'paddingRight', '3px']]),
            _this = this;

        if (this._renderParams.allowActive) {
          span.onclick = function () {
            _this.setActive(this);
          };
        }

        if (!layerManagerFlag) {
          nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Map', function () {
            return _queryMapLayers.currentMapRights() == "edit";
          }, function () {
            return {
              div: spanParent.parentNode,
              tree: _this
            };
          });
        }

        return [spanParent];
      };

      layersTree.prototype.removeGroup = function (div) {
        var template = Handlebars.compile('<div class="removeGroup-container">' + '{{#if anyChildren}}' + '<label><input type="checkbox" checked class="removeGroup-layers">{{i "Включая вложенные слои"}}</label><br>' + '{{/if}}' + '<button class="removeGroup-remove">{{i "Удалить"}}</button>' + '</div>');

        var groupNode = _layersTree.treeModel.findElemByGmxProperties(div.gmxProperties).elem;

        var ui = $(template({
          anyChildren: groupNode.content.children.length > 0
        })),
            pos = nsGmx$1.Utils.getDialogPos(div, true, 90),
            _this = this;

        ui.find('.removeGroup-remove').click(function () {
          var parentTree = div.parentNode.parentNode,
              childsUl = _abstractTree.getChildsUl(div.parentNode);

          if (ui.find('.removeGroup-layers').prop('checked')) {
            _layersTree.treeModel.forEachLayer(function (layerContent) {
              _queryMapLayers.removeLayer(layerContent.properties.name);
            }, groupNode);
          } else {
            //TODO: не работает, когда группа не раскрыта или раскрыта не полностью
            var divDestination = $(parentTree.parentNode).children("div[MapID],div[GroupID]")[0];

            if (childsUl) {
              // переносим все слои наверх
              $(childsUl).find("div[LayerID],div[MultiLayerID]").each(function () {
                var spanSource = $(this).find("span.layer")[0];

                _this.moveHandler(spanSource, divDestination);
              });
            }
          }

          _this.removeTreeElem(div);

          div.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          $(dialogDiv).dialog('destroy');
          dialogDiv.removeNode(true);

          _mapHelper.updateUnloadEvent(true);

          _this.updateZIndexes();
        });

        var title = _gtxt("Удаление группы [value0]", div.gmxProperties.content.properties.title);

        var dialogDiv = showDialog(title, ui[0], 250, 100, pos.left, pos.top);
      }; //по элементу дерева слоёв ищет соответствующий элемент в DOM представлении


      layersTree.prototype.findUITreeElem = function (elem) {
        var props = elem.content.properties,
            searchStr;
        if (props.LayerID) searchStr = "div[LayerID='" + props.LayerID + "']";else if (props.MultiLayerID) searchStr = "div[MultiLayerID='" + props.MultiLayerID + "']";else if (props.GroupID) searchStr = "div[GroupID='" + props.GroupID + "']";else searchStr = "div[LayerID='" + props.name + "']";
        return $(this._treeCanvas).find(searchStr)[0];
      };

      layersTree.prototype.getLayerVisibility = function (box) {
        if (!box.checked) return false;
        var el = box.parentNode.parentNode.parentNode;

        while (!el.root) {
          var group = $(el).children("[GroupID]"),
              chB = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];

          if (group.length > 0) {
            if (!chB.checked) return false;
          }

          el = el.parentNode;
        }

        return true;
      }; //Устанавливает галочку в checkbox и нужный стиль DOM ноде дерева в зависимости от видимости
      //ничего не трогает вне ноды и в самом дереве


      layersTree.prototype.updateVisibilityUI = function (elem) {
        var div = this.findUITreeElem(elem);

        if (div) {
          var isVisible = elem.content.properties.visible;
          $(div).children("[titleDiv], [multiStyle]").toggleClass("invisible", !isVisible);
          var checkbox = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0];
          checkbox.checked = isVisible;
        }
      };

      layersTree.prototype.dummyNode = function (node) {
        var text = node.innerHTML;

        if (text.length > 40) {
          text = text.substring(0, 37) + '...';
        }

        return _div([_t(text)], [['dir', 'className', 'dragableDummy']]);
      }; //проходится по всем слоям дерева и устанавливает им z-индексы в соответствии с их порядком в дереве


      layersTree.prototype.updateZIndexes = function () {
        var curZIndex = 0;
        this.treeModel.forEachLayer(function (layerContent) {
          var layer = nsGmx$1.gmxMap.layersByID[layerContent.properties.name];
          var zIndex = curZIndex++;
          layer.setZIndex && layer.setZIndex(zIndex);
        });
      };

      layersTree.prototype.moveHandler = function (spanSource, divDestination) {
        var node = divDestination.parentNode,
            divSource = spanSource.parentNode.parentNode.parentNode,
            parentTree = divSource.parentNode,
            parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];
        this.removeTreeElem(spanSource.parentNode.parentNode);
        this.addTreeElem(divDestination, 0, spanSource.parentNode.parentNode.gmxProperties); // добавим новый узел

        var childsUl = _abstractTree.getChildsUl(node);

        if (childsUl) {
          _abstractTree.addNode(node, divSource);

          this.updateListType(divSource);
          if (!childsUl.loaded) divSource.removeNode(true);
        } else {
          _abstractTree.addNode(node, divSource);

          this.updateListType(divSource);
        }

        parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem); // удалим старый узел

        _abstractTree.delNode(node, parentTree, parentTree.parentNode);

        _mapHelper.updateUnloadEvent(true);

        this.updateZIndexes();
      };

      layersTree.prototype.swapHandler = function (spanSource, divDestination) {
        var node = divDestination.parentNode,
            divSource = spanSource.parentNode.parentNode.parentNode,
            parentTree = divSource.parentNode,
            parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];
        if (node == divSource) return;
        this.removeTreeElem(spanSource.parentNode.parentNode);
        var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
            divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
            index = this.findTreeElem(divElem).index;
        this.addTreeElem(divParent, index + 1, spanSource.parentNode.parentNode.gmxProperties);

        _abstractTree.swapNode(node, divSource);

        this.updateListType(divSource);
        parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem); // удалим старый узел

        _abstractTree.delNode(node, parentTree, parentTree.parentNode);

        _mapHelper.updateUnloadEvent(true);

        this.updateZIndexes();
      };

      layersTree.prototype.copyHandler = function (gmxProperties, divDestination, swapFlag, addToMap) {
        var _this = this;

        var isFromList = typeof gmxProperties.content.geometry === 'undefined';

        var layerProperties = gmxProperties.type !== 'layer' || !isFromList ? gmxProperties : false,
            copyFunc = function copyFunc() {
          if (addToMap) {
            if (!_this.addLayersToMap(layerProperties)) {
              return;
            }
          } else if (_this.treeModel.findElemByGmxProperties(gmxProperties)) {
            if (layerProperties.type === 'layer') {
              showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", layerProperties.content.properties.title), true);
            } else {
              showErrorMessage(_gtxt("Группа '[value0]' уже есть в карте", layerProperties.content.properties.title), true);
            }

            return;
          }

          var node = divDestination.parentNode,
              parentProperties = swapFlag ? $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0].gmxProperties : divDestination.gmxProperties,
              li;

          if (swapFlag) {
            var parentDiv = $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0];
            li = _this.getChildsList(layerProperties, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _this.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0] ? $(parentDiv).find('input[type="checkbox"]')[0] : parentDiv.firstChild));
          } else li = _this.getChildsList(layerProperties, parentProperties, false, _this.getLayerVisibility($(divDestination).find('input[type="checkbox"]')[0] ? $(divDestination).find('input[type="checkbox"]')[0] : divDestination.firstChild));

          if (layerProperties.type == 'group') {
            // добавляем группу
            if (_abstractTree.getChildsUl(li)) {
              var div = _div(null, [['dir', 'className', 'hitarea']]);

              if (layerProperties.content.properties.expanded) {
                $(div).addClass('collapsable-hitarea');
                $(li).addClass('collapsable');
              } else {
                $(div).addClass('expandable-hitarea');
                $(li).addClass('expandable');
              }

              _abstractTree.toggle(div);

              li.insertBefore(div, li.firstChild);
              $(li).treeview(); // если копируем из карты

              if (isFromList) _layersTree.runLoadingFuncs();
            }

            _queryMapLayers.addDraggable(li);

            _queryMapLayers.addDroppable(li);
          } else {
            _queryMapLayers.addDraggable(li);

            if (layerProperties.type == 'layer' && layerProperties.content.properties.styles.length > 1) $(li).treeview();
          }

          _queryMapLayers.addSwappable(li);

          if (swapFlag) {
            var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
                index = _this.findTreeElem(divElem).index;

            _this.addTreeElem(divParent, index + 1, layerProperties);

            _abstractTree.swapNode(node, li);

            _this.updateListType(li, true);
          } else {
            _this.addTreeElem(divDestination, 0, layerProperties);

            var childsUl = _abstractTree.getChildsUl(node);

            _abstractTree.addNode(node, li);

            _this.updateListType(li, true);

            if (childsUl && !childsUl.loaded) {
              li.removeNode(true);
            }
          }

          _mapHelper.updateUnloadEvent(true);

          _this.updateZIndexes();
        };

        if (!layerProperties) {
          if (gmxProperties.content.properties.LayerID) {
            sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + gmxProperties.content.properties.name + "&srs=" + (nsGmx$1.leafletMap.options.srs || "3395"), function (response) {
              if (!parseResponse(response)) return;
              layerProperties = {
                type: 'layer',
                content: response.Result
              };
              if (layerProperties.content.properties.type == 'Vector') layerProperties.content.properties.styles = [{
                MinZoom: 1,
                MaxZoom: 21,
                RenderStyle: layerProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[layerProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[layerProperties.content.properties.GeometryType]
              }];else if (layerProperties.content.properties.type != 'Vector' && !layerProperties.content.properties.MultiLayerID) layerProperties.content.properties.styles = [{
                MinZoom: layerProperties.content.properties.MinZoom,
                MaxZoom: 21
              }];
              layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
              layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
              layerProperties.content.properties.visible = true;
              copyFunc();
            });
          } else {
            sendCrossDomainJSONRequest(window.serverBase + "MultiLayer/GetMultiLayerJson.ashx?WrapStyle=func&MultiLayerID=" + gmxProperties.content.properties.MultiLayerID, function (response) {
              if (!parseResponse(response)) return;
              layerProperties = {
                type: 'layer',
                content: response.Result
              };
              layerProperties.content.properties.styles = [{
                MinZoom: layerProperties.content.properties.MinZoom,
                MaxZoom: 20
              }];
              layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
              layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
              layerProperties.content.properties.visible = true;
              copyFunc();
            });
          }
        } else copyFunc();
      }; //не работает для мультислоёв


      layersTree.prototype.addLayerToTree = function (layerName) {
        var gmxProperties = {
          type: 'layer',
          content: {
            properties: {
              LayerID: layerName,
              name: layerName
            }
          }
        };
        var targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0];
        this.copyHandler(gmxProperties, targetDiv, false, true);
      };

      layersTree.prototype.checkGroupForDuplicates = function (elements) {
        var alreadyOnMap = false;

        for (var i = 0; i < elements.length; i++) {
          var elem = elements[i],
              layer = elem.content,
              name = layer.properties.name;

          if (nsGmx$1.gmxMap.layersByID[name]) {
            alreadyOnMap = nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title;
            break;
          }
        }

        return alreadyOnMap;
      }; //геометрия слоёв должна быть в координатах меркатора


      layersTree.prototype.addLayersToMap = function (elem) {
        var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
        var layerOrder = nsGmx$1.gmxMap.rawTree.properties.LayerOrder,
            currentZoom = nsGmx$1.leafletMap.getZoom();

        if (typeof elem.content.properties.GroupID != 'undefined') {
          var alreadyOnMap = this.checkGroupForDuplicates(elem.content.children);

          if (alreadyOnMap) {
            showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", alreadyOnMap), true);
            return false;
          } else {
            for (var i = 0; i < elem.content.children.length; i++) {
              var res = this.addLayersToMap(elem.content.children[i]);
              if (!res) return false;
            }
          }
        } else {
          var layer = elem.content,
              name = layer.properties.name; // hack to avoid API defaults by initFromDescription;

          var propsHostName = window.serverBase.replace(/https?:\/\//, '');
          propsHostName = propsHostName.replace(/\//g, '');
          layer.properties.hostName = propsHostName;

          if (!nsGmx$1.gmxMap.layersByID[name]) {
            var visibility = typeof layer.properties.visible != 'undefined' ? layer.properties.visible : false,
                layerOnMap = L.gmx.createLayer(layer, {
              layerID: name,
              hostName: propsHostName,
              zIndexOffset: null,
              srs: nsGmx$1.leafletMap.options.srs || '',
              skipTiles: nsGmx$1.leafletMap.options.skipTiles || '',
              isGeneralized: window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true
            });
            updateZIndex(layerOnMap);
            nsGmx$1.gmxMap.addLayer(layerOnMap);
            visibility && nsGmx$1.leafletMap.addLayer(layerOnMap);
            layerOnMap.getGmxProperties().changedByViewer = true;
            nsGmx$1.leafletMap.on('zoomend', function () {
              currentZoom = nsGmx$1.leafletMap.getZoom();

              for (var l = 0; l < nsGmx$1.gmxMap.layers.length; l++) {
                var layer = nsGmx$1.gmxMap.layers[l];
                updateZIndex(layer);
              }
            });
          } else {
            showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title), true);
            return false;
          }
        }

        function updateZIndex(layer) {
          var props = layer.getGmxProperties();

          switch (layerOrder) {
            case 'VectorOnTop':
              if (props.type === 'Vector') {
                if (props.IsRasterCatalog) {
                  var rcMinZoom = props.RCMinZoomForRasters;
                  layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                } else {
                  layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                }
              }

              break;
          }
        }

        return true;
      };

      layersTree.prototype.getParentParams = function (li) {
        //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
        var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
            listFlag;
        if (parentParams.content) listFlag = parentParams.content.properties;else listFlag = parentParams.properties;
        return listFlag;
      };

      layersTree.prototype.updateListType = function (li, skipVisible) {
        //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
        var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
            listFlag;
        if (parentParams.content) listFlag = parentParams.content.properties.list;else listFlag = parentParams.properties.list;

        var div = $(li).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
            box = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0],
            newBox = _checkbox(box.checked, listFlag ? 'radio' : 'checkbox', parentParams.content ? parentParams.content.properties.GroupID : parentParams.properties.MapID),
            _this = this;

        newBox.className = 'box layers-visibility-checkbox';
        if (box.getAttribute('box') == 'group') newBox.setAttribute('box', 'group');
        $(box).replaceWith(newBox);

        newBox.onclick = function () {
          _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
        };

        if (box.isDummyCheckbox) {
          newBox.isDummyCheckbox = true;
          newBox.style.display = 'none';
        }

        if (!skipVisible) {
          var parentDiv = $(newBox.parentNode.parentNode.parentNode.parentNode).children("div[GroupID]")[0];
          parentDiv && this.treeModel.updateNodeVisibility(this.findTreeElem(parentDiv).elem, this.findTreeElem(newBox.parentNode).elem);
        }

        return newBox;
      };

      layersTree.prototype.removeTreeElem = function (div) {
        var elem = this.findTreeElem(div);
        if (typeof elem.parents[0].children != 'undefined') elem.parents[0].children.splice(elem.index, 1);else elem.parents[0].content.children.splice(elem.index, 1);
      };

      layersTree.prototype.addTreeElem = function (div, index, elemProperties) {
        var elem = this.findTreeElem(div);
        if (typeof elem.elem.children != 'undefined') elem.elem.children.splice(index, 0, elemProperties);else elem.elem.content.children.splice(index, 0, elemProperties);
        $(this.treeModel.getRawTree()).triggerHandler('addTreeElem', [elemProperties]);
      };

      layersTree.prototype.findTreeElem = function (div) {
        if (div.getAttribute("MapID")) return {
          elem: this.treeModel.getRawTree(),
          parents: [],
          index: false
        };else if (div.getAttribute("GroupID")) return this.treeModel.findElem("GroupID", div.getAttribute("GroupID"));else if (div.getAttribute("LayerID")) return this.treeModel.findElem("name", div.getAttribute("LayerID"));else if (div.getAttribute("MultiLayerID")) return this.treeModel.findElem("name", div.getAttribute("MultiLayerID"));
      }; //Дерево основной карты


      var _layersTree = new layersTree({
        showVisibilityCheckbox: true,
        allowActive: true,
        allowDblClick: true
      });

      window.layersTree = layersTree;
      window._layersTree = _layersTree; //Виджет в левой панели для отображения основного дерева

      var queryMapLayers = function queryMapLayers() {
        this.buildedTree = null;
        this.builded = false;
        this.buttonsCanvas = _div();
        this.loadDeferred = $.Deferred();
      };

      queryMapLayers.prototype = new leftMenu();

      queryMapLayers.prototype.addLayers = function (data, condition, mapStyles, LayersTreePermalinkParams) {
        if (condition) _layersTree.condition = condition;
        if (mapStyles) _layersTree.mapStyles = mapStyles;
        if (LayersTreePermalinkParams) _layersTree.LayersTreePermalinkParams = LayersTreePermalinkParams;
        this.buildedTree = _layersTree.drawTree(data);
      };

      queryMapLayers.prototype.applyState = function (condition, mapLayersParam, div) {
        if (!objLength(condition.visible) && !objLength(condition.expanded) && !objLength(mapLayersParam)) return;

        var parentElem = typeof div == 'undefined' ? _layersTree.treeModel.getRawTree() : _layersTree.findTreeElem(div).elem,
            visFlag = typeof div == 'undefined' ? true : _layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0]),
            _this = this;

        _mapHelper.findTreeElems(parentElem, function (elem) {
          var props = elem.content.properties;

          if (elem.type == 'group') {
            var groupId = props.GroupID;

            if (typeof condition.visible[groupId] != 'undefined' && props.visible != condition.visible[groupId]) {
              props.visible = condition.visible[groupId];
              var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

              if (group.length) {
                var it = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];
                if (it) it.checked = condition.visible[groupId];
              }
            }

            if (typeof condition.expanded[groupId] != 'undefined' && props.expanded != condition.expanded[groupId]) {
              props.expanded = condition.expanded[groupId];

              var _group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

              if (_group.length) {
                var clickDiv = $(_group[0].parentNode).children("div.hitarea");
                if (clickDiv.length) $(clickDiv[0]).trigger("click");
              }
            }
          } else {
            var name = props.name;

            if (typeof condition.visible[name] != 'undefined') {
              _layersTree.treeModel.setNodeVisibility(elem, condition.visible[name]);
            } else {
              _layersTree.treeModel.setNodeVisibility(elem, props.initVisible);
            }

            if (props.type == "Vector" && typeof mapLayersParam != 'undefined' && typeof mapLayersParam[name] != 'undefined' && !_this.equalStyles(props.styles, mapLayersParam[name])) {
              // что-то менялось в стилях
              var newStyles = mapLayersParam[name],
                  _div2 = $(_this.buildedTree).find("div[LayerID='" + props.LayerID + "']")[0];
              props.styles = newStyles;

              _mapHelper.updateMapStyles(newStyles, name);

              props.changedByViewer = true;
              _div2 && _mapHelper.updateTreeStyles(newStyles, _div2, _layersTree, true);
            }
          }
        }, visFlag);
      };

      queryMapLayers.prototype.equalStyles = function (style1, style2) {
        if (style1.length != style2.length) return false;

        for (var i = 0; i < style1.length; i++) {
          if (!equals(style1[i], style2[i])) return false;
        }

        return true;
      };

      queryMapLayers.prototype.getContainerBefore = function () {
        if (!this.builded) return;
        return $('.layers-before', this.workCanvas).show();
      };

      queryMapLayers.prototype.getContainerAfter = function () {
        if (!this.builded) return;
        return $('.layers-after', this.workCanvas).show();
      };

      queryMapLayers.prototype.load = function () {
        if (this.buildedTree && !this.builded) {
          var _this = this;

          this.treeCanvas = _div(null, [['dir', 'className', 'layers-tree']]); //Для обратной совместимости - есть много мапплетов карт, которые пытаются интегрироваться после первого table
          //TODO: изнечтожить все такие мапплеты

          _(this.workCanvas, [_table()]);

          _(this.workCanvas, [_div([//_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
          ], [['dir', 'className', 'layers-before'], ['css', 'display', 'none']])]);

          _(this.workCanvas, [this.treeCanvas]);

          _(this.treeCanvas, [this.buildedTree]);

          _(this.workCanvas, [_div([//_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
          ], [['dir', 'className', 'layers-after'], ['css', 'display', 'none']])]);

          $(this.buildedTree).treeview();

          _layersTree.runLoadingFuncs();

          _layersTree.addExpandedEvents(this.buildedTree); //при клике на любом пустом месте дерева слоёв снимаем выделение


          $(this.treeCanvas).click(function (event) {
            var t = $(event.target); //все элементы, на которых можно кликнуть без снятия выделения

            if (t.hasClass('hitarea') || t.hasClass('groupLayer') || t.attr('styletype') || t.parents('div[layerid],div[MultiLayerID]').length) {
              return;
            }

            _layersTree.setActive(null);
          });
          $(this.treeCanvas).droppable({
            accept: "span[dragg]",
            drop: function drop(ev, ui) {
              queryMapLayers._droppableHandler.bind($(_this.buildedTree).find('[mapid]')[0], ev, ui)();
            }
          });
          this.applyState(_layersTree.condition, _layersTree.mapStyles);
          this.builded = true;
          $(this).triggerHandler('load');
          this.loadDeferred.resolve();
        }
      };

      queryMapLayers.prototype.applyOpacityToRasterLayers = function (opacity, parent) {
        var active = $(parent).find(".active"); // слой

        if (active[0] && (active[0].parentNode.getAttribute("LayerID") || active[0].parentNode.getAttribute("MultiLayerID"))) {
          var props = active[0].parentNode.gmxProperties.content.properties,
              layer = nsGmx$1.gmxMap.layersByID[props.name];
          layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);
          return;
        }

        if (active.length) {
          // группа или карта
          var treeElem = _layersTree.findTreeElem(active[0].parentNode);

          _mapHelper.findChilds(treeElem.elem, function (child) {
            var props = child.content.properties;
            var layer = nsGmx$1.gmxMap.layersByID[props.name];
            layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);
          }, true);
        } else {
          // все растровые слои
          var layers = nsGmx$1.gmxMap.layers;

          for (var i = 0; i < layers.length; i++) {
            layers[i].setRasterOpacity && layers[i].setRasterOpacity(opacity / 100);
          }
        }
      };

      queryMapLayers.prototype.rasterLayersSlider = function (parent) {
        var slider = nsGmx$1.Controls.createSlider(100, function (event, ui) {
          _queryMapLayers.applyOpacityToRasterLayers(ui.value, parent);
        }),
            elem = _div([slider], [['css', 'width', '120px']]);

        slider.style.margin = '10px';
        slider.style.backgroundColor = '#F4F4F4';

        _title(slider, _gtxt("Прозрачность выбранного слоя/группы/карты"));

        return _div([elem], [['css', 'padding', '5px 0px 0px 15px']]);
      };

      queryMapLayers.prototype.currentMapRights = function () {
        var mapProperties = _layersTree.treeModel && _layersTree.treeModel.getMapProperties();

        return mapProperties ? mapProperties.Access : "none";
      };

      queryMapLayers.prototype.layerRights = function (name) {
        var layer = nsGmx$1.gmxMap.layersByID[name];
        return layer ? layer.getGmxProperties().Access : null;
      };

      queryMapLayers.prototype.addUserActions = function () {
        if (this.currentMapRights() == "edit") {
          this.addDraggable(this.treeCanvas);
          this.addDroppable(this.treeCanvas);
          this.addSwappable(this.treeCanvas);
        }
      };

      queryMapLayers.prototype.removeUserActions = function () {
        //  removeChilds(this.buttonsCanvas);
        this.removeDraggable(this.treeCanvas);
        this.removeDroppable(this.treeCanvas);
        this.removeSwappable(this.treeCanvas);
      };

      queryMapLayers.prototype.addDraggable = function (parent) {
        $(parent).find("span[dragg]").draggable({
          helper: function helper(ev) {
            return _layersTree.dummyNode(ev.target);
          },
          cursorAt: {
            left: 5,
            top: 10
          },
          appendTo: document.body
        });
      };

      queryMapLayers.prototype.removeDraggable = function (parent) {
        $(parent).find("span[dragg]").draggable('destroy');
      };

      queryMapLayers._droppableHandler = function (ev, ui) {
        $('body').css("cursor", ''); // удалим элемент, отображающий копирование

        ui.helper[0].removeNode(true); // уберем заведомо ложные варианты - сам в себя, копирование условий

        if (this == ui.draggable[0].parentNode.parentNode) return;
        var circle = false,
            layerManager = false;
        $(this).parents().each(function () {
          if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode) circle = true;
        });
        if (circle) return;
        var isFromExternalMaps = false;
        $(ui.draggable[0].parentNode.parentNode).parents().each(function () {
          if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0]) layerManager = true;
          if (this == $('#externalMapsCanvas')[0]) isFromExternalMaps = true;
        });
        if (!layerManager) _layersTree.moveHandler(ui.draggable[0], this);else _layersTree.copyHandler(ui.draggable[0].parentNode.parentNode.gmxProperties, this, false, !isFromExternalMaps);
      };

      queryMapLayers.prototype.addDroppable = function (parent) {
        $(parent).find("div[GroupID],div[MapID]").droppable({
          accept: "span[dragg]",
          hoverClass: 'droppableHover',
          greedy: true,
          drop: queryMapLayers._droppableHandler
        });
        $(parent).find("div[LayerID],div[MultiLayerID]").droppable({
          accept: "span[dragg]",
          greedy: true,
          drop: function drop(ev, ui) {
            var swapElem = $(this).next();
            swapElem.removeClass('swap-droppableHover');

            queryMapLayers._swapHandler.call(swapElem[0], ev, ui);
          },
          over: function over() {
            $(this).next().addClass('swap-droppableHover');
          },
          out: function out() {
            $(this).next().removeClass('swap-droppableHover');
          }
        });
      };

      queryMapLayers.prototype.removeDroppable = function (parent) {
        $(parent).find("div[GroupID],div[MapID]").droppable('destroy');
      }; //статическая ф-ция


      queryMapLayers._swapHandler = function (ev, ui) {
        $('body').css("cursor", ''); // удалим элемент, отображающий копирование

        ui.helper[0].removeNode(true); //проверим, не идёт ли копирование группы внутрь самой себя

        var circle = false;
        $(this).parents().each(function () {
          if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode) circle = true;
        });
        if (circle) return;
        var layerManager = false;
        var isFromExternalMaps = false;
        $(ui.draggable[0].parentNode.parentNode).parents().each(function () {
          if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0]) layerManager = true;
          if (this == $('#externalMapsCanvas')[0]) isFromExternalMaps = true;
        });
        var gmxProperties = ui.draggable[0].parentNode.parentNode.gmxProperties;
        if (!layerManager) _layersTree.swapHandler(ui.draggable[0], this);else _layersTree.copyHandler(gmxProperties, this, true, !isFromExternalMaps);
      };

      queryMapLayers.prototype.addSwappable = function (parent) {
        $(parent).find("div[swap]").droppable({
          accept: "span[dragg]",
          hoverClass: 'swap-droppableHover',
          greedy: true,
          drop: queryMapLayers._swapHandler
        });
      };

      queryMapLayers.prototype.removeSwappable = function (parent) {
        $(parent).find("div[swap]").droppable('destroy');
      };

      queryMapLayers.prototype.asyncCreateLayer = function (promise, title) {
        var _this = this;

        var taskDiv = _div(),
            active = $(_this.buildedTree).find(".active")[0],
            parentDiv;

        if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID'))) parentDiv = active.parentNode.parentNode;else parentDiv = _this.buildedTree.firstChild;

        _abstractTree.addNode(parentDiv, _li([taskDiv, _div(null, [['css', 'height', '5px'], ['css', 'fontSize', '0px']])]));

        promise.fail(function () {
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);
        }).done(function (taskInfo) {
          if (!$.isArray(taskInfo.Result)) {
            taskInfo.Result = [taskInfo.Result];
          }

          var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
              parentProperties = parentDiv.gmxProperties;
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          for (var l = 0; l < taskInfo.Result.length; l++) {
            var newLayer = taskInfo.Result[l];
            var newProps = newLayer.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();

            newProps.mapName = mapProperties.name;
            newProps.hostName = mapProperties.hostName;
            newProps.visible = true;

            if (!newProps.styles) {
              if (newProps.type == 'Vector') newProps.styles = [{
                MinZoom: 1,
                MaxZoom: 21,
                RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType]
              }];else if (newProps.type != 'Vector' && !newProps.MultiLayerID) newProps.styles = [{
                MinZoom: newProps.MinZoom,
                MaxZoom: 21
              }];
            }

            var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

            _layersTree.addLayersToMap({
              content: {
                properties: newProps,
                geometry: newLayer.geometry
              }
            });

            var li = _layersTree.getChildsList({
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            }, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0]));

            _abstractTree.addNode(parentDiv.parentNode, li);

            var divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

            _layersTree.addTreeElem(divParent, 0, {
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            });

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);
          }

          _mapHelper.updateUnloadEvent(true);

          _layersTree.updateZIndexes();
        }).progress(function (taskInfo) {
          $(taskDiv).empty();

          _(taskDiv, [_span([_t(title + ':')], [['css', 'color', '#153069'], ['css', 'margin', '0px 3px']]), _t(taskInfo.Status)]);
        });
      };

      queryMapLayers.prototype.asyncUpdateLayer = function (promise, properties, recreateLayer) {
        var layerDiv = $(_queryMapLayers.buildedTree).find("[LayerID='" + properties.LayerID + "']")[0],
            _this = this;

        promise.done(function (taskInfo) {
          if (recreateLayer) {
            var newLayerProperties = taskInfo.Result.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();

            newLayerProperties.mapName = mapProperties.name;
            newLayerProperties.hostName = mapProperties.hostName;
            newLayerProperties.visible = layerDiv.gmxProperties.content.properties.visible;
            newLayerProperties.styles = layerDiv.gmxProperties.content.properties.styles; //var convertedCoords = from_merc_geometry(taskInfo.Result.geometry);

            var origGeometry = taskInfo.Result.geometry,
                convertedGeometry = origGeometry ? L.gmxUtil.geometryToGeoJSON(origGeometry, true) : null;

            _this.removeLayer(newLayerProperties.name);

            _layersTree.addLayersToMap({
              content: {
                properties: newLayerProperties,
                geometry: origGeometry
              }
            });

            var parentProperties = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0].gmxProperties,
                li = _layersTree.getChildsList({
              type: 'layer',
              content: {
                properties: newLayerProperties,
                geometry: convertedGeometry
              }
            }, parentProperties, false, _layersTree.getLayerVisibility($(layerDiv).find('input[type="checkbox"]')[0] || $(layerDiv).find('input[type="radio"]')[0]));

            $(li).find('[multiStyle]').treeview();
            $(layerDiv.parentNode).replaceWith(li);
            _layersTree.findTreeElem($(li).children("div[LayerID]")[0]).elem = {
              type: 'layer',
              content: {
                properties: newLayerProperties,
                geometry: convertedGeometry
              }
            };

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);

            _layersTree.updateZIndexes();

            var checkedLayer = nsGmx$1.gmxMap.layersByID[newLayerProperties.name];

            if (checkedLayer) {
              L.gmx.layersVersion.chkVersion(checkedLayer);
            }
          } else {
            $('#' + taskInfo.TaskID).remove();
            layerDiv.style.display = '';
          }
        }).fail(function (taskInfo) {
          $('#' + taskInfo.TaskID).remove();
          layerDiv.style.display = '';
        }).progress(function (taskInfo) {
          var taskDiv;

          if (!$('#' + taskInfo.TaskID).length) {
            taskDiv = _div(null, [['attr', 'id', taskInfo.TaskID]]);
            layerDiv.style.display = 'none';
            $(layerDiv).before(taskDiv);
          } else {
            taskDiv = $('#' + taskInfo.TaskID)[0];
            $(taskDiv).empty();
          }

          _(taskDiv, [_span([_t(properties.Title + ':')], [['css', 'color', '#153069'], ['css', 'margin', '0px 3px']]), _t(taskInfo.Status)]);
        });
      };

      queryMapLayers.prototype.asyncCopyLayer = function (promise, title) {
        console.log('layer copied');

        var _this = this;

        var taskDiv = _div(),
            active = $(_this.buildedTree).find(".active")[0],
            parentDiv;

        if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID'))) parentDiv = active.parentNode.parentNode;else parentDiv = _this.buildedTree.firstChild;

        _abstractTree.addNode(parentDiv, _li([taskDiv, _div(null, [['css', 'height', '5px'], ['css', 'fontSize', '0px']])]));

        promise.fail(function () {
          console.log('failed');
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);
        }).done(function (taskInfo) {
          console.log('ok');

          if (!$.isArray(taskInfo.Result)) {
            taskInfo.Result = [taskInfo.Result];
          }

          var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
              parentProperties = parentDiv.gmxProperties;
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          for (var l = 0; l < taskInfo.Result.length; l++) {
            var newLayer = taskInfo.Result[l];
            var newProps = newLayer.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();

            newProps.mapName = mapProperties.name;
            newProps.hostName = mapProperties.hostName;
            newProps.visible = true;

            if (!newProps.styles) {
              if (newProps.type == 'Vector') newProps.styles = [{
                MinZoom: 1,
                MaxZoom: 21,
                RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType]
              }];else if (newProps.type != 'Vector' && !newProps.MultiLayerID) newProps.styles = [{
                MinZoom: newProps.MinZoom,
                MaxZoom: 21
              }];
            }

            var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

            _layersTree.addLayersToMap({
              content: {
                properties: newProps,
                geometry: newLayer.geometry
              }
            });

            var li = _layersTree.getChildsList({
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            }, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0]));

            _abstractTree.addNode(parentDiv.parentNode, li);

            var divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

            _layersTree.addTreeElem(divParent, 0, {
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            });

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);
          }

          _mapHelper.updateUnloadEvent(true);

          _layersTree.updateZIndexes();
        }).progress(function (taskInfo) {
          console.log('progress');
          $(taskDiv).empty();

          _(taskDiv, [_span([_t(title + ':')], [['css', 'color', '#153069'], ['css', 'margin', '0px 3px']]), _t(taskInfo.Status)]);
        }).always(function (taskInfo) {
          console.log(taskInfo);
        });
      };

      queryMapLayers.prototype.removeLayer = function (name) {
        var layer = nsGmx$1.gmxMap.layersByID[name];

        if (layer) {
          nsGmx$1.leafletMap.removeLayer(layer);
          nsGmx$1.gmxMap.removeLayer(layer);
        }
      };

      queryMapLayers.prototype.getLayers = function () {
        this.createLayersManager();
      };

      queryMapLayers.prototype.createLayersManager = function () {
        var canvas = _div();

        var layerManagerControl = new nsGmx$1.LayerManagerControl(canvas, 'layers');
        var existLayers = [];

        for (var i = 0; i < nsGmx$1.gmxMap.layers.length; i++) {
          existLayers.push(nsGmx$1.gmxMap.layers[i].getGmxProperties().name);
        }

        layerManagerControl.disableLayers(existLayers);
        showDialog(_gtxt("Список слоев"), canvas, 571, 485, 535, 130, function (size) {
          layerManagerControl.resize(size.height - 55);
        });
      };

      queryMapLayers.prototype.getMaps = function () {
        if (!$('#mapsList').length) new nsGmx$1.MapsManagerControl();
      };

      queryMapLayers.prototype.createMapDialog = function (title, buttonName, func, addLink) {
        var uiTemplate = Handlebars.compile('<div class = "createMap-container">' + '<input class = "inputStyle inputFullWidth createMap-input">' + '<button class = "createMap-button">{{buttonName}}</button>' + '</div>');
        var ui = $(uiTemplate({
          buttonName: buttonName
        })),
            input = $('.createMap-input', ui)[0];

        var tryCreateMap = function tryCreateMap() {
          input.focus();

          if (input.value != '') {
            removeDialog(dialogDiv);
            func(input.value);
          } else {
            inputError(input);
          }
        };

        $(input, ui).on('keydown', function (e) {
          if (e.keyCode === 13) {
            tryCreateMap();
            return false;
          }
        });
        $('.createMap-button', ui).click(tryCreateMap);
        addLink && ui.append(addLink);
        var dialogDiv = showDialog(title, ui[0], 280, 115 + (addLink ? 20 : 0), false, false);
      };

      queryMapLayers.prototype.createMap = function (name) {
        sendCrossDomainJSONRequest(window.serverBase + 'Map/Insert.ashx?WrapStyle=func&Title=' + encodeURIComponent(name), function (response) {
          if (!parseResponse(response)) return;
          window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + response.Result);
        });
      };

      (function () {
        var saveMapInternal = function saveMapInternal(scriptName, mapTitle, callback) {
          var mapID = String($(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.MapID),
              saveTree = {};
          window._mapEditorsHash && window._mapEditorsHash[mapID] && window._mapEditorsHash[mapID].update(); //обновим стили слоёв из всех незакрытых диалогов редактирования стилей

          var mStyleEditor = window.gmxCore.getModule('LayerStylesEditor');
          mStyleEditor && mStyleEditor.updateAllStyles();
          nsGmx$1.userObjectsManager.collect();
          $(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.UserData = JSON.stringify(nsGmx$1.userObjectsManager.getData());
          $.extend(true, saveTree, _layersTree.treeModel.getRawTree());
          var attributesToSave = ['visible', 'styles', 'AllowSearch', 'TiledQuicklook', 'TiledQuicklookMinZoom', 'name', 'MapStructureID'];
          saveTree.properties.BaseLayers = JSON.stringify(nsGmx$1.leafletMap.gmxBaseLayersManager.getActiveIDs()); //раскрываем все группы так, как записано в свойствах групп

          _mapHelper.findTreeElems(saveTree, function (child) {
            var props = child.content.properties;

            if (child.type === "group") {
              props.expanded = typeof props.initExpand !== 'undefined' ? props.initExpand : false;
              delete props.initVisible;
              delete props.initExpand;
            } else {
              var propsToSave = {};

              for (var i = 0; i < attributesToSave.length; i++) {
                var attrName = attributesToSave[i];

                if (attrName in props) {
                  propsToSave[attrName] = props[attrName];
                }
              }

              var styles = props.styles || [];

              for (var s = 0; s < styles.length; s++) {
                delete styles[s].HoverStyle;
              }

              if (window.newStyles) {
                var keys = L.gmx.StyleManager.DEFAULT_STYLE_KEYS,
                    stylesHash = {};

                for (var _i3 = 0; _i3 < keys.length; _i3++) {
                  stylesHash[keys[_i3]] = true;
                }

                propsToSave.gmxStyles = props.gmxStyles;

                for (var _s = 0; _s < propsToSave.gmxStyles.styles.length; _s++) {
                  var st = propsToSave.gmxStyles.styles[_s];
                  delete st.HoverStyle;

                  for (var key in st.RenderStyle) {
                    if (!(key in stylesHash)) {
                      delete st.RenderStyle[key];
                    }
                  }
                }
              }

              child.content.properties = propsToSave;
              delete child.content.geometry;
            }
          }, true);

          var params = {
            WrapStyle: 'window',
            MapID: mapID,
            MapJson: JSON.stringify(saveTree)
          };
          if (mapTitle) params.Title = mapTitle;
          sendCrossDomainPostRequest(window.serverBase + scriptName, params, function (response) {
            if (!parseResponse(response)) return;
            callback && callback(response.Result);

            _mapHelper.updateUnloadEvent(false);

            nsGmx$1.widgets.notifications.stopAction('saveMap', 'success', _gtxt("Сохранено"));
          });
        };

        queryMapLayers.prototype.saveMap = function () {
          nsGmx$1.widgets.notifications.startAction('saveMap');
          saveMapInternal("Map/SaveMap.ashx", null);
        };

        queryMapLayers.prototype.saveMapAs = function (name) {
          nsGmx$1.widgets.notifications.startAction('saveMap');
          saveMapInternal("Map/SaveAs.ashx", name);
        };
      })();

      var _queryMapLayers = new queryMapLayers();

      window._queryMapLayers = _queryMapLayers;

      mapLayers.mapLayers.load = function () {
        var alreadyLoaded = _queryMapLayers.createWorkCanvas('layers', {
          path: null,
          showCloseButton: false,
          showMinimizeButton: false
        });

        if (!alreadyLoaded) _queryMapLayers.load();
      };

      mapLayers.mapLayers.unload = function () {};
    })(nsGmx$1.Utils._);

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.AuthWidget = {};
    nsGmx$1.Templates.AuthWidget["authWidget"] = "{{#if userName}}\n" + "    <div class=\"authWidget_authorized\">\n" + "        <div class=\"authWidget-userPanel\">\n" + "            <div class=\"authWidget-userPanel-iconCell\">\n" + "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" + "            </div>\n" + "            <div class=\"authWidget-userPanel-userMenuCell\"></div>\n" + "        </div>\n" + "    </div>\n" + "{{else}}\n" + "\n" + "    <div class=\"authWidget_unauthorized\">\n" + "        <div class=\"authWidget-userPanel\">\n" + "            <div class=\"authWidget-userPanel-iconCell\">\n" + "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" + "            </div>\n" + "            <div class=\"authWidget-loginButton\">\n" + "                {{i 'auth.login'}}\n" + "            </div>\n" + "        </div>\n" + "    </div>\n" + "{{/if}}\n" + "";

    nsGmx$1.AuthWidget = function () {
      // options.loginDialog
      var AuthWidget = function AuthWidget(options) {
        this._view = $('<div>');

        this._view.addClass('authWidget ui-widget');

        this._authManager = options.authManager;
        this._userInfo = null;
        this._options = $.extend({
          showAccountLink: true,
          accountLink: 'http://my.kosmosnimki.ru/Home/Settings/',
          showMapLink: true,
          changePassword: false
          /* mapLink */

        }, options);

        this._authManager.getUserInfo().then(function (response) {
          this._render({
            login: response.Result && response.Result.Login,
            userName: response.Result && (response.Result.FullName || response.Result.Nickname || response.Result.Login)
          });

          this._userInfo = response.Result;
          $(this).trigger('ready');
        }.bind(this)).fail(function (response) {
          this._render(response);
        }.bind(this));
      };

      AuthWidget.prototype._render = function (vm) {
        this._view.html(Handlebars.compile(nsGmx$1.Templates.AuthWidget.authWidget)(vm));

        if (vm.userName) {
          var dropdownItems = [];

          if (this._options.showAccountLink) {
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('auth.myAccount'),
              link: this._options.accountLink,
              id: 'AuthWidgetAccountLink',
              newWindow: true
            });
          }

          if (this._options.showMapLink) {
            var defaultMapLink = 'http://maps.kosmosnimki.ru/api/index.html?' + encodeURIComponent('@' + vm.login);
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('auth.myMap'),
              link: this._options.mapLink || defaultMapLink,
              id: 'AuthWidgetMapLink',
              newWindow: true
            });
          }

          if (this._options.changePassword) {
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('auth.changePassword'),
              className: 'authWidget-changePasswordButton'
            });
          }

          if (this._options.isAdmin) {
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('Системные настройки'),
              link: window.serverBase + 'Administration/Actions.aspx',
              id: 'AuthWidgetAdminLink',
              newWindow: true
            });
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('Управление группами'),
              link: 'javascript:void(0)',
              className: 'authWidget-usergroupMenuItem'
            });
          }

          dropdownItems.push({
            title: nsGmx$1.Translations.getText('auth.logout'),
            className: 'authWidget-logoutButton'
          });
          var dropdownMenuWidget = new nsGmx$1.DropdownMenuWidget({
            items: [{
              title: vm.userName,
              dropdown: dropdownItems
            }]
          });
          dropdownMenuWidget.appendTo(this._view.find('.authWidget-userPanel-userMenuCell'));
        }

        this._view.find('.authWidget-usergroupMenuItem').click(function () {
          if (this._options.callbacks && 'authWidget-usergroupMenuItem' in this._options.callbacks) {
            this._options.callbacks['authWidget-usergroupMenuItem']();
          } else {
            return false;
          }
        }.bind(this));

        this._view.find('.authWidget-changePasswordButton').click(function () {
          var _native = this._authManager.getNative();

          _native.changePasswordDialog();
        }.bind(this));

        this._view.find('.authWidget-loginButton').click(function () {
          var $iframeContainer;

          if (this._options.loginDialog) {
            $iframeContainer = $('<div>').addClass('authWidget-iframeContainer');
            var dialog = $iframeContainer.dialog({
              width: 500,
              height: 450,
              closeText: nsGmx$1.Translations.getText('auth.closeDialog'),
              close: function close() {
                $(this).dialog('destroy');
              }
            }); // HACK:

            $(dialog).parent().find('button.ui-button').addClass('ui-icon').css('outline', 'none');
          }

          this._authManager.login({
            iframeContainer: $iframeContainer && $iframeContainer[0]
          });
        }.bind(this));

        this._view.find('.authWidget-logoutButton').click(function () {
          this._authManager.logout().then(function (response) {
            this._render(response);

            this._userInfo = response.Result;
            $(this).trigger('logout');
          }.bind(this));
        }.bind(this));
      };
      /** Получить информацию о пользователе, которую вернул AuthManager
       * @return {Object}
       */


      AuthWidget.prototype.getUserInfo = function () {
        return this._userInfo;
      };

      AuthWidget.prototype.on = function (eventName, callback) {
        $(this).on(eventName, callback);
      };

      AuthWidget.prototype.appendTo = function (placeholder) {
        placeholder.append(this._view);
      };

      return AuthWidget;
    }();

    nsGmx$1.Translations.addText('rus', {
      auth: {
        'login': 'Войти',
        'logout': 'Выйти',
        'myAccount': 'Личный кабинет',
        'changePassword': 'Сменить пароль',
        'myMap': 'Личная карта',
        'closeDialog': 'Закрыть'
      }
    });
    nsGmx$1.Translations.addText('eng', {
      auth: {
        'login': 'Login',
        'logout': 'Logout',
        'myAccount': 'My account',
        'changePassword': 'Change password',
        'myMap': 'My map',
        'closeDialog': 'Close'
      }
    });

    /** Виджет для визуализации информации о текущем статусе пользователя.
    * Показывает кнопки Вход/Выход, имя пользователя. Позволяет отослать логин/пароль на сервер, сменить пароль.
     @memberOf nsGmx
     @class
     @name GeoMixerAuthWidget
    */

    (function ($, _) {
      var _dialogCanvas = null;

      function changePasswordDialog() {
        if ($('#changePasswordCanvas').length) return;

        var oldInput = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '160px'], ['attr', 'type', 'password']]),
            newInput = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '160px'], ['attr', 'type', 'password']]),
            confirmInput = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '160px'], ['attr', 'type', 'password']]),
            changeButton = makeButton(_gtxt("Изменить")),
            canvas = _div([_div([_span([_t(_gtxt("Старый пароль"))]), _br(), oldInput, _br(), _span([_t(_gtxt("Новый пароль"))]), _br(), newInput, _br(), _span([_t(_gtxt("Подтвердите пароль"))]), _br(), confirmInput, _br()], [['css', 'textAlign', 'center']]), _div([changeButton], [['css', 'textAlign', 'center'], ['css', 'margin', '5px']])], [['attr', 'id', 'changePasswordCanvas']]),
            checkPassw = function checkPassw() {
          if (newInput.value != confirmInput.value) {
            newInput.value = '';
            confirmInput.value = '';
            inputError([newInput, confirmInput], 2000);
            newInput.focus();
            return;
          }

          nsGmx$1.widgets.notifications.startAction('changePassword');
          nsGmx$1.AuthManager.changePassword(oldInput.value, newInput.value, function () {
            jQuery(canvas.parentNode).dialog("destroy");
            canvas.parentNode.removeNode(true);
            nsGmx$1.widgets.notifications.stopAction('changePassword', 'success', _gtxt('Пароль изменён'));
          }, function (message) {
            message && showErrorMessage(message, true);
            nsGmx$1.widgets.notifications.stopAction('changePassword', 'failure');
          });
          oldInput.value = '';
          newInput.value = '';
          confirmInput.value = '';
        };

        showDialog(_gtxt("Изменение пароля"), canvas, 200, 200, false, false);
        canvas.parentNode.style.overflow = 'hidden';
        oldInput.focus();

        changeButton.onclick = function () {
          checkPassw();
        };

        $(confirmInput).on('keyup', function (e) {
          if (e.keyCode === 13) {
            checkPassw();
            return false;
          }

          return true;
        });
      }

      var loginDialogTemplate = '<div>' + '<div class = "loginMainDiv">' + '<form>' + '<div>' + '<span class="loginLabel">{{i "Логин"}}</span><br>' + '<input name="login" class = "inputStyle inputLogin" placeholder = "{{i "адрес электронной почты"}}"><br>' + '</div>' + '<div>' + '<span class="loginLabel">{{i "Пароль"}}</span><br>' + '<input name="password" class = "inputStyle inputPass" type = "password" placeholder = "{{i "пароль"}}"><br>' + '</div>' + '<button class="loginButton">{{i "Вход"}}</button>' + '</form>' + '</div>' + '{{#isMapsSite}}' + '<div class="loginLinks">' + '<span class = "buttonLink registration">{{i "Регистрация"}}</span><br>' + '<span class = "buttonLink passRecovery">{{i "Восстановление пароля"}}</span>' + '</div>' + '{{/isMapsSite}}' + '</div>';

      nsGmx$1.GeoMixerAuthWidget = function (container, authManager, loginCallback, options) {
        var _container = container;
        var _authManager = authManager;

        var _this = this;

        _this.changePasswordDialog = changePasswordDialog;
        options = options || {};

        var _createLogin = function _createLogin() {
          var span = makeLinkButton(_gtxt('Вход'));

          span.onclick = function () {
            _this.showLoginDialog(loginCallback);
          };

          _(_container, [_div([span], [['attr', 'id', 'log'], ['dir', 'className', 'log']])]);
        };

        var _createLogout = function _createLogout() {
          var logoutSpan = makeLinkButton(_gtxt('Выход'));

          logoutSpan.onclick = function () {
            _authManager.logout(function () {
              if (nsGmx$1.GeomixerFramework) _mapHelper.reloadMap();else window.location.replace(window.location.href.split("?")[0] + (window.defaultMapID == window.globalMapName ? "" : "&" + window.globalMapName));
            });
          };

          var userText = _authManager.getLogin();

          if (_authManager.getFullname() !== null && _authManager.getFullname() !== '') userText += ' (' + _authManager.getFullname() + ')';

          var userSpan = _span([_t(userText)], [['css', 'cursor', 'pointer']]);

          userSpan.onclick = function () {
            if (_authManager.isAccounts()) {
              if (window.gmxAuthServer) window.open(window.gmxAuthServer + "Account/ChangePassword", '_blank');
            } else changePasswordDialog();
          };

          if (_authManager.isAccounts()) $(userSpan).css('color', '#5555FF');

          _title(userSpan, _gtxt("Изменение пароля"));

          _(_container, [_table([_tr([_td([_div([userSpan], [['attr', 'id', 'user'], ['dir', 'className', 'user']])]), _td([_div([logoutSpan], [['attr', 'id', 'log'], ['dir', 'className', 'log']])])])])]);
        };

        var _update = function _update() {
          if (window.gmxViewerUI && window.gmxViewerUI.hideLogin) return;
          $(_container).empty();

          if (_authManager.isLogin()) {
            _createLogout();
          } else {
            _createLogin();
          }
        };

        $(_authManager).change(_update);

        _update(); //Показывает диалог с вводом логина/пароля, посылает запрос на сервер.


        this.showLoginDialog = function () {
          if (_dialogCanvas) {
            return;
          }

          var isMapsSite = !!window.mapsSite;
          var dialogHeight = isMapsSite ? 210 : 175;
          var canvas = $(Handlebars.compile(loginDialogTemplate)({
            isMapsSite: isMapsSite
          })),
              loginInput = canvas.find('.inputLogin')[0],
              passwordInput = canvas.find('.inputPass')[0],
              loginButton = canvas.find('.loginButton')[0];

          var checkLogin = function checkLogin() {
            _authManager.login(loginInput.value, passwordInput.value, function () {
              //всё хорошо
              $(jQueryDialog).dialog("destroy");
              jQueryDialog.removeNode(true);
              _dialogCanvas = null;
              loginCallback && loginCallback();
            }, function (err) {
              //ошибка
              if (err.emailWarning) {
                var errorDiv = $("<div/>", {
                  'class': 'EmailErrorMessage'
                }).text(err.message);
                $(loginButton).after(errorDiv);
                setTimeout(function () {
                  errorDiv.hide(500, function () {
                    errorDiv.remove();
                  });
                }, 8000);
              }

              loginInput.value = '';
              passwordInput.value = '';
              inputError([loginInput, passwordInput], 2000);
              loginInput.focus();
            });
          };

          _dialogCanvas = canvas;
          var jQueryDialog = showDialog(_gtxt("Пожалуйста, авторизуйтесь"), canvas[0], 248, dialogHeight, false, false, null, function () {
            _dialogCanvas = null;
          });
          loginInput.focus();
          loginButton.onclick = checkLogin;
          canvas.find('form').submit(function (e) {
            e.preventDefault();
          });
          canvas.find('.registration').click(options.registrationCallback || function () {
            window.open(window.gmxAuthServer + 'Account/Registration', '_blank');
          });
          canvas.find('.passRecovery').click(function () {
            window.open(window.gmxAuthServer + 'Account/Retrive', '_blank');
          });
          $(passwordInput).on('keyup', function (e) {
            if (e.keyCode === 13) {
              checkLogin();
              return false;
            }

            return true;
          });
        };

        this.getContainer = function () {
          return _container;
        };
      }; // Обратная совместимость. Проверка нужна из-за возможного конфликта с одноимённым классом из общих компонент


      if (!nsGmx$1.AuthWidget) {
        nsGmx$1.AuthWidget = nsGmx$1.GeoMixerAuthWidget;
      }
    })(jQuery, nsGmx$1.Utils._);

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var EventTarget = function () {
        function EventTarget() {
            classCallCheck(this, EventTarget);

            this.listeners = {};
        }

        createClass(EventTarget, [{
            key: 'addEventListener',
            value: function addEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(callback);
            }
        }, {
            key: 'on',
            value: function on(type, callback) {
                this.addEventListener(type, callback);
                return this;
            }
        }, {
            key: 'removeEventListener',
            value: function removeEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[type];
                for (var i = 0, l = stack.length; i < l; i++) {
                    if (stack[i] === callback) {
                        stack.splice(i, 1);
                        return this.removeEventListener(type, callback);
                    }
                }
            }
        }, {
            key: 'off',
            value: function off(type, callback) {
                this.removeEventListener(type, callback);
                return this;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(event) {
                if (!(event.type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[event.type];
                Object.defineProperty(event, 'target', {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: this
                });
                for (var i = 0, l = stack.length; i < l; i++) {
                    stack[i].call(this, event);
                }
            }
        }]);
        return EventTarget;
    }();

    var scanexEventTarget_cjs = EventTarget;

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var scanexObjectExtensions_cjs = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var copy = function copy(source) {
        switch (typeof source === 'undefined' ? 'undefined' : _typeof(source)) {
            case 'number':
            case 'string':
            case 'function':
            default:
                return source;
            case 'object':
                if (source === null) {
                    return null;
                } else if (Array.isArray(source)) {
                    return source.map(function (item) {
                        return copy(item);
                    });
                } else if (source instanceof Date) {
                    return source;
                } else {
                    return Object.keys(source).reduce(function (a, k) {
                        a[k] = copy(source[k]);
                        return a;
                    }, {});
                }
        }
    };

    var extend = function extend(target, source) {
        if (target === source) {
            return target;
        } else {
            return Object.keys(source).reduce(function (a, k) {
                var value = source[k];
                if (_typeof(a[k]) === 'object' && k in a) {
                    a[k] = extend(a[k], value);
                } else {
                    a[k] = copy(value);
                }
                return a;
            }, copy(target));
        }
    };

    exports.copy = copy;
    exports.extend = extend;
    //# sourceMappingURL=scanex-object-extensions.cjs.js.map
    });

    unwrapExports(scanexObjectExtensions_cjs);
    var scanexObjectExtensions_cjs_1 = scanexObjectExtensions_cjs.copy;
    var scanexObjectExtensions_cjs_2 = scanexObjectExtensions_cjs.extend;

    class IconSidebarWidget extends scanexEventTarget_cjs {
      constructor(container, options) {
        super();
        this._options = options;
        this._options.position = this._options.position || 'left';
        this._collapsedWidth = this._options.collapsedWidth || 40;
        this._extendedWidth = this._options.extendedWidth || 400;
        this._container = container;

        this._container.classList.add('iconSidebarControl');

        this._container.innerHTML = `<ul class="iconSidebarControl-tabs"></ul><div class="iconSidebarControl-content"></div>`;

        this._container.classList.add(this._options.position.indexOf('left') !== -1 ? 'iconSidebarControl-left' : 'iconSidebarControl-right');

        this._tabsContainer = this._container.querySelector('.iconSidebarControl-tabs');
        this._panesContainer = this._container.querySelector('.iconSidebarControl-content');
        this._onTabClick = this._onTabClick.bind(this);
        this._panes = {};
      }

      setPane(id, paneOptions) {
        paneOptions = paneOptions || {};
        let defaultPaneOptions = {
          position: 0,
          enabled: true
        };
        let activeTabId = this._activeTabId;
        this._panes[id] = scanexObjectExtensions_cjs_2(scanexObjectExtensions_cjs_2(scanexObjectExtensions_cjs_2({}, defaultPaneOptions), this._panes[id] || {}), paneOptions);

        if (!this._panes[id].enabled && this._activeTabId === id) {
          this.close();
        }

        this._renderTabs({
          activeTabId
        });

        return this._ensurePane(id);
      }

      enable(id, enabled) {
        let pane = this._panes[id];

        if (pane) {
          pane.enabled = enabled;
        }
      }

      enabled(id) {
        let pane = this._panes[id];

        if (pane) {
          return pane.enabled;
        } else {
          return false;
        }
      }

      open(paneId) {
        if (this._isAnimating) {
          return;
        }

        const pane = this._panes[paneId];

        if (!pane || !pane.enabled) {
          return;
        }

        this._activeTabId = paneId;

        this._setTabActive(paneId, true);

        this._setActiveClass(paneId);

        if (this._isOpened) {
          let event = document.createEvent('Event');
          event.initEvent('opened', false, false);
          event.detail = {
            id: this._activeTabId
          };
          this.dispatchEvent(event);
          return;
        }

        this._isAnimating = true;

        this._container.classList.add('iconSidebarControl_opened');

        this._container.classList.add('iconSidebarControl_expanded');

        this._isOpened = true;
        let event = document.createEvent('Event');
        event.initEvent('opening', false, false);
        this.dispatchEvent(event);
        setTimeout(() => {
          let ev = document.createEvent('Event');
          ev.initEvent('opened', false, false);
          ev.detail = {
            id: this._activeTabId
          };
          this.dispatchEvent(ev);
          this._isAnimating = false;
        }, 250);
      }

      _setTabActive(paneId, flag) {
        let tabs = this._tabsContainer.querySelectorAll('.iconSidebarControl-tab');

        for (let i = 0; i < tabs.length; ++i) {
          let id = tabs[i].getAttribute('data-tab-id');
          let tab = tabs[i].querySelector('.tab-icon');

          if (id === paneId) {
            if (flag) {
              tab.classList.add('tab-icon-active');
            } else {
              tab.classList.remove('tab-icon-active');
            }
          } else {
            tab.classList.remove('tab-icon-active');
          }
        }
      }

      close() {
        if (this._isAnimating) {
          return;
        }

        this._setTabActive(this._activeTabId, false);

        this._container.classList.remove('iconSidebarControl_opened');

        this._isAnimating = true;
        this._isOpened = false;
        let event = document.createEvent('Event');
        event.initEvent('closing', false, false);
        this.dispatchEvent(event);
        setTimeout(() => {
          this._container.classList.remove('iconSidebarControl_expanded');

          let ev = document.createEvent('Event');
          ev.detail = {
            id: this._activeTabId
          };
          ev.initEvent('closed', false, false);
          this.dispatchEvent(ev);
          this._isAnimating = false;

          this._setActiveClass('');

          this._activeTabId = null;
        }, 250);
      }

      getWidth() {
        if (this._isOpened) {
          return this._extendedWidth;
        } else {
          return this._collapsedWidth;
        }
      }

      getActiveTabId() {
        return this._activeTabId;
      }

      isOpened() {
        return this._isOpened;
      }

      _ensurePane(id) {
        for (let i = 0; i < this._panesContainer.childNodes.length; ++i) {
          let node = this._panesContainer.childNodes[i];

          if (node.getAttribute('data-pane-id') === id) {
            return node;
          }
        }

        let paneEl = document.createElement('div');
        paneEl.classList.add('iconSidebarControl-pane');
        paneEl.setAttribute('data-pane-id', id);

        this._panesContainer.appendChild(paneEl);

        return paneEl;
      }

      _setActiveClass(activeId) {
        for (let i = 0; i < this._panesContainer.children.length; i++) {
          let id = this._panesContainer.children[i].getAttribute('data-pane-id');

          let pane = this._panesContainer.querySelector('[data-pane-id=' + id + ']');

          if (id === activeId) {
            pane.classList.add('iconSidebarControl-pane-active');
          } else {
            pane.classList.remove('iconSidebarControl-pane-active');
          }
        }
      }

      _onTabClick(e) {
        let tabId = e.currentTarget.getAttribute('data-tab-id');
        let pane = this._panes[tabId];

        if (!pane || !pane.enabled) {
          return;
        }

        if (!this._isOpened || this._activeTabId !== tabId) {
          this._renderTabs({
            activeTabId: tabId
          });

          this.open(tabId);
        } else {
          this._renderTabs({});

          this.close();
        }
      }

      _renderTabs(options) {
        const getFlag = (tabId, activeTabId, hoveredTabId, enabled) => {
          if (!enabled) {
            return 'disabled';
          } else if (hoveredTabId && tabId === hoveredTabId) {
            return 'hover';
          } else if (activeTabId && tabId === activeTabId) {
            return 'active';
          } else {
            return 'default';
          }
        };

        let activeTabId = options.activeTabId;
        let hoveredTabId = options.hoveredTabId;
        this._tabsContainer.innerHTML = '';
        Object.keys(this._panes).map(id => scanexObjectExtensions_cjs_2({
          id
        }, this._panes[id])).sort((a, b) => a.position - b.position).forEach(options => {
          const {
            id,
            createTab,
            enabled
          } = options;

          if (!createTab) {
            return;
          }

          let tabContainerEl = document.createElement('li');
          tabContainerEl.classList.add('iconSidebarControl-tab');
          tabContainerEl.setAttribute('data-tab-id', id);
          let tabEl = createTab(getFlag(id, activeTabId, hoveredTabId, enabled));
          tabContainerEl.addEventListener('click', this._onTabClick);
          tabContainerEl.appendChild(tabEl);

          this._tabsContainer.appendChild(tabContainerEl);
        });
      }

    }

    /** Узел дерева слоёв
     * @typedef nsGmx.LayersTree~Node
     * @property {String} type тип узла (`layer` или `group`)
     * @property {Object} content содержимое узла
     * @property {Object} [content.properties] свойства узла
     * @property {Object} [content.children] потомки узла
    */

    /** Результат поиска узла в дереве слоёв
     * @typedef nsGmx.LayersTree~SearchResult
     * @property {nsGmx.LayersTree~Node} elem Найденный элемент
     * @property {nsGmx.LayersTree~Node[]} parents Массив родителей. Самый последний элемент массива - сама карта
     * @property {Number} index Индекс найденного элемента в своей группе
    */

    /** Visitor при обходе слоёв дерева
     * @callback nsGmx.LayersTree~LayerVisitor
     * @param {Object} layerContent Содержимое узла слоя
     * @param {Boolean} isVisible Видимость слоя с учётом видимости всех родителей
     * @param {Number} nodeDepth Глубина слоя в дереве (начинается с 0)
    */

    /** Visitor при обходе узлов дерева слоёв
     * @callback nsGmx.LayersTree~NodeVisitor
     * @param {nsGmx.LayersTree~Node} node Свойства узла
     * @param {Boolean} isVisible Видимость узла с учётом видимости всех родителей
     * @param {Number} nodeDepth Глубина узла в дереве (начинается с 0)
    */

    /** Класс для работы с деревом слоёв
     * @class
     * @param {Object} tree Дерево слоёв в формате сервера
    */

    nsGmx$1.LayersTree = function (tree) {
      /** Изменилась видимость узла дерева. Если изменения касаются нескольких узлов, событие будет 
          генерироваться для каждого узла по отдельности. Кроме того, это же событие генерируется 
          на отдельных узлах дерева.
       * @event nsGmx.LayersTree#nodeVisibilityChange
       * @param {nsGmx.LayersTree~Node} node Узел, видимость которой изменилась
       */
      var _tree = tree;

      var _this = this;

      var _findElem = function _findElem(elem, propName, propValue, parents) {
        var childs = typeof elem.children != 'undefined' ? elem.children : elem.content.children;

        for (var i = 0; i < childs.length; i++) {
          var props = childs[i].content.properties;

          if (propName in props && props[propName] === propValue) {
            return {
              elem: childs[i],
              parents: [elem].concat(parents || []),
              index: i
            };
          }

          if (typeof childs[i].content.children != 'undefined') {
            var res = _findElem(childs[i], propName, propValue, [elem].concat(parents || []));

            if (res) return res;
          }
        }
      };
      /** Получить исходное дерево слоёв
      */


      this.getRawTree = function () {
        return _tree;
      };
      /** Получить свойства карты
      */


      this.getMapProperties = function () {
        return _tree.properties;
      };
      /** Поиск узла дерева по значению одного из атрибутов. Ищет как папки, так и слои. Возвращает первый найденный результат
       * @param {String} propName Имя атрибута
       * @param {String} propValue Значение атрибута
       * @return {nsGmx.LayersTree~SearchResult} Результат поиска. undefined если ничего не найденно
      */


      this.findElem = function (propName, propValue) {
        return _findElem(_tree, propName, propValue);
      };

      this.findElemByGmxProperties = function (gmxProperties) {
        if (gmxProperties.type == 'group') //группа
          return this.findElem("GroupID", gmxProperties.content.properties.GroupID);else return this.findElem("name", gmxProperties.content.properties.name);
      };
      /** Итерирование по всем слоям группы дерева
       * @param {nsGmx.LayersTree~LayerVisitor} callback Будет вызвана для каждого слоя внутри группы. Первый аргумент - свойства слоя, второй - видимость слоя
       * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
       */


      this.forEachLayer = function (callback, groupNode) {
        this.forEachNode(function (node, isVisible, nodeDepth) {
          if (node.type === 'layer') {
            callback(node.content, isVisible, nodeDepth);
          }
        }, groupNode);
      };
      /** Итерирование по всем под-узлам узла дерева
       * @param {nsGmx.LayersTree~NodeVisitor} callback Будет вызвана для каждого узла внутри группы. Первый аргумент - узел, второй - видимость узла
       * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
       */


      this.forEachNode = function (callback, groupNode) {
        var forEachNodeRec = function forEachNodeRec(o, isVisible, nodeDepth) {
          isVisible = isVisible && !!o.content.properties.visible;
          callback(o, isVisible, nodeDepth);

          if (o.type === 'group') {
            var a = o.content.children;

            for (var k = a.length - 1; k >= 0; k--) {
              forEachNodeRec(a[k], isVisible, nodeDepth + 1);
            }
          }
        };

        var layers = groupNode ? groupNode.content : _tree;

        for (var k = layers.children.length - 1; k >= 0; k--) {
          forEachNodeRec(layers.children[k], true, 0);
        }
      };
      /** Клонирование дерева с возможностью его модификации
       * @param {function(node):nsGmx.LayersTree~Node|null} filterFunc - ф-ция, которая может модифицировать узлы дерева. 
                  Вызывается при клонировании очередного узла. Изменения данных можно делать in-place.
                  Для групп вызывается после обработки всех потомков. Если возвращает null, то узел удаляется
       */


      this.cloneRawTree = function (filterFunc) {
        filterFunc = filterFunc || function (node) {
          return node;
        };

        var forEachLayerRec = function forEachLayerRec(o) {
          if (o.type == "layer") {
            return filterFunc($.extend(true, {}, o));
          } else if (o.type == "group") {
            var a = o.content.children;
            var newChildren = [];

            for (var k = 0; k < a.length; k++) {
              var newNode = forEachLayerRec(a[k]);
              newNode && newChildren.push(newNode);
            }

            return filterFunc({
              type: 'group',
              content: {
                children: newChildren,
                properties: $.extend(true, {}, o.content.properties)
              }
            });
          }
        };

        var newFirstLevelGroups = [];

        for (var k = 0; k < _tree.children.length; k++) {
          var newNode = forEachLayerRec(_tree.children[k]);
          newNode && newFirstLevelGroups.push(newNode);
        }

        return {
          properties: $.extend(true, {}, _tree.properties),
          children: newFirstLevelGroups
        };
      }; //Методы управления видимостью слоёв в дереве
      //проходится по всему поддереву elem и устанавливает видимость isVisible всем узлам включая elem (учитывая ограничения на radio buttons)


      var setSubtreeVisibility = function setSubtreeVisibility(elem, isVisible) {
        var props = elem.content.properties;

        if (props.visible != isVisible) {
          props.visible = isVisible;
          $(_this).triggerHandler('nodeVisibilityChange', [elem]);
          $(elem).triggerHandler('nodeVisibilityChange', [elem]);

          if (elem.content.children) {
            for (var c = 0; c < elem.content.children.length; c++) {
              var vis = isVisible && (!props.list || c == 0); //когда делаем видимой группу-список, виден только первый элемент группы

              setSubtreeVisibility(elem.content.children[c], vis);
            }
          }
        }
      };
      /** Устанавливает видимость узла дерева и всех родительских элементов данного узла в зависимости от видимости его прямых потомков. Узел должен быть группой.
       * При этом разруливаются конфликты с несколькими видимыми узлами в radio-группах.
       * @param {nsGmx.LayersTree~Node} node Узел дерева, видимость которого нужно обновить
       * @param {nsGmx.LayersTree~Node} triggerSubnode один их прямых потомков node, состояние которого должно остаться неизменным (важно для разруливания конфликтов в radio-групп)
       * @param {nsGmx.LayersTree~Node[]} [parents] массив всех родителей, опционально
       */


      this.updateNodeVisibility = function (elem, triggerSubnode, parents) {
        var props = elem.content.properties,
            isList = props.list,
            children = elem.content.children,
            triggerNodeVisible = triggerSubnode ? triggerSubnode.content.properties.visible : false,
            visibleNode = triggerNodeVisible ? triggerSubnode : null;
        var isVisible = false;

        for (var c = 0; c < children.length; c++) {
          var child = children[c];
          var childVisible = child.content.properties.visible;
          isVisible = isVisible || childVisible;

          if (childVisible && !visibleNode) {
            visibleNode = child;
          }

          if (isList && childVisible && child !== visibleNode) {
            setSubtreeVisibility(child, false);
          }
        }

        if (isVisible !== props.visible) {
          props.visible = isVisible;
          $(this).triggerHandler('nodeVisibilityChange', [elem]);
          $(elem).triggerHandler('nodeVisibilityChange', [elem]);

          if (!parents) {
            parents = this.findElemByGmxProperties(elem).parents;
            parents.pop(); //последний элемент - карта; нас не интересует
          }

          var parent = parents.shift();
          parent && this.updateNodeVisibility(parent, elem, parents);
        }
      };
      /** Задать видимость узла дерева. Будут сделаны все нужные изменения видимости как выше, 
       * так и ниже по дереву относительно этого узла.
       * @param {nsGmx.LayersTree~Node} node Узел дерева, которому мы хотим задать видимость
       * @param {Boolean} isVisible Видимость узла (true - виден)
       */


      this.setNodeVisibility = function (node, isVisible) {
        if (node.content.properties.visible != isVisible) {
          //устанавливаем видимость поддерева, которое начинается с этого элемента
          setSubtreeVisibility(node, isVisible); //идём вверх по дереву до корня и меняем видимость родителей

          var parentElem = _this.findElemByGmxProperties(node).parents[0];

          parentElem && parentElem.content && this.updateNodeVisibility(parentElem, node);
        }
      };
    };

    $('#flash').droppable({
      drop: function drop(event, ui) {
        var obj = ui.draggable[0].gmxDrawingObject;

        if (obj) {
          var text = Functions.GetFullName(obj.TypeName, obj.ObjName);
          nsGmx$1.leafletMap.gmxDrawing.addGeoJSON({
            type: 'Feature',
            geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry)
          }, {
            text: text
          });
        }
      }
    });

    window._translationsHash.addtext("rus", {
      "Текущее местоположение отображается только для России и Украины": "Текущее местоположение отображается только для России и Украины",
      "Следующие [value0] страниц": "Следующие [value0] страниц",
      "Следующие [value0] страницы": "Следующие [value0] страницы",
      "Следующая страница": "Следующая страница",
      "Следующая [value0] страница": "Следующая [value0] страница",
      "Предыдущие [value0] страниц": "Предыдущие [value0] страниц",
      "Первая страница": "Первая страница",
      "Последняя страница": "Последняя страница"
    });

    window._translationsHash.addtext("eng", {
      "Текущее местоположение отображается только для России и Украины": "Current location is shown only for Russia and Ukraine",
      "Следующие [value0] страниц": "Next [value0] pages",
      "Следующие [value0] страницы": "Next [value0] pages",
      "Следующая страница": "Next page",
      "Следующая [value0] страница": "Next [value0] pages",
      "Предыдущие [value0] страниц": "Previous [value0] pages",
      "Первая страница": "First page",
      "Последняя страница": "Last page"
    });

    var imagesHost = "img";
    /** Вспомогательные функции
     @namespace Functions
     @memberOf Search
    */

    var Functions = {
      /** Возвращает полное наименование объекта, состоящее из типа и наименования
       @static
       @param sType Наименование типа объекта
       @param sName Наименование объекта
         */
      GetFullName: function GetFullName(
      /** string */
      sType,
      /** string */
      sName) {
        var sFullName = "";
        if (sType == null || sType == "государство" || sType == "г." || /[a-zA-Z]/.test(sName)) sFullName = sName;else if (sType.indexOf("район") != -1 || sType.indexOf("область") != -1 || sType.indexOf("край") != -1) sFullName = sName + " " + sType;else sFullName = sType + " " + sName;
        return sFullName;
      },

      /** Возвращает полный путь к объекту
         * @memberOf Search.Functions
         *
      * @param oFoundObject найденный объект
      * @param sObjectsSeparator разделитель между дочерним элементом и родителем в строке пути
      * @param bParentAfter признак того, что родительский элемент идет после дочернего
      * @param sObjNameField название свойства, из которого брать наименование
         */
      GetPath: function GetPath(
      /*object*/
      oFoundObject,
      /* string */
      sObjectsSeparator,
      /* bool */
      bParentAfter,
      /* string */
      sObjNameField) {
        if (sObjNameField == null) sObjNameField = "ObjName";
        if (oFoundObject == null) return "";
        var oParentObj = oFoundObject.Parent;

        if (oParentObj != null && (oParentObj.ObjName == "Российская Федерация" || oParentObj.TypeName == "административный округ")) {
          oParentObj = oParentObj.Parent;
        }

        var sObjectName = oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183 ? oFoundObject[sObjNameField] : this.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);

        if (oParentObj != null && oParentObj[sObjNameField] != null && oParentObj[sObjNameField]) {
          if (bParentAfter) {
            return sObjectName + sObjectsSeparator + this.GetPath(oParentObj, sObjectsSeparator, bParentAfter, sObjNameField);
          } else {
            return this.GetPath(oParentObj, sObjectsSeparator, bParentAfter, sObjNameField) + sObjectsSeparator + sObjectName;
          }
        } else {
          return sObjectName;
        }
      },

      /** Возвращает строку, соединяющую переданные свойства
       @static
       @param oProps - Свойства
       @param sObjectsSeparator Разделитель 2х свойств в строке*/
      GetPropertiesString: function GetPropertiesString(
      /**object[]*/
      oProps,
      /**string*/
      sPropSeparator) {
        var sResultString = "";

        if (oProps != null) {
          for (var sPropName in oProps) {
            if (sResultString != "") sResultString += sPropSeparator;
            sResultString += sPropName + ": " + oProps[sPropName];
          }
        }

        return sResultString;
      }
      /** Конструктор
       @class Предоставляет функции, отображающие найденные объекты на карте
       @memberof Search
       @param {L.Map} map карта, на которой будут рисоваться объекты
       @param {string} sInitImagesHost - строка пути к картинкам
       @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту*/

    };

    var ResultRenderer = function ResultRenderer(map, sInitImagesHost, bInitAutoCenter) {
      if (map == null) throw "ResultRenderer.Map is null";
      var sImagesHost = sInitImagesHost || "http://maps.kosmosnimki.ru/api/img";
      var bAutoCenter = bInitAutoCenter == null || bInitAutoCenter;
      this.arrContainer = [];
      var counts = [];
      /** возвращает стили найденных объектов, используется только для точки*/

      var getSearchIcon = function getSearchIcon(iPosition) {
        iPosition = Math.min(iPosition, 9);
        return L.icon({
          iconUrl: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png",
          iconAnchor: [15, 38],
          popupAnchor: [0, -28]
        }); // return [
        // { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png", dx: -14, dy: -38} },
        // { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + "a.png", dx: -14, dy: -38} }
        // ];
      };

      var bindHoverPopup = function bindHoverPopup(layer, content) {
        layer.bindPopup(content);
      };
      /**Помещает объект на карту
      @param {MapObject} oContainer контейнер, содержащий в себе объекты текущей группы результатов поиска
      @param {MapObject} oFoundObject добавляемый объект
      @param {int} iPosition порядковый номер добавляемого объекта в группе
      @param {int} iCount общее количество объектов в группе
         @return {Object} Нарисованные на карте объекты: хеш с полями center и boundary */


      var DrawObject = function DrawObject(oContainer, oFoundObject, iPosition, iCount) {
        var color = Math.round(0x22 + 0x99 * iPosition / iCount);
        var sDescr = "<b>" + Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName) + "</b><br/>" + Functions.GetPath(oFoundObject.Parent, "<br/>", true);
        if (oFoundObject.properties != null) sDescr += "<br/>" + Functions.GetPropertiesString(oFoundObject.properties, "<br/>");
        sDescr = sDescr.replace(/;/g, "<br/>"); // var fnBaloon = function(o) {
        // 	return o.properties.Descr.replace(/;/g, "<br/>");
        // };

        var centerMapElem, boundaryMapElem; //Рисуем центр объекта

        if (oFoundObject.Geometry != null && oFoundObject.Geometry.type.toUpperCase() == 'POINT') {
          centerMapElem = L.marker([oFoundObject.Geometry.coordinates[1], oFoundObject.Geometry.coordinates[0]], {
            icon: getSearchIcon(iPosition)
          });
          bindHoverPopup(centerMapElem, sDescr);
          oContainer.addLayer(centerMapElem);
        } else if (oFoundObject.CntrLon != null && oFoundObject.CntrLat != null) {
          centerMapElem = L.marker([oFoundObject.CntrLat, oFoundObject.CntrLon], {
            icon: getSearchIcon(iPosition)
          });
          bindHoverPopup(centerMapElem, sDescr);
          oContainer.addLayer(centerMapElem);
        } //Рисуем контур объекта


        if (oFoundObject.Geometry != null && oFoundObject.Geometry.type.toUpperCase() != 'POINT') {
          boundaryMapElem = L.geoJson(L.gmxUtil.geometryToGeoJSON(oFoundObject.Geometry), {
            style: function style() {
              return;
            },
            onEachFeature: function onEachFeature(feature, layer) {
              layer.setStyle({
                color: '#' + (0x1000000 + (color << 16) + (color << 8) + color).toString(16).substr(-6),
                weight: 3,
                opacity: 0.6,
                fill: false
              });
              bindHoverPopup(layer, sDescr);
            }
          });
          oContainer.addLayer(boundaryMapElem);
        }

        return {
          center: centerMapElem,
          boundary: boundaryMapElem
        };
      };
      /**Центрует карту по переданному объекту*/


      var CenterObject = function CenterObject(oFoundObject) {
        if (!oFoundObject) return;
        var iZoom = oFoundObject.TypeName == "г." ? 9 : 15;

        if (oFoundObject.Geometry == null) {
          if (oFoundObject.MinLon != null && oFoundObject.MaxLon != null && oFoundObject.MinLat != null && oFoundObject.MaxLat != null && oFoundObject.MaxLon - oFoundObject.MinLon < 1e-9 && oFoundObject.MaxLat - oFoundObject.MinLat < 1e-9) map.setView([oFoundObject.CntrLat, oFoundObject.CntrLon], iZoom);else map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
        } else if (oFoundObject.Geometry.type.toUpperCase() == 'POINT') {
          if (oFoundObject.MinLon != oFoundObject.MaxLon && oFoundObject.MinLat != oFoundObject.MaxLat) {
            map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
          } else {
            var c = oFoundObject.Geometry.coordinates;
            map.setView([c[1], c[0]], iZoom);
          }
        } else {
          var bounds = L.gmxUtil.getGeometryBounds(oFoundObject.Geometry); //var oExtent = getBounds(oFoundObject.Geometry.coordinates);

          map.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
        }
      };
      /**Центрует карту по переданному объекту
      @param {MapObject} oFoundObject объект, который нужно поместить в центр
      @returns {void}*/


      this.CenterObject = function (oFoundObject) {
        CenterObject(oFoundObject);
      };
      /** Рисует объекты на карте.
      @param {int} iDataSourceN № источника данных (группы результатов поиска)
      @param {Array} arrFoundObjects Массив объектов для отрисовки. Каждый объект имеет свойства
      @param {bool} [options.append=false] Добавить к существующим объектам для источника данных, а не удалять их
      @return {Array} Нарисованные на карте объекты: массив хешей с полями center и boundary
         */


      this.DrawObjects = function (iDataSourceN, arrFoundObjects, options) {
        options = $.extend({
          append: false
        }, options);

        if (!options.append && this.arrContainer[iDataSourceN]) {
          map.removeLayer(this.arrContainer[iDataSourceN]);
          delete this.arrContainer[iDataSourceN];
        }

        if (!this.arrContainer[iDataSourceN]) {
          this.arrContainer[iDataSourceN] = L.layerGroup();
          counts[iDataSourceN] = 0;
        } // iCount = arrFoundObjects.length;


        var mapObjects = [];
        counts[iDataSourceN] += arrFoundObjects.length; //Отрисовываем задом наперед, чтобы номер 1 был сверху от 10ого

        for (var i = arrFoundObjects.length - 1; i >= 0; i--) {
          mapObjects.unshift(DrawObject(this.arrContainer[iDataSourceN], arrFoundObjects[i], counts[iDataSourceN] + i - arrFoundObjects.length, counts[iDataSourceN]));
        }

        this.arrContainer[iDataSourceN].addTo(map);
        if (bAutoCenter && iDataSourceN == 0) CenterObject(arrFoundObjects[0]);
        return mapObjects;
      };
    }; // /** Конструктор
    //  @class Предоставляет функции, отображающие найденные объекты на карте
    //  @memberof Search
    //  @param {object} oInitMap карта, на которой будут рисоваться объекты
    //  @param {function} fnSearchLocation = function({Geometry, callback})- функция поиска объектов по переданной геометрии*/
    // var LocationTitleRenderer = function(oInitMap, fnSearchLocation){
    // 	var _this = this;
    // 	var oMap = oInitMap;
    // 	var dtLastSearch;
    // 	/**Добавляет объект в список найденных результатов*/
    // 	var drawObject = function(oFoundObject, elemDiv)
    // 	{
    // 		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
    // 		var	realPath = oFoundObject.IsForeign ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
    // 		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', 'searchLocationPath']]);
    // 		/** Вызывается при клике на найденный объект в списке результатов поиска
    // 		@name Search.ResultList.onObjectClick
    // 		@event
    // 		@param {object} oFoundObject Найденный объект*/
    // 		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};
    // 		if (oFoundObject.Parent != null) _(elemDiv, [_t("->")]);
    // 		_(elemDiv, [searchElemHeader]);
    // 	}
    // 	var setLocationTitleDiv = function(div, attr) {
    // 		if (dtLastSearch && Number(new Date()) - dtLastSearch < 300) return;
    // 		dtLastSearch = new Date();
    // 		var locationTitleDiv = div;
    // 		fnSearchLocation({Geometry: attr['screenGeometry'], callback: function(arrResultDataSources){
    // 			$(locationTitleDiv).empty();
    // 			if (arrResultDataSources.length>0 && arrResultDataSources[0].SearchResult.length>0){
    // 				drawObject(arrResultDataSources[0].SearchResult[0], locationTitleDiv);
    // 			}
    // 			else {
    // 				_(locationTitleDiv, [_t(_gtxt("Текущее местоположение отображается только для России и Украины"))]);
    // 			}
    // 		}});
    // 	};
    // 	if (oMap.coordinates) oMap.coordinates.addCoordinatesFormat(setLocationTitleDiv);
    // }


    var ResultList = function ResultList(oInitContainer, oRenderer, ImagesHost) {
      /**Объект, в котором находится контрол (div)*/
      // создается в начале searchLogic.showResult
      var Container = oInitContainer;

      var _this = this;

      var sImagesHost = ImagesHost || "http://maps.kosmosnimki.ru/api/img";
      var arrDisplayedObjects = []; //Объекты, которые отображаются на текущей странице

      var iLimit = 10; //Максимальное количество результатов на странице

      var iPagesCount = 7; //Количество прокручиваемых страниц при нажатии на двойные стрелки

      if (Container == null) throw "ResultList.Container is null";
      var oResultCanvas;
      var arrTotalResultSet = [];

      if (oResultCanvas == null) {
        oResultCanvas = nsGmx$1.Utils._div(null, [['dir', 'className', 'searchResultCanvas']]);
        Container.appendChild(oResultCanvas);
      }

      var oLoading = nsGmx$1.Utils._div([_img(null, [['attr', 'src', sImagesHost + '/progress.gif'], ['dir', 'className', 'searchResultListLoadingImg']]), _t(_gtxt("загрузка..."))], [['dir', 'className', 'searchResultListLoading']]);

      var fnNotFound = function fnNotFound() {
        nsGmx$1.Utils._(oResultCanvas, [nsGmx$1.Utils._div([_t(_gtxt("Поиск не дал результатов"))], [['dir', 'className', 'SearchResultListNotFound']])]);
      };
      /**Удаляет все найденные объекты из результатов поиска*/


      var unload = function unload() {
        for (var i = 0; i < arrDisplayedObjects.length; i++) {
          SetDisplayedObjects(i, []);
        }

        $(oResultCanvas).empty();
      }; // /** Переход на следующие страницы*/
      // var next = function(iDataSourceN, divChilds, divPages) {
      //     var button = makeImageButton(sImagesHost + '/next.png', sImagesHost + '/next_a.png');
      //     button.style.marginBottom = '-7px';
      //     button.onclick = function() {
      // 		var oDataSource = arrTotalResultSet[iDataSourceN];
      //         oDataSource.start += iPagesCount;
      //         oDataSource.reportStart = oDataSource.start * iLimit;
      //         drawPagesRow(iDataSourceN, divChilds, divPages);
      //     }
      //     _title(button, _gtxt('Следующие [value0] страниц', iPagesCount));
      //     return button;
      // }

      /** Переход на предыдущие страницы*/


      var previous = function previous(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/prev.png', sImagesHost + '/prev_a.png');
        button.style.marginBottom = '-7px';

        button.onclick = function () {
          var oDataSource = arrTotalResultSet[iDataSourceN];
          oDataSource.start -= iPagesCount;
          oDataSource.reportStart = oDataSource.start * iLimit;
          drawPagesRow(iDataSourceN, divChilds, divPages);
        };

        _title(button, _gtxt('Предыдущие [value0] страниц', iPagesCount));

        return button;
      };
      /** Переход на первую страницу*/


      var first = function first(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/first.png', sImagesHost + '/first_a.png');
        button.style.marginBottom = '-7px';

        button.onclick = function () {
          var oDataSource = arrTotalResultSet[iDataSourceN];
          oDataSource.start = 0;
          oDataSource.reportStart = oDataSource.start * iLimit;
          drawPagesRow(iDataSourceN, divChilds, divPages);
        };

        _title(button, _gtxt('Первая страница'));

        return button;
      }; // /** Переход на последнюю страницу*/
      // var last = function(iDataSourceN, divChilds, divPages) {
      //     var _this = this,
      // 		button = makeImageButton(sImagesHost + '/last.png', sImagesHost + '/last_a.png');
      //     button.style.marginBottom = '-7px';
      //     button.onclick = function() {
      // 		var oDataSource = arrTotalResultSet[iDataSourceN];
      //         oDataSource.start = Math.floor((oDataSource.SearchResult.length - 1)/ (iPagesCount * iLimit)) * iPagesCount;
      //         oDataSource.reportStart = Math.floor((oDataSource.SearchResult.length - 1)/ (iLimit)) * iLimit;
      //         drawPagesRow(iDataSourceN, divChilds, divPages);
      //     }
      //     _title(button, _gtxt('Последняя страница'));
      //     return button;
      // }

      /**Добавляет объект в список найденных результатов*/


      var drawObject = function drawObject(oFoundObject, elemDiv, bIsParent) {
        var realPath = oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183 ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
        if (oFoundObject.Parent != null) realPath += ",";

        var searchElemHeader = _span([_t(realPath)], [['dir', 'className', bIsParent ? 'searchElemParent' : 'searchElem']]);
        /** Вызывается при клике на найденный объект в списке результатов поиска
        @name Search.ResultList.onObjectClick
        @event
        @param {object} oFoundObject Найденный объект*/


        searchElemHeader.onclick = function () {
          $(_this).triggerHandler('onObjectClick', [oFoundObject]);
        };

        nsGmx$1.Utils._(elemDiv, [searchElemHeader]);

        if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
        if (oFoundObject.properties != null) nsGmx$1.Utils._(elemDiv, [document.createTextNode(" " + Functions.GetPropertiesString(oFoundObject.properties, "; "))]);
      };
      /** Рисует строки списка*/


      var drawRows = function drawRows(iDataSourceN, divChilds) {
        var arrObjects = arrDisplayedObjects[iDataSourceN];
        $(divChilds).empty();

        var tbody = _tbody();

        for (var i = 0; i < arrObjects.length; i++) {
          var elemTR = _tr(null, [['dir', 'className', 'SearchResultRow']]);

          var elemTD = _td(null, [['dir', 'className', 'SearchResultText']]);

          nsGmx$1.Utils._(elemTR, [_td([_t((i + 1).toString() + ".")], [['dir', 'className', 'searchElemPosition']]), elemTD]);

          drawObject(arrObjects[i], elemTD); // загрузка SHP Файла

          if (window.gmxGeoCodeShpDownload && arrObjects[i].Geometry != null) {
            var shpFileLink = _span([_t(".shp")], [['dir', 'className', 'searchElem'], ['attr', 'title', 'скачать SHP-файл'], ['attr', 'number', i]]);

            shpFileLink.onclick = function () {
              var obj = arrObjects[$(this).attr('number')];
              var objsToDownload = [obj];
              $(_this).triggerHandler('onDownloadSHP', [obj.ObjCode, objsToDownload]);
            };

            nsGmx$1.Utils._(elemTD, [_t(" ")]);

            nsGmx$1.Utils._(elemTD, [shpFileLink]);
          }

          elemTD.gmxDrawingObject = arrObjects[i];
          $(elemTD).draggable({
            scroll: false,
            appendTo: document.body,
            helper: 'clone',
            distance: 10
          });

          nsGmx$1.Utils._(tbody, [elemTR]);
        }

        nsGmx$1.Utils._(divChilds, [_table([tbody])]);
      }; // /**рисует номера страниц списка
      // @param end - последний номер
      // @param iDataSourceN - номер источника данных
      // @param divChilds - раздел для элементов списка
      // @param divPages - раздел для номеров страниц списка*/
      // var drawPages = function(end, iDataSourceN, divChilds, divPages) {
      // 	var oDataSource = arrTotalResultSet[iDataSourceN];
      // 	for (var i = oDataSource.start + 1; i <= end; i++) {
      // 		// текущий элемент
      // 		if (i - 1 == oDataSource.reportStart / iLimit) {
      // 			var el = _span([_t(i.toString())]);
      // 			nsGmx.Utils._(divPages, [el]);
      // 			$(el).addClass('page');
      // 		}
      // 		else {
      // 			var link = makeLinkButton(i.toString());
      // 			link.setAttribute('page', i - 1);
      // 			link.style.margin = '0px 2px';
      // 			nsGmx.Utils._(divPages, [link]);
      // 			link.onclick = function() {
      // 				arrTotalResultSet[iDataSourceN].reportStart = this.getAttribute('page') * iLimit;
      // 				drawPagesRow(iDataSourceN, divChilds, divPages);
      // 			};
      // 		}
      // 	}
      // }

      /**Рисует одну из страниц списка
      @param iDataSourceN - номер источника данных
      @param divChilds - раздел для элементов списка
      @param divPages - раздел для номеров страниц списка*/


      var drawPagesRow = function drawPagesRow(iDataSourceN, divChilds, divPages) {
        var oDataSource = arrTotalResultSet[iDataSourceN]; // перерисовывем номера страниц

        $(divPages).empty(); // var end = (oDataSource.start + iPagesCount <= oDataSource.allPages) ? oDataSource.start + iPagesCount : oDataSource.allPages;

        if (oDataSource.start - iPagesCount >= 0) nsGmx$1.Utils._(divPages, [first(iDataSourceN, divChilds, divPages), previous(iDataSourceN, divChilds, divPages)]); // drawPages(end, iDataSourceN, divChilds, divPages);
        // if (end + 1 <= oDataSource.allPages)
        // 	nsGmx.Utils._(divPages, [next(iDataSourceN, divChilds, divPages), last(iDataSourceN, divChilds, divPages)]);

        var startFrom = oDataSource.reportStart * iLimit;
        SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult.slice(startFrom, startFrom + iLimit));
        drawRows(iDataSourceN, divChilds);
      };
      /**Рисует таблицу для результатов источника данных
      @param iDataSourceN - номер источника данных
      @param divChilds - раздел для элементов списка
      @param divPages - раздел для номеров страниц списка*/


      var drawTable = function drawTable(iDataSourceN, divChilds, divPages) {
        var oDataSource = arrTotalResultSet[iDataSourceN];

        if (oDataSource.SearchResult.length <= iLimit
        /* && iDataSourceN < oDataSource.SearchResult.length - 1*/
        ) {
            $(divPages).empty();
            SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult);
            drawRows(iDataSourceN, divChilds);
          } else {
          oDataSource.allPages = Math.ceil(oDataSource.SearchResult.length / iLimit);
          drawPagesRow(iDataSourceN, divChilds, divPages);
        }
      };
      /**Обрабатывает событие нажатия на кнопку "Скачать SHP-файл"
      @param iDataSourceN - номер источника данных*/


      var downloadMarkers = function downloadMarkers(iDataSourceN) {
        var oDataSource = arrTotalResultSet[iDataSourceN];

        var canvas = nsGmx$1.Utils._div(),
            filename = _input(null, [['dir', 'className', 'filename'], ['attr', 'value', oDataSource.name]]);

        var downloadButton = makeButton(_gtxt("Скачать"));

        downloadButton.onclick = function () {
          if (filename.value == '') {
            inputError(filename, 2000);
            return;
          }
          /** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
          @name Search.ResultList.onDownloadSHP
          @event
          @param {string} filename Имя файла, которой необходимо будет сформировать
          @param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/


          $(_this).triggerHandler('onDownloadSHP', [filename.value, oDataSource.SearchResult]);
          $(canvas.parentNode).dialog("destroy").remove();
        };

        nsGmx$1.Utils._(canvas, [nsGmx$1.Utils._div([_t(_gtxt("Введите имя файла для скачивания")), filename], [['dir', 'className', 'DownloadSHPButtonText']]), nsGmx$1.Utils._div([downloadButton], [['dir', 'className', 'DownloadSHPButton']])]);

        var area = getOffsetRect(Container);
        showDialog(_gtxt("Скачать shp-файл"), canvas, 291, 120, 30, area.top + 10);
      };
      /**Отображает результаты поиска с источника данных
      @param iDataSourceN - номер источника данных*/


      var drawSearchResult = function drawSearchResult(iDataSourceN, options) {
        var oDataSource = arrTotalResultSet[iDataSourceN];
        var arrDataSourceList = oDataSource.SearchResult;
        var header = oDataSource.name;

        var divChilds = nsGmx$1.Utils._div(null, [['dir', 'className', 'SearchResultListChildsCanvas']]),
            divPages = nsGmx$1.Utils._div(),
            liInner = _li([divChilds, divPages]),
            li;

        if (arrTotalResultSet.length == 1) {
          li = nsGmx$1.Utils._ul([liInner]);
        } else {
          li = _li([nsGmx$1.Utils._div([_t(header), _span([_t("(" + arrDataSourceList.length + ")")])], [['dir', 'className', 'searchLayerHeader']]), nsGmx$1.Utils._ul([liInner])]);
        }

        oDataSource.start = 0;
        oDataSource.reportStart = options.page || 0;
        oDataSource.allPages = 0;
        drawTable(iDataSourceN, divChilds, divPages);

        if (oDataSource.CanDownloadVectors) {
          var downloadVector = makeLinkButton(_gtxt("Скачать shp-файл"));

          downloadVector.onclick = function () {
            downloadMarkers(iDataSourceN);
          };

          liInner.insertBefore(nsGmx$1.Utils._div([downloadVector], [['dir', 'className', 'SearchDownloadShpLink']]), liInner.firstChild);
        }

        return li;
      };

      var fnDisplayedObjectsChanged = function fnDisplayedObjectsChanged(event, iDataSourceN, arrFoundObjects) {
        oRenderer.DrawObjects(iDataSourceN, arrFoundObjects);
        /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
        @name Search.ResultListMap.onDisplayedObjectsChanged
        @event
        @param {int} iDataSourceN № источника данных(группы результатов поиска)
        @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
        // $(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
      };

      var fnObjectClick = function fnObjectClick(event, oFoundObject) {
        oRenderer.CenterObject(oFoundObject);
        /** Вызывается при клике на найденный объект в списке результатов поиска
        @name Search.ResultListMap.onObjectClick
        @event
        @param {object} oFoundObject Найденный объект*/
        // $(oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
      };

      var fnDownloadSHP = function fnDownloadSHP() {
        /** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
        @name Search.ResultListMap.onDownloadSHP
        @event
        @param {string} filename Имя файла, которой необходимо будет сформировать
        @param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
        // $(oSearchResultDiv).triggerHandler('onDownloadSHP', [filename, arrObjectsToDownload]);
      };

      $(_this).bind('onDisplayedObjectsChanged', fnDisplayedObjectsChanged);
      $(_this).bind('onObjectClick', fnObjectClick);
      $(_this).bind('onDownloadSHP', fnDownloadSHP);
      /**Отображает результаты поиска в списке
      @param sTotalListName - заголовок итогового результата
      @param {Array.<Object>} arrTotalList. Массив объектов со следующими свойствами{name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
      @returns {void}
      */

      this.ShowResult = function (sTotalListName, arrTotalList, options) {
        arrTotalResultSet = arrTotalList;
        $(oResultCanvas).empty();
        arrDisplayedObjects = [];

        if (!objLength(arrTotalResultSet)) {
          fnNotFound();
          return;
        } else {
          var foundSomething = false;

          for (var i = 0; i < arrTotalResultSet.length; i++) {
            if (arrTotalResultSet[i].SearchResult.length > 0) {
              foundSomething = true;
              break;
            }
          }

          if (!foundSomething) {
            fnNotFound();
            return;
          }
        }

        var ulSearch = nsGmx$1.Utils._ul();

        for (var iDataSourceN = 0; iDataSourceN < arrTotalResultSet.length; iDataSourceN++) {
          nsGmx$1.Utils._(ulSearch, [drawSearchResult(iDataSourceN, options)]);
        }

        if (arrTotalResultSet.length == 1) {
          nsGmx$1.Utils._(oResultCanvas, [ulSearch]);
        } else {
          nsGmx$1.Utils._(oResultCanvas, [_li([nsGmx$1.Utils._div([_t(sTotalListName)], [['dir', 'className', 'SearchTotalHeader']]), ulSearch])]);
        }

        if (typeof $.fn.treeview === 'function') {
          $(oResultCanvas).treeview();
        }

        $(oResultCanvas).find(".SearchResultListChildsCanvas").each(function () {
          this.parentNode.style.padding = '0px';
          this.parentNode.style.background = 'none';
        });
      };
      /**Создается переключатель страниц
      @param results - набор результатов
      @param onclick - обработчик нажатия переключателя страниц
      @returns {void}*/


      this.CreatePager = function (results, onclick) {
        function makeNavigButton(pager, img, imga, id, title) {
          var b = makeImageButton(sImagesHost + img, sImagesHost + imga);
          b.style.marginBottom = '-7px';
          $(b).attr('id', id);

          nsGmx$1.Utils._title(b, title);

          nsGmx$1.Utils._(pager, [b]);

          return b;
        }

        var containerList = Container;
        $('#respager').remove(); //var pager = nsGmx.Utils._div([_t('всего: ' + results[0].ResultsCount)], [["attr", "id", "respager"]]);

        var pager = nsGmx$1.Utils._div([_t('')], [["attr", "id", "respager"]]);

        nsGmx$1.Utils._(containerList, [pager]);

        var pcount = results[0].SearchResult[0] ? Math.ceil(results[0].SearchResult[0].OneOf / iLimit) : 0;

        if (pcount > 1) {
          var first = makeNavigButton(pager, '/first.png', '/first_a.png', 'firstpage', _gtxt('Первая страница'));
          $(first).bind('click', function () {
            fnShowPage(0);
          });
          var prev = makeNavigButton(pager, '/prev.png', '/prev_a.png', 'prevpages', _gtxt('Предыдущие [value0] страниц', iPagesCount));
          $(prev).bind('click', function () {
            fnShowPage(parseInt($('#page1').text()) - iPagesCount - 1);
          });
          $(first).hide();
          $(prev).hide();

          for (var i = 0; i < iPagesCount && i < pcount; ++i) {
            var pagelink = makeLinkButton(i + 1);
            $(pagelink).attr('id', 'page' + (i + 1));

            if (i == 0) {
              $(pagelink).attr('class', 'page');
              attachEffects(pagelink, '');
            }

            $(pagelink).bind('click', onclick);

            nsGmx$1.Utils._(pager, [pagelink, _t(' ')]);
          }

          var remains = pcount % iPagesCount;
          var nextPages = pcount / iPagesCount < 2 ? remains : iPagesCount;
          var nextButTitle = 'Следующие [value0] страниц';
          if (nextPages == 1) nextButTitle = 'Следующая страница';
          if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11) nextButTitle = 'Следующая [value0] страница';
          if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20)) nextButTitle = 'Следующие [value0] страницы';
          var next = makeNavigButton(pager, '/next.png', '/next_a.png', 'nextpages', _gtxt(nextButTitle, nextPages));
          $(next).bind('click', function () {
            fnShowPage(parseInt($('#page' + iPagesCount).text()));
          });
          var last = makeNavigButton(pager, '/last.png', '/last_a.png', 'lastpage', _gtxt('Последняя страница'));
          $(last).bind('click', function () {
            var lastindex = remains == 0 ? iPagesCount : remains;
            fnShowPage(pcount - lastindex, $('#page' + lastindex));
          });

          if (iPagesCount >= pcount) {
            $(next).hide();
            $(last).hide();
          }
        }

        var fnShowPage = function fnShowPage(n, active) {
          //alert(n + "\n" + pcount);
          for (var i = 0; i < iPagesCount; ++i) {
            //pcount
            if (i + n < pcount) {
              $('#page' + (i + 1)).text(i + n + 1);
              $('#page' + (i + 1)).show();
            } else $('#page' + (i + 1)).hide();
          }

          if (n < iPagesCount) {
            $('#prevpages').hide();
            $('#firstpage').hide();
          } else {
            $('#prevpages').show();
            $('#firstpage').show();
          }

          if (n + iPagesCount < pcount) {
            $('#nextpages').show();
            $('#lastpage').show();
            var rest = pcount - n - iPagesCount;
            var nextPages = rest < iPagesCount ? rest : iPagesCount;
            var nextButTitle = 'Следующие [value0] страниц';
            if (nextPages == 1) nextButTitle = 'Следующая страница';
            if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11) nextButTitle = 'Следующая [value0] страница';
            if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20)) nextButTitle = 'Следующие [value0] страницы';
            $('#nextpages').attr('title', _gtxt(nextButTitle, nextPages));
          } else {
            $('#nextpages').hide();
            $('#lastpage').hide();
          }

          if (active == null) active = $('#prevpages~span')[0];
          $(active).trigger('click');
        };
      };
      /*----------------------------------------------------------*/

      /**Возвращает список объектов, которые отображаются на текущей странице во всех разделах*/


      this.GetDisplayedObjects = function () {
        return arrDisplayedObjects;
      };

      var SetDisplayedObjects = function SetDisplayedObjects(iDataSourceN, value) {
        arrDisplayedObjects[iDataSourceN] = value;
        /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
        @name Search.ResultList.onDisplayedObjectsChanged
        @event
        @param {int} iDataSourceN № источника данных(группы результатов поиска)
        @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/

        $(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrDisplayedObjects[iDataSourceN]]);
      };
      /** Показывает режим загрузки
      @returns {void}*/


      this.ShowLoading = function () {
        $('#respager').remove();
        $(oResultCanvas).empty(); // Container.appendChild(oResultCanvas);

        nsGmx$1.Utils._(oResultCanvas, [oLoading]);
      };
      /**Показывает сообщение об ошибке
      @returns {void}*/


      this.ShowError = function () {
        $(oResultCanvas).empty();

        nsGmx$1.Utils._(oResultCanvas, [_t("Произошла ошибка")]);
      };
      /**Очищает результаты поиска
      @returns {void}*/


      this.Unload = function () {
        unload();
      };
      /** Возвращает контрол, в котором находится данный контрол*/


      this.getContainer = function () {
        return Container;
      };
    };

    nsGmx$1.SearchLogic = function () {};

    nsGmx$1.SearchLogic.prototype = {
      init: function init(params) {
        this.oMenu = params.oMenu || new leftMenu();
        this.oRenderer = new ResultRenderer(nsGmx$1.leafletMap, imagesHost, true);
        this.oSearchResultDiv = document.createElement('div');
        this.searchByStringHooks = [];
        this.oSearchResultDiv.className = 'ddfdfdf';
        this.oSearchResultDiv.title = window._gtxt('Изменить параметры поиска');

        var fnBeforeSearch = function fnBeforeSearch() {
          /** Вызывается перед началом поиска
          @name Search.SearchGeomixer.onBeforeSearch
          @event */
          $(this.oSearchResultDiv).triggerHandler('onBeforeSearch');
          this.fnLoad();
        };

        var fnAfterSearch = function fnAfterSearch() {
          /** Вызывается после окончания поиска
          @name Search.SearchGeomixer.onAfterSearch
          @event */
          $(this.oSearchResultDiv).triggerHandler('onAfterSearch');
        };

        var onDisplayedObjectsChanged = function onDisplayedObjectsChanged(event, iDataSourceN, arrFoundObjects) {
          /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
          @name Search.SearchGeomixer.onDisplayedObjectsChanged
          @event
          @param {int} iDataSourceN № источника данных(группы результатов поиска)
          @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
          $(this.oSearchResultDiv).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
        };

        var onObjectClick = function onObjectClick(event, oFoundObject) {
          /** Вызывается при клике на найденный объект в списке результатов поиска
          @name Search.SearchGeomixer.onObjectClick
          @event
          @param {object} oFoundObject Найденный объект*/
          $(this.oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
        };

        $(this.oSearchResultDiv).bind('onBeforeSearch', fnBeforeSearch);
        $(this.oSearchResultDiv).bind('onAfterSearch', fnAfterSearch);
        $(this.oSearchResultDiv).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
        $(this.oSearchResultDiv).bind('onObjectClick', onObjectClick); // coordinates search hook

        this.addSearchByStringHook(function (searchString) {
          var pos = L.gmxUtil.parseCoordinates(searchString);

          if (pos) {
            nsGmx$1.leafletMap.panTo(pos); // Добавим иконку по умолчанию
            // L.Icon.Default.imagePath = 'leaflet/images';

            nsGmx$1.leafletMap.gmxDrawing.add(L.marker(pos, {
              draggable: true,
              title: searchString
            })); // Либо задать свою иконку
            // map.gmxDrawing.add(L.marker(pos, {
            // draggable: true, title: searchString,
            // icon: L.icon({ iconUrl: 'img/flag_blau1.png', iconAnchor: [6, 36] })
            // }));
            //map.moveTo(pos[0], pos[1], map.getZ());
            //map.drawing.addObject({ type: "POINT", coordinates: pos }, { text: searchString });

            return true;
          }
        });
      },
      fnLoad: function fnLoad() {
        if (this.oMenu != null) {
          var alreadyLoaded = this.oMenu.createWorkCanvas("search", this.fnUnload.bind(this));

          if (!alreadyLoaded) {
            this.oMenu.workCanvas.appendChild(this.oSearchResultDiv);
          }

          $(this.oSearchResultDiv).empty();
        }
      },
      fnUnload: function fnUnload() {
        if (this.lstResult) {
          this.lstResult.Unload();
        }
      },
      showResult: function showResult(response) {
        var _this = this;

        var searchString = response.searchString || '';

        if (searchString) {
          for (var h = 0; h < this.searchByStringHooks.length; h++) {
            if (this.searchByStringHooks[h].hook(searchString)) {
              return;
            }
          }
        }

        this.fnLoad();
        this.lstResult = new ResultList(this.oSearchResultDiv, this.oRenderer, imagesHost);
        this.lstResult.ShowLoading();
        this.lstResult.ShowResult(searchString, response, {
          page: 0
        });
        this.lstResult.CreatePager(response, function (e) {
          var evt = e || window.event,
              active = evt.srcElement || evt.target,
              activePage = parseInt($(this).text()) - 1;
          $('#prevpages~span:visible').attr('class', 'buttonLink');

          for (var i = 0; i < $('#prevpages~span:visible').length; ++i) {
            attachEffects($('#prevpages~span:visible')[i], 'buttonLinkHover');
          }

          $(active).attr('class', 'page');
          attachEffects(active, '');

          _this.lstResult.ShowResult(searchString, response, {
            page: activePage
          });
        });
      },
      addSearchByStringHook: function addSearchByStringHook(hook, priority) {
        var _this = this;

        this.searchByStringHooks.push({
          hook: hook,
          priority: priority || 0,
          index: _this.searchByStringHooks.length
        });
        this.searchByStringHooks.sort(function (a, b) {
          return b.priority - a.priority || a.index - b.index;
        });
      },
      removeSearchByStringHook: function removeSearchByStringHook(hook) {
        for (var h = 0; h < this.searchByStringHooks.length; h++) {
          if (this.searchByStringHooks[h].hook === hook) {
            this.searchByStringHooks.splice(h, 1);
            return;
          }
        }
      },
      layersSearch: function layersSearch(res) {
        if (!nsGmx$1.gmxMap) {
          return new Promise(function (resolve, reject) {
            reject(res);
          });
        }

        var promisesArr = [];
        var layersToSearch = [];

        for (var i = 0; i < nsGmx$1.gmxMap.layers.length; i++) {
          //свойства мы берём из дерева слоёв, а не из API. Cвойство AllowSearch относится к карте и не поддерживаются API
          var searchRes = window._layersTree.treeModel.findElem('name', nsGmx$1.gmxMap.layers[i].getGmxProperties().name);

          if (searchRes) {
            var props = searchRes.elem.content.properties;

            if (props.type == "Vector" && props.AllowSearch) {
              layersToSearch.push(props);
            }
          }
        }

        if (layersToSearch.length > 0) {
          layersToSearch.forEach(function (props) {
            var mapName = nsGmx$1.gmxMap.layersByID[props.name].options.mapID;
            var url = window.serverBase + "SearchObject/SearchVector.ashx" + "?LayerNames=" + props.name + "&MapName=" + mapName + "&SearchString=" + encodeURIComponent(res.Result.searchString);
            var promise = new Promise(function (resolve, reject) {
              var req = new XMLHttpRequest();
              req.withCredentials = true;
              req.open('GET', url);

              req.onload = function () {
                if (req.status == 200) {
                  var res = handleResponse(req.response, props);
                  res.then(function (res2) {
                    resolve(res2);
                  });
                } else {
                  reject(Error(req.statusText));
                }
              };

              req.onerror = function () {
                reject(Error("Network Error"));
              };

              req.send();
            });
            promisesArr.push(promise);
          });
          return Promise.all(promisesArr);
        } else {
          return new Promise(function (resolve) {
            resolve(res);
          });
        }

        function handleResponse(searchReq, layerProps) {
          searchReq = typeof searchReq === 'string' ? JSON.parse(searchReq.substring(1, searchReq.length - 1)) : searchReq;
          var arrLayerResult = [];
          var arrResult = [];

          if (searchReq.Status == 'ok') {
            for (var iServer = 0; iServer < searchReq.Result.length; iServer++) {
              var limitSearchResults = typeof window.LayerSearchLimit == "number" ? window.LayerSearchLimit : 100;
              var req = searchReq.Result[iServer];

              for (var j = 0; j < limitSearchResults && j < req.SearchResult.length; j++) {
                var arrDisplayProperties = {};

                {
                  arrDisplayProperties = req.SearchResult[j].properties;
                }

                for (var p in arrDisplayProperties) {
                  var type = layerProps.attrTypes[layerProps.attributes.indexOf(p)];
                  arrDisplayProperties[p] = nsGmx$1.Utils.convertFromServer(type, arrDisplayProperties[p]);
                }

                arrLayerResult.push({
                  ObjName: req.SearchResult[j].properties.NAME || req.SearchResult[j].properties.Name || req.SearchResult[j].properties.name || req.SearchResult[j].properties.text || req.SearchResult[j].properties["Название"] || "[объект]",
                  properties: arrDisplayProperties,
                  Geometry: L.gmxUtil.convertGeometry(req.SearchResult[j].geometry, true)
                });
              }
            }

            if (arrLayerResult.length > 0) arrResult.push({
              name: layerProps.title,
              SearchResult: arrLayerResult,
              CanDownloadVectors: true
            });

            return Promise.resolve(arrResult);
          } else {
            return Promise.reject(searchReq);
          }
        }
      }
    };

    var main = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var EventTarget = function () {
        function EventTarget() {
            classCallCheck(this, EventTarget);

            this.listeners = {};
        }

        createClass(EventTarget, [{
            key: 'addEventListener',
            value: function addEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(callback);
            }
        }, {
            key: 'on',
            value: function on(type, callback) {
                this.addEventListener(type, callback);
                return this;
            }
        }, {
            key: 'removeEventListener',
            value: function removeEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[type];
                for (var i = 0, l = stack.length; i < l; i++) {
                    if (stack[i] === callback) {
                        stack.splice(i, 1);
                        return this.removeEventListener(type, callback);
                    }
                }
            }
        }, {
            key: 'off',
            value: function off(type, callback) {
                this.removeEventListener(type, callback);
                return this;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(event) {
                if (!(event.type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[event.type];
                Object.defineProperty(event, 'target', {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: this
                });
                for (var i = 0, l = stack.length; i < l; i++) {
                    stack[i].call(this, event);
                }
            }
        }]);
        return EventTarget;
    }();

    var scanexEventTarget_cjs = EventTarget;

    var ResultView =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(ResultView, _EventTarget);

      function ResultView(_ref) {
        var _this;

        var input = _ref.input,
            _ref$replaceInput = _ref.replaceInput,
            replaceInput = _ref$replaceInput === void 0 ? false : _ref$replaceInput;

        _classCallCheck(this, ResultView);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultView).call(this));
        _this._input = input;
        _this.index = -1;
        _this.count = 0;
        _this._item = null;
        _this._inputText = '';
        _this._replaceInput = replaceInput;
        _this._list = L.DomUtil.create('div');

        _this._list.setAttribute('class', 'leaflet-ext-search-list noselect');

        _this.allowNavigation = true;
        _this._list.style.top = "".concat(_this._input.offsetTop + _this._input.offsetHeight + 2, "px");
        _this._list.style.left = "".concat(_this._input.offsetLeft, "px");
        _this._handleKey = _this._handleKey.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('keydown', _this._handleKey);

        _this._handleInputClick = _this._handleInputClick.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('click', _this._handleInputClick);

        _this._handleFocus = _this._handleFocus.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('focus', _this._handleFocus);

        _this._list.addEventListener('keydown', _this._handleKey);

        _this._handleWheel = _this._handleWheel.bind(_assertThisInitialized(_this));

        _this._list.addEventListener('wheel', _this._handleWheel);

        L.DomEvent.disableClickPropagation(_this._list).disableScrollPropagation(_this._list); // this._list.addEventListener('mousewheel', this._handleWheel.bind(this));
        // this._list.addEventListener('MozMousePixelScroll', this._handleWheel.bind(this));       

        _this._input.parentElement.appendChild(_this._list);

        _this._handleChange = _this._handleChange.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('input', _this._handleChange);

        return _this;
      }

      _createClass(ResultView, [{
        key: "_handleInputClick",
        value: function _handleInputClick(e) {
          e.stopPropagation();
        }
      }, {
        key: "_handleFocus",
        value: function _handleFocus(e) {
          if (this.index >= 0) {
            var el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

            L.DomUtil.removeClass(el, 'leaflet-ext-search-list-selected');
          }

          this.index = -1;
          this._item = null;
        }
      }, {
        key: "_handleChange",
        value: function _handleChange(e) {
          this._inputText = this._input.value;
        }
      }, {
        key: "_handleWheel",
        value: function _handleWheel(e) {
          e.stopPropagation();
        }
      }, {
        key: "_handleKey",
        value: function _handleKey(e) {
          if (this.listVisible()) {
            switch (e.keyCode) {
              // ArroLeft / ArrowRight
              case 37:
              case 39:
                e.stopPropagation();
                break;
              // ArrowDown

              case 40:
                e.preventDefault();
                e.stopPropagation();

                if (this.allowNavigation) {
                  if (this.index < 0) {
                    this.index = 0;
                  } else if (0 <= this.index && this.index < this.count - 1) {
                    var _el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el, 'leaflet-ext-search-list-selected');
                    ++this.index;
                  } else {
                    var _el2 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el2, 'leaflet-ext-search-list-selected');
                    this.index = this.count - 1;
                  }

                  var el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                  L.DomUtil.addClass(el, 'leaflet-ext-search-list-selected');
                  this.selectItem(this.index);
                  el.focus();
                }

                break;
              // ArrowUp

              case 38:
                e.preventDefault();
                e.stopPropagation();

                if (this.allowNavigation) {
                  if (this.index > 0) {
                    var _el3 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el3, 'leaflet-ext-search-list-selected');
                    --this.index;
                    _el3 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));
                    L.DomUtil.addClass(_el3, 'leaflet-ext-search-list-selected');
                    this.selectItem(this.index);

                    _el3.focus();
                  } else if (this.index === 0) {
                    this._input.focus();

                    this._input.value = this._inputText;
                  }
                }

                break;
              // Enter

              case 13:
                if (this.index < 0 && this._input.value) {
                  var text = this._input.value;

                  this._input.focus();

                  this._input.setSelectionRange(text.length, text.length);

                  this.hide();
                  var event = document.createEvent('Event');
                  event.initEvent('suggestions:confirm', false, false);
                  event.detail = text;
                  this.dispatchEvent(event);
                } else {
                  this.complete(this.index);
                }

                break;
              // Escape

              case 27:
                if (this.index < 0) {
                  this.hide();
                }

                this._input.focus();

                this._input.value = this._inputText;
                break;

              default:
                break;
            }
          } else {
            if (e.keyCode === 13 && this._input.value) {
              var _text = this._input.value;

              this._input.setSelectionRange(_text.length, _text.length);

              var _event = document.createEvent('Event');

              _event.initEvent('suggestions:confirm', false, false);

              _event.detail = _text;
              this.dispatchEvent(_event);
            } else if (e.keyCode === 27) {
              this._input.value = '';
              this.index = -1;

              this._input.focus();
            }
          }
        }
      }, {
        key: "listVisible",
        value: function listVisible() {
          return this.count > 0 && this._list.style.display !== 'none';
        }
      }, {
        key: "selectItem",
        value: function selectItem(i) {
          this._item = this._items[i];
          var text = this._item.name;

          if (this._replaceInput) {
            this._input.value = text;

            this._input.setSelectionRange(text.length, text.length);
          }
        }
      }, {
        key: "_handleClick",
        value: function _handleClick(i, e) {
          e.preventDefault();
          this.complete(i);
        }
      }, {
        key: "complete",
        value: function complete(i) {
          var item = i >= 0 ? this._items[i] : this._item ? this._item : null;

          if (item) {
            this._item = item;
            this.index = -1;
            var text = item.name;

            if (this._replaceInput) {
              this._input.value = text;

              this._input.setSelectionRange(text.length, text.length);
            }

            this._input.focus();

            this.hide();
            var event = document.createEvent('Event');
            event.initEvent('suggestions:select', false, false);
            event.detail = item;
            this.dispatchEvent(event);
          }
        }
      }, {
        key: "show",
        value: function show(items, highlight) {
          if (items.length) {
            this._item = null;
            this.index = -1;
            this._items = items;
            var html = '<ul>' + this._items.filter(function (x) {
              return x.name && x.name.length;
            }).map(function (x, i) {
              var name = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(x.name, "</span>");

              if (highlight && highlight.length) {
                var start = x.name.toLowerCase().indexOf(highlight.toLowerCase());

                if (start != -1) {
                  var head = x.name.substr(0, start);

                  if (head.length) {
                    head = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(head, "</span>");
                  }

                  var tail = x.name.substr(start + highlight.length);

                  if (tail.length) {
                    tail = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(tail, "</span>");
                  }

                  name = "".concat(head, "<span class=\"leaflet-ext-search-list-item-highlight\">").concat(highlight, "</span>").concat(tail);
                }
              }

              return "<li tabindex=".concat(i, ">").concat(name, "</li>");
            }, []).join('') + '</ul>';
            this._list.innerHTML = html;

            var elements = this._list.querySelectorAll('li');

            for (var i = 0; i < elements.length; ++i) {
              elements[i].addEventListener('click', this._handleClick.bind(this, i));
            }

            this.count = elements.length;
            this._list.style.display = 'block';
          }
        }
      }, {
        key: "hide",
        value: function hide() {
          this._list.style.display = 'none';
        }
      }]);

      return ResultView;
    }(scanexEventTarget_cjs);

    function chain(tasks, state) {
      return tasks.reduce(function (prev, next) {
        return prev.then(next);
      }, new Promise(function (resolve, reject) {
        return resolve(state);
      }));
    }

    var SearchWidget =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(SearchWidget, _EventTarget);

      function SearchWidget(container, _ref) {
        var _this;

        var placeHolder = _ref.placeHolder,
            providers = _ref.providers,
            _ref$suggestionTimeou = _ref.suggestionTimeout,
            suggestionTimeout = _ref$suggestionTimeou === void 0 ? 1000 : _ref$suggestionTimeou,
            _ref$suggestionLimit = _ref.suggestionLimit,
            suggestionLimit = _ref$suggestionLimit === void 0 ? 10 : _ref$suggestionLimit,
            _ref$fuzzySearchLimit = _ref.fuzzySearchLimit,
            fuzzySearchLimit = _ref$fuzzySearchLimit === void 0 ? 1000 : _ref$fuzzySearchLimit,
            _ref$retrieveManyOnEn = _ref.retrieveManyOnEnter,
            retrieveManyOnEnter = _ref$retrieveManyOnEn === void 0 ? false : _ref$retrieveManyOnEn,
            _ref$replaceInputOnEn = _ref.replaceInputOnEnter,
            replaceInputOnEnter = _ref$replaceInputOnEn === void 0 ? false : _ref$replaceInputOnEn;

        _classCallCheck(this, SearchWidget);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchWidget).call(this));
        _this._container = container;
        _this._allowSuggestion = true;
        _this._providers = providers;
        _this._suggestionTimeout = suggestionTimeout;
        _this._suggestionLimit = suggestionLimit;
        _this._fuzzySearchLimit = fuzzySearchLimit;
        _this._retrieveManyOnEnter = retrieveManyOnEnter;
        _this._replaceInputOnEnter = replaceInputOnEnter;

        _this._container.classList.add('leaflet-ext-search');

        _this._container.innerHTML = "<input type=\"text\" value=\"\" placeholder=\"".concat(placeHolder, "\" /><span class=\"leaflet-ext-search-button\"></span>");
        _this._input = _this._container.querySelector('input');
        _this._handleChange = _this._handleChange.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('input', _this._handleChange);

        _this._handleMouseMove = _this._handleMouseMove.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('mousemove', _this._handleMouseMove);

        _this._input.addEventListener('dragstart', _this._handleMouseMove);

        _this._input.addEventListener('drag', _this._handleMouseMove);

        _this._handleSearch = _this._handleSearch.bind(_assertThisInitialized(_this));
        _this._button = _this._container.querySelector('.leaflet-ext-search-button');

        _this._button.addEventListener('click', _this._handleSearch);

        _this.results = new ResultView({
          input: _this._input,
          replaceInput: _this._replaceInputOnEnter
        });
        _this._search = _this._search.bind(_assertThisInitialized(_this));
        _this._selectItem = _this._selectItem.bind(_assertThisInitialized(_this));

        _this.results.addEventListener('suggestions:confirm', function (e) {
          var event = document.createEvent('Event');
          event.initEvent('suggestions:confirm', false, false);
          event.detail = e.detail;

          _this.dispatchEvent(event);

          _this._search(e);
        });

        _this.results.addEventListener('suggestions:select', _this._selectItem); // map.on ('click', this.results.hide.bind(this.results));
        // map.on ('dragstart', this.results.hide.bind(this.results));


        return _this;
      }

      _createClass(SearchWidget, [{
        key: "_suggest",
        value: function _suggest(text) {
          var _this2 = this;

          this.results.allowNavigation = false;

          var tasks = this._providers.filter(function (provider) {
            return provider.showSuggestion;
          }).map(function (provider) {
            return function (state) {
              return new Promise(function (resolve) {
                if (state.completed) {
                  resolve(state);
                } else {
                  provider.find(text, _this2._suggestionLimit, false, false).then(function (response) {
                    state.completed = response.length > 0;
                    state.response = state.response.concat(response);
                    resolve(state);
                  })["catch"](function (e) {
                    return console.log(e);
                  });
                }
              });
            };
          });

          chain(tasks, {
            completed: false,
            response: []
          }).then(function (state) {
            _this2.results.show(state.response, text.trim());

            _this2.results.allowNavigation = true;
          });
        }
      }, {
        key: "_handleChange",
        value: function _handleChange(e) {
          var _this3 = this;

          if (this._input.value.length) {
            if (this._allowSuggestion) {
              this._allowSuggestion = false;
              this._timer = setTimeout(function () {
                clearTimeout(_this3._timer);
                _this3._allowSuggestion = true;
                var text = _this3._input.value;

                _this3._suggest(text);
              }, this._suggestionTimeout);
            }
          } else {
            this.results.hide();
          }
        }
      }, {
        key: "_handleMouseMove",
        value: function _handleMouseMove(e) {
          e.stopPropagation();
          e.preventDefault();
        }
      }, {
        key: "_search",
        value: function _search(e) {
          var _this4 = this;

          var text = e.detail;

          var tasks = this._providers.filter(function (provider) {
            return provider.showOnEnter;
          }).map(function (provider) {
            return function (state) {
              return new Promise(function (resolve) {
                if (state.completed) {
                  resolve(state);
                } else {
                  provider.find(text, _this4._retrieveManyOnEnter ? _this4._fuzzySearchLimit : 1, true, true).then(function (response) {
                    state.completed = response.length > 0;
                    state.response = state.response.concat(response);
                    resolve(state);
                  })["catch"](function (e) {
                    console.log(e);
                    resolve(state);
                  });
                }
              });
            };
          });

          chain(tasks, {
            completed: false,
            response: []
          }).then(function (state) {// if(state.response.length > 0 && !this._retrieveManyOnEnter){
            //     let item = state.response[0];
            //     item.provider
            //     .fetch(item.properties)
            //     .then(response => {});                    
            // }
          });
          this.results && this.results.hide();
        }
      }, {
        key: "_selectItem",
        value: function _selectItem(e) {
          var item = e.detail;
          return item.provider.fetch(item.properties);
        }
      }, {
        key: "_handleSearch",
        value: function _handleSearch(e) {
          e.stopPropagation();

          this._search({
            detail: this._input.value
          });
        }
      }, {
        key: "setText",
        value: function setText(text) {
          this._input.value = text;
        }
      }, {
        key: "setPlaceHolder",
        value: function setPlaceHolder(value) {
          this._input.placeholder = value;
        }
      }]);

      return SearchWidget;
    }(scanexEventTarget_cjs);

    var SearchControl = L.Control.extend({
      includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
      initialize: function initialize(options) {
        L.setOptions(this, options);
        this._allowSuggestion = true;
        this.options.suggestionTimeout = this.options.suggestionTimeout || 1000;
        this.options.suggestionLimit = this.options.suggestionLimit || 10;
      },
      onAdd: function onAdd(map) {
        this._container = L.DomUtil.create('div', 'leaflet-ext-search');
        this._widget = new SearchWidget(this._container, this.options);
        map.on('click', this._widget.results.hide.bind(this._widget.results));
        map.on('dragstart', this._widget.results.hide.bind(this._widget.results));
        return this._container;
      },
      addTo: function addTo(map) {
        L.Control.prototype.addTo.call(this, map);

        if (this.options.addBefore) {
          this.addBefore(this.options.addBefore);
        }

        return this;
      },
      addBefore: function addBefore(id) {
        var parentNode = this._parent && this._parent._container;

        if (!parentNode) {
          parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }

        if (!parentNode) {
          this.options.addBefore = id;
        } else {
          for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
            var it = parentNode.childNodes[i];

            if (id === it._id) {
              parentNode.insertBefore(this._container, it);
              break;
            }
          }
        }

        return this;
      },
      setText: function setText(text) {
        this._widget.setText(text);
      },
      setPlaceHolder: function setPlaceHolder(value) {
        this._widget.setPlaceHolder(value);
      }
    });

    var OsmDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(OsmDataProvider, _EventTarget);

      function OsmDataProvider(_ref) {
        var _this;

        var serverBase = _ref.serverBase;

        _classCallCheck(this, OsmDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(OsmDataProvider).call(this));
        _this._serverBase = serverBase;
        _this.showSuggestion = true;
        _this.showOnSelect = true;
        _this.showOnEnter = true;
        _this.find = _this.find.bind(_assertThisInitialized(_this));
        _this.fetch = _this.fetch.bind(_assertThisInitialized(_this));
        _this._convertGeometry = _this._convertGeometry.bind(_assertThisInitialized(_this));
        _this._key = window.KOSMOSNIMKI_SESSION_KEY == null || window.KOSMOSNIMKI_SESSION_KEY == 'INVALID' ? '' : "&key=".concat(window.KOSMOSNIMKI_SESSION_KEY);
        return _this;
      }

      _createClass(OsmDataProvider, [{
        key: "_convertGeometry",
        value: function _convertGeometry(geometry) {
          switch (geometry.type.toUpperCase()) {
            case 'POINT':
              geometry.type = 'Point';
              break;

            case 'POLYGON':
              geometry.type = 'Polygon';
              break;

            case 'MULTIPOLYGON':
              geometry.type = 'MultiPolygon';
              break;

            case 'LINESTRING':
            case 'POLYLINE':
              geometry.type = 'LineString';
              break;

            case 'MULTILINESTRING':
              geometry.type = 'MultiLineString';
              break;

            default:
              throw 'Unknown WKT type';
          }

          return geometry;
        }
      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (obj) {
          var _this2 = this;

          var query = "WrapStyle=None&RequestType=ID&ID=".concat(obj.ObjCode, "&TypeCode=").concat(obj.TypeCode, "&UseOSM=1");
          var req = new Request("".concat(this._serverBase, "/SearchObject/SearchAddress.ashx?").concat(query).concat(this._key));
          var headers = new Headers();
          headers.append('Content-Type', 'application/json');
          var init = {
            method: 'GET',
            mode: 'cors',
            credentials: 'include',
            cache: 'default'
          };
          return new Promise(function (resolve, reject) {
            fetch(req, init).then(function (response) {
              return response.json();
            }).then(function (json) {
              if (json.Status === 'ok') {
                var rs = json.Result.reduce(function (a, x) {
                  return a.concat(x.SearchResult);
                }, []).map(function (x) {
                  var g = _this2._convertGeometry(x.Geometry);

                  var props = Object.keys(x).filter(function (k) {
                    return k !== 'Geometry';
                  }).reduce(function (a, k) {
                    a[k] = x[k];
                    return a;
                  }, {});
                  return {
                    feature: {
                      type: 'Feature',
                      geometry: g,
                      properties: props
                    },
                    provider: _this2,
                    query: obj
                  };
                });
                var event = document.createEvent('Event');
                event.initEvent('fetch', false, false);
                event.detail = rs;

                _this2.dispatchEvent(event);

                resolve(rs);
              } else {
                reject(json);
              }
            })["catch"](function (response) {
              return reject(response);
            });
          });
        })
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            if (value || value.trim()) {
              var _strong = Boolean(strong) ? 1 : 0;

              var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;

              var query = "WrapStyle=None&RequestType=SearchObject&IsStrongSearch=".concat(_strong, "&WithoutGeometry=").concat(_withoutGeometry, "&UseOSM=1&Limit=").concat(limit, "&SearchString=").concat(encodeURIComponent(value));
              var req = new Request("".concat(_this3._serverBase, "/SearchObject/SearchAddress.ashx?").concat(query).concat(_this3._key));
              var headers = new Headers();
              headers.append('Content-Type', 'application/json');
              var init = {
                method: 'GET',
                mode: 'cors',
                credentials: 'include',
                cache: 'default'
              };
              fetch(req, init).then(function (response) {
                return response.json();
              }).then(function (json) {
                if (json.Status === 'ok') {
                  var rs = json.Result.reduce(function (a, x) {
                    return a.concat(x.SearchResult);
                  }, []).map(function (x) {
                    if (retrieveGeometry && x.Geometry) {
                      var g = _this3._convertGeometry(x.Geometry);

                      var props = Object.keys(x).filter(function (k) {
                        return k !== 'Geometry';
                      }).reduce(function (a, k) {
                        a[k] = x[k];
                        return a;
                      }, {});
                      return {
                        name: x.ObjNameShort,
                        feature: {
                          type: 'Feature',
                          geometry: g,
                          properties: props
                        },
                        properties: props,
                        provider: _this3,
                        query: value
                      };
                    } else {
                      return {
                        name: x.ObjNameShort,
                        properties: x,
                        provider: _this3,
                        query: value
                      };
                    }
                  });

                  if (strong && retrieveGeometry) {
                    var event = document.createEvent('Event');
                    event.initEvent('fetch', false, false);
                    event.detail = rs;

                    _this3.dispatchEvent(event);
                  }

                  resolve(rs);
                } else {
                  reject(json);
                }
              })["catch"](function (response) {
                return reject(response);
              });
            } else {
              reject('Empty string');
            }
          });
        }
      }]);

      return OsmDataProvider;
    }(scanexEventTarget_cjs);

    var CoordinatesDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(CoordinatesDataProvider, _EventTarget);

      function CoordinatesDataProvider() {
        var _this;

        _classCallCheck(this, CoordinatesDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CoordinatesDataProvider).call(this));
        _this.showSuggestion = false;
        _this.showOnSelect = false;
        _this.showOnEnter = true;
        _this.fetch = _this.fetch.bind(_assertThisInitialized(_this));
        _this.find = _this.find.bind(_assertThisInitialized(_this));
        _this.rxF = new RegExp('^\\s*\\-?(\\d+(\\.\\d+)?)(\\s+[N|S])?(,\\s*|\\s+)\\-?(\\d+(\\.\\d+)?)(\\s+[E|W])?');
        _this.rxD = new RegExp("^\\s*(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[N|S])?,?\\s+(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[E|W])?");
        return _this;
      }

      _createClass(CoordinatesDataProvider, [{
        key: "_parseCoordinates",
        value: function _parseCoordinates(value) {
          var m = this.rxD.exec(value);

          if (Array.isArray(m) && m.length === 9) {
            return this._parseDegrees([m[1], m[2], m[3], m[5], m[6], m[7]].map(function (x) {
              return parseFloat(x);
            }));
          }

          m = this.rxF.exec(value);

          if (Array.isArray(m) && m.length === 8) {
            return {
              type: 'Point',
              coordinates: [parseFloat(m[5]), parseFloat(m[1])]
            };
          }

          return null;
        }
      }, {
        key: "_parseDegrees",
        value: function _parseDegrees(_ref) {
          var _ref2 = _slicedToArray(_ref, 6),
              latDeg = _ref2[0],
              latMin = _ref2[1],
              latSec = _ref2[2],
              lngDeg = _ref2[3],
              lngMin = _ref2[4],
              lngSec = _ref2[5];

          return {
            type: 'Point',
            coordinates: [lngDeg + lngMin / 60 + lngSec / 3600, latDeg + latMin / 60 + latSec / 3600]
          };
        }
      }, {
        key: "fetch",
        value: function fetch(value) {
          return new Promise(function (resolve) {
            return resolve([]);
          });
        }
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this2 = this;

          var g = this._parseCoordinates(value);

          return new Promise(function (resolve) {
            var result = {
              feature: {
                type: 'Feature',
                geometry: g,
                properties: {}
              },
              provider: _this2,
              query: value
            };

            if (g) {
              var event = document.createEvent('Event');
              event.initEvent('fetch', false, false);
              event.detail = result;

              _this2.dispatchEvent(event);
            }

            resolve(g ? [result] : []);
          });
        }
      }]);

      return CoordinatesDataProvider;
    }(scanexEventTarget_cjs);

    var CadastreDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(CadastreDataProvider, _EventTarget);

      function CadastreDataProvider(_ref) {
        var _this;

        var serverBase = _ref.serverBase,
            tolerance = _ref.tolerance;

        _classCallCheck(this, CadastreDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CadastreDataProvider).call(this));
        _this._serverBase = serverBase;
        _this._tolerance = tolerance;
        _this.showSuggestion = true;
        _this.showOnSelect = false;
        _this.showOnEnter = true;
        _this._cadastreLayers = [{
          id: 1,
          title: 'Участок',
          reg: /^\d\d:\d+:\d+:\d+$/
        }, {
          id: 2,
          title: 'Квартал',
          reg: /^\d\d:\d+:\d+$/
        }, {
          id: 3,
          title: 'Район',
          reg: /^\d\d:\d+$/
        }, {
          id: 4,
          title: 'Округ',
          reg: /^\d\d$/
        }, {
          id: 5,
          title: 'ОКС',
          reg: /^\d\d:\d+:\d+:\d+:\d+$/
        }, {
          id: 10,
          title: 'ЗОУИТ',
          reg: /^\d+\.\d+\.\d+/ // ,
          // {id: 7, title: 'Границы', 	reg: /^\w+$/},
          // {id: 6, title: 'Тер.зоны', 	reg: /^\w+$/},
          // {id: 12, title: 'Лес', 		reg: /^\w+$/},
          // {id: 13, title: 'Красные линии', 		reg: /^\w+$/},
          // {id: 15, title: 'СРЗУ', 	reg: /^\w+$/},
          // {id: 16, title: 'ОЭЗ', 		reg: /^\w+$/},
          // {id: 9, title: 'ГОК', 		reg: /^\w+$/},
          // {id: 10, title: 'ЗОУИТ', 	reg: /^\w+$/}
          // /[^\d\:]/g,
          // /\d\d:\d+$/,
          // /\d\d:\d+:\d+$/,
          // /\d\d:\d+:\d+:\d+$/

        }];
        return _this;
      }

      _createClass(CadastreDataProvider, [{
        key: "getCadastreLayer",
        value: function getCadastreLayer(str, type) {
          str = str.trim();

          for (var i = 0, len = this._cadastreLayers.length; i < len; i++) {
            var it = this._cadastreLayers[i];

            if (it.id === type) {
              return it;
            }

            if (it.reg.exec(str)) {
              return it;
            }
          }

          return this._cadastreLayers[0];
        }
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this2 = this;

          var cadastreLayer = this.getCadastreLayer(value);
          return new Promise(function (resolve) {
            // let req = new Request(`${this._serverBase}/typeahead?limit=${limit}&skip=0&text=${value}&type=${cadastreLayer.id}`);
            var req = new Request("".concat(_this2._serverBase, "/features/").concat(cadastreLayer.id, "?text=").concat(value, "&tolerance=").concat(_this2._tolerance, "&limit=").concat(limit));
            var headers = new Headers();
            headers.append('Content-Type', 'application/json');
            var init = {
              method: 'GET',
              mode: 'cors',
              cache: 'default'
            };
            fetch(req, init).then(function (response) {
              return response.json();
            }).then(function (json) {
              // if(json.status === 200){
              var rs = json.features.map(function (x) {
                return {
                  name: x.attrs.name || x.attrs.cn || x.attrs.id,
                  properties: x,
                  provider: _this2,
                  query: value
                };
              });
              resolve(rs); // }
              // else {
              // resolve(json);
              // }                                       
            });
          });
        }
      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (obj) {
          var _this3 = this;

          var text = obj.attrs.name || obj.attrs.cn || obj.attrs.id;
          var cadastreLayer = this.getCadastreLayer(text, obj.type);
          return new Promise(function (resolve) {
            if (cadastreLayer) {
              // let req = new Request(`${this._serverBase}/features/${cadastreLayer.id}?tolerance=${this._tolerance}&limit=1&text=${obj.value}`);
              var req = new Request("".concat(_this3._serverBase, "/features/").concat(cadastreLayer.id, "?tolerance=").concat(_this3._tolerance, "&limit=1&text=").concat(text));
              var headers = new Headers();
              headers.append('Content-Type', 'application/json');
              var init = {
                method: 'GET',
                mode: 'cors',
                cache: 'default'
              };
              fetch(req, init).then(function (response) {
                return response.json();
              }).then(function (json) {
                if (json.status === 200) {
                  var event = document.createEvent('Event');
                  event.initEvent('fetch', false, false);
                  event.detail = json;

                  _this3.dispatchEvent(event);

                  var rs = json.features.map(function (x) {
                    return {
                      name: x.attrs.name || x.attrs.cn || x.attrs.id,
                      properties: x,
                      provider: _this3,
                      query: obj
                    };
                  });
                  resolve(rs);
                } else {
                  resolve(json);
                }
              });
            } else {
              resolve([]);
            }
          });
        })
      }]);

      return CadastreDataProvider;
    }(scanexEventTarget_cjs);

    exports.CadastreDataProvider = CadastreDataProvider;
    exports.CoordinatesDataProvider = CoordinatesDataProvider;
    exports.OsmDataProvider = OsmDataProvider;
    exports.SearchControl = SearchControl;
    exports.SearchWidget = SearchWidget;
    //# sourceMappingURL=main.js.map
    });

    unwrapExports(main);
    var main_1 = main.CadastreDataProvider;
    var main_2 = main.CoordinatesDataProvider;
    var main_3 = main.OsmDataProvider;
    var main_4 = main.SearchControl;
    var main_5 = main.SearchWidget;

    nsGmx$1.OsmDataProvider = main_3;
    nsGmx$1.searchProviders = {};

    nsGmx$1.searchProviders.Osm2DataProvider = function (options) {
      nsGmx$1.OsmDataProvider.call(this, options);
    };

    nsGmx$1.searchProviders.Osm2DataProvider.prototype = Object.create(nsGmx$1.OsmDataProvider.prototype);
    nsGmx$1.searchProviders.Osm2DataProvider.prototype.constructor = nsGmx$1.Osm2DataProvider;

    nsGmx$1.searchProviders.Osm2DataProvider.prototype.fetch = function (obj) {
      var _this = this;

      var query = 'WrapStyle=None&RequestType=ID&ID=' + obj.ObjCode + '&TypeCode=' + obj.TypeCode + '&UseOSM=1';
      var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
      var headers = new Headers();
      headers.append('Content-Type', 'application/json');
      var init = {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        cache: 'default'
      };
      return new Promise(function (resolve, reject) {
        fetch(req, init).then(function (response) {
          return response.json();
        }).then(function (json) {
          if (json.Status === 'ok') {
            if (typeof _this._onFetch === 'function') {
              _this._onFetch(json.Result);
            }

            var event = document.createEvent('Event');
            event.initEvent('fetch', false, false);
            event.detail = json.Result;

            _this.dispatchEvent(event);

            resolve(json.Result);
          } else {
            reject(json.Result);
          }
        })["catch"](function (response) {
          return reject(response);
        });
      });
    };

    nsGmx$1.searchProviders.Osm2DataProvider.prototype.find = function (value, limit, strong, retrieveGeometry) {
      var result;

      var _this2 = this;

      _this2.searchString = value;

      var _strong = strong ? 1 : 0;

      var _withoutGeometry = retrieveGeometry ? 0 : 1;

      var query = 'WrapStyle=None&RequestType=SearchObject&IsStrongSearch=' + _strong + '&WithoutGeometry=' + _withoutGeometry + '&UseOSM=1&Limit=' + limit + '&SearchString=' + encodeURIComponent(value);
      var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
      var headers = new Headers();
      headers.append('Content-Type', 'application/json');
      var init = {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        cache: 'default'
      };
      return new Promise(function (resolve, reject) {
        var initPromise;

        if (!window.useInternalSearch) {
          initPromise = fetch(req, init).then(function (response) {
            return response.json();
          });
        } else {
          initPromise = Promise.resolve({
            Status: 'ok',
            Result: []
          });
        }

        initPromise.then(function (json) {
          if (json.Status === 'ok') {
            json.Result.searchString = _this2.searchString;
            result = json;
            return json;
          } else {
            reject(json.Result);
          }
        }).then(function (json1) {
          return window.searchLogic && window.searchLogic.layersSearch(json1);
        }).then(function (json2) {
          var arr = [];

          for (var i = 0; i < result.Result.length; i++) {
            arr.push(result.Result[i]);
          }

          for (var _i = 0; _i < json2.length; _i++) {
            if (json2[_i] && json2[_i].length) {
              for (var j = 0; j < json2[_i].length; j++) {
                arr.push(json2[_i][j]);
              }
            }
          }

          arr.searchString = result.Result.searchString;
          return {
            Status: result.Status,
            Result: arr
          };
        }).then(function (json3) {
          if (json3.Status === 'ok') {
            var rs = json3.Result.reduce(function (a, x) {
              return a.concat(x.SearchResult);
            }, []).map(function (x) {
              if (retrieveGeometry && x.Geometry) {
                var g = _this2._convertGeometry(x.Geometry);

                var props = Object.keys(x).filter(function (k) {
                  return k !== 'Geometry';
                }).reduce(function (a, k) {
                  a[k] = x[k];
                  return a;
                }, {});
                return {
                  name: x.ObjNameShort,
                  feature: {
                    type: 'Feature',
                    geometry: g,
                    properties: props
                  },
                  properties: props,
                  provider: _this2,
                  query: value
                };
              } else {
                return {
                  name: x.ObjNameShort,
                  properties: x,
                  provider: _this2,
                  query: value
                };
              }
            });

            if (strong && retrieveGeometry) {
              var event = document.createEvent('Event');
              event.initEvent('fetch', false, false);
              event.detail = json3.Result;

              _this2.dispatchEvent(event);
            }

            resolve(rs);
          } else {
            reject(json3);
          }
        });
      });
    };

    window._translationsHash.addtext("rus", {
      "loadShape.inputTitle": "Добавить shp-файл (в zip)",
      "loadShape.loadDone": "Геометрия успешно загружена",
      "loadShape.loadFail": "Ошибка загрузки геометрии"
    });

    window._translationsHash.addtext("eng", {
      "loadShape.inputTitle": "Add shp-file (zipped)",
      "loadShape.loadDone": "Successfully loaded",
      "loadShape.loadFail": "Error loading file"
    });

    var drawingObjects = {
      loadShp: {}
    };

    var queryLoadShp = function queryLoadShp() {
      this.builded = false;
      this.uploader = null;
    };

    queryLoadShp.prototype = new leftMenu(); //Старый вариант для IE9
    //просто удаляет все контролы и создаёт все их заново...

    queryLoadShp.prototype._regenerateControl = function () {
      var _this = this;

      $(this.workCanvas).empty();

      var fileInput = _input(null, [['attr', 'type', 'file'], ['attr', 'name', 'file'], ['attr', 'id', 'upload_shapefile']]);

      fileInput.onchange = function () {
        if (this.value != "") _this.upload();
      }; //задаём одновременно и enctype и encoding для корректной работы в IE


      this.postForm = _form([fileInput], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);
      this.progress = _img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'display', 'none']]);
      this.inputControl = _div([_span([_t(_gtxt("loadShape.inputTitle") + ":")]), this.postForm]);
      this.workCanvas.appendChild(_div([this.inputControl, this.progress], [['css', 'padding', '10px 0px 5px 20px']]));
    };

    queryLoadShp.prototype.load = function () {
      if (!this.builded) {
        this._regenerateControl();

        this.builded = true;
      }
    };

    queryLoadShp.prototype._showObjectsOnMap = function (objs) {
      if (objs.length == 0) {
        showErrorMessage(_gtxt("Загруженный shp-файл пуст"), true);
        return;
      }

      var lmap = nsGmx$1.leafletMap,
          gmxDrawing = lmap.gmxDrawing,
          latLngBounds = L.latLngBounds([]);

      for (var i = 0; i < objs.length; i++) {
        var it = objs[i],
            geoJSON = L.gmxUtil.geometryToGeoJSON(it.geometry),
            b = gmxDrawing.addGeoJSON(geoJSON, {
          fill: false,
          properties: it.properties
        })[0].getBounds();
        latLngBounds.extend(b);
      }

      if (latLngBounds.isValid()) {
        lmap.fitBounds(latLngBounds);
      }
    }; //files - массив File или WebForms


    queryLoadShp.prototype.loadAndShowFiles = function (files) {
      nsGmx$1.widgets.notifications.startAction('uploadShp');
      var def = $.when.apply($, [].slice.call(files).map(function (file) {
        return nsGmx$1.Utils.parseShpFile(file);
      }));
      def.then(function () {
        this._showObjectsOnMap(_.flatten([].slice.call(arguments)));

        nsGmx$1.widgets.notifications.stopAction('uploadShp', 'success', _gtxt('loadShape.loadDone'));
      }.bind(this), function () {
        nsGmx$1.widgets.notifications.stopAction('uploadShp', 'failure', _gtxt('loadShape.loadFail'));
      });
      return def;
    }; //Загружает файлы из поля "file"


    queryLoadShp.prototype.upload = function () {
      hide(this.inputControl);
      show(this.progress);
      this.loadAndShowFiles([this.postForm]).always(function () {
        this.inputControl.removeChild(this.postForm);

        this._regenerateControl();
      }.bind(this));
    };

    var _queryLoadShp = new queryLoadShp();

    drawingObjects.loadShp.load = function () {
      if ('File' in window) {
        $('<input type="file" multiple>').change(function (e) {
          _queryLoadShp.loadAndShowFiles(e.target.files);
        }).click();
      } else {
        //IE9
        var alreadyLoaded = _queryLoadShp.createWorkCanvas(arguments[0] || "shp");

        if (!alreadyLoaded) _queryLoadShp.load();
      }
    };

    drawingObjects.loadShp.unload = function () {};

    var _$4 = nsGmx$1.Utils._;
    var wmsProjections = ['EPSG:3395', 'EPSG:4326', 'EPSG:41001']; // типы проекций

    var getTextContent = function getTextContent(node) {
      if (typeof node.textContent != 'undefined') return node.textContent;
      var data = '';

      for (var i = 0; i < node.childNodes.length; i++) {
        data += node.childNodes[i].data;
      }

      return data;
    };

    var getScale = function getScale(z) {
      return Math.pow(2, -z) * 156543.033928041;
    };
    /** Формирует URL картинки, который можно использовать для получения WMS слоя для данного положения карты
     * @property {String} url - WMS ссылка.
     * @property {object} props - атрибуты.
     * @property {String} props.srs - тип проекции.
     * @property {String} props.version - версия.
     * @property {String} props.name - Идентификатор слоя.
     * @property {object} props.bbox - ограничение по bounds(в географических координатах).
     * @property {object} requestProperties - атрибуты формата результирующего image.
     * @property {String} requestProperties.format - тип (по умолчанию 'image/jpeg').
     * @property {String} requestProperties.transparent - прозрачность подложки ('TRUE'/'FALSE' по умолчанию 'FALSE').
     * @returns {object} - {url: String, bounds: {Extent}}. bounds в географических координатах.
    */


    var getWMSMapURL = function getWMSMapURL(url, props, requestProperties) {
      var CRSParam = {
        '1.1.1': 'SRS',
        '1.3.0': 'CRS'
      };
      requestProperties = requestProperties || {};
      var lmap = nsGmx$1.leafletMap,
          extend = lmap.getBounds();
      var miny = Math.max(extend.getSouth(), -90);
      var maxy = Math.min(extend.getNorth(), 90);
      var minx = Math.max(extend.getWest(), -180);
      var maxx = Math.min(extend.getEast(), 180);

      if (props.bbox) {
        minx = Math.max(props.bbox.minx, minx);
        miny = Math.max(props.bbox.miny, miny);
        maxx = Math.min(props.bbox.maxx, maxx);
        maxy = Math.min(props.bbox.maxy, maxy);
        if (minx >= maxx || miny >= maxy) return;
      }

      var mercMin = L.Projection.Mercator.project({
        lat: miny,
        lng: minx
      }),
          mercMax = L.Projection.Mercator.project({
        lat: maxy,
        lng: maxx
      });
      var scale = getScale(lmap.getZoom());
      var w = Math.round((mercMax.x - mercMin.x) / scale);
      var h = Math.round((mercMax.y - mercMin.y) / scale);
      var isMerc = !(props.srs == wmsProjections[1]);
      var st = url;
      var format = requestProperties.format || 'image/jpeg';
      var transparentParam = requestProperties.transparent ? 'TRUE' : 'FALSE';
      var version = props.version || '1.1.1';
      var isV130 = version === '1.3.0'; //st = st.replace(/Service=WMS[\&]*/i, '');
      //st = st.replace(/\&$/, '');

      st += (st.indexOf('?') == -1 ? '?' : '&') + 'request=GetMap&Service=WMS';
      st += "&layers=" + encodeURIComponent(props.name) + "&VERSION=" + encodeURIComponent(version) + "&" + CRSParam[version] + "=" + encodeURIComponent(props.srs) + "&styles=" + "&width=" + w + "&height=" + h + "&bbox=" + (isMerc ? mercMin.x : isV130 ? miny : minx) + "," + (isMerc ? mercMin.y : isV130 ? minx : miny) + "," + (isMerc ? mercMax.x : isV130 ? maxy : maxx) + "," + (isMerc ? mercMax.y : isV130 ? maxx : maxy);
      if (url.indexOf('format=') == -1) st += "&format=" + encodeURIComponent(format);
      if (url.indexOf('transparent=') == -1) st += "&transparent=" + encodeURIComponent(transparentParam);
      return {
        url: st,
        bounds: {
          minX: minx,
          maxX: maxx,
          minY: miny,
          maxY: maxy
        }
      };
    };
    /**
     * Возвращает описание WMS-слоёв от XML, которую вернул сервер на запрос GetCapabilities
     * @returns {Array} - массив объектов с описанием слоёв
    */


    var parseWMSCapabilities = function parseWMSCapabilities(response) {
      var supportedVersions = {
        '1.1.1': true,
        '1.3.0': true
      };
      var SRSTagName = {
        '1.1.1': 'SRS',
        '1.3.0': 'CRS'
      };
      var BBOXTagName = {
        '1.1.1': 'LatLonBoundingBox',
        '1.3.0': 'EX_GeographicBoundingBox'
      };
      var serviceLayers = []; // var strResp = response.replace(/[\t\n\r]/g, ' ');
      //     strResp = strResp.replace(/\s+/g, ' ');

      var xml = parseXML(response),
          mainTag = xml.getElementsByTagName('WMS_Capabilities')[0] || xml.getElementsByTagName('WMT_MS_Capabilities')[0],
          version = mainTag.getAttribute('version'),
          layersXML = xml.getElementsByTagName('Layer');

      if (!(version in supportedVersions)) {
        return [];
      }

      for (var i = 0; i < layersXML.length; i++) {
        var layer = {
          version: version
        },
            name = layersXML[i].getElementsByTagName('Name'),
            title = layersXML[i].getElementsByTagName('Title'),
            bbox = layersXML[i].getElementsByTagName(BBOXTagName[version]),
            srs = layersXML[i].getElementsByTagName(SRSTagName[version]);

        if (srs.length) {
          layer.srs = null;
          var supportedSrs = {};

          for (var si = 0; si < srs.length; si++) {
            var srsName = strip(getTextContent(srs[si]));
            supportedSrs[srsName] = true;
          } //порядок имеет значение!


          for (var p = 0; p < wmsProjections.length; p++) {
            if (wmsProjections[p] in supportedSrs) {
              layer.srs = wmsProjections[p];
              break;
            }
          }

          if (!layer.srs) continue;
        } else {
          layer.srs = wmsProjections[0];
        }

        if (name.length) layer.name = getTextContent(name[0]);

        if (bbox.length) {
          if (version == '1.1.1') {
            layer.bbox = {
              minx: Number(bbox[0].getAttribute('minx')),
              miny: Number(bbox[0].getAttribute('miny')),
              maxx: Number(bbox[0].getAttribute('maxx')),
              maxy: Number(bbox[0].getAttribute('maxy'))
            };
          } else {
            layer.bbox = {
              minx: Number(getTextContent(bbox[0].getElementsByTagName('westBoundLongitude')[0])),
              miny: Number(getTextContent(bbox[0].getElementsByTagName('southBoundLatitude')[0])),
              maxx: Number(getTextContent(bbox[0].getElementsByTagName('eastBoundLongitude')[0])),
              maxy: Number(getTextContent(bbox[0].getElementsByTagName('northBoundLatitude')[0]))
            };
          }
        }

        if (title.length) layer.title = getTextContent(title[0]);
        if (layer.name) serviceLayers.push(layer);
      }

      return serviceLayers;
    };

    var loadServerData = window.loadServerData = {
      WFS: {},
      WMS: {}
      /* Порядок координат в WFS зависит от формата SRS (http://geoserver.org/display/GEOSDOC/2.+WFS+-+Web+Feature+Service)
          * EPSG:xxxx: longitude/latitude (supported in WFS 1.1 requests too)
          * http://www.opengis.net/gml/srs/epsg.xml#xxxx: longitude/latitude (supported in WFS 1.1 requests too)
          * urn:x-ogc:def:crs:EPSG:xxxx: latitude/longitude
      */

    };

    var wfsParser = function wfsParser() {
      this.gmlns = window.location.protocol + '//www.opengis.net/gml';
      this.kmlns = window.location.protocol + '//earth.google.com/kml/2.0';
      this.axisOrder = null;
    };

    wfsParser.prototype.elementsNS = function (node, uri, name) {
      var elements = [];
      if (node.getElementsByTagNameNS) elements = node.getElementsByTagNameNS(uri, name);else {
        var allNodes = node.getElementsByTagName("*"),
            potentialNode,
            fullName;

        for (var i = 0, len = allNodes.length; i < len; ++i) {
          potentialNode = allNodes[i];
          fullName = potentialNode.prefix ? potentialNode.prefix + ":" + name : name;

          if (name == "*" || fullName == potentialNode.nodeName) {
            if (uri == "*" || uri == potentialNode.namespaceURI) elements.push(potentialNode);
          }
        }
      }
      return elements;
    };

    wfsParser.prototype.getChildValue = function (node, def) {
      var value = def || "";

      if (node) {
        for (var child = node.firstChild; child; child = child.nextSibling) {
          switch (child.nodeType) {
            case 3:
            case 4:
              value += child.nodeValue;
          }
        }
      }

      return value;
    };

    wfsParser.prototype.parse = function (response, srs) {
      var geometries = [];
      var strResp = response.replace(/[\t\n\r]/g, ' ');
      strResp = strResp.replace(/\s+/g, ' ');
      var xml = parseXML(strResp),
          parsedNS = strResp.indexOf('<kml') > -1 ? this.kmlns : this.gmlns;
      this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';
      var order = ["Polygon", "LineString", "Point"];

      for (var i = 0, len = order.length; i < len; ++i) {
        var type = order[i],
            nodeList = this.elementsNS(xml.documentElement, parsedNS, type);

        for (var j = 0; j < nodeList.length; ++j) {
          var geometry = this['parse' + type].apply(this, [nodeList[j]]);
          if (geometry) geometries.push(geometry);
        }
      }

      return geometries;
    };

    wfsParser.prototype.parsePoint = function (node) {
      var coordString,
          coords = [],
          nodeList = this.elementsNS(node, this.gmlns, "pos");

      if (nodeList.length > 0) {
        coordString = strip(nodeList[0].firstChild.nodeValue);
        coords = coordString.split(" ");
      }

      if (coords.length == 0) {
        nodeList = this.elementsNS(node, this.gmlns, "coordinates");

        if (nodeList.length > 0) {
          coordString = strip(nodeList[0].firstChild.nodeValue);
          coords = coordString.split(",");
        }
      }

      if (coords.length == 0) {
        nodeList = this.elementsNS(node, this.gmlns, "coord");

        if (nodeList.length > 0) {
          var xList = this.elementsNS(nodeList[0], this.gmlns, "X"),
              yList = this.elementsNS(nodeList[0], this.gmlns, "Y");
          if (xList.length > 0 && yList.length > 0) coords = [xList[0].firstChild.nodeValue, yList[0].firstChild.nodeValue];
        }
      }

      return {
        feature: {},
        geometry: {
          type: 'Point',
          coordinates: this.swapCoordinates([Number(coords[0]), Number(coords[1])])
        }
      };
    };

    wfsParser.prototype.parseLineString = function (node) {
      var coordString,
          coords = [],
          points = [],
          nodeList = this.elementsNS(node, this.gmlns, "posList");

      if (nodeList.length > 0) {
        coordString = strip(this.getChildValue(nodeList[0]));
        coords = coordString.split(" ");

        for (var i = 0; i < coords.length / 2; ++i) {
          var j = i * 2;
          points.push(this.swapCoordinates([Number(coords[j]), Number(coords[j + 1])]));
        }
      }

      if (coords.length == 0) {
        nodeList = this.elementsNS(node, this.gmlns, "coordinates");

        if (nodeList.length > 0) {
          coordString = strip(this.getChildValue(nodeList[0]));
          coordString = coordString.replace(/\s*,\s*/g, ",");
          var pointList = coordString.split(" ");

          for (var _i = 0; _i < pointList.length; ++_i) {
            coords = pointList[_i].split(",");
            points.push(this.swapCoordinates([Number(coords[0]), Number(coords[1])]));
          }
        }
      }

      if (points.length != 0) {
        return {
          feature: {},
          geometry: {
            type: 'LineString',
            coordinates: points
          }
        };
      } else return false;
    };

    wfsParser.prototype.parsePolygon = function (node) {
      var nodeList = this.elementsNS(node, this.gmlns, "LinearRing"),
          components = [];

      if (nodeList.length > 0) {
        var ring;

        for (var i = 0; i < nodeList.length; ++i) {
          ring = this.parseLineString.apply(this, [nodeList[i], true]);
          if (ring) components.push(ring.geometry.coordinates);
        }
      }

      return {
        feature: {},
        geometry: {
          type: 'Polygon',
          coordinates: components
        }
      };
    };

    wfsParser.prototype.swapCoordinates = function (arr) {
      if (this.axisOrder == 'latlong') return [arr[1], arr[0]];else return [arr[0], arr[1]];
    };

    var _wfsParser = new wfsParser();

    var jsonParser = function jsonParser() {
      this.axisOrder = null;
    };

    jsonParser.prototype.parse = function (response, srs) {
      var resp = JSON.parse(response),
          geometries = [];
      this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';

      for (var i = 0; i < resp.features.length; i++) {
        if (resp.features[i].geometry.type.toLowerCase().indexOf('point') > -1) this.parsePoint(resp.features[i], geometries);else if (resp.features[i].geometry.type.toLowerCase().indexOf('linestring') > -1) this.parseLineString(resp.features[i], geometries);else if (resp.features[i].geometry.type.toLowerCase().indexOf('polygon') > -1) this.parsePolygon(resp.features[i], geometries);
      }

      return geometries;
    };

    jsonParser.prototype.parsePoint = function (feature, geometryArr) {
      if (feature.geometry.type.toLowerCase().indexOf('multi') < 0) geometryArr.push({
        feature: feature,
        geometry: {
          type: 'POINT',
          coordinates: this.swapCoordinates(feature.geometry.coordinates)
        }
      });else {
        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
          geometryArr.push({
            feature: feature,
            geometry: {
              type: 'POINT',
              coordinates: this.swapCoordinates(feature.geometry.coordinates[i])
            }
          });
        }
      }
    };

    jsonParser.prototype.parseLineString = function (feature, geometryArr) {
      if (feature.geometry.type.toLowerCase().indexOf('multi') < 0) {
        var newCoords = [];

        for (var j = 0; j < feature.geometry.coordinates.length; j++) {
          newCoords.push(this.swapCoordinates(feature.geometry.coordinates[j]));
        }

        geometryArr.push({
          feature: feature,
          geometry: {
            type: 'LINESTRING',
            coordinates: newCoords
          }
        });
      } else {
        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
          var _newCoords = [];

          for (var _j = 0; _j < feature.geometry.coordinates[i].length; _j++) {
            _newCoords.push(this.swapCoordinates(feature.geometry.coordinates[i][_j]));
          }

          geometryArr.push({
            feature: feature,
            geometry: {
              type: 'LINESTRING',
              coordinates: _newCoords
            }
          });
        }
      }
    };

    jsonParser.prototype.parsePolygon = function (feature, geometryArr) {
      if (feature.geometry.type.toLowerCase().indexOf('multi') < 0) {
        var newCoords = [];
        var k = 0,
            j = 0;

        for (k = 0; k < feature.geometry.coordinates.length; j++) {
          var newCoords2 = [];

          for (j = 0; j < feature.geometry.coordinates[k].length; k++) {
            newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[k][j]));
          }

          newCoords.push(newCoords2);
        }

        geometryArr.push({
          feature: feature,
          geometry: {
            type: 'POLYGON',
            coordinates: newCoords
          }
        });
      } else {
        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
          var _newCoords2 = [];

          for (var _k = 0; _k < feature.geometry.coordinates[i].length; _k++) {
            var _newCoords3 = [];

            for (var _j2 = 0; _j2 < feature.geometry.coordinates[i][_k].length; _j2++) {
              _newCoords3.push(this.swapCoordinates(feature.geometry.coordinates[i][_k][_j2]));
            }

            _newCoords2.push(_newCoords3);
          }

          geometryArr.push({
            feature: feature,
            geometry: {
              type: 'POLYGON',
              coordinates: _newCoords2
            }
          });
        }
      }
    };

    jsonParser.prototype.swapCoordinates = function (arr) {
      if (this.axisOrder == 'latlong') return [arr[1], arr[0]];else return [arr[0], arr[1]];
    };

    var _jsonParser = new jsonParser();

    var queryServerData = function queryServerData() {
      this.inputField = null;
      this.parentCanvas = null;
      this.wfsFormats = {};
      this.oldBalloon = false;
      this.oldBalloonIndex = -1;
      this.proj = ['EPSG:4326', 'EPSG:3395', 'EPSG:41001'];
      this.customParams = undefined;
    };

    queryServerData.prototype = new leftMenu();
    /**
        Загружает виджет для добавления/просмотра WMS/WFS слоёв
     @param protocol
     @param parseFunc
     @param drawFunc
     @param customParamsManager {object}- контролер дополнительных параметров. Имеет методы: <br/>
            - init(targetDiv)->void Добавляет контрол к элементу targetDiv<br/>
            - collect()->Object Возвращает выбранные пользователем объекты<br/>
     @param version {string} Версия протокола, которая будет использоваться
    */

    queryServerData.prototype.load = function (protocol, parseFunc, drawFunc, customParamsManager) {
      window.convertCoords = function (coordsStr) {
        var res = [],
            coordsPairs = strip(coordsStr).replace(/\s+/, ' ').split(' ');

        if (coordsStr.indexOf(',') == -1) {
          for (var j = 0; j < Math.floor(coordsPairs.length / 2); j++) {
            res.push([Number(coordsPairs[2 * j + 1]), Number(coordsPairs[2 * j])]);
          }
        } else {
          for (var _j3 = 0; _j3 < coordsPairs.length; _j3++) {
            var parsedCoords = coordsPairs[_j3].split(',');

            res.push([Number(parsedCoords[1]), Number(parsedCoords[0])]);
          }
        }

        return res;
      };

      window.parseGML = function (response, format, srs) {
        if (format == 'gml') return _wfsParser.parse(response, srs);else if (format == 'json') return _jsonParser.parse(response, srs);else return [];
      };

      var inputField = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]);

      this.parentCanvas = _div(null, [['dir', 'className', 'serverDataCanvas']]);

      var goButton = makeButton(_gtxt("Загрузить")),
          _this = this;

      var doGetCapabilities = function doGetCapabilities() {
        if (inputField.value != '') {
          if (customParamsManager) _this.customParams = customParamsManager.collect();

          _this.getCapabilities(protocol, strip(inputField.value), parseFunc, drawFunc);

          inputField.value = '';
        } else inputError(inputField);
      };

      goButton.onclick = doGetCapabilities;
      $(inputField).on('keydown', function (e) {
        if (e.keyCode === 13) {
          doGetCapabilities();
          return false;
        }
      });

      var canvas = _div([_div([_span([_t(_gtxt("URL сервера"))])], [['css', 'marginBottom', '3px']]), _table([_tbody([_tr([_td([inputField]), _td([goButton])])])], [['css', 'marginBottom', '5px']])], [['css', 'margin', '3px 0px 0px 10px']]);

      if (customParamsManager) {
        var customParamsDiv = _div();

        $(canvas).append(customParamsDiv);
        _this.customParams = customParamsManager.init(customParamsDiv);
      }

      _$4(this.workCanvas, [canvas, this.parentCanvas]);
    };

    queryServerData.prototype.getCapabilities = function (protocol, url, parseFunc, drawFunc, version) {
      var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
          _this = this;

      if (this.parentCanvas.childNodes.length == 0) _$4(this.parentCanvas, [loading]);else this.parentCanvas.insertBefore(loading, this.parentCanvas.firstChild);
      var capabilitiesUrl = url.replace(/REQUEST=GetCapabilities[&]*/i, '').replace(new RegExp('SERVICE=' + protocol + '[&]', 'i'), '').replace(/&$/, '');
      capabilitiesUrl += capabilitiesUrl.indexOf('?') !== -1 ? '&' : '?';
      capabilitiesUrl += 'REQUEST=GetCapabilities&SERVICE=' + protocol;

      if (version) {
        capabilitiesUrl += '&VERSION=' + version;
      }

      sendCrossDomainJSONRequest(window.serverBase + "ApiSave.ashx?get=" + encodeURIComponent(capabilitiesUrl), function (response) {
        if (!parseResponse(response)) return;
        var servicelayers = parseFunc.call(_this, response.Result);
        drawFunc.call(_this, servicelayers, url, loading, undefined, _this.customParams);
      });
    };

    queryServerData.prototype.parseWFSCapabilities = function (response) {
      var serviceLayers = [],
          // strResp = response.replace(/[\t\n\r]/g, ' '),
      // strResp = strResp.replace(/\s+/g, ' '),
      featuresXML = parseXML(response).getElementsByTagName('FeatureType');

      for (var i = 0; i < featuresXML.length; i++) {
        var layer = {},
            name = featuresXML[i].getElementsByTagName('Name'),
            title = featuresXML[i].getElementsByTagName('Title'),
            srs = featuresXML[i].getElementsByTagName('DefaultSRS');
        if (name.length) layer.name = getTextContent(name[0]);
        if (title.length) layer.title = getTextContent(title[0]);
        if (srs.length) layer.srs = getTextContent(srs[0]);
        if (layer.name) serviceLayers.push(layer);
      }

      return serviceLayers;
    };

    queryServerData.prototype.loadGML = function (url, parentTreeCanvas, box, header, format, loadLayerParams, srs) {
      var _this = this;

      sendCrossDomainJSONRequest(window.serverBase + "ApiSave.ashx?get=" + encodeURIComponent(url), function (response) {
        if (!parseResponse(response)) return;
        var geometries = window.parseGML(response.Result, format, srs);

        _this.drawGML(geometries, url, parentTreeCanvas, box, header, loadLayerParams);
      });
    };

    queryServerData.prototype.saveGML = function (geometries) {
      if (typeof geometries == 'undefined' || geometries == null) {
        geometries = [];
        window.globalFlashMap.drawing.forEachObject(function (ret) {
          geometries.push(ret.geometry);
        });
      }

      window.promptFunction(_gtxt('Введите имя gml-файла для скачивания:'), 'objects.gml', function (fileName) {
        window.globalFlashMap.saveObjects(geometries, nsGmx$1.Utils.translit(fileName));
      });
      return false;
    };

    queryServerData.prototype.drawGML = function (geometries, url, parentTreeCanvas, box) {
      var parent = {
        'Point': L.gmx.createLayer({
          properties: {}
        }).addTo(nsGmx$1.leafletMap),
        'LineString': L.gmx.createLayer({
          properties: {}
        }).addTo(nsGmx$1.leafletMap),
        'Polygon': L.gmx.createLayer({
          properties: {}
        }).addTo(nsGmx$1.leafletMap)
      }; // var styles = {
      //          'Point': typeof loadLayerParams != 'undefined' && loadLayerParams['point'] ? loadLayerParams['point'].RenderStyle : { marker: { size: 2 }, outline: { color: 0x0000ff, thickness: 1 } },
      //          'LineString': typeof loadLayerParams != 'undefined' && loadLayerParams['linestring'] ? loadLayerParams['linestring'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2 } },
      //          'Polygon': typeof loadLayerParams != 'undefined' && loadLayerParams['polygon'] ? loadLayerParams['polygon'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2, opacity: 100 }, fill: {color: 0xffffff, opacity: 20} }
      //      };
      // parent['POINT'].setStyle(styles['POINT']);
      // parent['LINESTRING'].setStyle(styles['LINESTRING']);
      // parent['POLYGON'].setStyle(styles['POLYGON']);

      var geomsPresent = {},
          bounds = L.gmxUtil.bounds(),
          items = {
        'Point': [],
        'LineString': [],
        'Polygon': []
      };

      for (var i = 0; i < geometries.length; i++) {
        //var elem = parent[geometries[i].geometry.type].addObject(geometries[i].geometry);
        items[geometries[i].geometry.type].push([L.gmxUtil.geoJSONtoGeometry(geometries[i].geometry, true)]); //parent[geometries[i].geometry.type].addItems();

        /*if (objLength(geometries[i].feature) > 0)
        {
            (function(i)
            {
                elem.setHandler("onClick", function(obj)
                {
                    var elemCanvas = $(divCanvas).find("[geometryType='" + geometries[i].geometry.type + "']")[0];
                      if (!elemCanvas.graphDataProperties ||
                        !geometries[i].feature.properties)
                        return;
                      var balloonCanvas = _div();
                      if (!_diagram.createBalloon(obj, balloonCanvas))
                        return;
                      if (_diagram.createDateTimeDiagramByAttrs(balloonCanvas, 500, 300, geometries[i].feature.properties, elemCanvas.graphDataProperties))
                        _diagram.oldBalloon.resize();
                })
            })(i);
        }*/

        geomsPresent[geometries[i].geometry.type] = true;
        bounds.extendArray(geometries[i].geometry.coordinates[0]);
      }

      parent['Point'].addData(items['Point']);
      parent['LineString'].addData(items['LineString']);
      parent['Polygon'].addData(items['Polygon']);

      var divCanvas = _div(),
          divChilds = _div(),
          // spanHeader = _span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')]),
      _this = this;

      var clickFunc = function clickFunc(flag) {
        var lmap = nsGmx$1.leafletMap,
            method = flag ? 'addLayer' : 'removeLayer';
        lmap[method](parent['Point']);
        lmap[method](parent['LineString']);
        lmap[method](parent['Polygon']);
        if (flag) show(divChilds);else hide(divChilds);
      };

      parentTreeCanvas.loaded = function () // переопределим функцию загрузки слоя на центрирование
      {
        if (!box.checked) {
          clickFunc.call(_this, true);
          box.checked = true;
        } //globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);


        nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
      };

      parentTreeCanvas.clear = function () {
        var lmap = nsGmx$1.leafletMap;
        lmap.removeLayer(parent['Point']);
        lmap.removeLayer(parent['LineString']);
        lmap.removeLayer(parent['Polygon']);
        divCanvas.removeNode(true);
      };

      box.onclick = function () {
        clickFunc.call(_this, this.checked);
      };

      $(parentTreeCanvas).empty();
      if (parentTreeCanvas.childNodes.length == 0) _$4(parentTreeCanvas, [divCanvas]);else parentTreeCanvas.insertBefore(divCanvas, parentTreeCanvas.firstChild);

      _$4(divCanvas, [divChilds]); // for (var type in geomsPresent)
      // {
      // var elemCanvas = _div(null, [['css','padding','2px'],['attr','geometryType', type]]),
      // //icon = _mapHelper.createStylesEditorIcon([{MinZoom:1,MaxZoom:20,RenderStyle:styles[type]}], type.toLowerCase()),
      // spanElem = _span(null, [['dir','className','layerfeature']]);
      // if (type == 'Point')
      // _(spanElem, [_t(_gtxt('точки'))]);
      // else if (type == 'LineString')
      // _(spanElem, [_t(_gtxt('линии'))]);
      // else if (type == 'Polygon')
      // _(spanElem, [_t(_gtxt('полигоны'))]);
      // var icon;
      // (function(type){
      // icon = _mapHelper.createWFSStylesEditor(parent[type], styles[type], type.toLowerCase(), divCanvas)
      // })(type);
      // if (typeof loadLayerParams != 'undefined' && loadLayerParams[type.toLowerCase()])
      // {
      // var info = loadLayerParams[type.toLowerCase()];
      // elemCanvas.graphDataType = info.graphDataType;
      // elemCanvas.graphDataProperties = info.graphDataProperties;
      // }
      // else
      // {
      // elemCanvas.graphDataType = "func";
      // elemCanvas.graphDataProperties = "";
      // }
      // _(elemCanvas, [icon, spanElem])
      // _(divChilds, [elemCanvas]);
      // }
      //globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);


      nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
      box.checked = true;
    }; //loadParams - параметры для отдельных слоёв
    //serverParams - параметры сервера, которые были указаны пользователем.


    queryServerData.prototype.drawWMS = function (serviceLayers, url, replaceElem, loadParams, serverParams) {
      var ulCanvas = _ul(null, [['css', 'paddingBottom', '5px'], ['attr', 'url', url]]),
          ulChilds = _ul(),
          remove = makeImageButton('img/closemin.png', 'img/close_orange.png'),
          lmap = nsGmx$1.leafletMap;

      $(replaceElem).replaceWith(ulCanvas);
      $(ulCanvas).data('serverParams', serverParams);

      remove.onclick = function () {
        for (var i = 0; i < ulChilds.childNodes.length; i++) {
          ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
          lmap.removeLayer(ulChilds.childNodes[i].firstChild.lastChild.gmxObject);
        }

        this.parentNode.parentNode.parentNode.removeNode(true);
      };

      remove.className = 'remove';
      remove.style.right = '0px';

      _$4(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')], [['dir', 'className', 'urlHeader']]), remove], [['css', 'position', 'relative']]), ulChilds])]);

      var clickFunc = function clickFunc(layer, parent, flag) {
        if (!flag) {
          lmap.removeLayer(parent);
        } else {
          updateFunc(layer, parent);
          lmap.addLayer(parent);
        }
      };

      var updateFunc = function updateFunc(layer, parent) {
        var requestParams = {};

        if (serverParams && serverParams.format) {
          requestParams.format = "image/" + serverParams.format;
          requestParams.transparent = serverParams.format === 'png';
        }

        var res = getWMSMapURL(url, layer, requestParams);

        if (res) {
          var b = res.bounds;
          parent.clearLayers();
          parent.addLayer(L.imageOverlay(window.serverBase + "ImgSave.ashx?now=true&get=" + encodeURIComponent(res.url), L.latLngBounds([[b.minY, b.minX], [b.maxY, b.maxX]])));
        }
      };

      serviceLayers.forEach(function (layer) {
        var elemCanvas = _div(null, [['css', 'padding', '2px']]),
            box = _checkbox(false, 'checkbox'),
            spanElem = _span([_t(layer.title)], [['css', 'cursor', 'pointer'], ['dir', 'className', 'layerfeature']]),
            parent = L.layerGroup().addTo(nsGmx$1.leafletMap);

        spanElem.gmxObject = parent;
        box.className = 'floatLeft';

        spanElem.onclick = function () {
          if (!box.checked) box.checked = true;
          clickFunc(layer, parent, true);
        };

        box.onclick = function () {
          clickFunc(layer, parent, this.checked);
        };

        box.update = function () {
          updateFunc(layer, parent);
        };

        box.setAttribute('layerName', layer.name);

        _$4(elemCanvas, [box, spanElem]);

        _$4(ulChilds, [_li([elemCanvas])]);

        if (typeof loadParams != 'undefined' && loadParams[layer.name]) $(spanElem).trigger("click");
      });
      $(ulCanvas).treeview();
      nsGmx$1.leafletMap.on('moveend', function () {
        var boxes = ulChilds.getElementsByTagName('input');

        for (var i = 0; i < boxes.length; i++) {
          if (boxes[i].checked) boxes[i].update();
        }
      });
    }; //Добавляет контрол выбора формата запроса к WMS и возвращает его в параметре format (пример: "png", "jpg")


    queryServerData.prototype.customWMSParamsManager = function () {
      var _targetDiv = null;
      return {
        init: function init(targetDiv) {
          var select = nsGmx$1.Utils._select([_option([_t('png')]), _option([_t('jpeg')])], [['dir', 'className', 'selectStyle'], ['css', 'width', '60px']]);

          _targetDiv = targetDiv;

          _$4(_targetDiv, [_t(_gtxt('Формат изображения') + ': '), select]);

          _targetDiv.style.marginBottom = '5px';
        },
        collect: function collect() {
          return {
            format: $("option:selected", _targetDiv).text()
          };
        }
      };
    }();

    queryServerData.prototype.drawWFS = function (serviceLayers, url, replaceElem, loadParams) {
      var ulCanvas = _ul(null, [['css', 'paddingBottom', '5px'], ['attr', 'url', url]]),
          ulChilds = _ul(),
          divFormat = _div(),
          remove = makeImageButton('img/closemin.png', 'img/close_orange.png'),
          _this = this;

      $(replaceElem).replaceWith(ulCanvas);

      remove.onclick = function () {
        for (var i = 0; i < ulChilds.childNodes.length; i++) {
          ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
        }

        this.parentNode.parentNode.parentNode.removeNode(true);
      };

      remove.className = 'remove';
      remove.style.right = '0px';

      _$4(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')], [['dir', 'className', 'urlHeader']]), divFormat, remove], [['css', 'position', 'relative']]), ulChilds])]);

      var formatSelect = nsGmx$1.Utils._select([_option([_t("JSON")], [['attr', 'value', 'json']]), _option([_t("GML / KML")], [['attr', 'value', 'gml']])], [['dir', 'className', 'selectStyle'], ['css', 'width', '100px']]);

      _$4(divFormat, [formatSelect]);

      var clickFunc = function clickFunc(layer, flag, elemCanvas, box, header, loadLayerParams) {
        if (flag) {
          var newFormat = formatSelect.value; // загружаем данные только один раз

          if (!elemCanvas.loaded || elemCanvas.format != newFormat) {
            elemCanvas.clear && elemCanvas.clear();
            var separator = url.indexOf('?') !== -1 ? '&' : '?';
            var objUrl = url + separator + "request=GetFeature&version=1.0.0&typeName=" + layer.name;
            if (formatSelect.value == 'json') objUrl += '&outputFormat=json';

            _this.loadGML(objUrl, elemCanvas, box, header, newFormat, loadLayerParams, layer.srs);

            elemCanvas.loaded = true;
            elemCanvas.format = newFormat;

            var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px']]);

            _$4(elemCanvas, [loading]);
          } else if (typeof elemCanvas.loaded == 'function') {
            elemCanvas.loaded();
          }
        }
      };

      for (var i = 0; i < serviceLayers.length; i++) {
        var elemCanvas = _div(null, [['css', 'padding', '2px']]),
            box = _checkbox(false, 'checkbox'),
            spanElem = _span([_t(serviceLayers[i].title != '' ? serviceLayers[i].title : serviceLayers[i].name)], [['css', 'cursor', 'pointer'], ['dir', 'className', 'layerfeature']]),
            elemChilds = _div(null, [['css', 'marginLeft', '20px']]);

        box.className = 'floatLeft';
        box.setAttribute('layerName', serviceLayers[i].name);

        (function (layer, parentTreeCanvas, box, header) {
          spanElem.onclick = function () {
            if (!box.checked) box.checked = true;
            clickFunc.call(_this, layer, true, parentTreeCanvas, box, header);
          };

          box.onclick = function () {
            clickFunc.call(_this, layer, this.checked, parentTreeCanvas, box, header);
          };
        })(serviceLayers[i], elemChilds, box, spanElem);

        _$4(elemCanvas, [box, _div([spanElem], [['css', 'display', 'inline']]), elemChilds]);

        _$4(ulChilds, [_li([elemCanvas])]);

        if (typeof loadParams != 'undefined' && loadParams[serviceLayers[i].name]) {
          if (!box.checked) box.checked = true;
          formatSelect.value = loadParams[serviceLayers[i].name].format;
          clickFunc.call(_this, serviceLayers[i], true, elemChilds, box, spanElem, loadParams[serviceLayers[i].name].info);
        }
      }

      $(ulCanvas).treeview();
    };

    var _queryServerDataWFS = new queryServerData(),
        _queryServerDataWMS = new queryServerData();

    loadServerData.WFS.load = function () {
      var alreadyLoaded = _queryServerDataWFS.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryServerDataWFS.load('WFS', _queryServerDataWFS.parseWFSCapabilities, _queryServerDataWFS.drawWFS, null, '1.0.0');
    };

    loadServerData.WFS.unload = function () {//  removeChilds($$('leftContent'))
    };

    loadServerData.WMS.load = function () {
      var alreadyLoaded = _queryServerDataWMS.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryServerDataWMS.load('WMS', parseWMSCapabilities, _queryServerDataWMS.drawWMS, _queryServerDataWMS.customWMSParamsManager);
    };

    loadServerData.WMS.unload = function () {//  removeChilds($$('leftContent'))
    };

    nsGmx$1.userObjectsManager.addDataCollector('wms', {
      collect: function collect() {
        if (!_queryServerDataWMS.workCanvas) return null;
        var value = {};
        $(_queryServerDataWMS.workCanvas.lastChild).children("ul[url]").each(function () {
          var url = this.getAttribute('url');
          var serverParams = $(this).data('serverParams');
          value[url] = {
            params: serverParams,
            layersVisibility: {}
          };
          $(this).find("input[type='checkbox']").each(function () {
            if (this.checked) {
              value[url].layersVisibility[this.getAttribute('layerName')] = true;
            }
          });
        });
        if (!objLength(value)) return null;
        return value;
      },
      load: function load(data) {
        if (!data) return;
        $('#left_wms').remove();
        _queryServerDataWMS.builded = false;
        loadServerData.WMS.load('wms');

        for (var url in data) {
          (function (loadParams) {
            //поддержка старого формата данных
            if (!('layersVisibility' in loadParams)) {
              loadParams = {
                layersVisibility: loadParams
              };
            }

            _queryServerDataWMS.getCapabilities('WMS', url, parseWMSCapabilities, function (serviceLayers, url, replaceElem) {
              _queryServerDataWMS.drawWMS(serviceLayers, url, replaceElem, loadParams.layersVisibility, loadParams.params);
            });
          })(data[url]);
        }
      }
    });
    nsGmx$1.userObjectsManager.addDataCollector('wfs', {
      collect: function collect() {
        if (!_queryServerDataWFS.workCanvas) return null;
        var value = {};
        $(_queryServerDataWFS.workCanvas.lastChild).children("ul[url]").each(function () {
          var url = this.getAttribute('url');
          value[url] = {};
          $(this).find("input[type='checkbox']").each(function () {
            if (this.checked) {
              var wfsLayerInfo = {};
              $(this.parentNode.lastChild).find(".colorIcon").each(function () {
                wfsLayerInfo[this.geometryType] = {
                  RenderStyle: this.getStyle(),
                  graphDataType: this.parentNode.graphDataType,
                  graphDataProperties: this.parentNode.graphDataProperties
                };
              });
              value[url][this.getAttribute('layerName')] = {
                format: this.parentNode.lastChild.format,
                info: wfsLayerInfo
              };
            }
          });
        });
        if (!objLength(value)) return null;
        return value;
      },
      load: function load(data) {
        if (!data) return;
        $('#left_wfs').remove();
        _queryServerDataWFS.builded = false;
        loadServerData.WFS.load('wfs');

        for (var url in data) {
          (function (loadParams) {
            _queryServerDataWFS.getCapabilities('WFS', url, _queryServerDataWFS.parseWFSCapabilities, function (serviceLayers, url, replaceElem) {
              _queryServerDataWFS.drawWFS(serviceLayers, url, replaceElem, loadParams);
            }, '1.0.0');
          })(data[url]);
        }
      }
    });

    /**
        Возвращает массив ссылок в верхнее левое мета-меню в формате HeaderWidget из CommonComponents.
        Считывает информацию из window.gmxViewerUI.headerLinkItems в формате [{icon: iconPath, title: TITLE, href: HREF}, ...] (формат ГеоМиксера)
        Если переменной нет, подставляет значения по умолчению ("Карта пожаров", "Поиск снимков", "Платформа Геомиксер")
        @memberOf nsGmx
    */

    nsGmx$1.addHeaderLinks = function () {
      var isHeaderLinks = false;
      if (typeof window.headerLinks === 'boolean') isHeaderLinks = window.headerLinks; //совместимость с предыдущими версиями

      if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.headerLinks !== 'undefined') isHeaderLinks = window.gmxViewerUI.headerLinks;

      if (!isHeaderLinks) {
        return [];
      }

      var items = window.gmxViewerUI && window.gmxViewerUI.headerLinkItems || [{
        title: _gtxt("Карта пожаров"),
        href: _gtxt("http://fires.ru"),
        newWindow: true
      }, {
        title: _gtxt("Поиск снимков"),
        href: _gtxt("https://search.kosmosnimki.ru"),
        newWindow: true
      }, {
        title: _gtxt("Платформа Геомиксер"),
        newWindow: true,
        id: 'HeaderLinkGeoMixer'
      }];
      return $.extend(true, [], items).map(function (item, index) {
        item.link = item.href;
        return {
          id: 'headerLinksItem' + index,
          title: item.title,
          func: function () {
            if (item.link) {
              window.open(item.link, '_blank');
            }
          }.bind(item)
        };
      });
    };

    nsGmx$1.TransparencySliderWidget = function (container) {
      var _this = this;

      var ui = $(Handlebars.compile('<div class="leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency svgIcon leaflet-control gmx-transslider-toggle-icon" title="{{i "TransparencySliderWidget.title"}}"><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency"></use></svg></div>' + '<div class = "gmx-transslider-container"></div>' + '<div class = "leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency-eye svgIcon leaflet-gmx-iconSvg-active leaflet-control gmx-transslider-onoff" title="{{i "TransparencySliderWidget.onOffTitle"}}"><svg role="img" class="svgIcon gmx-transslider-hide"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye"></use></svg><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye-off"></use></svg></div>')());
      ui.appendTo(container);
      var sliderContainer = container.find('.gmx-transslider-container');
      this._isCollapsed = true;
      container.find('.gmx-transslider-toggle-icon').click(function () {
        this._isCollapsed = !this._isCollapsed;
        sliderContainer.toggle(!this._isCollapsed);
        container.find('.gmx-transslider-onoff').toggle(!this._isCollapsed);
        container.find('.gmx-transslider-toggle-icon').toggleClass('leaflet-gmx-iconSvg-active', !this._isCollapsed);
      }.bind(this));
      var isOpaque = true;

      var updateOnOffIcon = function updateOnOffIcon(value) {
        var isOpaqueNew = value === 1.0;

        if (isOpaqueNew !== isOpaque) {
          isOpaque = isOpaqueNew;
          var arr = container.find('.gmx-transslider-onoff')[0].childNodes;

          if (isOpaque) {
            L.DomUtil.removeClass(arr[1], 'gmx-transslider-hide');
            L.DomUtil.addClass(arr[0], 'gmx-transslider-hide');
          } else {
            L.DomUtil.removeClass(arr[0], 'gmx-transslider-hide');
            L.DomUtil.addClass(arr[1], 'gmx-transslider-hide');
          }
        }
      };

      sliderContainer.slider({
        range: 'min',
        min: 0.0,
        max: 1.0,
        step: 0.01,
        value: 1.0,
        change: function change(event, ui) {
          $(_this).triggerHandler(event, ui);
          updateOnOffIcon(ui.value);
        },
        slide: function slide(event, ui) {
          $(_this).triggerHandler(event, ui);
          updateOnOffIcon(ui.value);
        }
      }).hide(); // fix map moving in IE

      if (nsGmx$1.leafletMap) {
        var dragging = nsGmx$1.leafletMap.dragging;
        L.DomEvent.on(sliderContainer[0], 'mouseover', dragging.disable, dragging).on(sliderContainer[0], 'mouseout', dragging.enable, dragging);
      }

      container.find('.gmx-transslider-onoff').click(function () {
        var curValue = sliderContainer.slider('value');
        sliderContainer.slider('value', curValue !== 1.0 ? 1.0 : 0.0);
      }).hide();
      container.on('mousedown click', function (event) {
        event.stopPropagation();
      });
    };

    nsGmx$1.TransparencySliderWidget.prototype.isCollapsed = function () {
      return this._isCollapsed;
    };

    nsGmx$1.Translations.addText('rus', {
      TransparencySliderWidget: {
        title: 'Прозрачность растровых слоёв',
        onOffTitle: 'Показать/скрыть растры'
      }
    });
    nsGmx$1.Translations.addText("eng", {
      TransparencySliderWidget: {
        title: 'Raster layers transparency',
        onOffTitle: 'Show/hide rasters'
      }
    });

    L.Control.GmxLayers2 = L.Control.Layers.extend({
      options: {
        collapsed: true,
        autoZIndex: false,
        id: 'layers'
      },
      initialize: function initialize(baseLayers, overlays, options) {
        L.Control.Layers.prototype.initialize.call(this, baseLayers, overlays, options);
      },
      onAdd: function onAdd(map) {
        L.Control.Layers.prototype.onAdd.call(this, map);
        this.init = false;

        this._initLayout();

        this._update();

        this._iconClick = function () {
          if (this._iconContainer) {
            this.setActive(!this.options.isActive);

            this._update();

            if (this.options.stateChange) {
              this.options.stateChange(this);
            }
          }
        };

        var stop = L.DomEvent.stopPropagation;
        L.DomEvent.on(this._iconContainer, 'mousemove', stop).on(this._iconContainer, 'touchstart', stop).on(this._iconContainer, 'mousedown', stop).on(this._iconContainer, 'dblclick', stop).on(this._iconContainer, 'click', stop).on(this._iconContainer, 'click', this._iconClick, this);
        return this._container;
      },
      _initLayout: function _initLayout() {
        var controlClassName = 'leaflet-control-layers2',
            prefix = 'leaflet-gmx-iconSvg',
            iconClassName = prefix + ' ' + prefix + '-overlays svgIcon',
            listClassName = 'leaflet-control-layers',
            container = this._container = L.DomUtil.create('div', controlClassName),
            iconContainer = this._iconContainer = L.DomUtil.create('div', iconClassName),
            listContainer = this._listContainer = L.DomUtil.create('div', listClassName);
        var openingDirection = this.options.direction || 'bottom';
        L.DomUtil.addClass(listContainer, listClassName + '-' + openingDirection);

        if (this.options.title) {
          this._iconContainer.title = this.options.title;
        }

        this._prefix = prefix; //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released

        container.setAttribute('aria-haspopup', true);

        if (!L.Browser.touch) {
          L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
        } else {
          L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
        }

        var placeHolder = this._placeHolder = L.DomUtil.create('div', 'layers-placeholder');
        placeHolder.innerHTML = this.options.placeHolder;
        var form = this._form = L.DomUtil.create('form', listClassName + '-list');

        if (this.options.collapsed) {
          var useHref = '#' + 'overlays';
          iconContainer.innerHTML = '<svg role="img" class="svgIcon">\
              <use xlink:href="' + useHref + '"></use>\
            </svg>';
          var link = this._layersLink = L.DomUtil.create('a', '', listContainer);
          link.href = '#';
          link.title = 'Layers';

          if (L.Browser.touch) {
            L.DomEvent.on(iconContainer, 'click', L.DomEvent.stop).on(iconContainer, 'click', this._expand, this);
          } //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033


          L.DomEvent.on(form, 'click', function () {
            setTimeout(L.bind(this._onInputClick, this), 0);
          }, this);

          this._map.on('click', this._collapse, this);
        } else {
          this._expand();
        }

        this._baseLayersList = L.DomUtil.create('div', listClassName + '-base', form);
        this._separator = L.DomUtil.create('div', listClassName + '-separator', form);
        this._overlaysList = L.DomUtil.create('div', listClassName + '-overlays', form);
        listContainer.appendChild(form);
        listContainer.appendChild(placeHolder);
        container.appendChild(iconContainer);
        container.appendChild(listContainer);

        if (!this.init) {
          container.style.display = 'none';
        }
      },
      _addLayer: function _addLayer(layer, name, overlay) {
        if (Object.keys(this._layers).length === 0) {
          this.init = true;
        }

        L.Control.Layers.prototype._addLayer.call(this, layer, name, overlay);
      },
      _addItemObject: function _addItemObject(obj) {
        var label = this._addItem(obj);

        if (obj.layer && obj.layer._gmx && obj.layer._gmx.layerID) {
          label.className = '_' + obj.layer._gmx.layerID;
        }
      },
      _addItem: function _addItem(obj) {
        if (L.version === '0.7.7') {
          var label = document.createElement('label'),
              input,
              checked = this._map.hasLayer(obj.layer);

          if (obj.overlay) {
            input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'leaflet-control-layers-selector';
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement('leaflet-base-layers', checked);
          }

          input.layerId = L.stamp(obj.layer);
          L.DomEvent.on(input, 'click', this._onInputClick, this);
          var name = document.createElement('span');
          name.innerHTML = ' ' + obj.name;
          label.appendChild(input);
          label.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          return label;
        } else {
          var _label = document.createElement('label'),
              _checked = this._map.hasLayer(obj.layer),
              _input;

          if (obj.overlay) {
            _input = document.createElement('input');
            _input.type = 'checkbox';
            _input.className = 'leaflet-control-layers-selector';
            _input.defaultChecked = _checked;
          } else {
            _input = this._createRadioElement('leaflet-base-layers', _checked);
          }

          var presentLayer, presentIndex;

          for (var i = 0; i < this._layerControlInputs.length; i++) {
            var inp = this._layerControlInputs[i];

            if (inp.layerId === obj.layer._leaflet_id) {
              presentLayer = inp;
            }
          }

          presentIndex = this._layerControlInputs.indexOf(presentLayer);

          if (presentLayer) {
            this._layerControlInputs = [].concat(this._layerControlInputs.slice(0, presentIndex), _input, this._layerControlInputs.slice(presentIndex + 1, this._layerControlInputs.length));
          } else {
            this._layerControlInputs.push(_input);
          }

          _input.layerId = L.Util.stamp(obj.layer);
          L.DomEvent.on(_input, 'click', this._onInputClick, this);

          var _name = document.createElement('span');

          _name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled
          // https://github.com/Leaflet/Leaflet/issues/2771

          var holder = document.createElement('div');

          _label.appendChild(holder);

          holder.appendChild(_input);
          holder.appendChild(_name);

          var _container = obj.overlay ? this._overlaysList : this._baseLayersList;

          _container.appendChild(_label);

          this._checkDisabledLayers();

          return _label;
        }
      },
      _update: function _update() {
        if (!this._listContainer) {
          return;
        }

        var options = this.options;

        if (this.init) {
          this._container.style.display = '';
          this.setActive(false);
          this.init = false;
        }

        this._baseLayersList.innerHTML = '';
        this._overlaysList.innerHTML = '';
        var baseLayersPresent = false,
            overlaysPresent = false,
            obj;

        for (var i in this._layers) {
          obj = this._layers[i];

          if (obj.overlay) {
            this._addItemObject(obj);

            overlaysPresent = true;
          } else {
            baseLayersPresent = true;
          }
        }

        this._container.style.display = overlaysPresent ? '' : 'none';
        this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
        this._form.style.display = overlaysPresent || baseLayersPresent ? '' : 'none';
        this._placeHolder.style.display = overlaysPresent || baseLayersPresent ? 'none' : '';

        if (!options.isActive) {
          this._form.style.display = 'none';
          this._placeHolder.style.display = 'none';
        }
      },
      _expand: function _expand() {
        L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
      },
      _collapse: function _collapse() {
        this._listContainer.className = this._listContainer.className.replace(' leaflet-control-layers-expanded', '');
        this.setActive(false);
      },
      setActive: function setActive(active) {
        var options = this.options,
            togglable = options.togglable || options.toggle;

        if (togglable) {
          var prefix = this._prefix,
              className = prefix + '-' + options.id,
              container = this._iconContainer;
          options.isActive = active;

          if (active) {
            L.DomUtil.addClass(container, prefix + '-active');
            L.DomUtil.addClass(container, className + '-active');

            if (container.children.length) {
              L.DomUtil.addClass(container, prefix + '-externalImage-active');
            }

            if (options.styleActive) {
              this.setStyle(options.styleActive);
            }

            L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
          } else {
            L.DomUtil.removeClass(container, prefix + '-active');
            L.DomUtil.removeClass(container, className + '-active');

            if (container.children.length) {
              L.DomUtil.removeClass(container, prefix + '-externalImage-active');
            }

            if (options.style) {
              this.setStyle(options.style);
            }

            L.DomUtil.removeClass(this._listContainer, 'leaflet-control-layers-expanded');
          } // ugly bug in IE
          // IE appends 'extended' class to the parent!


          if (L.DomUtil.hasClass(this._container, 'leaflet-control-layers-expanded')) {
            L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
          }
        }
      },
      addTo: function addTo(map) {
        // L.Control.prototype.addTo.call(this, map);
        L.Control.GmxIcon.prototype.addTo.call(this, map);

        if (this.options.addBefore) {
          this.addBefore(this.options.addBefore);
        }

        return this;
      },
      addBefore: function addBefore(id) {
        var parentNode = this._parent && this._parent._container;

        if (!parentNode) {
          parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }

        if (!parentNode) {
          this.options.addBefore = id;
        } else {
          for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
            var it = parentNode.childNodes[i];

            if (id === it._id) {
              parentNode.insertBefore(this._container, it);
              break;
            }
          }
        }

        return this;
      }
    });
    L.Control.gmxLayers2 = L.Control.GmxLayers2;

    L.control.gmxLayers2 = function (baseLayers, overlays, options) {
      return new L.Control.GmxLayers2(baseLayers, overlays, options);
    };

    var gmxMediaDescription = function gmxMediaDescription(descField, descData, storeDescFieldName, mode, mediaLayerName, mediaObjId, mediaLayer, dialogSettings) {
      //Основные переменные
      var editor,
          mediaDescDialog = jQuery('<div class="mediaDesc-Div"><img src="' + pluginPath + 'addit/media_img_load.gif"></img></div>'),
          mediaDescDialogTitle,
          mediaDescTextArea = jQuery('<textarea name="mediaDescInput" id="mediaDescInput"></textarea>'),
          exp1 = /(?:^|[^"'])(\b((https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]))/gim,
          exp2 = /(?:^|[^"'https?:\/\/])(\b((www.)[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]))/gim; //descData = descData.replace(exp1, '<a href="$1" target="_blank">$1</a>'); //Проверяем текст на наличие ссылок вида http/ftp и превращаем в URL.
      //descData = descData.replace(exp2, '<a href="http://$1" target="_blank">$1</a>'); //Проверяем текст на наличие ссылок вида www и превращаем в URL.
      //Основные функции диалога
      //Исправление бага с окном добавления ссылок через CKEditor в модальном режиме диалога описания

      $.widget("ui.dialog", $.ui.dialog, {
        //  jQuery UI - v1.10.2 - 2013-12-12
        //  http://bugs.jqueryui.com/ticket/9087#comment:27 - bugfix
        //  http://bugs.jqueryui.com/ticket/4727#comment:23 - bugfix
        //  allowInteraction fix to accommodate windowed editors
        _allowInteraction: function _allowInteraction(event) {
          if (this._super(event)) {
            return true;
          } // address interaction issues with general iframes with the dialog


          if (event.target.ownerDocument != this.document[0]) {
            return true;
          } // address interaction issues with dialog window


          if ($(event.target).closest(".cke_dialog").length) {
            return true;
          } // address interaction issues with iframe based drop downs in IE


          if ($(event.target).closest(".cke").length) {
            return true;
          }
        },
        // jQuery UI - v1.10.2 - 2013-10-28
        //  http://dev.ckeditor.com/ticket/10269 - bugfix
        //  moveToTop fix to accommodate windowed editors
        _moveToTop: function _moveToTop(event, silent) {
          if (!event || !this.options.modal) {
            this._super(event, silent);
          }
        }
      }); //Функция сохранения описание из Режима Чтения (данные записываются сразу в слой)

      var saveDescfromReadMode = function saveDescfromReadMode() {
        var newData = mediaDescTextArea.val();
        var descriptionLength = newData.length;
        var edata = editor.getData();
        newData = edata.replace(/>/gim, '> ');
        newData = newData.replace(exp1, ' <a href="$1" target="_blank">$1</a> ' + ' ');
        newData = newData.replace(exp2, ' <a href="http://$1" target="_blank">$1</a> ' + ' ');

        if (descriptionLength > 5000) {
          var descriptionLengthDIFF = descriptionLength - 5000;
          alert(_gtxt('mediaPlugin2.mediaDescDialogLimit.alert') + descriptionLengthDIFF + _gtxt('mediaPlugin2.mediaDescDialogSymbols.alert'));
        } else {
          _mapHelper.modifyObjectLayer(mediaLayerName, [{
            id: mediaObjId,
            properties: {
              '_mediadescript_': newData
            },
            action: 'update'
          }]).done(function () {
            mediaDescDialog.dialog('close').remove();
            new gmxMediaDescription(null, newData, null, 'read', mediaLayerName, mediaObjId, mediaLayer, dialogSettings); //После сохранения закрываем старое окно и открываем новое с описанием.
          });
        }
      }; //Функция сохранения описание из Режима Чтения (Пользователь решает сохранять данные или нет)


      var saveDescfromEditMode = function saveDescfromEditMode() {
        var newdescData = mediaDescTextArea.val();
        var descriptLength = newdescData.length;
        var eddata = editor.getData();
        newdescData = eddata.replace(/>/gim, '> ');
        newdescData = newdescData.replace(exp1, ' <a href="$1" target="_blank">$1</a> ' + ' ');
        newdescData = newdescData.replace(exp2, ' <a href="http://$1" target="_blank">$1</a> ' + ' ');

        if (descriptLength > 5000) {
          var descriptLengthDIFF = descriptLength - 5000;
          alert(_gtxt('mediaPlugin2.mediaDescDialogLimit.alert') + descriptLengthDIFF + _gtxt('mediaPlugin2.mediaDescDialogSymbols.alert'));
        } else {
          descField.set(storeDescFieldName, newdescData);
          mediaDescDialog.dialog('close').remove();
        }
      }; //Функция переключения в режим "HTML"


      var editortoHTML = function editortoHTML(prevmode) {
        for (var editorHTMLInstance in CKEDITOR.instances) {
          var curHTMLInstance = editorHTMLInstance;
          break;
        }
        $('#' + editor.id + '_top').hide();
        editor.resize('100%', mediaDescDialog.height() - 5, true);
        CKEDITOR.instances[curHTMLInstance].setMode('source');

        if (prevmode == 'fromedit') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'WYSIWYGMode',
              text: _gtxt("mediaPlugin2.descDialogWYSIWYGButton.label"),
              click: function click() {
                editortoWYSIWYG('fromedit');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
              click: saveDescfromEditMode
            }]
          });
        } else if (prevmode == 'fromread') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'WYSIWYGMode',
              text: _gtxt("mediaPlugin2.descDialogWYSIWYGButton.label"),
              click: function click() {
                editortoWYSIWYG('fromread');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
              click: saveDescfromReadMode
            }]
          });
        }
      }; //Функция переключения в режим "WYSIWYG"


      var editortoWYSIWYG = function editortoWYSIWYG(prevmode) {
        for (var editorWYSIWYGInstance in CKEDITOR.instances) {
          var curWYSIWYGInstance = editorWYSIWYGInstance;
          break;
        }
        $('#' + editor.id + '_top').show();
        editor.resize('100%', mediaDescDialog.height() - 50, true);
        CKEDITOR.instances[curWYSIWYGInstance].setMode('wysiwyg');

        if (prevmode == 'fromedit') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'htmlMode',
              text: 'HTML',
              click: function click() {
                editortoHTML('fromedit');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
              click: saveDescfromEditMode
            }]
          });
        } else if (prevmode == 'fromread') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'htmlMode',
              text: 'HTML',
              click: function click() {
                editortoHTML('fromread');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
              click: saveDescfromReadMode
            }]
          });
        }
      }; //Функция переключения из режима "Чтение" в режим "Редактирование"


      var changeDescDialogMode = function changeDescDialogMode() {
        mediaDescDialog.dialog('close');
        descEditMode();
        mediaDescDialog.dialog({
          buttons: [{
            id: 'htmlMode',
            text: 'HTML',
            click: function click() {
              editortoHTML('fromread');
            }
          }, {
            id: 'saveDescData',
            text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
            click: saveDescfromReadMode
          }]
        });
        mediaDescDialog.dialog('open');
      }; //Режим "Чтение"


      var descReadMode = function descReadMode() {
        var isEditableLayer = function isEditableLayer(layer) {
          var layerProps = layer.getGmxProperties();

          var layerRights = _queryMapLayers.layerRights(layerProps.name);

          return layerProps.type === 'Vector' && (layerRights == 'edit' || layerRights == 'editrows');
        };

        $(mediaDescDialog).on('click', '.imgMedia', function (e) {
          var newwindowHref = $(this).find('img').attr('src');

          if (newwindowHref) {
            e.preventDefault();
            window.open(newwindowHref, 'new' + e.screenX);
          }
        });
        mediaDescDialog.dialog({
          title: mediaDescDialogTitle,
          width: 510,
          height: dialogSettings.dialogDescHeight,
          minHeight: dialogSettings.dialogDescHeight,
          maxWidth: 510,
          minWidth: 510,
          modal: false,
          autoOpen: false,
          dialogClass: 'media-DescDialog',
          close: function close() {
            mediaDescDialog.dialog('close').remove();
          }
        });
        mediaDescDialog.html('<div class="media-descDiv">' + descData + '</div>');
        mediaDescDialog.dialog('open');

        if (isEditableLayer(mediaLayer)) {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'changeDescMode',
              text: _gtxt("mediaPlugin2.descDialogEditButton.label"),
              click: changeDescDialogMode
            }]
          });
        }
      }; //Режим "Редактирование"


      var descEditMode = function descEditMode() {
        gmxCore.loadScript(pluginPath + 'ckeditor_4.4.1_custom/ckeditor/ckeditor.js');
        gmxCore.loadScript(pluginPath + 'ckeditor_4.4.1_custom/ckeditor/adapters/jquery.js').done(function () {
          var CKEDITOR_BASEPATH = gmxCore.getModulePath('ckeditor'); //CKEDITOR.config.enterMode = '2';

          mediaDescTextArea.val(descData);
          mediaDescTextArea.ckeditor();
          CKEDITOR.on('instanceReady', function (ev) {
            editor = ev.editor;
            $('#' + editor.id + '_top').show();
            editor.resize('100%', mediaDescDialog.height() - 65, true);
            editor.on('doubleclick', function (evt) {
              var element = evt.data.element;

              if (element.is('img') && !element.data('cke-realelement') && !element.isReadOnly()) {
                var targetSrc = element.getAttribute('src');
                window.open(targetSrc, 'new' + e.screenX);
              }
            });
            $('iframe').contents().click(function (e) {
              if (typeof e.target.href != 'undefined' && e.ctrlKey == true) {
                window.open(e.target.href, 'new' + e.screenX);
              }
            });
          });
          CKEDITOR.on('dialogDefinition', function (ev) {
            var dialogName = ev.data.name;
            var dialogDefinition = ev.data.definition;

            if (dialogName == 'link') {
              var informationTab = dialogDefinition.getContents('target');
              var targetField = informationTab.get('linkTargetType');
              targetField['default'] = '_blank';
            }
          });
          mediaDescDialog.html(mediaDescTextArea);
        });
        mediaDescDialog.dialog({
          //title: mediaDescDialogTitle,
          width: 510,
          height: dialogSettings.dialogDescHeight,
          minHeight: dialogSettings.dialogDescHeight,
          maxWidth: 510,
          minWidth: 510,
          modal: true,
          resize: function resize() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          resizeStop: function resizeStop() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          drag: function drag() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          dragStop: function dragStop() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          autoOpen: false,
          buttons: [{
            id: 'htmlMode',
            text: 'HTML',
            click: function click() {
              editortoHTML('fromedit');
            }
          }, {
            id: 'saveDescData',
            text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
            click: saveDescfromEditMode
          }],
          dialogClass: 'media-DescDialog',
          close: function close() {
            mediaDescDialog.dialog('close').remove();
          }
        });
        mediaDescDialog.dialog('open');
      }; //Дополнительные условия


      if (mode == 'read') {
        //mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleRead.label');
        descReadMode();
      } else if (mode == 'edit') {
        //mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleEdit.label');
        descEditMode();
      } else if (mode == 'baloon') {
        /*mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleEdit.label');*/
        descReadMode();
        changeDescDialogMode();
      }
    };

    _translationsHash.addtext("rus", {
      mediaPlugin2: {
        "layerPropertiesTitle": 'Добавить описание',
        "balloonDefaultTitle": 'Медиа Описание',
        "descButton.label": 'Редактировать',
        "descButton.help": 'Редактировать медиа описание',
        "descSpan.label": 'Описание',
        "descSpan.help": 'Медиа описание',
        "descDialogEditButton.label": 'Редактировать',
        "descDialogWYSIWYGButton.label": 'Визуально',
        "descDialogSaveButton.label": 'Сохранить',
        "descDialogEditSaveButton.label": 'Готово',
        "descBalloonButton.label": 'Описание',
        "descInBalloonButton.label": 'Редактировать описание',
        "descDialogTitle.label": 'Просмотр Медиа-Описания',
        "mediaDescDialogTitleEdit.label": 'Редактировать описание',
        "mediaDescDialogTitleRead.label": 'Чтение описания',
        "mediaDescDialogLimit.alert": 'Количество символов в описании больше 5000.\nУкоротите описание на ',
        "mediaDescDialogSymbols.alert": ' символов',
        "mediaDescImgDialogError.alert": 'Не удалось загрузить изображение.\n Проверьте правильность ссылки',
        "WarningText": 'Для хранения описаний требуется добавление нового поля к слою'
      }
    });

    _translationsHash.addtext("eng", {
      mediaPlugin2: {
        "layerPropertiesTitle": 'Add media description',
        "balloonDefaultTitle": 'Media description',
        "descButton.label": 'Edit',
        "descButton.help": 'Edit media description',
        "descSpan.label": 'Description',
        "descSpan.help": 'Media Description',
        "descDialogEditButton.label": 'Edit',
        "descDialogWYSIWYGButton.label": 'WYSIWYG',
        "descDialogSaveButton.label": 'Save',
        "descDialogEditSaveButton.label": 'OK',
        "descBalloonButton.label": 'Description',
        "descInBalloonButton.label": 'Edit Description',
        "descDialogTitle.label": 'Media-Description Viewer',
        "mediaDescDialogTitleEdit.label": 'Edit Description',
        "mediaDescDialogTitleRead.label": 'View Description',
        "mediaDescDialogLimit.alert": 'Description length more then 5000 symbols.\nDelete ',
        "mediaDescDialogSymbols.alert": ' symbols',
        "mediaDescImgDialogError.alert": 'Image load failure.\n Check URL on error',
        "WarningText": 'New attribute will be added to this layer to store descriptions'
      }
    }); //Модифицирует описание слоя, добавляя или удаляя свойства, необходимые для хранения описания объектов.
    //Метатег удаляется и добавляется, а необходимый атриут только добавляется (никогда не удаляется)


    var modifyLayerProperties = function modifyLayerProperties(layerProperties, isAddDescription) {
      var metaProps = layerProperties.get('MetaProperties'),
          tagId = metaProps.getTagIdByName(DESC_METATAG);

      if (isAddDescription) {
        tagId || metaProps.addNewTag(DESC_METATAG, DESC_DEFAULT_FIELD, 'String');
        var columns = layerProperties.get('Columns').slice();

        if (!_.findWhere(columns, {
          Name: DESC_DEFAULT_FIELD
        })) {
          columns.push({
            Name: DESC_DEFAULT_FIELD,
            ColumnSimpleType: 'String'
          });
        }

        layerProperties.set('Columns', columns);
      } else {
        metaProps.deleteTag(tagId);
      }

      layerProperties.set('MetaProperties', metaProps);
    };

    var DESC_METATAG = 'mediaDescField',
        DESC_DEFAULT_FIELD = '_mediadescript_',
        DESC_INLINE_HOOK = 'mediainline';
    var pluginPath = gmxCore.getModulePath('MediaPlugin2');
    var publicInterface$1 = {
      pluginName: 'Media Plugin',
      afterViewer: function afterViewer(mediaDescDialogSettings, map) {
        mediaDescDialogSettings = $.extend({
          dialogDescHeight: 450,
          inBaloonDesc: false
        }, mediaDescDialogSettings);

        gmxCore.loadModule('LayerEditor').done(function () {
          nsGmx.LayerEditor.addInitHook(function (layerEditor, layerProperties, parametres) {
            var metaProps = layerProperties.get('MetaProperties'),
                isMedia = metaProps.getTagByName(DESC_METATAG);

            if (layerProperties.get('Type') !== 'Vector') {
              return;
            }

            var uiTemplate = Handlebars.compile('<label class = "media-props">' + '<input type="checkbox" id="media-props-checkbox" {{#isMedia}}checked{{/isMedia}}>' + '{{i "mediaPlugin2.layerPropertiesTitle"}}' + '</label>');
            $(layerEditor).on('premodify', function () {
              modifyLayerProperties(layerProperties, $('#media-props-checkbox', ui).prop("checked"));
            });
            var ui = $(uiTemplate({
              isMedia: isMedia
            }));
            parametres.additionalUI = parametres.additionalUI || {};
            parametres.additionalUI.advanced = parametres.additionalUI.advanced || [];
            parametres.additionalUI.advanced.push(ui[0]);
          });
        });

        var balloonHook = function balloonHook(layer, props, div, node, hooksCount) {
          //Если есть описание в балуне, отдельной ссылки на описание не нужно
          if (hooksCount[DESC_INLINE_HOOK]) {
            return;
          } // var layer = o.layer,


          var layerProps = layer.getGmxProperties(),
              layerName = layerProps.name,
              metaTag = layerProps.MetaProperties && layerProps.MetaProperties[DESC_METATAG];

          if (!metaTag) {
            $(node).empty().append(props[DESC_DEFAULT_FIELD]);
          } else if (props[metaTag.Value].length) {
            var descBaloonButtonLabel = '<b><a href="">{{i "mediaPlugin2.descBalloonButton.label"}}</a></b>',
                mediaDescDialogMode = 'read';
            var ui = $(Handlebars.compile(descBaloonButtonLabel)()).click(function (e) {
              e.preventDefault();
              var mediaObjectId = props[layerProps.identityField];
              var descripText = props[metaTag.Value];
              new gmxMediaDescription('', descripText, '', mediaDescDialogMode, layerName, mediaObjectId, layer, mediaDescDialogSettings);
            });

            if (node) {
              $(node).empty().append(ui);
            } else {
              $(div).append($('<br/>'), ui);
            }
          }
        };

        var attachBalloonHook = function attachBalloonHook(layer) {
          if (!layer.addPopupHook) {
            //например, виртуальные слои могут не поддерживать popup hooks
            return;
          }

          var props = layer.getGmxProperties();
          var metaTag = props.MetaProperties && props.MetaProperties[DESC_METATAG];
          layer.addPopupHook(metaTag ? metaTag.Value : DESC_DEFAULT_FIELD, function (properties, div, node, hooksCount) {
            balloonHook(layer, properties, div, node, hooksCount);
          }); //добавляем просмотр описания внутри балуна

          layer.addPopupHook(DESC_INLINE_HOOK, function (properties, div, node) {
            var metaTag = props.MetaProperties && props.MetaProperties[DESC_METATAG];

            if (!node || !metaTag) {
              return;
            }

            var html = properties[metaTag.Value];
            $(node).html('<div class="media-inlineDescr media-descDiv">' + html + '</div>');
            $(node).on('click', '.imgMedia', function (e) {
              e.preventDefault();
              var contwindowHref = $(this).find('img').attr('src');
              window.open(contwindowHref, 'new' + e.screenX);
            });
          });
        };

        nsGmx.gmxMap.layers.forEach(attachBalloonHook);

        var paramHook = function paramHook(layerName, id, parametres) {
          var layer = nsGmx.gmxMap.layersByID[layerName],
              props = layer.getGmxProperties(),
              fieldName = props.MetaProperties && props.MetaProperties[DESC_METATAG] && props.MetaProperties[DESC_METATAG].Value; //layer.bringToTopItem(id);

          parametres = parametres || {};
          parametres.fields = parametres.fields || [];

          if (fieldName) {
            var fieldDescription = _.findWhere(parametres.fields, {
              name: fieldName
            });

            if (fieldDescription) {
              fieldDescription.hide = true;
            } else {
              parametres.fields.push({
                name: fieldName,
                hide: true
              });
            }
          }

          parametres.afterPropertiesControl = function (EOCInteraction) {
            var mediaGUI = $('<div class="media-Desc-GUI"><span id="media-Desc-EditLabel" title="' + _gtxt("mediaPlugin2.descSpan.help") + '">' + _gtxt("mediaPlugin2.descSpan.label") + '</span><span id ="mediaDesc-EditButton" class="buttonLink" title="' + _gtxt("mediaPlugin2.descButton.help") + '">' + _gtxt("mediaPlugin2.descButton.label") + '</span></div>');
            $('#mediaDesc-EditButton', mediaGUI).click(function () {
              if (!fieldName) {
                var ui = $(Handlebars.compile('<div>{{i "mediaPlugin2.WarningText"}}</div>')());
                ui.dialog({
                  buttons: [{
                    id: 'warning-ok',
                    text: 'OK',
                    click: function click() {
                      $(this).dialog("close");
                      gmxCore.loadModule('LayerProperties').then(function () {
                        var layerProperties = new nsGmx.LayerProperties();
                        layerProperties.initFromServer(layerName).then(function () {
                          modifyLayerProperties(layerProperties, true);
                          layerProperties.save().then(function () {
                            L.gmx.layersVersion.chkVersion(layer, function () {
                              fieldName = layer.getGmxProperties().MetaProperties[DESC_METATAG].Value;
                              var fields = EOCInteraction.getAll();

                              if (!fields[fieldName]) {
                                EOCInteraction.add({
                                  name: fieldName,
                                  view: {
                                    _value: '',
                                    setValue: function setValue(value) {
                                      this._value = value;
                                    },
                                    getValue: function getValue() {
                                      return this._value;
                                    },
                                    checkValue: function checkValue() {
                                      return true;
                                    }
                                  }
                                });
                              }

                              var getdescData = EOCInteraction.get(fieldName) || '';
                              new gmxMediaDescription(EOCInteraction, getdescData, fieldName, 'edit', null, null, null, mediaDescDialogSettings);
                            });
                          });
                        });
                      });
                    }
                  }, {
                    id: 'warning-cancel',
                    text: 'Cancel',
                    click: function click() {
                      $(this).dialog("close");
                    }
                  }]
                });
              } else {
                var getdescData = EOCInteraction.get(fieldName);
                new gmxMediaDescription(EOCInteraction, getdescData, fieldName, 'edit', null, null, null, mediaDescDialogSettings);
              }
            });
            return mediaGUI[0];
          };

          return parametres;
        };

        nsGmx.EditObjectControl.addParamsHook(paramHook);
      }
    };
    gmxCore.addModule("MediaPlugin2", publicInterface$1, {// css: 'MediaPlugin2.css'
    });

    var _$5 = nsGmx$1.Utils._; //для отслеживания того, что не открыли диалог редактирования одного и того же объекта несколько раз

    var EditObjectControlsManager = {
      _editControls: [],
      _paramsHooks: [],
      find: function find(layerName, oid) {
        for (var iD = 0; iD < this._editControls.length; iD++) {
          if (layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid) return this._editControls[iD].control;
        }
      },
      add: function add(layerName, oid, control) {
        for (var iD = 0; iD < this._editControls.length; iD++) {
          if (layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid) {
            this._editControls[iD].control = control;
            return;
          }
        }

        this._editControls.push({
          layer: layerName,
          oid: oid,
          control: control
        });
      },
      remove: function remove(layerName, oid) {
        for (var iD = 0; iD < this._editControls.length; iD++) {
          if (layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid) {
            this._editControls.splice(iD, 1);

            return;
          }
        }
      },
      addParamsHook: function addParamsHook(paramsHook) {
        this._paramsHooks.push(paramsHook);
      },
      applyParamsHook: function applyParamsHook(layerName, objectId, params) {
        for (var h = 0; h < this._paramsHooks.length; h++) {
          params = this._paramsHooks[h](layerName, objectId, params);
        }

        return params;
      }
    };

    var getInputElement = function getInputElement(type) {
      var input = _input(null, [['dir', 'className', 'inputStyle edit-obj-input']]);

      if (type == 'date') {
        $(input).datepicker({
          changeMonth: true,
          changeYear: true,
          dateFormat: "dd.mm.yy"
        });
      } else if (type == 'datetime') {
        $(input).datetimepicker({
          changeMonth: true,
          changeYear: true,
          dateFormat: "dd.mm.yy",
          timeFormat: "HH:mm:ss",
          showSecond: true,
          timeOnly: false
        });
      } else if (type == "time") {
        $(input).timepicker({
          timeOnly: true,
          timeFormat: "HH:mm:ss",
          showSecond: true
        });
      }

      return input;
    }; //Коллекция полей с информацией для создания диалога редактирования


    var FieldsCollection = function FieldsCollection() {
      var _asArray = [];
      var _asHash = {};

      this.append = function (field) {
        if (field.name && _asHash[field.name]) {
          var origIndex = _asHash[field.name].origIndex;
          $.extend(true, _asHash[field.name], field);
          _asHash[field.name].origIndex = origIndex;
        } else {
          field.origIndex = _asArray.length;

          _asArray.push(field);

          if (field.name) {
            _asHash[field.name] = field;
          }
        }
      };

      this.get = function (name) {
        return _asHash[name];
      };

      this.each = function (callback) {
        _asArray.forEach(callback);
      };

      this.updateValue = function (name) {
        var field = _asHash[name];

        if (field && field.view) {
          field.value = field.view.getValue();
        }

        return field && field.value;
      }; //Сначала isRequired, потом identityField, потом в порядке добавления


      this.sort = function () {
        _asArray = _asArray.sort(function (a, b) {
          if (!!a.isRequired !== !!b.isRequired) {
            return Number(!!b.isRequired) - Number(!!a.isRequired);
          }

          if (!!a.identityField !== !!b.identityField) {
            return Number(!!b.identityField) - Number(!!a.identityField);
          }

          var userZIndexDelta = (a.index || 0) - (b.index || 0);
          return userZIndexDelta || a.origIndex - b.origIndex;
        });
      };
    };
    /** Объект, описывающий один атрибут слоя
     * @typedef {Object} nsGmx.EditObjectControl.FieldInfo
     * @property {String} name имя атрибута (обязательно)
     * @property {String|int} [value] значение атрибута в формате сервера
     * @property {bool} [constant=false] можно ли редактировать атрибут
     * @property {bool} [hide=false] совсем не показыавать этот атрибут
     * @property {String} [title=<совпадает с name>] что показывать вместо имени атрибута
     * @property {function(val):bool} [validate] ф-ция для валидации результата. На вход получает введённое пользователем значение
    *      (до преобразования в серверный формат), должна вернуть валидно ли это значение.
     * @property {String} [isRequired=false] является ли значение атрибута обязательным. Обязательные атрибуты показываются выше всех остальных и выделяются жирным шрифтом.
     * @property {Number} [index=0] индекс для сортировки. Влияет на порядок показа полей в диалоге. Больше - выше.
    */

    /** Контрол, который показывает диалог редактирования существующего или добавления нового объекта в слой.
    *
    * @memberOf nsGmx
    * @class
    * @param {String}   layerName ID слоя
    * @param {Number}   objectId ID объекта (null для нового объекта)
    * @param {Object}   [params] Дополнительные параметры контрола
    * @param {gmxAPI.drawingObject} [params.drawingObject] Пользовательский объект для задании геометрии или null, если геометрия не задана
    * @param {function} [params.onGeometrySelection] Внешняя ф-ция для выбора геометрии объекта.
             Сигнатура: function(callback), параметр callback(gmxAPI.drawingObject|geometry) должен быть вызван когда будет выбрана геометрия.
    * @param {HTMLNode} [params.geometryUI] HTML элемент, который нужно использовать вместо стандартных контролов для выбора геометрии (надпись + иконка)
    * @param {nsGmx.EditObjectControl.FieldInfo[]} [params.fields] массив с описанием характеристик атрибутов для редактирования . Должен содержать только атрибуты, которые есть в слое.
    * @param {bool} [params.allowDuplicates=<depends>] Разрешать ли несколько диалогов для редактирования/создания этого объекта.
             По умолчанию для редактирования запрещено, а для создания нового разрешено.
    * @param {HTMLNode | function(nsGmx.EditObjectControl): HTMLNode} [params.afterPropertiesControl] HTML элемент, который нужно поместить после списка атрибутов или ф-ция, которая возвращает этот элемент
    */


    var EditObjectControl = function EditObjectControl(layerName, objectId, params) {
      /** Объект был изменён/добавлен
       * @event nsGmx.EditObjectControl#modify
       */

      /** Генерируется перед изменением/добавлением объекта. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
       * @event nsGmx.EditObjectControl#premodify
       */

      /** Закрытие диалога редактирования
       * @event nsGmx.EditObjectControl#close
       */
      if (_queryMapLayers.layerRights(layerName) !== 'edit' && _queryMapLayers.layerRights(layerName) !== 'editrows') {
        showErrorMessage(_gtxt('Недостаточно прав для редактирования объектов слоя'), true);
        return;
      }

      var isNew = objectId == null;

      var _params = $.extend({
        drawingObject: null,
        fields: [],
        validate: {},
        allowDuplicates: isNew,
        afterPropertiesControl: _span()
      }, params);

      _params = EditObjectControlsManager.applyParamsHook(layerName, objectId, _params);

      var _this = this;

      if (!_params.allowDuplicates && EditObjectControlsManager.find(layerName, objectId)) return EditObjectControlsManager.find(layerName, objectId);
      EditObjectControlsManager.add(layerName, objectId, this);
      var lmap = nsGmx$1.leafletMap,
          layersByID = nsGmx$1.gmxMap.layersByID;
      var layer = layersByID[layerName];

      var geometryInfoContainer = _div(null, [['css', 'color', '#215570'], ['css', 'fontSize', '12px']]);

      var originalGeometry = null;
      var identityField = layer._gmx.properties.identityField;
      var geometryInfoRow = null;
      var drawingObjectLeafletID = null;

      var bindDrawingObject = function bindDrawingObject(obj) {
        geometryInfoRow && geometryInfoRow.RemoveRow();
        if (!obj) return;
        var InfoRow = window.gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
        geometryInfoRow = new InfoRow(lmap, geometryInfoContainer, obj, {
          editStyle: false,
          allowDelete: false
        });
        drawingObjectLeafletID = obj._leaflet_id;
      };

      var objStyle = params && params.event ? params.event.gmx.target.currentStyle : null;

      var bindGeometry = function bindGeometry(geom) {
        if (geom) {
          var geojson = new L.GeoJSON(geom),
              styleParams = objStyle ? {
            pointStyle: {
              shape: 'box',
              color: objStyle.strokeStyle
            },
            lineStyle: {
              color: objStyle.strokeStyle
            }
          } : {},
              arr = lmap.gmxDrawing.addGeoJSON(geojson, styleParams);

          for (var i = 0, len = arr.length; i < len; i++) {
            bindDrawingObject(arr[i]);
          }
        }
      };

      var fieldsCollection = new FieldsCollection();

      var createDialog = function createDialog() {
        var createButton = makeLinkButton(isNew ? _gtxt("Создать") : _gtxt("Изменить")),
            removeButton = makeLinkButton(_gtxt("Удалить")),
            isSaving = false;

        var canvas = _div(null, [['dir', 'className', 'edit-obj']]);

        $(canvas).bind('dragover', function () {
          return false;
        });
        $(canvas).bind('drop', function (e) {
          var files = e.originalEvent.dataTransfer.files;
          nsGmx$1.Utils.parseShpFile(files[0]).done(function (objs) {
            bindGeometry(nsGmx$1.Utils.joinPolygons(nsGmx$1._.pluck(objs, 'geometry')));
          });
          return false;
        });

        removeButton.onclick = function () {
          _mapHelper.modifyObjectLayer(layerName, [{
            action: 'delete',
            id: objectId
          }]).done(function () {
            removeDialog(dialogDiv);
            closeFunc();
          });
        };

        removeButton.style.marginLeft = '10px';
        isNew && $(removeButton).hide();

        createButton.onclick = function () {
          if (isSaving) {
            return;
          }

          $(_this).trigger('premodify');
          var properties = {};
          var anyErrors = false;
          fieldsCollection.each(function (field) {
            var name = field.name;

            if (!name) {
              return;
            }

            var isValid = field.view.checkValue();

            if (isValid) {
              properties[name] = fieldsCollection.updateValue(name);
            }

            anyErrors = anyErrors || !isValid;
          });
          if (anyErrors) return;
          var obj = {
            properties: properties
          };

          var selectedGeom = _this.getGeometry(); // if (!selectedGeom)
          // {
          // showErrorMessage("Геометрия для объекта не задана", true, "Геометрия для объекта не задана");
          // return;
          // }


          if (!isNew) {
            obj.id = objectId;
            var curGeomString = JSON.stringify(selectedGeom);
            var origGeomString = JSON.stringify(originalGeometry);

            if (origGeomString !== curGeomString) {
              obj.geometry = selectedGeom;
            }
          } else {
            obj.geometry = selectedGeom;
          }

          isSaving = true;

          _mapHelper.modifyObjectLayer(layerName, [obj], 'EPSG:4326').done(function () {
            $(_this).trigger('modify');
            removeDialog(dialogDiv);
            closeFunc();
          });
        };

        var resizeFunc = function resizeFunc() {
          if (!isNew && $(canvas).children("[loading]").length) return;
          canvas.firstChild.style.height = canvas.parentNode.offsetHeight - 25 - 10 - 10 + 'px';
        };

        var closeFunc = function closeFunc() {
          // search for opened styles editing dialog
          if (drawingObjectLeafletID) {
            var styleEditingDialog = $('.drawing-object-leaflet-id-' + drawingObjectLeafletID);
          }

          geometryInfoRow && geometryInfoRow.getDrawingObject() && nsGmx$1.leafletMap.gmxDrawing.remove(geometryInfoRow.getDrawingObject());
          originalGeometry = null;

          if (styleEditingDialog) {
            removeDialog(styleEditingDialog);
          }
          EditObjectControlsManager.remove(layerName, objectId);
          $(_this).trigger('close');
        };

        var drawAttrList = function drawAttrList(fields) {
          var trs = [],
              firstInput; //сначала идёт геометрия

          var geomTitleTmpl = Handlebars.compile('<span>' + '<span class="edit-obj-geomtitle">{{i "Геометрия"}}</span>' + '<span id = "choose-geom" class="gmx-icon-choose"></span>' + '</span>');
          var geometryUI = _params.geometryUI || $(geomTitleTmpl())[0];
          $('#choose-geom', geometryUI).click(function () {
            if (_params.onGeometrySelection) {
              _params.onGeometrySelection(bindGeometry);
            } else {
              nsGmx$1.Controls.chooseDrawingBorderDialog('editObject', bindDrawingObject, {
                geomType: layer.getGmxProperties().GeometryType
              });
            }
          });
          trs.push(_tr([_td([geometryUI], [['css', 'height', '20px']]), _td([geometryInfoContainer])]));
          fields.sort(); //потом все остальные поля

          fields.each(function (field) {
            var td = _td();

            if (field.constant) {
              field.view = field.view || {
                getUI: function getUI() {
                  var span = _span(null, [['dir', 'className', 'edit-obj-constant-value']]);

                  span.rowName = field.name;
                  span.rowType = field.type;

                  if ('value' in field) {
                    _$5(span, [_t(nsGmx$1.Utils.convertFromServer(field.type, field.value))]);
                  }

                  return span;
                },
                getValue: function getValue() {
                  return field.value;
                },
                setValue: function setValue() {},
                checkValue: function checkValue() {
                  return true;
                }
              };
            } else {
              field.view = field.view || {
                getUI: function getUI() {
                  if (!this._input) {
                    var input = this._input = getInputElement(field.type);
                    input.rowName = field.name;
                    input.rowType = field.type;
                    firstInput = firstInput || input;
                    if ('value' in field) input.value = nsGmx$1.Utils.convertFromServer(field.type, field.value);
                  }

                  return this._input;
                },
                getValue: function getValue() {
                  return nsGmx$1.Utils.convertToServer(field.type, this._input.value);
                },
                setValue: function setValue(value) {
                  this._input.value = nsGmx$1.Utils.convertFromServer(field.type, value);
                },
                checkValue: function checkValue() {
                  var validationFunc = field.validate || _params.validate[field.name];
                  var isValid = !validationFunc || validationFunc(this._input.value);

                  if (!isValid) {
                    inputError(this._input);
                  }

                  return isValid;
                },
                _input: null
              };
            }

            _$5(td, [field.view.getUI(_this)]);

            var fieldHeader = _span([_t(field.title || field.name)], [['css', 'fontSize', '12px']]);

            if (field.isRequired) {
              fieldHeader.style.fontWeight = 'bold';
            }

            var tr = _tr([_td([fieldHeader]), td], [['css', 'height', '22px']]);

            field.hide && $(tr).hide();
            trs.push(tr);
          });
          var afterPropUI = typeof _params.afterPropertiesControl === 'function' ? _params.afterPropertiesControl(_this) : _params.afterPropertiesControl;

          _$5(canvas, [_div([_table([_tbody(trs)], [['dir', 'className', 'obj-edit-proptable']]), afterPropUI], [['dir', 'className', 'obj-edit-canvas'], ['css', 'overflow', 'auto']])]);

          _$5(canvas, [_div([createButton, removeButton], [['css', 'margin', '10px 0px'], ['css', 'height', '20px']])]);

          firstInput && firstInput.focus();
          resizeFunc();
        };

        var prop = layer._gmx.properties;
        var dialogDiv = showDialog(isNew ? _gtxt("Создать объект слоя [value0]", prop.title) : _gtxt("Редактировать объект слоя [value0]", prop.title), canvas, 520, 300, false, false, resizeFunc, closeFunc);

        if (!isNew) {
          var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px'], ['attr', 'loading', true]]);

          _$5(canvas, [loading]); //получаем геометрию объекта


          sendCrossDomainJSONRequest(window.serverBase + "VectorLayer/Search.ashx?WrapStyle=func&layer=" + layerName + "&page=0&pagesize=1&orderby=" + identityField + "&geometry=true&query=[" + identityField + "]=" + objectId, function (response) {
            if (!parseResponse(response)) return;
            $(canvas).children("[loading]").remove();
            var columnNames = response.Result.fields;
            var geometryRow = response.Result.values.length > 0 ? response.Result.values[0] : [];

            if (geometryRow.length > 0) {
              var types = response.Result.types;

              for (var i = 0; i < geometryRow.length; ++i) {
                if (columnNames[i] === 'geomixergeojson') {
                  var geom = L.gmxUtil.geometryToGeoJSON(geometryRow[i], true);

                  if (geom) {
                    bindGeometry(geom);
                    originalGeometry = $.extend(true, {}, geom);
                  }
                } else {
                  var field = {
                    value: geometryRow[i],
                    type: types[i],
                    name: columnNames[i],
                    constant: columnNames[i] === identityField,
                    identityField: columnNames[i] === identityField,
                    isRequired: false
                  };
                  fieldsCollection.append(field);
                }
              }

              _params.fields.forEach(fieldsCollection.append);

              drawAttrList(fieldsCollection);
            } else {
              console.log('Geometry row is empty');
              $(dialogDiv).dialog('close');
            }

            _this.initPromise.resolve();
          });
        } else {
          for (var i = 0; i < prop.attributes.length; ++i) {
            fieldsCollection.append({
              type: prop.attrTypes[i],
              name: prop.attributes[i]
            });
          }

          _params.fields.forEach(fieldsCollection.append);

          if (_params.drawingObject) {
            bindDrawingObject(_params.drawingObject);
          }

          drawAttrList(fieldsCollection);

          _this.initPromise.resolve();
        }
      };
      /** Promise для отслеживания момента полной инициализации диалога. Только после полной инициализации можно полноценно пользоваться методами get/set
        * @memberOf nsGmx.EditObjectControl.prototype
        * @member {jQuery.Deferred} initPromise
      */


      this.initPromise = $.Deferred();
      /** Получить текущее значение атрибута из контрола
        @memberOf nsGmx.EditObjectControl.prototype
        @param {String} fieldName Имя атрибута
        @method get
      */

      this.get = function (fieldName) {
        return fieldsCollection.updateValue(fieldName);
      };

      this.getAll = function () {
        var res = {};
        fieldsCollection.each(function (field) {
          res[field.name] = fieldsCollection.updateValue(field.name);
        });
        return res;
      };
      /** Задать значение атрибута объекта из контрола
        @memberOf nsGmx.EditObjectControl.prototype
        @method set
        @param {String} fieldName Имя атрибута
        @param {String|Integer} value Значение в клиентском формате, который нужно установить для этого атрибута
      */


      this.set = function (fieldName, value) {
        var field = fieldsCollection.get(fieldName);

        if (field) {
          field.view.setValue(value);
        }
      };
      /** Задать геометрию для редактируемого объекта
        @memberOf nsGmx.EditObjectControl.prototype
        @method setGeometry
        @param {gmxAPI.DrawingObject|geometry} geometry Геометрия в виде drawing объекта или просто описание геометрии
      */


      this.setGeometry = function (geometry) {
        bindGeometry(geometry);
      };

      this.getGeometryObj = function () {
        return geometryInfoRow ? geometryInfoRow.getDrawingObject() : null;
      };

      this.getGeometry = function () {
        if (geometryInfoRow) {
          var geom = geometryInfoRow.getDrawingObject();
          var geojson = geom.toGeoJSON();
          return geojson.geometry;
        } else {
          return null;
        }
      };

      this.getLayer = function () {
        return layer;
      };

      this.add = function (field) {
        fieldsCollection.append(field);
      };

      createDialog();
    };

    nsGmx$1.EditObjectControl = EditObjectControl;
    /** Добавить "хук" для модификации параметров при всех вызовах ф-ции {@link nsGmx.EditObjectControl}
        @function
        @param {function(Object): Object} {paramsHook} Ф-ция, которая принимает на вход параметры ф-ции {@link nsGmx.EditObjectControl}
            и возвращает модифицируемые параметры (возможна замена in place)
    */

    nsGmx$1.EditObjectControl.addParamsHook = EditObjectControlsManager.addParamsHook.bind(EditObjectControlsManager);

    (function ($) {
      var mykosmosnimki = location.protocol + "//my.kosmosnimki.ru"; //"http://localhost:56319"; //

      var initTranslations = function initTranslations() {
        _translationsHash.addtext("rus", {
          ProfilePlugin: {
            profile: "Профиль",
            billing: "Биллинг",
            developer: "Разработчикам",
            firstName: "Фамилия",
            lastName: "Имя",
            email: "Электронная почта",
            login: "Псевдоним",
            fullName: "Полное имя",
            phone: "Телефон",
            company: "Название организации",
            companyProfile: "Вид деятельности организации",
            companyPosition: "Должность",
            isCompany: "Я выступаю от имени организации",
            subscribe: "Я согласен получать сообщения по почте",
            saveChanges: "Сохранить",
            used: "используется",
            remain: "осталось",
            fileStorage: "Файлы",
            fileStorageUsed: "Хранилище файлов используется",
            fileStorageRemain: "Хранилище файлов осталось",
            vectorLayerStorage: "Векторные данные",
            vectorLayerStorageUsed: "Хранилище векторных слоев используется",
            vectorLayerStorageRemain: "Хранилище векторных слоев осталось",
            subscription: "Подписки (Live Alerts)",
            subscriptionUsed: "Подписок (Live Alerts) имеется",
            subscriptionRemain: "Подписок (Live Alerts) осталось",
            smsAvailable: "Sms (Live Alerts) доступны",
            apiKeys: "API-ключи",
            apiKeyInvite: "Для получения ключей воспользуйтесь соответсвующими ссылками",
            apiKeyDomain: "API-ключ на домен (вставка окна карты на сайт)",
            //"API-ключ для сайтов (вставка окна карты на сайт)", //"API-Ключ для домена (для сайтов)",
            apiKeyDomainCap: "API-ключ на домен",
            apiKeyDirect: "API-ключ для приложений (запросы к REST/OGC)",
            //"API-Ключ прямого доступа (для приложений)",
            apiKeyDirectCap: "API-ключ для приложений",
            apiKeyList: "Список API-ключей",
            apiKeyListCap: "Список API-ключей",
            apiKeyDirectShort: "Ключ для приложения",
            apiKeyFilter: "API-ключ или домен",
            apiKeyFilterApply: "Найти",
            apiKeyEnabled: "активен",
            apiKeyDisabled: "не активен",
            apiKeyCreated: "получен",
            directKeyPurpose1: "API-ключ для приложений используется для обращений к <a target='blank' class='hyperLink' href='https://geomixer.ru/docs/dev-manual/rest-api/get-started/'>REST-сервисам</a> для подключения данных в настольные и/или веб-приложения.",
            directKeyPurpose2: "API-ключ для приложений НЕ может быть использован на публичных сайтах.",
            apiKeySite: "Сайт:",
            apiKeyReadAgreement: "Пожалуйста, ознакомьтесь с ",
            apiKeyAgreement: "я согласен с ",
            apiKeyConditions: "условиями использования",
            apiKeyGet: "Получить ключ",
            apiKeyUrge: "Необходимо принять условия использования",
            apiKeyAccept: "Принять",
            apiKeyCancel: "Отклонить",
            apiKeyReceive: "Ваш новый ключ",
            ErrorApiKeySiteEmpty: "Поле сайт не может быть пустым!",
            ErrorApiKeySiteInvalid: "Введите корректный адрес вашего сайта! Например, http://kosmosnimki.ru",
            ErrorApiKeyConditionsNotAccepted: "Для получения ключа необходимо согласиться с условиями использования!",
            clientRegistration: "Регистрация oAuth клиента",
            appName: "Название приложения",
            clientID: "ID клиента (client_id)",
            clientSecret: "oAuth ключ клиента (client_secret)",
            redirectUri: "URI скрипта обратного вызова (redirect_uri)",
            registerClient: "Получить новый ключ",
            password: "Пароль",
            getNew: "Изменить",
            cancelNew: "Закрыть",
            passwordSaved: "сохранен",
            passwordChanged: "изменен",
            old: "Старый пароль",
            newp: "Новый пароль",
            repeat: "Повтор пароля",
            submitp: "Изменить",
            megabyte: " мБ",
            yes: "да",
            no: "нет",
            ErrorNOT_AUTHORIZED: "Пользователь не авторизован!",
            ErrorLoginEmpty: "Требуется указать псевдоним!",
            ErrorLoginFormat: "Неправильный псевдоним! Допустимый вариант ",
            ErrorLoginExists: "Псевдоним уже используется!",
            ErrorAppName: "Не указано название приложения!",
            ErrorRedirectUri: "Требуется действительный uri обратного вызыва!",
            ErrorOldPassword: "Старый пароль указан неверно!",
            ErrorNewPassword: "Пароль не может быть пустым!",
            ErrorNotMatch: "Введённые пароли не совпадают!",
            ErrorCapchaRequired: "Введите число!",
            ErrorWrongCapcha: "Числа не совпадают!",
            ErrorEmailEmpty: "Требуется указать email!",
            ErrorWrongEmail: "Недопустимый адрес электронной почты!",
            ErrorEmailExists: "Такой адрес электронной почты уже зарегистрирован!",
            dataUpdateSuccess: "Изменения сохранены",
            registration: "Регистрация",
            registrationPageAnnotation: "Заполните поля формы",
            //registrationPageAnnotation: "Заполните поля формы. Введите ваш адрес электронной почты, псевдоним, желаемый пароль и число с картинки. Можете указать фамилилию и имя.",
            capcha: "Введите число",
            register: "Зарегистрироваться",
            backOn: "Повторить",
            loginPage: "вход",
            close: "Закрыть"
          }
        });

        _translationsHash.addtext("eng", {
          ProfilePlugin: {
            profile: "Profile",
            billing: "Billing",
            developer: "Developer",
            firstName: "First name",
            lastName: "Last name",
            email: "Email",
            login: "Nickname",
            fullName: "Full name",
            phone: "Phone",
            company: "Company",
            companyProfile: "Type of company activity",
            companyPosition: "Company position",
            isCompany: "I am speaking on behalf of the organization",
            subscribe: "I agree to receive updates and news by email",
            saveChanges: "Save",
            used: "used",
            remain: "rest",
            fileStorage: "Files",
            fileStorageUsed: "File storage consumtion",
            fileStorageRemain: "File storage remain",
            vectorLayerStorage: "Vector data",
            vectorLayerStorageUsed: "Vector storage consumption",
            vectorLayerStorageRemain: "Vector storage remain",
            subscription: "Subscriptions",
            subscriptionUsed: "Subscription consumption",
            subscriptionRemain: "Subscription remain",
            smsAvailable: "Sms",
            apiKeys: "API-keys",
            apiKeyInvite: "To get a key use apropriate links below",
            apiKeyDomain: "Domain API-key (for sites)",
            apiKeyDomainCap: "Domain API-key",
            apiKeyDirect: "Direct access API-key (for applications)",
            apiKeyDirectCap: "Direct access API-key",
            apiKeyList: "Issued API-keys list",
            apiKeyListCap: "Issued API-keys list",
            apiKeyDirectShort: "Direct access key",
            apiKeyFilter: "Key or domain",
            apiKeyFilterApply: "Search",
            apiKeyEnabled: "enabled",
            apiKeyDisabled: "disabled",
            apiKeyCreated: "created",
            directKeyPurpose1: "API-ключ для приложений используется для обращений к REST-сервисам (https://geomixer.ru/docs/dev-manual/rest-api/get-started/) для подключения данных в настольные и/или веб-приложения. API-ключ для приложений НЕ может быть использован на публичных сайтах.",
            directKeyPurpose2: "Ключ прямого доступа не может быть использован на сайте.",
            apiKeySite: "Site:",
            apiKeyReadAgreement: "Пожалуйста, ознакомьтесь с ",
            apiKeyAgreement: "я согласен с ",
            apiKeyConditions: "условиями использования",
            apiKeyGet: "Get the key",
            apiKeyUrge: "Необходимо принять условия использования",
            apiKeyAccept: "Accept",
            apiKeyCancel: "Cancel",
            apiKeyReceive: "Ваш новый ключ",
            ErrorApiKeySiteEmpty: "Поле сайт не может быть пустым!",
            ErrorApiKeySiteInvalid: "Введите корректный адрес вашего сайта! Например, http://kosmosnimki.ru",
            ErrorApiKeyConditionsNotAccepted: "Для получения ключа необходимо согласиться с условиями использования!",
            clientRegistration: "oAuth Client Registration",
            appName: "Client Application",
            clientID: "Client ID (client_id)",
            clientSecret: "Client secret key (client_secret)",
            redirectUri: "Redirect endpoint URI",
            registerClient: "Issue new secret key",
            password: "Password",
            getNew: "change",
            cancelNew: "close",
            passwordSaved: "saved",
            passwordChanged: "changed",
            old: "Old password",
            newp: "New password",
            repeat: "Repeat",
            submitp: "Change",
            megabyte: " MB",
            yes: "yes",
            no: "no",
            ErrorNOT_AUTHORIZED: "Authorization is required!",
            ErrorLoginEmpty: "Nickname is required!",
            ErrorLoginFormat: "Invalid nickname! Allowable nickname ",
            ErrorLoginExists: "Nickname duplicates!",
            ErrorAppName: "Application name is required!",
            ErrorRedirectUri: "Valid redirect uri is required!",
            ErrorOldPassword: "Password is invalid!",
            ErrorNewPassword: "Password is required!",
            ErrorNotMatch: "Passwords does not match!",
            ErrorCapchaRequired: "Input a number!",
            ErrorWrongCapcha: "Number mismatch!",
            ErrorEmailEmpty: "Email is required!",
            ErrorWrongEmail: "Invalid email!",
            ErrorEmailExists: "Email duplicates!",
            dataUpdateSuccess: "Saved successfully",
            registration: "Registration",
            registrationPageAnnotation: "Please fill all fields",
            capcha: "Input a number",
            register: "Register",
            backOn: "Back to",
            loginPage: "Login",
            close: "Close"
          }
        });
      };

      var ppBackScreen = $("div.profilePanel"),
          ppMainParts;

      var showProfile = function showProfile() {
        if (!ppBackScreen.length) {
          // Create
          ppBackScreen = $('<div class="profilePanel"><table width="100%" height="100%"><tr><td><img src="img/progress.gif"></td></tr></table></div>').hide().appendTo('#all');
          var ppFrame = $('<div class="profilePanel-content"></div>');
          var ppScrollableContainer = $('<div class="profilePanel-scrollable"></div>');
          var ppMenu = $('<div class="profilePanel-menu"></div>');
          var success = $('<div class="UpdateMessage"><div class="success">' + _gtxt('ProfilePlugin.dataUpdateSuccess') + '</div></div>');
          var fail = $('<div class="UpdateMessage"><div class="fail">' + 'Error' + '</div></div>'); // Pages

          var pageTemplate = '<div class="page">' + '{{#each items}}' + '{{#if form_caption}}' + '<div class="form-caption {{#if first}}first{{/if}}">{{text}}</div>' + '{{/if}}' + '{{#if span}}' + '<div>{{text}}: <span {{#if id}}class="{{id}}"{{/if}}></span></div>' + '{{/if}}' + '{{#if span_nl}}' + '<div>{{text}}:<br/><span {{#if id}}class="{{id}}"{{/if}}></span></div>' + '{{/if}}' + '{{#if block}}' + '<div>' + '{{#content}}' + '{{#if p}}<p>{{text}}</p>{{/if}}' + '{{#if link_button}}<div {{#if id}}class="{{id}} link_button"{{/if}}><span>{{text}}</span></div>{{/if}}' + '{{/content}}' + '</div>' + '{{/if}}' + '{{#if text_input}}' + '<div onclick="$(this).children().focus()" class="editable">{{text}}: <input {{#if id}}class="{{id}}"{{/if}} type="text" value=""></div>' + '{{/if}}' + '{{#if text_area}}' + '<div onclick="$(this).children().focus()" class="editable">{{text}}: <textarea {{#if id}}class="{{id}}"{{/if}}></textarea></div>' + '{{/if}}' + '{{#if error}}' + '<div class="ErrorSummary">error</div>' + '{{/if}}' + '{{#if button_input}}' + '<div class="SubmitBlock" {{#if width}}style="width:{{width}}"{{/if}}>' + '<input type="button" {{#if id}}class="{{id}}"{{/if}} value="{{text}}"/>' + '<img src="img/progress.gif"></div>' + '{{/if}}' + '{{#if checkbox_group}}' + '<table>' + '{{#each checkbox_group}}' + '<tr><td><input type="checkbox" class="{{id}}" id="pp{{id}}"></td><td><label for="pp{{id}}">{{text}}</label></td></tr>' + '{{/each}}' + '</table>' + '{{/if}}' + '{{#if table}}' + '<table border=0 class="{{id}}">' + '{{#columns}}' + '<tr><th>{{column1}}</th><th>{{column2}}</th><th>{{column3}}</th></tr>' + '{{/columns}}' + '{{#rows}}' + '<tr>{{#cells}}<td class="{{id}}">{{text}}</td>{{/cells}}</tr>' + '{{/rows}}' + '</table>' + '{{/if}}' + '{{/each}}' + '</div>';
          var page1 = $(Handlebars.compile(pageTemplate)({
            id: "page1",
            items: [{
              span: true,
              id: "Email",
              text: _gtxt('ProfilePlugin.email')
            }, {
              text_input: true,
              id: "Login LoginEmpty LoginFormat LoginExists correct",
              text: _gtxt('ProfilePlugin.login')
            }, {
              text_input: true,
              id: "FullName correct",
              text: _gtxt('ProfilePlugin.fullName')
            }, {
              text_input: true,
              id: "Phone correct",
              text: _gtxt('ProfilePlugin.phone')
            }, {
              text_input: true,
              id: "Company correct",
              text: _gtxt('ProfilePlugin.company')
            }, {
              text_input: true,
              id: "CompanyProfile correct",
              text: _gtxt('ProfilePlugin.companyProfile')
            }, {
              text_input: true,
              id: "CompanyPosition correct",
              text: _gtxt('ProfilePlugin.companyPosition')
            }, {
              checkbox_group: [{
                id: "IsCompany",
                text: _gtxt('ProfilePlugin.isCompany')
              }, {
                id: "Subscribe",
                text: _gtxt('ProfilePlugin.subscribe')
              }]
            }, {
              error: true
            }, {
              button_input: true,
              id: "SaveChanges",
              text: _gtxt('ProfilePlugin.saveChanges')
            }]
          })).appendTo(ppFrame),
              page2 = $(Handlebars.compile(pageTemplate)({
            id: "page2",
            items: [{
              table: true,
              id: "ResourceTable",
              columns: [{
                column1: "",
                column2: _gtxt('ProfilePlugin.used'),
                column3: _gtxt('ProfilePlugin.remain')
              }],
              rows: [{
                cells: [{
                  id: "FileStorage",
                  text: _gtxt('ProfilePlugin.fileStorage')
                }, {
                  id: "FileStorageUsed value",
                  text: "b1"
                }, {
                  id: "FileStorageRemain value",
                  text: "c1"
                }]
              }, {
                cells: [{
                  id: "VectorLayerStorage",
                  text: _gtxt('ProfilePlugin.vectorLayerStorage')
                }, {
                  id: "VectorLayerStorageUsed value",
                  text: "b2"
                }, {
                  id: "VectorLayerStorageRemain value",
                  text: "c2"
                }]
              }, {
                cells: [{
                  id: "Subscription",
                  text: _gtxt('ProfilePlugin.subscription')
                }, {
                  id: "SubscriptionUsed value",
                  text: "b3"
                }, {
                  id: "SubscriptionRemain value",
                  text: "c3"
                }]
              }]
            }, {
              span: true,
              id: "SmsAvailable",
              text: _gtxt('ProfilePlugin.smsAvailable')
            }]
          })).appendTo(ppFrame),
              page3 = $(Handlebars.compile(pageTemplate)({
            id: "page3",
            items: [{
              form_caption: true,
              text: _gtxt('ProfilePlugin.apiKeys'),
              first: true
            }, {
              block: true,
              content: [{
                link_button: true,
                text: _gtxt('ProfilePlugin.apiKeyList'),
                id: "apiKeyList"
              }]
            }, {
              block: true,
              content: [{
                p: true,
                text: _gtxt('ProfilePlugin.apiKeyInvite')
              }, {
                link_button: true,
                text: _gtxt('ProfilePlugin.apiKeyDomain'),
                id: "apiKeyDomain"
              }, {
                link_button: true,
                text: _gtxt('ProfilePlugin.apiKeyDirect'),
                id: "apiKeyDirect"
              }]
            }, {
              form_caption: true,
              text: _gtxt('ProfilePlugin.clientRegistration')
            }, {
              text_input: true,
              id: "AppName correct",
              text: _gtxt('ProfilePlugin.appName')
            }, {
              span: true,
              id: "ClientID",
              text: _gtxt('ProfilePlugin.clientID')
            }, {
              span_nl: true,
              id: "ClientSecret",
              text: _gtxt('ProfilePlugin.clientSecret')
            }, {
              text_input: true,
              id: "RedirectUri correct",
              text: _gtxt('ProfilePlugin.redirectUri')
            }, {
              error: true
            }, {
              button_input: true,
              id: "RegisterClient",
              text: _gtxt('ProfilePlugin.registerClient'),
              width: '180px'
            }]
          })).appendTo(ppFrame); // Profile submit

          var successmess_timeout;
          page1.find('.SaveChanges').click(function () {
            changePassForm.slideUp("fast");
            changePassControls.first().val(_gtxt('ProfilePlugin.getNew'));
            success.hide();
            var wait = $(this).next().css('visibility', 'visible');
            clearTimeout(successmess_timeout);
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/Settings", {
              WrapStyle: 'message',
              Login: page1.find('.Login').val().trim(),
              FullName: page1.find('.FullName').val().trim(),
              Phone: page1.find('.Phone').val().trim(),
              Company: page1.find('.Company').val().trim(),
              Profile: page1.find('.CompanyProfile').val().trim(),
              Position: page1.find('.CompanyPosition').val().trim(),
              IsCompany: page1.find('.IsCompany').is(":checked"),
              Subscribe: page1.find('.Subscribe').is(":checked")
            }, function (response) {
              wait.css('visibility', 'hidden');

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                //page1.children('.ErrorSummary').text('error').css('visibility', 'hidden');
                page1.children('.ErrorSummary').hide();
                success.show();
                successmess_timeout = setTimeout(function () {
                  success.hide();
                }, 2000);
              } else if (response.Result.length > 0 && response.Result[0].Key) page1.trigger('onerror', [response.Result[0].Key, response.Result[0].Value.Errors[0].ErrorMessage]);else page1.trigger('onerror', response.Result.Message);
            });
          }); // Register client submit

          var newsecret_timeout;
          page3.find('.RegisterClient').click(function () {
            closeApiKeyDialog();
            var wait = $(this).next().css('visibility', 'visible');
            var client_secret = page3.find('.ClientSecret').removeClass('new');
            clearTimeout(newsecret_timeout);
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/RegisterClient", {
              WrapStyle: 'message',
              AppName: page3.find('.AppName').val(),
              RedirectUri: page3.find('.RedirectUri').val()
            }, function (response) {
              wait.css('visibility', 'hidden');

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                client_secret.addClass('new').text(response.Result.Key);
                newsecret_timeout = setTimeout(function () {
                  client_secret.removeClass('new');
                }, 2000); //page3.children('.ErrorSummary').css('visibility', 'hidden');

                page3.children('.ErrorSummary').hide();
              } else {
                page3.trigger('onerror', response.Result.Message);
              }
            });
          });
          var ppPages = ppFrame.find('div.page').hide(); // Change password form

          var changePassControls = $(Handlebars.compile('<input style="width:80px; float:right; margin:6px 12px 0 0;" type="button" value="{{i "ProfilePlugin.getNew"}}"/>' + '<div style="border:none; font-weight:normal;margin:10px 0 10px 12px;">{{i "ProfilePlugin.password"}} <span class="PasswordState">{{i "ProfilePlugin.passwordSaved"}}</span></div>')()).insertAfter(page1.find('.Email').parent()),
              changePassForm = $(Handlebars.compile('<div class="newpass-form">' + '{{i "ProfilePlugin.old"}}: <input type="password" class="OldPassword" value=""><br/>' + '{{i "ProfilePlugin.newp"}}: <input type="password" class="NewPassword NotMatch" value=""><br/>' + '{{i "ProfilePlugin.repeat"}}: <input type="password" class="PasswordRepeat NotMatch" value=""><br/>' + '<div class="ErrorSummary" style="padding-top:6px"></div>\
                <div class="SubmitBlock">\
                <input type="button" class="ChangePassword" value="{{i "ProfilePlugin.submitp"}}"/>\
                <img src="img/progress.gif"></div>' + '</div>')()),
              changePass_timeout;
          changePassForm.insertAfter(changePassControls.last());
          changePassForm.find('.ChangePassword').click(function () {
            //clearPageErrors($(this));
            //clearPageErrors(page1);
            var wait = $(this).next().css('visibility', 'visible');
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/ChangePassword", {
              WrapStyle: 'message',
              oldpassword: changePassForm.children('.OldPassword').val().trim(),
              password: changePassForm.children('.NewPassword').val().trim(),
              repeat: changePassForm.children('.PasswordRepeat').val().trim()
            }, function (response) {
              wait.css('visibility', 'hidden');
              clearTimeout(changePass_timeout);

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                var state = changePassForm.hide().prev().find('.PasswordState').text(_gtxt('ProfilePlugin.passwordChanged')).addClass('changed');
                changePassControls.first().val(_gtxt('ProfilePlugin.getNew'));
                changePass_timeout = setTimeout(function () {
                  state.fadeOut("slow", function () {
                    $(this).text(_gtxt('ProfilePlugin.passwordSaved')).removeClass('changed');
                  }).fadeIn("slow");
                }, 2000);
              } else changePassForm.trigger('onerror', response.Result.Message);
            });
          });
          changePassControls.first().click(function () {
            if (changePassForm.is(':visible')) {
              changePassForm.slideUp("fast");
              $(this).val(_gtxt('ProfilePlugin.getNew'));
            } else {
              changePassForm.slideDown("fast");
              $(this).val(_gtxt('ProfilePlugin.cancelNew'));
              changePassForm.trigger('onrender');
            }
          }); // API-keys dialogs

          var closeApiKeyDialog = function closeApiKeyDialog() {
            var akd = $('.apiKeyDialog');

            if (akd.length > 0) {
              // akd.find('.licence').mCustomScrollbar("destroy");
              // akd.find('.list').mCustomScrollbar("destroy");
              removeDialog($('.apiKeyDialog').parent()[0]);
            }
          },
              showApiKeyDialog = function showApiKeyDialog(dtype) {
            //if ($('.apiKeyDialog').length > 0) {
            //  return;
            //}
            closeApiKeyDialog();
            clearPageErrors($('.page:visible'));

            if (dtype == 'List') {
              var startW = 556,
                  startH = 340,
                  akDialog = $('<div class="apiKeyDialog"></div>'),
                  wait = $('<div style="position:absolute; top:120px; left:270px"><img src="img/progress.gif"></div>');
              akDialog.append(wait);
              window.showDialog(_gtxt('ProfilePlugin.apiKey' + dtype + 'Cap'), akDialog[0], startW, startH).style.overflow = 'hidden';
              akDialog.parent().on("dialogresizestart", function () {//startW = ui.size.width;
                //startH = ui.size.height;
              }).on("dialogresize", function (event, ui) {
                var list = akDialog.find('.list');
                list.height(list.height() + ui.size.height - startH); //startW = ui.size.width;

                startH = ui.size.height;
              });
              sendCrossDomainJSONRequest(mykosmosnimki + "/handler/apikeys?wrapstyle=func", function (response) {
                if (parseResponse(response) || response.Status == 'OK') {
                  wait.remove();

                  if (response.Result && response.Result.length > 0) {
                    var list = $('<div class="list"></div>'),
                        apiKeyActivation = function apiKeyActivation() {
                      var checkboxes = $('input[type="checkbox"]', list).click(function () {
                        checkboxes.prop('disabled', true);
                        var progress = $('<span>&nbsp;</span><img src="img/progress.gif">');
                        var checkbox = $(this);
                        checkbox.parent().append(progress);
                        sendCrossDomainPostRequest(mykosmosnimki + "/Handler/ActivateKey", {
                          WrapStyle: 'message',
                          Apikey: checkbox.val()
                        }, function (apiKeyResp) {
                          checkboxes.prop('disabled', false);
                          progress.remove();

                          if (apiKeyResp.Status.toLowerCase() == 'ok') {
                            for (var i = 0; i < response.Result.length; ++i) {
                              if (response.Result[i].Apikey == apiKeyResp.Result.Apikey) {
                                response.Result[i].IsActive = apiKeyResp.Result.IsActive;
                                break;
                              }
                            }
                          } else {
                            console.log(response);
                          }
                        });
                      });
                    },
                        createTbl = function createTbl(filter) {
                      var tbl = '<div><table border=0>';
                      var re = new RegExp(filter, 'i');

                      for (var i = 0; i < response.Result.length; ++i) {
                        if (filter == null || filter.search(/\S/) < 0 || response.Result[i].Apikey.search(re) != -1 || response.Result[i].Domain != 'Direct' && response.Result[i].Domain.search(re) != -1) tbl += '<tr><td>' + response.Result[i].Apikey + '</td><td style="word-break:break-all">' + (response.Result[i].AllowDirect ? _gtxt('ProfilePlugin.apiKeyDirectShort') : response.Result[i].Domain) + //'</td><td>' + (response.Result[i].IsActive ? '<i class="icon-check">' : '') +
                        '</td><td>' + '<input type="checkbox" ' + (response.Result[i].IsActive ? 'checked' : '') + ' value="' + response.Result[i].Apikey + '">' + '</td><td>' + response.Result[i].Created + '</td></tr>';
                      }

                      tbl += '</table></div>';
                      return tbl;
                    };

                    var filter = $('<div style="padding-left:6px">' + _gtxt('ProfilePlugin.apiKeyFilterApply') + ': <input type="text" placeholder="' + _gtxt('ProfilePlugin.apiKeyFilter') + '"></div>').appendTo(akDialog);
                    filter.find('input[type="text"]').keyup(function () {
                      list.find('table').parent().remove();
                      list.mCustomScrollbar('destroy').append(createTbl($(this).val())).mCustomScrollbar();
                      apiKeyActivation();
                      keys = list.find('table');
                      resize(akDialog.parent().dialog("option", "width") - startW);
                    });
                    list.appendTo(akDialog).append($(createTbl())).mCustomScrollbar();
                    apiKeyActivation();

                    var header = list.before($(Handlebars.compile('<table border=0><tr><th>ключ</th><th>тип/сайт</th><th>активен</th><th>{{i "ProfilePlugin.apiKeyCreated"}}</th></tr></table>')())).prev(),
                        keys = list.find('table'),
                        resize = function resize(dif) {
                      var th = header.find('tr th');
                      var td = keys.find('tr:eq(0) td');
                      header.width(keys.width(514 + dif).width());
                      th.eq(0).width(td.eq(0).width(90).width());
                      th.eq(2).width(td.eq(2).width(70).width());
                      th.eq(3).width(td.eq(3).width(90).width());
                      th.eq(1).width(td.eq(1).width());
                    };

                    akDialog.parent().on("dialogresize", function (event, ui) {
                      resize(ui.size.width - startW);
                    });
                    resize(0);
                  }
                } else {
                  removeDialog(akDialog.parent()[0]);
                }
              });
            } else {
              var fordirect = dtype == 'Direct' ? '<div>{{{i "ProfilePlugin.directKeyPurpose1"}}}</div>' + '<div>{{i "ProfilePlugin.directKeyPurpose2"}}</div>' : '';
              var fordomain = dtype == 'Domain' ? '<div>{{i "ProfilePlugin.apiKeySite"}}<input type="text" tabindex="2" class="ApiKeySite ApiKeySiteEmpty ApiKeySiteInvalid" value="http://"></div>' : '';
              var akForm = $(Handlebars.compile('<div class="apiKeyDialog">' + '<div class="first">' + '<div>{{i "ProfilePlugin.apiKeyReadAgreement"}}<span class="showLicence hyperLink">{{i "ProfilePlugin.apiKeyConditions"}}</span></div>' + '<div><div style="float:left;margin:0"><input type="checkbox" tabindex="1" id="agree" class="agree"></div><div style="padding-left:10px"><label for="agree">{{i "ProfilePlugin.apiKeyAgreement"}} {{i "ProfilePlugin.apiKeyConditions"}}</div></div>' + fordomain + fordirect + '<div class="spacer"></div>' + '<div class="ErrorSummary"><span class="fail"></span><span class="success"></span><img class="wait" src="img/progress.gif"></div>' + '<div class="submit"><input tabindex="3" type="button" class="get" title="{{i "ProfilePlugin.apiKeyUrge"}}" value="{{i "ProfilePlugin.apiKeyGet"}}"/></div>' + '</div>' + '<div class="licence"></div>' + '<div class="submit"><input tabindex="1" type="button" class="accept" value="{{i "ProfilePlugin.apiKeyAccept"}}"/><input tabindex="2" type="button" class="cancel" value="{{i "ProfilePlugin.apiKeyCancel"}}"/></div>' + '</div>')());

              var licence = akForm.find('.licence'),
                  spacer = akForm.find('.spacer'),
                  _startH;

              licence.hide().next().hide();
              if (dtype == 'Domain') spacer.height('20px');

              var summary = akForm.find('.ErrorSummary'),
                  _wait = summary.children('.wait'),
                  site = akForm.find('.ApiKeySite'),
                  agree = akForm.find('.agree'),
                  getKey = akForm.find('.get').css('opacity', 0.5).click(function () {
                var respHandler = function respHandler(response) {
                  _wait.css('visibility', 'hidden');

                  if (response.Status.toLowerCase() == 'ok' && response.Result) {
                    summary.children('span.success').text(_gtxt('ProfilePlugin.apiKeyReceive') + ' ' + response.Result.Key);
                  } else {
                    summary.children('span.fail').text(_gtxt('ProfilePlugin.Error' + response.Result.Message));
                    akForm.find('.' + response.Result.Message).addClass('error');
                  }
                };

                clearError();

                _wait.css('visibility', 'visible');

                if (site.length) sendCrossDomainPostRequest(mykosmosnimki + "/Handler/CreateKey", {
                  WrapStyle: 'message',
                  domain: site.val(),
                  agree: agree.is(':checked')
                }, respHandler);else sendCrossDomainPostRequest(mykosmosnimki + "/Handler/CreateDirect", {
                  WrapStyle: 'message',
                  agree: agree.is(':checked')
                }, respHandler);
              });

              getKey.prop('disabled', true);
              site.prop('disabled', true).keydown(function (e) {
                if ($(this).is('.error')) clearError();
                if (e.which == 13) getKey.click();
              });

              var clearError = function clearError() {
                summary.children('span').text('');
                site.removeClass('error');
              };

              akForm.find('.showLicence').click(function () {
                clearError();
                licence.show().prev().hide();
                licence.next().show();
                if (licence.text() == '') licence.load(window.gmxCore.getModulePath('ProfilePlugin') + 'license.html', function () {
                  licence.mCustomScrollbar();
                });
              });
              licence.next('div').children('input').click(function () {
                licence.next().hide();
                licence.hide().prev().show();
              }).first().click(function () {
                agree[0].checked = true;
                agree.change();
              }).next('.cancel').click(function () {
                agree[0].checked = false;
                agree.change();
              });
              agree.change(function () {
                getKey.prop('disabled', !agree.is(':checked'));
                site.prop('disabled', !agree.is(':checked'));

                if (agree.is(':checked')) {
                  getKey.css('opacity', 1).focus().attr('title', _gtxt('ProfilePlugin.apiKeyGet'));
                } else {
                  getKey.css('opacity', 0.5).attr('title', _gtxt('ProfilePlugin.apiKeyUrge'));
                }
              });
              window.showDialog(_gtxt('ProfilePlugin.apiKey' + dtype + 'Cap'), akForm[0], 555, 320);
              akForm.parent('.ui-dialog-content').css('overflow', 'hidden');
              akForm.parent().on("dialogresizestart", function (event, ui) {
                _startH = ui.size.height;
              }).on("dialogresize", function (event, ui) {
                licence.height(licence.height() + ui.size.height - _startH);
                spacer.height(spacer.height() + ui.size.height - _startH);
                _startH = ui.size.height;
              });
            }
          };

          page3.find('.apiKeyDomain').click(function () {
            showApiKeyDialog('Domain');
          });
          page3.find('.apiKeyDirect').click(function () {
            showApiKeyDialog('Direct');
          });
          page3.find('.apiKeyList').click(function () {
            showApiKeyDialog('List');
          });
          ppPages.find('input[type="text"], input[type="password"]').keyup(function (e) {
            if (e.which == 13) {
              var submit = $(this).siblings('div.SubmitBlock').children('input[type="button"]');
              if (!submit.length) submit = $(this).parent().siblings('div.SubmitBlock').children('input[type="button"]');
              submit.click();
            } else clearInputErrors($(this));
          }).focusin(function () {
            closeApiKeyDialog();
            clearInputErrors($(this));
          }); // Error display

          var clearInputErrors = function clearInputErrors(input) {
            if (input.val().search(/\S/) != -1 && input.is('.error')) {
              var es = input.nextAll('.ErrorSummary');
              if (es.length == 0) es = input.parent().nextAll('.ErrorSummary');

              if (input.is('.NotMatch')) {
                var s = input.siblings('.NotMatch');

                if (s.val() === input.val()) {
                  input.removeClass('error');
                  s.removeClass('error');
                  es.slideUp(); //.hide();
                }
              } else {
                input.removeClass('error').addClass('correct');
                es.slideUp(); //.hide();
              }
            }
          };

          var clearPageErrors = function clearPageErrors(page) {
            page.find('.ErrorSummary').hide();
            page.find('.error').removeClass('error');
          };

          changePassForm.bind('onerror', function (e, m) {
            $(this).children('.ErrorSummary').text(_gtxt('ProfilePlugin.Error' + m)).slideDown('slow');
            $(this).find('.' + m).addClass('error');
            $(this).find(':password,:text').filter(function () {
              return $(this).val() == "";
            }).addClass('error');
            return false;
          });
          changePassForm.bind('onrender', function () {
            $(this).children('input[type="password"]').val('');
            clearPageErrors($(this));
            clearPageErrors(page1);
            return false;
          });
          ppPages.bind('onerror', function (e, m1, m2) {
            var m = _gtxt('ProfilePlugin.Error' + m1);

            if (m2) m += " " + m2;
            $(this).children('.ErrorSummary').text(m).slideDown('slow');
            $(this).find('.' + m1).removeClass('correct').addClass('error');
            return false;
          });
          ppPages.bind('onrender', function () {
            clearPageErrors($(this));
            changePassForm.hide();
            changePassControls.first().val(_gtxt('ProfilePlugin.getNew'));
            return false;
          });
          ppPages.first().show();
          ppScrollableContainer.hide().appendTo('#all').append(ppFrame); // Menu

          var menuEntryTemplate = '<div class="MenuEntry">{{text}}</div>';

          var showPage = function showPage(e, page) {
            closeApiKeyDialog();
            ppMenu.children('.MenuEntry').removeClass('selected');
            ppPages.hide();
            page.show();
            $(e.target).removeClass('targeted').addClass('selected');
            page.trigger('onrender');
          };

          $(Handlebars.compile(menuEntryTemplate)({
            text: _gtxt('ProfilePlugin.profile')
          })).appendTo(ppMenu).click(function (e) {
            showPage(e, page1);
          });
          $(Handlebars.compile(menuEntryTemplate)({
            text: _gtxt('ProfilePlugin.billing')
          })).appendTo(ppMenu).click(function (e) {
            showPage(e, page2);
          });
          $(Handlebars.compile(menuEntryTemplate)({
            text: _gtxt('ProfilePlugin.developer')
          })).appendTo(ppMenu).click(function (e) {
            showPage(e, page3);
          }); //wait.appendTo(ppMenu).hide();

          success.appendTo(ppMenu).hide();
          fail.appendTo(ppMenu).hide();
          ppMenu.hide().appendTo('#all');
          var ppMenuEntries = ppMenu.children('.MenuEntry');
          ppMenuEntries.first().addClass('selected');
          ppMenuEntries.mouseover(function (e) {
            if (!$(e.target).is('.selected')) $(e.target).addClass('targeted');
          });
          ppMenuEntries.mouseout(function (e) {
            if (!$(e.target).is('.selected')) $(e.target).removeClass('targeted');
          }); // All together

          ppMainParts = $([ppScrollableContainer, ppMenu]).map(function () {
            return this[0];
          });
          ppMainParts.data('ondataload', function () {
            if (ppBackScreen.is(':visible')) {
              ppPages.trigger('onrender');
              ppMainParts.show();
            }
          });
          $('body>div>div').mousedown(function (e) {
            if (!ppMainParts.is($(e.target)) && !ppMainParts.find($(e.target)).length) {
              ppBackScreen.hide();
              ppMainParts.hide();
              closeApiKeyDialog();

              if (!nsGmx$1.leafletMap.gmxControlsManager.get('layers')) {
                nsGmx$1.leafletMap.addControl(overlays);
              }
            }
          });
          ppScrollableContainer.mCustomScrollbar();
          $(window).resize(resizePanel);
        } // Show


        var overlays = nsGmx$1.leafletMap.gmxControlsManager.get('layers');
        ppBackScreen.show();
        fillProfile(ppMainParts.data('ondataload'), function () {
          ppBackScreen.hide();
        });
        resizePanel();
      };

      var fillProfile = function fillProfile(onsuccess, onerror) {
        sendCrossDomainJSONRequest(mykosmosnimki + "/currentuser.ashx", function (response) {
          if (parseResponse(response) && response.Result) {
            var content = $('.profilePanel-content');
            content.find('.Email').text(response.Result[0].Email);
            content.find('.PasswordState').text(_gtxt('ProfilePlugin.passwordSaved'));
            content.find('.Login').val(response.Result[0].Login);
            content.find('.FullName').val(response.Result[0].FullName);
            content.find('.Phone').val(response.Result[0].Phone);
            content.find('.Company').val(response.Result[0].Company);
            content.find('.CompanyProfile').val(response.Result[0].CompanyProfile);
            content.find('.CompanyPosition').val(response.Result[0].CompanyPosition);
            content.find('.Subscribe').prop('checked', response.Result[0].Subscribe);
            content.find('.IsCompany').prop('checked', response.Result[0].IsCompany);
            fillBillingPage(content, response);
            fillDeveloperPage(content, response);
            onsuccess();
          } else {
            onerror();
          }
        });
      };

      var fillBillingPage = function fillBillingPage(content, response) {
        content.find('.FileStorageUsed').text((response.Result[0].FileStorageUsed / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.FileStorageRemain').text(response.Result[0].FileStorageAvailable == null ? '' : ((response.Result[0].FileStorageAvailable - response.Result[0].FileStorageUsed) / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.VectorLayerStorageUsed').text((response.Result[0].VectorLayerStorageUsed / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.VectorLayerStorageRemain').text(response.Result[0].VectorLayerStorageAvailable == null ? '' : ((response.Result[0].VectorLayerStorageAvailable - response.Result[0].VectorLayerStorageUsed) / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.VectorLayers').text(response.Result[0].VectorLayers);
        content.find('.VectorLayerObjects').text(response.Result[0].VectorLayerObjects);
        content.find('.SmsAvailable').text(response.Result[0].SmsAvailable == null || response.Result[0].SmsAvailable > 0 ? _gtxt('ProfilePlugin.yes') : _gtxt('ProfilePlugin.no'));
        content.find('.SubscriptionUsed').text(response.Result[0].SubscriptionUsed != null ? response.Result[0].SubscriptionUsed : '');
        content.find('.SubscriptionRemain').text(response.Result[0].SubscriptionRemain != null ? response.Result[0].SubscriptionRemain : '');
      };

      var fillDeveloperPage = function fillDeveloperPage(content, response) {
        content.find('.AppName').val(response.Result[0].AppName);
        content.find('.ClientID').text(response.Result[0].ID);
        content.find('.ClientSecret').text(response.Result[0].ClientSecret);
        content.find('.RedirectUri').val(response.Result[0].RedirectUri);
      };

      var resizePanel = function resizePanel() {
        var h = $('#leftMenu').css('height');
        $('.profilePanel, .profilePanel-scrollable, .profilePanel-menu').height(h);
      }; // RegistrationForm


      var showRegistrationForm = function showRegistrationForm() {
        var registrationForm = $(Handlebars.compile('<table style="width:100%;height:100%;" border="0"><tr><td>\
        <form>\
            <table class="registrationForm" border="0">\
            <tr><td colspan="2" class="header">{{i "ProfilePlugin.registrationPageAnnotation"}}</td></tr>\
			<tr><td colspan="2">\
			<table border="0"><tr>\
			<td>{{i "ProfilePlugin.firstName"}}</td><td align="right"><input type="text" tabindex="1" class="FirstName" id="RegFirstName" name="RegFirstName"/></td>\
			<td class="LastNameLbl">{{i "ProfilePlugin.lastName"}}</td><td align="right"><input type="text" tabindex="1" class="LastName" id="RegLastName" name="RegLastName"/></td>\
			</tr></table>\
			</td></tr>\
            <tr><td colspan="2"><table border="0"><tr><td>{{i "ProfilePlugin.email"}}</td><td align="right"><input type="text" tabindex="1" class="Login EmailEmpty WrongEmail EmailExists" id="RegEmail" name="RegEmail"/></td></tr></table></td></tr>\
            <tr>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.password"}}</td><td align="right"><input tabindex="2" type="password" class="Password NewPassword NotMatch"/></td></tr></table>\
                </td>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.repeat"}}</td><td align="right"><input type="password" tabindex="3" class="Repeat NotMatch"/></td></tr></table>\
                </td>\
            </tr>\
            <tr>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.login"}}</td><td align="right"><input type="text" tabindex="4" class="NickName LoginEmpty LoginFormat LoginExists" id="RegNick" name="RegNick"/></td></tr></table>\
                </td>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.capcha"}}</td><td align="right"><input type="text" tabindex="5" class="Capcha CapchaRequired WrongCapcha"/></td><td align="right">' + '<img src="' + mykosmosnimki + '/Account/Captcha?r=' + Math.round(Math.random() * Math.pow(10, 9)) + '">' + '</td></tr></table>\
            </tr>\
            <tr><td colspan="2" class="submit">\
                <div class="ErrorSummary"></div>\
                <div class="SubmitBlock">\
                <input tabindex="6" type="button" value="{{i "ProfilePlugin.register"}}"/>\
                <img src="img/progress.gif"></div>\
            </td></tr>\
            <tr><td colspan="2">\
            <div class="policy">\
            Нажимая на кнопку, вы соглашаетесь с <a target="blank" href="//my.kosmosnimki.ru/Docs/Политика конфиденциальности.pdf">политикой конфиденциальности</a>\
            и <a target="blank" href="//my.kosmosnimki.ru/Docs/Политика оператора в отношении обработки и защиты персональных данных.pdf">политикой оператора</a> в отношении обработки и защиты персональных данных\
            </td></tr>\
            </table>\
        </form>\
        </td></tr></table>')()),
            confirmScreen = $(Handlebars.compile('<div class="registrationConfirm"><div></div><div><input type="button" value="{{i "ProfilePlugin.close"}}"/></div></div>')()),
            errorSummaryHeight,
            submit = registrationForm.find('input[type="button"]').click(function () {
          var errorSummary = registrationForm.find('.ErrorSummary'),
              wait = submit.next('img').css('visibility', 'visible');
          registrationForm.find('form').submit();

          _mapHelper.createPermalink(function (id) {
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/RegistrationExt", {
              WrapStyle: 'message',
              firstName: registrationForm.find('.FirstName').val(),
              lastName: registrationForm.find('.LastName').val(),
              email: registrationForm.find('.Login').val(),
              login: registrationForm.find('.NickName').val(),
              password: registrationForm.find('.Password').val(),
              repeat: registrationForm.find('.Repeat').val(),
              captcha: registrationForm.find('.Capcha').val(),
              permalink: "http://" + window.location.host + window.location.pathname + "?permalink=" + id + (window.defaultMapID == window.globalMapName ? "" : "&" + window.globalMapName)
            }, function (response) {
              registrationForm.find('.Capcha').val("");
              registrationForm.find('input[type="button"]').focus();
              wait.css('visibility', 'hidden');

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                //afterRegistration();
                regFormDialog.style.height = errorSummaryHeight;
                registrationForm.fadeOut("slow", function () {
                  $(this).replaceWith(confirmScreen); //.fadeIn("slow");
                });
                confirmScreen.children('div').first().text(response.Result.Message);
                confirmScreen.find('input').click(function () {
                  removeDialog(regFormDialog);
                });
              } else {
                registrationForm.find('.error').removeClass('error');
                errorSummary.text('');
                registrationForm.find(':password,:text').filter(function () {
                  return $(this).val() == "";
                }).addClass('error');

                if (response.Result.length > 0 && response.Result[0].Key) {
                  errorSummaryHeight = errorSummary.text(_gtxt('ProfilePlugin.Error' + response.Result[0].Key) + " " + response.Result[0].Value.Errors[0].ErrorMessage).height();
                  registrationForm.find('.' + response.Result[0].Key).addClass('error');
                } else {
                  errorSummaryHeight = errorSummary.text(_gtxt('ProfilePlugin.Error' + response.Result.Message)).height();
                  registrationForm.find('.' + response.Result.Message).addClass('error');
                }

                errorSummary.slideDown();
                registrationForm.find('img').first().attr("src", mykosmosnimki + '/Account/Captcha/sort?r=' + Math.round(Math.random() * Math.pow(10, 9)));
              }
            });
          });
        });
        registrationForm.find('form').submit(function (e) {
          e.preventDefault();
        });
        var regFormDialog = window.showDialog(_gtxt('ProfilePlugin.registration'), registrationForm[0], 560, 272);
        $(regFormDialog).dialog('option', 'resizable', false);
        regFormDialog.style.overflow = 'hidden';
        errorSummaryHeight = regFormDialog.style.height;
        regFormDialog.style.height = '';

        var clearError = function clearError() {
          registrationForm.find('.error').removeClass('error');
          registrationForm.find('.ErrorSummary').text('').slideUp();
        };

        registrationForm.find('input[type="text"], input[type="password"]').keydown(function (e) {
          if (e.which == 13) submit.click();
        }).focusin(clearError);
        return regFormDialog;
      }; // var SubmitBlock = function (form, onsuccess, onerror) {
      //     this.submit = function () { }
      // };


      var checkExist;
      window.gmxCore.addModule('ProfilePlugin', {
        pluginName: 'ProfilePlugin',
        showProfile: showProfile,
        showRegistrationForm: showRegistrationForm,
        afterViewer: function afterViewer() {
          checkExist = setInterval(function () {
            if (nsGmx$1.widgets.authWidget && nsGmx$1.widgets.authWidget.getUserInfo() != null) {
              if (nsGmx$1.widgets.authWidget.getUserInfo().Login != null) {
                var a = $('a:contains("' + nsGmx$1.Translations.getText('auth.myAccount') + '")');
                a.attr({
                  'class': 'dropdownMenuWidget-dropdownItemAnchor'
                });
                a.siblings('div').remove();
                a.attr('href', 'javascript:void(0)');
                a.removeAttr('target');
                a.click(function (event) {
                  showProfile();
                  event.stopPropagation();
                });
              } else {
                var showLoginDialog = nsGmx$1.widgets.authWidget._authManager.login,
                    regForm;

                nsGmx$1.widgets.authWidget._authManager.login = function () {
                  if (regForm && $(regForm).is(':visible')) {
                    removeDialog(regForm);
                    regForm = false;
                  }

                  showLoginDialog();
                  var regLink = $(':ui-dialog .registration');
                  regLink.off("click").click(function () {
                    regLink.parents(':ui-dialog').dialog("close");
                    regForm = showRegistrationForm(function () {
                      window.location.reload();
                    });
                  });
                };
              }

              clearInterval(checkExist);
            }
          }, 100);
        }
      }, {
        // css: 'ProfilePlugin.css',
        init: function init() {
          initTranslations();
        }
      });
    })(jQuery);

    _translationsHash.addtext('rus', {
      LayerRCControl: {
        minZoom: 'Мин. зум',
        titleTemplate: 'Шаблон имени',
        pathTemplate: 'Шаблон тайлов',
        advancedLink: 'Дополнительно',
        layerTagTitle: 'Параметр слоя',
        attributeTitle: 'Атрибут объекта'
      }
    });

    _translationsHash.addtext('eng', {
      LayerRCControl: {
        minZoom: 'Min zoom',
        titleTemplate: 'Title template',
        pathTemplate: 'Path template',
        advancedLink: 'Advanced',
        layerTagTitle: 'Layer parameter',
        attributeTitle: 'Object Attribute'
      }
    });

    nsGmx$1.LayerRCProperties = Backbone.Model.extend({
      defaults: {
        IsRasterCatalog: false,
        RCMinZoomForRasters: 0,
        RCMaskForRasterTitle: '',
        RCMaskForRasterPath: '',
        ColumnTagLinks: {}
      },
      isAnyLinks: function isAnyLinks() {
        return window._.size(this.attributes.ColumnTagLinks) > 0;
      }
    });
    /**
    Контрол для задания параметров каталогов растров
    @memberOf nsGmx
    @class
    */

    nsGmx$1.LayerRasterCatalogWidget = function (container, rcProperties) {
      var advancedMode = !!(rcProperties.get('RCMaskForRasterPath') || rcProperties.get('RCMaskForRasterTitle') || rcProperties.isAnyLinks());

      var updateVisibility = function updateVisibility() {
        // var isRasterCatalog = rcProperties.get('IsRasterCatalog');
        $('.RCCreate-advanced', container).toggle(advancedMode);
        $('.RCCreate-advanced-link', container).toggle(!advancedMode);
        $('.RCCreate-tagContainer', container).toggle(advancedMode);
      };

      rcProperties.on('change:IsRasterCatalog', updateVisibility);
      var RCCheckbox = $('<input/>', {
        type: 'checkbox',
        'class': 'RCCreate-checkbox'
      }).change(function () {
        rcProperties.set('IsRasterCatalog', RCCheckbox[0].checked);
      });
      var advancedParamsLink = $(makeLinkButton(_gtxt('LayerRCControl.advancedLink'))).addClass('RCCreate-advanced-link').click(function () {
        advancedMode = !advancedMode;
        updateVisibility();
      });
      RCCheckbox[0].checked = rcProperties.get('IsRasterCatalog');
      var minZoomInput = $('<input/>', {
        'class': 'inputStyle RCCreate-zoom-input'
      }).val(rcProperties.get('RCMinZoomForRasters') || '').bind('keyup change', function () {
        rcProperties.set('RCMinZoomForRasters', parseInt(this.value));
      });
      var titleInput = $('<input/>', {
        'class': 'inputStyle'
      }).val(rcProperties.get('RCMaskForRasterTitle') || '').bind('keyup change', function () {
        rcProperties.set('RCMaskForRasterTitle', this.value);
      });
      var pathInput = $('<input/>', {
        'class': 'inputStyle'
      }).val(rcProperties.get('RCMaskForRasterPath') || '').bind('keyup change', function () {
        rcProperties.set('RCMaskForRasterPath', this.value);
      }); // var RCParamsTable =

      $('<table/>', {
        'class': 'RCCreate-params'
      }).append($('<tr/>').append($('<td/>').text(_gtxt('LayerRCControl.minZoom')).css('padding-right', '6px')).append($('<td/>').append(minZoomInput))).append($('<tr/>', {
        'class': 'RCCreate-advanced'
      }).append($('<td/>').text(_gtxt('LayerRCControl.titleTemplate'))).append($('<td/>').append(titleInput))).append($('<tr/>', {
        'class': 'RCCreate-advanced'
      }).append($('<td/>').text(_gtxt('LayerRCControl.pathTemplate'))).append($('<td/>').append(pathInput))).appendTo(container);
      nsGmx$1.TagMetaInfo.loadFromServer(function (realTagInfo) {
        var realTagsInfo = realTagInfo.getTagArrayExt();
        var fakeTagsInfo = {};

        for (var iT = 0; iT < realTagsInfo.length; iT++) {
          var info = realTagsInfo[iT];
          fakeTagsInfo[info.name] = {
            Type: 'String',
            Description: info.descr
          };
        }

        var fakeTagManager = new nsGmx$1.TagMetaInfo(fakeTagsInfo);
        var initTags = {};
        var columnTagLinks = rcProperties.get('ColumnTagLinks');

        for (var iP in columnTagLinks) {
          initTags[columnTagLinks[iP]] = {
            Value: iP
          };
        }

        var layerTags = new nsGmx$1.LayerTagsWithInfo(fakeTagManager, initTags);
        var tagContainer = $('<div/>', {
          'class': 'RCCreate-tagContainer RCCreate-advanced'
        }).addClass().appendTo(container);
        new nsGmx$1.LayerTagSearchControl(layerTags, tagContainer, {
          inputWidth: 100,
          tagHeader: _gtxt('LayerRCControl.layerTagTitle'),
          valueHeader: _gtxt('LayerRCControl.attributeTitle')
        });
        $(layerTags).change(function () {
          var columnTagLinks = {};
          layerTags.eachValid(function (id, tag, value) {
            columnTagLinks[value] = tag;
          });
          rcProperties.set('ColumnTagLinks', columnTagLinks);
        });
        advancedParamsLink.appendTo(container);
        updateVisibility();
      });
    };

    /** Параметры мультивременного слоя, связанные со временем
      @class
      @extends Backbone.Model
      @prop {number} [minPeriod=1] Минимальный период создания тайлов
      @prop {number} [maxPeriod=1] Максимальный период создания тайлов
      @prop {number} [columnName=null]  Название мультивременной колонки
      @prop {number} [isTemporal=false] Является ли слой мультивременным
    */

    nsGmx$1.TemporalLayerParams = Backbone.Model.extend(
    /** @lends nsGmx.TemporalLayerParams.prototype */
    {
      defaults: {
        isTemporal: false,
        maxShowPeriod: 0,
        minPeriod: 1,
        maxPeriod: 256,
        columnName: null
      },

      /** Возвращает строчку с перечислением временнЫх периодов (для передачи серверу) */
      getPeriodString: function getPeriodString() {
        var periods = [1, 16, 256],
            minPeriod = Number(this.attributes.minPeriod),
            maxPeriod = Number(this.attributes.maxPeriod);
        minPeriod = minPeriod > 1 && minPeriod < 16 ? 16 : minPeriod;
        minPeriod = minPeriod > 16 && minPeriod < 256 ? 256 : minPeriod;
        maxPeriod = maxPeriod > 1 && maxPeriod < 16 ? 16 : maxPeriod;
        maxPeriod = maxPeriod > 16 && maxPeriod < 256 ? 256 : maxPeriod;
        return periods.splice(periods.indexOf(minPeriod), periods.indexOf(maxPeriod) + 1).join(',');
      }
    }, {
      PERIOD_STEP: 4
    });

    /** Связанные с квиклуками параметры векторных слоёв. Умеет сериализовать/десериализовать себя в строку для хранения на сервере.
     * @class
     * @memberOf nsGmx
     * @extends Backbone.Model
     * @property {String} template Шаблон URL квиклука
     * @property {Number} minZoom Минимальный зум показа квиклуков
     * @property {Number} X1-X4,Y1-Y4 Названия полей слоя, в которых хранятся координаты привязки 4 углов изображения. Если не указаны, будут использованы значения по умолчанию (поля "X1"-"X4", "Y1"-"Y4" или их аналоги в нижнем регистре)
     */

    nsGmx$1.QuicklookParams = Backbone.Model.extend({
      /** Загружает параметры из строки с сервера.
       * @param {String} quicklookString Строка с параметрами с сервера
       */
      fromServerString: function fromServerString(quicklookString) {
        if (quicklookString) {
          //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом
          if (quicklookString[0] === '{') {
            var p = JSON.parse(quicklookString);
            this.set({
              template: p.template,
              minZoom: p.minZoom || 8,
              X1: p.X1,
              Y1: p.Y1,
              X2: p.X2,
              Y2: p.Y2,
              X3: p.X3,
              Y3: p.Y3,
              X4: p.X4,
              Y4: p.Y4
            });
          } else {
            this.set({
              template: quicklookString,
              minZoom: 8
            });
          }
        } else {
          this.set({
            minZoom: 8
          });
        }
      },

      /** Сохраняет все параметры в строку, которую можно передать серверу.
       * @return {String}
       */
      toServerString: function toServerString() {
        //$.extend чтобы удалить undefined поля
        return this.attributes.template ? JSON.stringify($.extend({}, this.attributes)) : '';
      }
    });

    /** Объект, описывающий один атрибут слоя. Формат для передачи на сервер
     * @typedef {Object} nsGmx.LayerProperties.Column
     * @property {String} Name Имя атрибута
     * @property {String} OldName Исходное имя атрибута. Используется для переименования атрибутов. Для новых атрибутов это поле должно отсутствовать.
     * @property {String}  ColumnSimpleType Тип атрибута
     * @property {Boolean} IsPrimary
     * @property {Boolean} IsIdentity
     * @property {Boolean} IsComputed
    */

    var LatLngColumnsModel = Backbone.Model.extend({
      defaults: {
        XCol: null,
        YCol: null
      }
    });
    /** Расширенный набор свойства слоя. Используется для редактирования свойств. Умеет сохранять себя на сервере
     * @class
     * @memberOf nsGmx
     * @extends Backbone.Model
     * @property {String} Type Тип слоя. Vector/Raster/MultiLayer/Virtual
     * @property {Number} LayerID Серверный ID слоя
     * @property {String} Name Уникальный неитерируемый ID слоя
     * @property {String} Title Заголовок слоя
     * @property {String} Copyright Копирайт слоя
     * @property {String} Description Описание слоя
     * @property {Object} MetaProperties Метаданные слоя
     * @property {Object} ShapePath Имеет атрибут Path. Для векторных слоёв из файла - источник слоя. Для растровых - файл с границей растра
     * @property {Object} Geometry Граница растрового слоя

     * @property {String} Legend Легенда слоя. Только для растровых слоёв

     * @property {String} NameObject Шаблон названий объектов. Только для векторных слоёв
     * @property {String} GeometryType Тип геометрии слоя. Только для векторных слоёв (point/linestring/polygon)
     * @property {nsGmx.QuicklookParams} Quicklook Параметры квиклуков. Только для векторных слоёв
     * @property {Object} TilePath Имеет атрибут Path. Путь к файлу с тайлами. Только для векторных слоёв
     * @property {String} EncodeSource Кодировка источника данных слоя. Только для векторных слоёв
     * @property {nsGmx.LayerProperties.Column[]} Columns Описание типов и названий атрибутов слоя. Только для векторных слоёв
     * @property {String} TableName Название таблицы, если источник был таблицей. Только для векторных слоёв
     * @property {String} TableCS Система координат выбранной таблицы ("EPSG:4326"/"EPSG:3395"). Только для векторных слоёв
     * @property {String} SourceType Тип источника данных для слоя (file/table/manual/sql)
     * @property {String[]} Attributes Список имён атрибутов векторного слоя (не сохраняется)
     * @property {String[]} AttrTypes Список типов атрибутов векторного слоя (не сохраняется)
     * @property {nsGmx.LayerRCProperties} RC Параметры каталога растров. Только для векторных слоёв
     * @property {nsGmx.TemporalLayerParams} Temporal Параметры мультивременного слоя. Только для векторных слоёв
     * @property {LatLngColumnsModel} GeometryColumnsLatLng Описание выбранных в таблице колонок с геометрией
     * @property {String} ZIndexField Название поля для сортировки объектов внутри векторного слоя
    */

    var LayerProperties = Backbone.Model.extend(
    /** @lends nsGmx.LayerProperties.prototype */
    {
      initialize: function initialize(attrs) {
        this.attributes = _.clone(attrs || {});
      },
      initFromViewer: function initFromViewer(type, divProperties, layerProperties) {
        this.set({
          Type: type || divProperties && divProperties.type || layerProperties && layerProperties.type,
          Title: divProperties ? divProperties.title || '' : layerProperties.Title || '',
          Copyright: divProperties ? divProperties.Copyright || '' : layerProperties.Copyright || '',
          Legend: divProperties ? divProperties.Legend || '' : layerProperties.Legend || '',
          Description: divProperties ? divProperties.description || '' : layerProperties.Description || '',
          NameObject: divProperties ? divProperties.NameObject || '' : layerProperties.NameObject || '',
          GeometryType: divProperties ? divProperties.GeometryType : layerProperties.GeometryType,
          LayerID: divProperties ? divProperties.LayerID : layerProperties.LayerID,
          ZIndexField: divProperties ? divProperties.ZIndexField : layerProperties.ZIndexField,
          ContentID: divProperties ? divProperties.ContentID : layerProperties.ContentID,
          ShapePath: layerProperties.ShapePath || {},
          TilePath: layerProperties.TilePath || {},
          Name: layerProperties.name,
          EncodeSource: layerProperties.EncodeSource,
          Columns: layerProperties.Columns,
          TableName: layerProperties.TableName,
          TableCS: layerProperties.TableCS,
          SourceType: layerProperties.SourceType || 'file',
          Geometry: layerProperties.Geometry,
          Attributes: divProperties ? divProperties.attributes : [],
          AttrTypes: divProperties ? divProperties.attrTypes : []
        });
        var metaProperties = layerProperties.MetaProperties;
        var convertedTagValues = {};

        for (var mp in metaProperties) {
          var tagtype = metaProperties[mp].Type;
          convertedTagValues[mp] = {
            Type: tagtype,
            Value: nsGmx$1.Utils.convertFromServer(tagtype, metaProperties[mp].Value)
          };
        }

        this.set('MetaProperties', new nsGmx$1.LayerTags(convertedTagValues));
        this.set('RC', new nsGmx$1.LayerRCProperties({
          IsRasterCatalog: layerProperties.IsRasterCatalog,
          RCMinZoomForRasters: layerProperties.RCMinZoomForRasters,
          RCMaskForRasterTitle: layerProperties.RCMaskForRasterTitle,
          RCMaskForRasterPath: layerProperties.RCMaskForRasterPath,
          ColumnTagLinks: layerProperties.ColumnTagLinks
        }));
        divProperties = divProperties || {};
        var tempPeriods = divProperties.TemporalPeriods;
        this.set('Temporal', new nsGmx$1.TemporalLayerParams({
          isTemporal: !!divProperties.Temporal,
          minPeriod: tempPeriods && tempPeriods[0],
          maxPeriod: tempPeriods && tempPeriods[tempPeriods.length - 1],
          maxShownPeriod: divProperties.maxShownPeriod || 0,
          columnName: divProperties.TemporalColumnName
        }));
        this.set('GeometryColumnsLatLng', new LatLngColumnsModel({
          XCol: layerProperties.GeometryXCol,
          YCol: layerProperties.GeometryYCol
        }));

        if (layerProperties.Name) {
          this.set("Name", layerProperties.Name);
        }

        var quicklookString = divProperties.Quicklook || layerProperties.Quicklook,
            quicklookParams = new nsGmx$1.QuicklookParams();
        quicklookParams.fromServerString(quicklookString);
        this.set('Quicklook', quicklookParams);
      },

      /** Инициализирует класс, используя информацию о слое с сервера.
       * @param {String} layerName ID слоя, информацию о котором нужно получить
       * @return {jQuery.Deferred} Deferred, который будет заполнен после инициализации класса
       */
      initFromServer: function initFromServer(layerName) {
        var def = $.Deferred(),
            _this = this;

        sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?NeedAttrValues=false&LayerName=" + encodeURIComponent(layerName), function (response) {
          if (!window.parseResponse(response)) {
            def.reject(response);
            return;
          }

          _this.initFromViewer(null, null, response.Result);

          def.resolve();
        });
        return def.promise();
      },

      /** Сохраняет изменения в слое или создаёт новый слой на сервере
       * @param {Boolean} geometryChanged Нужно ли передавать на сервер геометрию растрового слоя
       * @param {Function} [callback] Будет вызван после получения ответа от сервера
       * @return {jQuery.Deferred} Deferred, который будет заполнен после сохранения всей информации на сервере
       */
      save: function save(geometryChanged, callback, params) {
        var attrs = this.attributes,
            name = attrs.Name,
            stype = attrs.SourceType,
            def;
        var reqParams = {
          WrapStyle: "window",
          Title: attrs.Title,
          Description: attrs.Description,
          Copyright: attrs.Copyright
        };

        if (attrs.MetaProperties) {
          var metaProperties = {};
          attrs.MetaProperties.eachValid(function (id, tag, value, type) {
            //для неизвестных тегов присваиваем тип String
            type = type || 'String';
            value = nsGmx$1.Utils.convertToServer(type, value);

            if (value !== null) {
              metaProperties[tag] = {
                Value: value,
                Type: type
              };
            }
          }, true);
          reqParams.MetaProperties = JSON.stringify(metaProperties);
        }

        if (attrs.Type === 'Vector') {
          if (attrs.EncodeSource) reqParams.EncodeSource = attrs.EncodeSource;
          reqParams.NameObject = attrs.NameObject || '';
          reqParams.srs = nsGmx$1.leafletMap.options.srs || '';
          if (stype === 'table') reqParams.TableCS = attrs.TableCS;
          var rcProps = attrs.RC;
          reqParams.IsRasterCatalog = !!(rcProps && rcProps.get('IsRasterCatalog'));

          if (reqParams.IsRasterCatalog) {
            reqParams.RCMinZoomForRasters = rcProps.get('RCMinZoomForRasters');
            reqParams.RCMaskForRasterPath = rcProps.get('RCMaskForRasterPath');
            reqParams.RCMaskForRasterTitle = rcProps.get('RCMaskForRasterTitle');
            reqParams.ColumnTagLinks = JSON.stringify(rcProps.get('ColumnTagLinks'));
          }

          var tempProperties = attrs.Temporal;
          reqParams.TemporalLayer = !!(tempProperties && tempProperties.get('isTemporal') && tempProperties.get('columnName'));

          if (reqParams.TemporalLayer) {
            reqParams.TemporalColumnName = tempProperties.get('columnName');
            reqParams.TemporalPeriods = tempProperties.getPeriodString();
            reqParams.maxShownPeriod = tempProperties.get('maxShownPeriod');
          }
          /* отсылать на сервер колонки нужно только если это:
           * - уже созданный слой или тип слоя "Вручную",
           * - копия слоя
          */


          if (attrs.Columns && (name || stype === 'manual') || params && params.copy) {
            reqParams.Columns = JSON.stringify(attrs.Columns);
          }

          if (attrs.LayerID) reqParams.VectorLayerID = attrs.LayerID;

          if (attrs.Quicklook) {
            reqParams.Quicklook = attrs.Quicklook.toServerString();
            /*JSON.stringify({
                minZoom: attrs.MinZoomQuicklooks,
                template: attrs.Quicklook
            });*/
          } else {
            attrs.Quicklook = '';
          }

          reqParams.ZIndexField = attrs.ZIndexField || '';

          if (!name && stype === 'manual' && !(params && params.copy)) {
            reqParams.UserBorder = attrs.UserBorder ? JSON.stringify(attrs.UserBorder) : null;
            reqParams.geometrytype = attrs.GeometryType;
            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/CreateVectorLayer.ashx", reqParams);
          } else if (!name && params && params.copy) {
            var copyParams = {},
                columnsList = [{
              Value: "[geomixergeojson]",
              Alias: "gmx_geometry"
            }],
                sqlString = params.buffer ? 'select Buffer([gmx_geometry], ' + (params.bufferSize || 0) + ') as gmx_geometry' : 'select [geomixergeojson] as gmx_geometry';

            for (var i = 0; i < attrs.Columns.length; i++) {
              var col = attrs.Columns[i];

              if (col.Name !== 'gmx_geometry') {
                columnsList.push({
                  Value: col.Name,
                  Alias: col.Name
                });
                var exp = col.expression || '"' + col.Name + '"';
                sqlString += ', ' + exp + ' as "' + col.Name + '"';
              }
            }

            sqlString += ' from [' + params.sourceLayerName + ']';

            if (params.query) {
              sqlString += ' WHERE ' + params.query;
            }

            copyParams.WrapStyle = "message";
            copyParams.Title = attrs.Title;
            copyParams.SourceType = attrs.SourceType;
            copyParams.Sql = sqlString;
            copyParams.srs = nsGmx$1.leafletMap.options.srs || '';
            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/Insert.ashx", copyParams);
          } else {
            //Если нет колонки с геометрией, то нужно передавать выбранные пользователем колонки
            var parsedColumns = nsGmx$1.LayerProperties.parseColumns(attrs.Columns);
            var geomColumns = attrs.GeometryColumnsLatLng;

            if (parsedColumns.geomCount === 0 && geomColumns && geomColumns.get('XCol') && geomColumns.get('YCol')) {
              reqParams.ColX = geomColumns.get('XCol');
              reqParams.ColY = geomColumns.get('YCol');
            }

            if (stype !== 'manual') {
              reqParams.GeometryDataSource = stype === 'file' ? attrs.ShapePath.Path : attrs.TableName;
            }

            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/" + (name ? "Update.ashx" : "Insert.ashx"), reqParams);
          }
        } else if (attrs.Type === 'Raster') {
          var curBorder = _mapHelper.drawingBorders.get(name);

          reqParams.Legend = attrs.Legend;
          reqParams.srs = nsGmx$1.leafletMap.options.srs || '';
          if (attrs.TilePath.Path) reqParams.TilePath = attrs.TilePath.Path;
          reqParams.GeometryChanged = geometryChanged;

          if (geometryChanged) {
            if (typeof curBorder === 'undefined') {
              if (attrs.ShapePath.Path) {
                reqParams.BorderFile = attrs.ShapePath.Path;
              } else if (typeof attrs.Geometry !== 'undefined') {
                //может быть как null (удалили), так и undefined (не поменялась)
                reqParams.BorderGeometry = JSON.stringify(attrs.Geometry);
              }
            } else {
              reqParams.BorderGeometry = JSON.stringify(L.gmxUtil.geoJSONtoGeometry(curBorder.toGeoJSON(), true));
            }
          }

          if (attrs.LayerID) reqParams.RasterLayerID = attrs.LayerID;
          def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "RasterLayer/" + (name ? "Update.ashx" : "Insert.ashx"), reqParams);
        } else if (attrs.Type === 'MultiLayer') {
          var multiLayerInfo = {
            LayersChanged: false,
            //изменение состава слоёв пока не поддерживается
            Properties: {
              Title: attrs.Title,
              Description: attrs.Description
            }
          };

          if ('MetaProperties' in reqParams) {
            multiLayerInfo.Properties.MetaProperties = JSON.parse(reqParams.MetaProperties);
          }

          if (attrs.LayerID) {
            multiLayerInfo.Properties.MultiLayerID = attrs.LayerID;
          }

          var multiReqParams = {
            WrapStyle: "window",
            MultiLayerInfo: JSON.stringify(multiLayerInfo)
          };
          def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "MultiLayer/" + (name ? "Update.ashx" : "Insert.ashx"), multiReqParams);
        } else if (attrs.Type === 'Virtual') {
          if (name) {
            reqParams.VectorLayerID = name;
          } else {
            reqParams.SourceType = 'Virtual';
          }

          if (attrs.ContentID) {
            reqParams.ContentID = attrs.ContentID;
          }

          reqParams.Legend = attrs.Legend || '';
          def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/" + (name ? "Update.ashx" : "Insert.ashx"), reqParams);
        }

        callback && def.done(callback);
        return def.promise();
      }
    });

    LayerProperties.parseColumns = function (columns) {
      var geomCount = 0; //кол-во колонок с типом Геометрия

      var coordColumns = []; //колонки, которые могут быть использованы для выбора координат

      var dateColumns = []; //колонки, которые могут быть использованы для выбора временнОго параметра

      columns = columns || [];

      for (var f = 0; f < columns.length; f++) {
        var type = columns[f].ColumnSimpleType.toLowerCase();
        if (type === 'geometry') geomCount++;
        if ((type === 'string' || type === 'integer' || type === 'float') && !columns[f].IsIdentity && !columns[f].IsPrimary) coordColumns.push(columns[f].Name);
        if (type === 'date' || type === 'datetime') dateColumns.push(columns[f].Name);
      }

      return {
        geomCount: geomCount,
        coordColumns: coordColumns,
        dateColumns: dateColumns
      };
    };

    nsGmx$1.LayerProperties = LayerProperties;
    nsGmx$1.LatLngColumnsModel = LatLngColumnsModel; // window.gmxCore.addModule('LayerProperties', {
    //     LayerProperties: LayerProperties,
    //     LatLngColumnsModel: LatLngColumnsModel
    // })

    nsGmx$1.ShpEncodingWidget = function () {
      var _encodings = {
        'windows-1251': 'windows-1251',
        'utf-8': 'utf-8',
        'koi8-r': 'koi8-r',
        'utf-7': 'utf-7',
        'iso-8859-5': 'iso-8859-5',
        'koi8-u': 'koi8-u',
        'cp866': 'cp866'
      };
      var _DEFAULT_ENCODING = 'windows-1251';
      var _curEncoding = _DEFAULT_ENCODING;

      var _this = this;

      this.drawWidget = function (container, initialEncoding) {
        initialEncoding = initialEncoding || _DEFAULT_ENCODING;
        var select = $("<select></select>").addClass('selectStyle VectorLayerEncodingInput');
        select.change(function () {
          _curEncoding = $('option:selected', select).val();
          $(_this).change();
        });
        var isStandard = false;

        for (var enc in _encodings) {
          var opt = $('<option></option>').val(enc).text(enc);

          if (_encodings[enc] === initialEncoding) {
            opt.attr('selected', 'selected');
            _curEncoding = enc;
            isStandard = true;
          }

          select.append(opt);
        }

        var anotherCheckbox = $("<input></input>", {
          'class': 'box',
          type: 'checkbox',
          id: 'otherEncoding'
        });
        var anotherInput = $("<input></input>", {
          'class': 'VectorLayerEncodingInput'
        });

        if (!isStandard) {
          anotherCheckbox[0].checked = 'checked';
          anotherInput.val(initialEncoding);
          select.attr('disabled', 'disabled');
        } else {
          anotherInput.attr('disabled', 'disabled');
        }

        anotherInput.bind('keyup', function () {
          _curEncoding = this.value;
          $(_this).change();
        });
        anotherCheckbox.click(function () {
          if (this.checked) {
            select.attr('disabled', 'disabled');
            anotherInput.removeAttr('disabled');
            anotherInput.focus();
            _curEncoding = anotherInput.val();
          } else {
            select.removeAttr('disabled');
            anotherInput.attr('disabled', 'disabled');
            _curEncoding = $('option:selected', select).val();
          }

          $(_this).change();
        });
        var tr1 = $("<tr></tr>").append($("<td></td>").text(_gtxt("Кодировка"))).append($("<td></td>").append(select));
        var tr2 = $("<tr></tr>").append($("<td></td>").append(anotherCheckbox).append($("<label></label>", {
          'for': 'otherEncoding'
        }).text(_gtxt("Другая")))).append($("<td></td>").append(anotherInput));
        $(container).append($("<table></table>", {
          'class': 'VectorLayerEncoding'
        }).append(tr1).append(tr2));
      };

      this.getServerEncoding = function () {
        return _curEncoding;
      };
    };

    (function () {
      Handlebars.registerPartial('TemporalLayerWidgetOptions', '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}');

      _translationsHash.addtext('rus', {
        'Макс. период на экране': 'На экране не более',
        'Тайлы с': 'Тайлы с',
        'Тайлы по дням до': 'Тайлы по дням до',
        'дней': 'дней'
      });

      _translationsHash.addtext('eng', {
        'Макс. период на экране': 'Max period to show',
        'Тайлы с': 'Tiles from',
        'Тайлы по дням до': 'Max tiling period',
        'дней': 'days'
      });
      /** Создаёт виджет для задания мультивременных параметров слоя
      * @class
      * @param {HTMLNode} parentDiv контейнер для размещения виджета
      * @param {nsGmx.TemporalLayerParams} paramsModel начальные параметры
      * @param {String[]} columns массив имён колонок, из которых можно выбрать врменнУю
      */


      nsGmx$1.TemporalLayerParamsWidget = function (parentDiv, paramsModel, columns) {
        var PERIODS = [1, 16, 256]; // var optionsHtml = '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}';

        var template = Handlebars.compile('<table><tbody>' + '<tr>' + '<td>{{i "Макс. период на экране"}}</td>' + '<td><input id="maxShownPeriod" class="inputStyle temporal-maxshow"></input> <span>{{i "дней"}}</span> </td>' + '</tr>' + '<tr class="temporal-columns">' + '<td>{{i "Колонка даты"}}</td>' + '<td><select id="columnSelect" class="selectStyle"></select></td>' + '</tr>' + // '<tr class="temporal-advanced">' +
        //     '<td>{{i "Тайлы с"}}</td>' +
        //     '<td><select id="minPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' +
        // '</tr>' +
        '<tr class="temporal-advanced">' + '<td>{{i "Тайлы по дням до"}}</td>' + '<td><select id="maxPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' + '</tr>' + '</tbody></table>' + '<span class="buttonLink RCCreate-advanced-link">{{i "LayerRCControl.advancedLink"}}</span>');
        $(parentDiv).html(template({
          periods: PERIODS
        }));
        var _columns = columns;
        var isAdvancedMode = paramsModel.get('minPeriod') !== paramsModel.defaults.minPeriod || paramsModel.get('maxPeriod') !== paramsModel.defaults.maxPeriod;
        var wasInAdvancedMode = isAdvancedMode;

        var updateVisibility = function updateVisibility() {
          // var isTemporal = paramsModel.get('isTemporal');
          $('.temporal-advanced', parentDiv).toggle(isAdvancedMode);
          $('.RCCreate-advanced-link', parentDiv).toggle(!isAdvancedMode);
          $('.temporal-columns', parentDiv).toggle(_columns.length > 1);
        };

        var updateColumnsSelect = function updateColumnsSelect() {
          var selectDateColumn = $('#columnSelect', parentDiv);
          var curColumn = paramsModel.get('columnName');
          var foundOption = null;
          selectDateColumn.empty();

          for (var i = 0; i < _columns.length; i++) {
            var option = $('<option></option>').text(_columns[i]);
            selectDateColumn.append(option);

            if (curColumn === _columns[i]) {
              foundOption = option;
            }
          }

          if (foundOption) {
            foundOption.attr('selected', 'selected');
          } else if (_columns.length) {
            paramsModel.set('columnName', _columns[0]);
          }
        };

        updateVisibility();
        $('.RCCreate-advanced-link', parentDiv).click(function () {
          isAdvancedMode = !isAdvancedMode;
          wasInAdvancedMode = true;
          updateVisibility();
        });
        paramsModel.on('change:isTemporal', updateVisibility);
        updateColumnsSelect();
        $('#columnSelect', parentDiv).change(function () {
          paramsModel.set('columnName', $('option:selected', this).val());
        });
        $('#minPeriod>option[name=' + paramsModel.get('minPeriod') + ']', parentDiv).attr('selected', 'selected');
        $('#minPeriod', parentDiv).change(function () {
          paramsModel.set('minPeriod', $('option:selected', this).val());
        });
        $('#maxPeriod>option[name=' + paramsModel.get('maxPeriod') + ']', parentDiv).attr('selected', 'selected');
        $('#maxPeriod', parentDiv).change(function () {
          paramsModel.set('maxPeriod', $('option:selected', this).val());
        });
        $('#maxShownPeriod', parentDiv).val(paramsModel.get('maxShownPeriod') || '').bind('keyup', function () {
          var val = parseInt(this.value) || 0;
          var paramsToSet = {
            maxShownPeriod: Math.max(0, val)
          };

          if (!wasInAdvancedMode) {
            if (val > 0) {
              var index = Math.ceil(Math.log(val) / Math.log(4));
              paramsToSet.maxPeriod = PERIODS[Math.min(PERIODS.length - 1, index)];
            } else {
              paramsToSet.maxPeriod = paramsModel.defaults.maxPeriod;
            }

            $('#maxPeriod>option[name=' + paramsToSet.maxPeriod + ']', parentDiv).attr('selected', 'selected');
          }

          paramsModel.set(paramsToSet);
        });
        /**
            Обновляет список доступных для выбора колонок даты
            @param {String[]} columns массив имён колонок
        */

        this.updateColumns = function (columns) {
          _columns = columns;
          updateColumnsSelect();
          updateVisibility();
        };
      };
    })();

    nsGmx$1.SuggestWidget = function (attrNames, textarea, textTemplate, func, valuesArr, addValueFlag, attrType) {
      var _this = this;

      this.textArea = textarea;
      this.func = func;
      this.currentTextArea = textarea[0] || textarea;

      if (valuesArr && !(valuesArr instanceof nsGmx$1.ILazyAttributeValuesProvider)) {
        valuesArr = new nsGmx$1.LazyAttributeValuesProviderFromArray(valuesArr);
      }

      var canvas = this.el = nsGmx$1.Utils._div(null, [['dir', 'className', 'suggest-helper']]);

      canvas.style.display = 'none';

      canvas.onmouseout = function (e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement;

        if (canvas.getAttribute('arr')) {
          try {
            while (relTarget && !$(relTarget).hasClass('suggest-helper-elem-group')) {
              if (relTarget === canvas) {
                return;
              }

              relTarget = relTarget.parentNode;
            }

            $(canvas).fadeOut(100, function () {
              $(this).remove();
            });
          } catch (ev) {
            if (target === canvas) {
              $(canvas).fadeOut(100, function () {
                $(this).remove();
              });
            }
          }
        }
      };

      attrNames.forEach(function (name) {
        var className;

        if (attrType === 'functions') {
          className = 'suggest-helper-elem suggest-helper-elem-custom-tooltip';
        } else {
          className = 'suggest-helper-elem';
        }

        if (_typeof(name) === 'object') {
          name = name.groupTag;

          var div = nsGmx$1.Utils._div([nsGmx$1.Utils._t(String(name))], [['dir', 'className', className], ['dir', 'className', 'suggest-helper-elem-group']]);

          $(div).css('margin-top', '3px');
          $(canvas).append(div);
        } else {
          var _div = nsGmx$1.Utils._div([nsGmx$1.Utils._t(String(name))], [['dir', 'className', className]]);

          var hasCustomTooltip = $(_div).hasClass('suggest-helper-elem-custom-tooltip');

          if (hasCustomTooltip) {
            var titleObj = nsGmx$1.sqlTemplates[name],
                isRus = window.language === 'rus',
                description = isRus ? titleObj.descRus : titleObj.descEng,
                title = titleObj["interface"] + ' - \n' + description;

            _title(_div, title);
          } else {
            _title(_div, name);
          }

          _div.onmouseover = function () {
            var _curDiv = this,
                attrType;

            $(this.parentNode).children('.suggest-helper-hover').removeClass('suggest-helper-hover');
            $(this).addClass('suggest-helper-hover');

            if (!valuesArr) {
              return;
            }

            $(canvas.parentNode).children('[arr]').each(function () {
              if (this.getAttribute('arr') !== name) {
                $(this).fadeOut(100, function () {
                  $(this).remove();
                });
              }
            });

            if (!valuesArr.isAttributeExists(name)) {
              return;
            }

            attrType = valuesArr.getAttributeType(name);

            if (!$(canvas.parentNode).children('[arr=\'' + name + '\']').length) {
              this.timer = setTimeout(function () {
                valuesArr.getValuesForAttribute(name, function (attrValues) {
                  if (!attrValues || !$(_curDiv).hasClass('suggest-helper-hover')) {
                    return;
                  }

                  var arrSuggestCanvas = new nsGmx$1.SuggestWidget(attrValues, [_this.currentTextArea], 'suggest', function () {
                    _this.func && _this.func();
                    $(canvasArr.parentNode.childNodes[2]).fadeOut(100);
                    canvasArr.removeNode(true);
                  }, false, addValueFlag, attrType);
                  var canvasArr = arrSuggestCanvas.el;
                  canvasArr.style.left = '86px';
                  canvasArr.style.height = '220px';
                  canvasArr.style.width = '100px';
                  $(canvasArr).children().css('width', '80px');
                  canvasArr.setAttribute('arr', name);
                  $(canvas.parentNode).append(canvasArr);
                  $(canvasArr).fadeIn(100);
                });
              }, 300);
            }
          };

          _div.onmouseout = function (e) {
            var evt = e || window.event,
                target = evt.srcElement || evt.target,
                relTarget = evt.relatedTarget || evt.toElement;

            if ($(target).hasClass('suggest-helper-hover') && relTarget === this.parentNode) {
              $(this).removeClass('suggest-helper-hover');
            }

            if (this.timer) {
              clearTimeout(this.timer);
            }
          };

          _div.onclick = function (e) {
            console.log(_div);
            var val = textTemplate.replace(/suggest/g, name);

            if (this.parentNode.getAttribute('arr') != null) {
              var isNumber = attrType === 'float' || attrType === 'integer';

              if (isNumber) {
                val = val.replace(/,/g, '.');
              } else {
                val = '\'' + val + '\'';
              }

              if (addValueFlag) {
                val = '"' + this.parentNode.getAttribute('arr') + '" = ' + val;
              }
            }

            insertAtCursor(_this.currentTextArea, val, this.parentNode.sel);
            $(canvas).fadeOut(100);

            if (this.timer) {
              clearTimeout(this.timer);
            }

            $(canvas.parentNode).children('[arr]').fadeOut(100, function () {
              $(this).remove();
            });
            _this.func && _this.func();
            stopEvent(e);
          };

          $(canvas).append(_div);
        }
      });
    };

    nsGmx$1.SuggestWidget.prototype.setActiveTextArea = function (textArea) {
      for (var i = 0; i < this.textArea.length; i++) {
        if (this.textArea[i] === textArea) {
          this.currentTextArea = this.textArea[i];
          break;
        }
      }
    };

    nsGmx$1.SuggestWidget.prototype.setCallback = function (func) {
      this.func = func;
    };
    /**
     * @param {domElement} targetTextarea textArea to append
     * @param {array} attrNames
     * @param {object} attrValuesProvider
     * @param {function} changeCallback
     * @param {array} selectors array of sub-widgets (attrs, operators, functions)
     */


    nsGmx$1.AttrSuggestWidget = function (targetTextarea, attrNames, attrValuesProvider, changeCallback, selectors) {
      this.changeCallback = changeCallback;
      this.targetTextarea = targetTextarea;
      var template = Handlebars.compile('<div class="suggest-container">' + '<table><tbody><tr>' + '{{#if attrs}}<td><div class="suggest-link-container selectStyle suggest-attr">{{i "Колонки"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>{{/if}}' + '{{#if operators}}<td><div class="suggest-link-container selectStyle suggest-op">{{i "Операторы"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>{{/if}}' + '{{#if functions}}<td><div class="suggest-link-container selectStyle suggest-func">{{i "Функции"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>{{/if}}' + '</tr></tbody></table>' + '</div>');
      var ui = this.el = $(template({
        attrs: selectors.indexOf('attrs') !== -1,
        functions: selectors.indexOf('functions') !== -1,
        operators: selectors.indexOf('operators') !== -1
      }));
      this.attrsSuggest = selectors.indexOf('attrs') !== -1 ? new nsGmx$1.SuggestWidget(attrNames, targetTextarea, '"suggest"', changeCallback, attrValuesProvider, true) : null;
      this.functionsSuggest = selectors.indexOf('functions') !== -1 ? new nsGmx$1.SuggestWidget(transformHash(nsGmx$1.sqlFunctions), targetTextarea, 'suggest()', this.changeCallback, null, false, 'functions') : null;
      this.operatorsSuggest = selectors.indexOf('operators') !== -1 ? new nsGmx$1.SuggestWidget(['=', '>', '<', '>=', '<=', '<>', 'AND', 'OR', 'NOT', 'IN', 'CONTAINS', 'CONTAINSIGNORECASE', 'BETWEEN', 'STARTSWITH', 'ENDSWITH'], targetTextarea, 'suggest', this.changeCallback) : null;
      this.attrsSuggest && ui.find('.suggest-attr').append(this.attrsSuggest.el);
      this.functionsSuggest && ui.find('.suggest-func').append(this.functionsSuggest.el);
      this.operatorsSuggest && ui.find('.suggest-op').append(this.operatorsSuggest.el);

      var clickFunc = function clickFunc(div) {
        if (document.selection) {
          targetTextarea.focus();
          var sel = document.selection.createRange();
          div.sel = sel;
          targetTextarea.blur();
        }

        ui.find('.attrsHelperCanvas').children('[arr]').fadeOut(100, function () {
          $(this).remove();
        });
      };

      ui.find('.suggest-link-container').click(function (e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target; //var relTarget = evt.relatedTarget || evt.toElement;

        if (!$(target).hasClass('suggest-helper-elem-group')) {
          var placeholder = $(this).children('.suggest-helper');
          clickFunc(placeholder[0]);
          ui.find('.suggest-helper').fadeOut(100);
          placeholder.fadeIn(100);
        }
      });
      $(targetTextarea).click(function () {
        ui.find('.suggest-helper').fadeOut(100);
        return true;
      });
      /**
       * SQLHASH TRANSFORM HELPER
       */

      function transformHash(hash) {
        var arr = [],
            res = [];

        for (var key in hash) {
          if (hash.hasOwnProperty(key)) {
            res.push({
              groupTag: key
            });
            arr = hash[key];

            for (var i = 0; i < arr.length; i++) {
              res.push(arr[i]);
            }
          }
        }

        return res;
      }
    };

    nsGmx$1.AttrSuggestWidget.prototype.setActiveTextArea = function (textArea) {
      this.attrsSuggest && this.attrsSuggest.setActiveTextArea(textArea);
      this.functionsSuggest && this.functionsSuggest.setActiveTextArea(textArea);
      this.operatorsSuggest && this.operatorsSuggest.setActiveTextArea(textArea);
    };

    nsGmx$1.AttrSuggestWidget.prototype.setCallback = function (callback) {
      this.attrsSuggest && this.attrsSuggest.setCallback(callback);
      this.functionsSuggest && this.functionsSuggest.setCallback(callback);
      this.operatorsSuggest && this.operatorsSuggest.setCallback(callback);
    };

    window._translationsHash.addtext('rus', {
      LayerQuicklookWidget: {
        minZoom: 'Мин. зум',
        regTitle: 'Атрибуты привязки',
        title: 'Показать'
      }
    });

    window._translationsHash.addtext('eng', {
      LayerQuicklookWidget: {
        minZoom: 'Min zoom',
        regTitle: 'Registration fields',
        title: 'Expand'
      }
    });

    var template = Handlebars.compile('<div>' + '{{#if isMinimized}}<span class="lqw-title buttonLink">{{i "LayerQuicklookWidget.title"}}</span>{{/if}}' + '<div class="lqw-container" {{#if isMinimized}}style="display:none"{{/if}}>' + '<div>{{i "LayerQuicklookWidget.minZoom"}}<input class="lqw-minzoom-input inputStyle" value="{{minZoom}}"></div>' + '<textarea class="inputStyle lqw-textarea">{{quicklook}}</textarea>' + '<div class="suggest-link-container">{{i "Атрибут >"}}</div>' + '<div class="lqw-registration-link">{{i "LayerQuicklookWidget.regTitle"}}</div>' + '<table class="lqw-registration-container">' + '{{#points}}' + '<tr><td>X{{idx}}{{../regSelect "X"}}</td><td>Y{{idx}}{{../regSelect "Y"}}</td></tr>' + '{{/points}}' + '</table>' + '</div>' + '</div>');
    var selectTemplate = Handlebars.compile('<select data-name="{{targetName}}" class="lqw-point-select selectStyle">' + '{{#opts}}' + '<option value="{{name}}"{{#if isDefault}} selected{{/if}}>{{name}}</option>' + '{{/opts}}' + '</select>');
    /**
    Виджет для задания параметров слоя, связанных с показом квиклуков
    @memberOf nsGmx
    @class
    */

    nsGmx$1.LayerQuicklookWidget = function (container, layerProperties) {
      var DEFAULT_OPTION = {
        name: '',
        isDefault: false
      };

      var layerColumns = window._.pluck(layerProperties.get('Columns'), 'Name'),
          quicklookParams = layerProperties.get('Quicklook');

      var ui = $(template({
        isMinimized: !quicklookParams.get('template'),
        minZoom: quicklookParams.get('minZoom'),
        quicklook: quicklookParams.get('template'),
        points: Array.apply(null, {
          length: 4
        }).map(function (elem, index) {
          return {
            idx: index + 1
          };
        }),
        regSelect: function regSelect(label) {
          var targetName = label + this.idx,
              initValue = (quicklookParams.get(targetName) || targetName).toLowerCase();
          return new Handlebars.SafeString(selectTemplate({
            targetName: targetName,
            opts: [].concat(DEFAULT_OPTION, layerColumns.map(function (column) {
              return {
                name: column,
                isDefault: column.toLowerCase() === initValue
              };
            }))
          }));
        }
      }));
      ui.find('.lqw-title').click(function () {
        ui.find('.lqw-title').hide();
        ui.find('.lqw-container').show();
      });

      var updateRegistrationStatus = function updateRegistrationStatus() {
        ui.find('td').each(function (index, td) {
          $(td).toggleClass('lqw-reg-error', !$(td).find('option:selected').val());
        });
      };

      ui.find('.lqw-minzoom-input').on('change keyup', function () {
        var minZoom = Number(this.value);
        quicklookParams.set('minZoom', minZoom);
      });
      ui.find('select').change(function () {
        updateRegistrationStatus();
        var name = $(this).data('name');
        quicklookParams.set(name, this.value || undefined);
      });
      updateRegistrationStatus();

      if (ui.find('.lqw-reg-error').length === 0) {
        ui.find('.lqw-registration-container').hide();
        ui.find('.lqw-registration-link').addClass('buttonLink').click(function () {
          $(this).removeClass('buttonLink');
          ui.find('.lqw-registration-container').show();
        });
      }

      var quicklookText = ui.find('.lqw-textarea');

      var setQuicklook = function setQuicklook() {
        layerProperties.get('Quicklook').set('template', quicklookText.val());
      };

      var suggestWidget = new nsGmx$1.SuggestWidget(layerProperties.get('Attributes') || [], quicklookText[0], '[suggest]', setQuicklook, ['attrs', 'operators']);
      quicklookText.on('focus', function () {
        $(suggestWidget.el).hide();
      });
      ui.find('.suggest-link-container').append(suggestWidget.el).click(function () {
        if (suggestWidget.el.style.display === 'none') {
          $(suggestWidget.el).fadeIn(500);
        }
      });
      quicklookText.on('keyup change', setQuicklook);
      ui.appendTo(container);
    };

    function capitaliseFirstLetter(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    } //events: newAttribute, delAttribute, updateAttribute, updateExpression, moveAttribute, change


    nsGmx$1.ManualAttrModel = function (isRCLayer) {
      var _attributes = [];
      this.expressions = [];

      this.addAttribute = function (type, name) {
        _attributes.push({
          type: type,
          name: name,
          IsPrimary: false,
          IsIdentity: false,
          IsComputed: false,
          expression: '"' + name + '"'
        });

        this.expressions.push({
          name: name,
          expression: '"' + name + '"'
        });
        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');
        return _attributes.length - 1;
      };

      this.changeName = function (idx, newName) {
        _attributes[idx].name = newName;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
      };

      this.changeType = function (idx, newType) {
        _attributes[idx].type = newType;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
      };

      this.changeExpression = function (name, newExp) {
        var obj = this.expressions.find(function (obj) {
          return obj.name === name;
        });
        obj.expression = newExp;
        $(this).triggerHandler('updateExpression');
        $(this).triggerHandler('change');
      };

      this.deleteAttribute = function (idx) {
        _attributes.splice(idx, 1);

        $(this).triggerHandler('delAttribute');
        $(this).triggerHandler('change');
      };

      this.getAttribute = function (idx) {
        return _attributes[idx];
      };

      this.getCount = function () {
        return _attributes.length;
      };

      this.each = function (callback, addInternalColumns, params) {
        for (var k = 0; k < _attributes.length; k++) {
          var column = _attributes[k];
          var isInternal = column.IsPrimary || column.IsIdentity || column.IsComputed || column.type.server === 'geometry' || isRCLayer && column.name === 'GMX_RasterCatalogID';

          if (!isInternal || addInternalColumns) {
            callback(column, k, params);
          }
        }
      };

      this.moveAttribute = function (oldIdx, newIdx) {
        if (newIdx > oldIdx) {
          newIdx--;
        }

        if (oldIdx !== newIdx) {
          _attributes.splice(newIdx, 0, _attributes.splice(oldIdx, 1)[0]);

          $(this).triggerHandler('moveAttribute');
          $(this).triggerHandler('change');
        }
      };

      this.initFromServerFormat = function (serverColumns) {
        var _this = this;

        _attributes = [];
        $.each(serverColumns || [], function (i, column) {
          var type = window._.find(nsGmx$1.ManualAttrModel.TYPES, function (elem) {
            return elem.server === column.ColumnSimpleType.toLowerCase();
          });

          var obj = _this.expressions.find(function (obj) {
            return obj.name === column.Name;
          });

          if (!obj) {
            _this.expressions.push({
              name: column.Name,
              expression: '"' + column.Name + '"'
            });
          }

          _attributes.push({
            type: type || {
              server: column.ColumnSimpleType.toLowerCase()
            },
            name: column.Name,
            oldName: column.Name,
            IsPrimary: column.IsPrimary,
            IsIdentity: column.IsIdentity,
            IsComputed: column.IsComputed
          });
        });
        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');
      };

      this.toServerFormat = function () {
        var _this = this;

        var res = [];
        $.each(_attributes, function (i, attr) {
          var obj = _this.expressions.find(function (obj) {
            return obj.name === attr.name;
          });

          res.push({
            Name: attr.name,
            OldName: attr.oldName,
            ColumnSimpleType: capitaliseFirstLetter(attr.type.server),
            IsPrimary: attr.IsPrimary,
            IsIdentity: attr.IsIdentity,
            IsComputed: attr.IsComputed,
            expression: obj ? obj.expression : '"' + attr.name + '"'
          });
        });
        return res;
      };

      this.replaceString = function (string) {
        if (!string) return;

        _attributes.forEach(function (attr) {
          if (attr.name) {
            var re = new RegExp('\\"' + attr.name + '\\"', "g");

            if (!string.match(re)) {
              string = string.replace(attr.name, '"' + attr.name + '"');
            }
          }
        });

        return string;
      };
    };

    nsGmx$1.ManualAttrModel.TYPES = {
      DOUBLE: {
        user: 'Float',
        server: 'float'
      },
      INTEGER: {
        user: 'Integer',
        server: 'integer'
      },
      STRING: {
        user: 'String',
        server: 'string'
      },
      TIME: {
        user: 'Time',
        server: 'time'
      },
      DATE: {
        user: 'Date',
        server: 'date'
      },
      DATETIME: {
        user: 'DateTime',
        server: 'datetime'
      },
      BOOL: {
        user: 'Boolean',
        server: 'boolean'
      }
    };

    var utils = nsGmx$1.Utils;

    _translationsHash.addtext('rus', {
      ManualAttrView: {
        headerName: 'Название',
        headerType: 'Тип',
        headerExp: 'Выражение'
      }
    });

    _translationsHash.addtext('eng', {
      ManualAttrView: {
        headerName: 'Name',
        headerType: 'Type',
        headerExp: 'Expression'
      }
    });

    var selectorTemplate = Handlebars.compile('<select class="selectStyle customAttr-typesselect">' + '{{#each types}}' + '<option value="{{server}}" id="{{server}}"{{#if @root.isSelected}} selected{{/if}}>{{user}}</option>' + '{{/each}}' + '</select>');

    nsGmx$1.ManualAttrView = function () {
      var _parent = null;
      var _model = null;
      var _params = null;
      var _trs = [];
      var _isActive = true;

      var _this = this;

      var isAddingNew = false;

      var createTypeSelector = function createTypeSelector(selectedType) {
        return $(selectorTemplate({
          types: nsGmx$1.ManualAttrModel.TYPES,
          isSelected: function isSelected() {
            return this.server === selectedType;
          }
        }));
      };

      var createRow = function createRow(attr, i, params) {
        var sqlSelector, cellsArr;
        var typeSelector = createTypeSelector(attr.type.server)[0];
        $(typeSelector).data('idx', i);
        $(typeSelector).change(function () {
          var serverType = $('option:selected', this).val(),
              attrType = window._.findWhere(nsGmx$1.ManualAttrModel.TYPES, {
            server: serverType
          });

          _model.changeType($(this).data('idx'), attrType);
        });
        var nameSelectorLength = params.copy ? 90 : 120;

        var nameSelector = utils._input(null, [['attr', 'class', 'customAttrNameInput inputStyle'], ['css', 'width', nameSelectorLength + 'px']]);

        $(nameSelector).data('idx', i).val(attr.name);
        var deleteIcon = utils.makeImageButton('img/recycle.png', 'img/recycle_a.png');

        if (params.copy) {
          var obj = _model.expressions.find(function (obj) {
            return obj.name === attr.name;
          });

          var expression = obj ? obj.expression : '';
          sqlSelector = utils._input(null, [['attr', 'class', 'manualSqlAttrInput inputStyle'], ['css', 'width', '100px']]);
          $(sqlSelector).data('idx', i).val(_model.replaceString(expression));
          $(sqlSelector).on('keyup', function () {
            var idx = $(this).data('idx');
            var exp = $(this).val();

            if (idx >= 0) {
              _model.changeExpression(attr.name, exp);
            }
          });
          cellsArr = [utils._td([nameSelector]), utils._td([typeSelector]), utils._td([sqlSelector]), utils._td([deleteIcon])];
        } else {
          // sqlSelector =
          cellsArr = [utils._td([nameSelector]), utils._td([typeSelector]), utils._td([deleteIcon])];
        }

        var tr = utils._tr(cellsArr);

        $(nameSelector).on('keyup', function () {
          var idx = $(this).data('idx');
          var name = $(this).val();

          if (idx >= 0) {
            _model.changeName(idx, name);
          } else if (name) {
            isAddingNew = true;
            $(tr).find('td:gt(0)').show();
            $(tr).removeClass('customAttributes-new');

            var newIdx = _model.addAttribute(nsGmx$1.ManualAttrModel.TYPES.STRING, name);

            $([nameSelector, typeSelector, deleteIcon]).data('idx', newIdx);
            isAddingNew = false;
          }
        });
        $(deleteIcon).addClass('removeIcon').data('idx', i);

        deleteIcon.onclick = function () {
          _model.deleteAttribute($(this).data('idx'));
        };

        return tr;
      };

      var redraw = function redraw() {
        if (!_model || isAddingNew) {
          return;
        }

        $(_parent).empty();
        _trs = [];

        _model.each(function (attr, i) {
          _trs.push(createRow(attr, i, _params));
        });

        var newAttr = createRow({
          name: '',
          type: nsGmx$1.ManualAttrModel.TYPES.STRING
        }, -1, _params);
        $(newAttr).find('td:gt(0)').hide();
        $(newAttr).addClass('customAttributes-new');

        _trs.push(newAttr);

        var tbody = nsGmx$1.Utils._tbody(_trs);

        var theader = $(Handlebars.compile('<thead>' + '<tr>' + '<th>{{i "ManualAttrView.headerName"}}</th>' + '<th>{{i "ManualAttrView.headerType"}}</th>' + '{{#if copy}}<th>{{i "ManualAttrView.headerExp"}}</th>{{/if}}' + '</tr>' + '</thead>')({
          copy: _params.copy
        }));
        $(_parent).append($('<fieldset/>').css('border', 'none').append(nsGmx$1.Utils._table([theader[0], tbody], [['dir', 'className', 'customAttributes']])));

        _this.setActive(_isActive);
      };

      this.setActive = function (isActive) {
        _isActive = isActive;
        var fieldset = $(_parent).children('fieldset');

        if (isActive) {
          fieldset.removeAttr('disabled');
        } else {
          fieldset.attr('disabled', 'disabled');
        }

        $('.removeIcon, .customAttributes-new', fieldset).toggle(isActive);
      };

      this.init = function (parent, model, params) {
        _parent = parent;
        _model = model;
        _params = params;
        $(_model).on('newAttribute delAttribute moveAttribute', redraw);
        $(_model).on('newAttribute', function () {
          if (!$(_parent).find('.customAttributes-new').length) {
            var newAttr = createRow({
              name: '',
              type: nsGmx$1.ManualAttrModel.TYPES.STRING
            }, -1, params);
            $(newAttr).find('td:gt(0)').hide();
            $(newAttr).addClass('customAttributes-new');
            $(_parent).find('tbody').append(newAttr);
          }
        });
        redraw();
      };
    };

    var _$6 = nsGmx$1.Utils._;
    /**
    * @class Веб браузер для выбора и загрузки файлов на сервер
    */

    var fileBrowser = function fileBrowser() {
      var _this = this;

      this.parentCanvas = null;
      this._homeDir = '';
      this._status = {
        _state: false,
        start: function start() {
          this._state = true;
          var me = this;
          setTimeout(function () {
            if (me._state) {
              $(_this.statusContainer).show();
            }
          }, 100);
        },
        stop: function stop() {
          $(_this.statusContainer).hide();
          this._state = false;
        }
      };

      this._path = function () {
        var path;
        var alternativePath;
        return {
          set: function set(newPath, newAlternativePath) {
            path = newPath + (newPath.charAt(newPath.length - 1) === _this.slash ? '' : _this.slash);

            if (newAlternativePath) {
              alternativePath = newAlternativePath + (newAlternativePath.charAt(newAlternativePath.length - 1) === _this.slash ? '' : _this.slash);
            } else {
              alternativePath = undefined;
            }

            $(this).change();
          },
          get: function get() {
            return path;
          },
          getAlternative: function getAlternative() {
            return alternativePath;
          },
          isRoot: function isRoot() {
            return path && path.indexOf(_this.slash) === path.length - 1;
          },
          isInited: function isInited() {
            return typeof path !== 'undefined';
          },
          isInHome: function isInHome() {
            return path && path.indexOf(_this._homeDir) === 0;
          },
          getRoot: function getRoot() {
            var index = String(path).indexOf(_this.slash);
            return String(path).substr(0, index + 1);
          },
          getParentFolder: function getParentFolder() {
            var index = String(path).lastIndexOf(_this.slash, path.length - 2);
            return String(path).substr(0, index + 1);
          }
        };
      }();

      this.currentFiles = [];
      this.slash = "\\";
      this.fileCanvas = null;
      this.fileHeader = null;
      this.fileUpload = null;
      this.sortFuncs = {
        name: [function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase();
          if (a > b) return 1;else if (a < b) return -1;else return 0;
        }, function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase();
          if (a < b) return 1;else if (a > b) return -1;else return 0;
        }],
        ext: [function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase(),
              index1 = a.lastIndexOf('.'),
              ext1 = a.substr(index1 + 1, a.length),
              index2 = b.lastIndexOf('.'),
              ext2 = b.substr(index2 + 1, b.length);
          if (ext1 > ext2) return 1;else if (ext1 < ext2) return -1;else return 0;
        }, function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase(),
              index1 = a.lastIndexOf('.'),
              ext1 = a.substr(index1 + 1, a.length),
              index2 = b.lastIndexOf('.'),
              ext2 = b.substr(index2 + 1, b.length);
          if (ext1 < ext2) return 1;else if (ext1 > ext2) return -1;else return 0;
        }],
        size: [function (a, b) {
          return a.Size - b.Size;
        }, function (a, b) {
          return b.Size - a.Size;
        }],
        date: [function (a, b) {
          return a.Date - b.Date;
        }, function (a, b) {
          return b.Date - a.Date;
        }]
      };
      this.currentSortType = 'name';
      this.currentSortIndex = {
        name: 0,
        ext: 0,
        size: 0,
        date: 0
      };
      this.shownPathScroll = false;
      this.returnMask = ['noname'];
      this._discs = null;
      this._params = null;
      this.ext7z = ['7Z', 'ZIP', 'GZIP', 'BZIP2', 'TAR', 'ARJ', 'CAB', 'CHM', 'CPIO', 'DEB', 'DMG', 'HFS', 'ISO', 'LZH', 'LZMA', 'MSI', 'NSIS', 'RAR', 'RPM', 'UDF', 'WIM', 'XAR', 'Z'];
    };

    fileBrowser.MAX_UPLOAD_SIZE = 500 * 1024 * 1024;
    /**
     Показать браузер пользователю. Если браузер уже показывается, он будет закрыт и открыт новый
     @param {String} title Заголовок окна браузера
     @param {String[]} mask Массив допустимых для выбора разрешений файлов. Если массив пустой, то выбираются директории, а не отдельные файлы
     @param {function(path)} closeFunc Функция, которая будет вызвана при выборе файла/директории (если браузер просто закрыли, не вызовется)
     @param {Object} params Параметры браузера
     @param {String} params.restrictDir Ограничивающая директория (поддерево). Нельзя посмотреть файлы вне этой директории (даже для админов)
     @param {String} params.startDir Начальная директория. Если нет, то будет открыто в том же месте, где и закрыт в прошлый раз.
    */

    fileBrowser.prototype.createBrowser = function (title, mask, closeFunc, params) {
      this._params = $.extend({
        restrictDir: null,
        startDir: null
      }, params);
      if (this._params.startDir !== null) this._path.set(this._params.startDir);

      if ($('#fileBrowserDialog').length) {
        $('#fileBrowserDialog').parent().dialog("destroy");
        $('#fileBrowserDialog').parent().remove();
      }

      var canvas = _div(null, [['attr', 'id', 'fileBrowserDialog']]);

      var oDialog = showDialog(title, canvas, 800, 400, false, false, this.resize);
      this.returnMask = mask;
      this.parentCanvas = canvas;
      this.closeFunc = closeFunc;
      this._homeDir = nsGmx$1.AuthManager.getUserFolder();
      if (this._discs === null) // && nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE )
        this.loadInfo();else this.loadInfoHandler();
      return oDialog;
    };

    fileBrowser.prototype.resize = function () {
      if (!$("#fileBrowserDialog").find(".fileCanvas").length) return;
      var container = $('#fileBrowserDialog')[0];
      var titleHeight = container.parentNode.parentNode.firstChild.offsetHeight;
      container.childNodes[1].lastChild.style.height = container.parentNode.parentNode.offsetHeight - titleHeight - 6 - container.lastChild.offsetHeight - container.firstChild.offsetHeight - container.childNodes[1].firstChild.offsetHeight - 20 + 'px';
    };

    fileBrowser.prototype.close = function (path) {
      this.closeFunc(path);
      var canvas = $('#fileBrowserDialog')[0];
      $(canvas.parentNode).dialog("destroy");
      canvas.parentNode.removeNode(true);
    };

    fileBrowser.prototype.loadInfo = function () {
      var _this = this;

      sendCrossDomainJSONRequest(window.serverBase + "FileBrowser/GetDrives.ashx?WrapStyle=func", function (response) {
        if (!parseResponse(response)) return;
        _this._discs = response.Result;

        _this.loadInfoHandler();
      });
    };

    fileBrowser.prototype._showWarningDialog = function () {
      var canvas = _div([_t(_gtxt("FileBrowser.ExceedLimitMessage"))], [['dir', 'className', 'CustomErrorText']]);

      showDialog(_gtxt("Ошибка!"), canvas, 220, 100);
    };

    fileBrowser.prototype._uploadFilesAjax = function (formData) {
      var _this = this;

      this.progressBar.progressbar('option', 'value', 0);
      this.progressBar.show();
      formData.append('WrapStyle', 'None');
      var xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", function (e) {
        _this.progressBar.progressbar('option', 'value', e.loaded / e.total * 100);
      }, false);
      xhr.open('POST', window.serverBase + 'FileBrowser/Upload.ashx');
      xhr.withCredentials = true;

      xhr.onload = function () {
        _this.progressBar.hide();

        if (xhr.status === 200) {
          var response = JSON.parse(xhr.responseText);
          if (!parseResponse(response)) return;

          if (typeof response.Result == 'string') {
            var indexSlash = String(response.Result).lastIndexOf(_this.slash),
                fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
            _this.shownPath = fileName;
          }

          _this.getFiles();
        }
      };

      xhr.send(formData);
    };

    fileBrowser.prototype.loadInfoHandler = function () {
      var _this = this;

      if (!this._path.isInited()) {
        var mapFolder = _layersTree.treeModel.getMapProperties().LayersDir;

        if (mapFolder) {
          this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, nsGmx$1.AuthManager.getUserFolder());
        } else {
          this._path.set(nsGmx$1.AuthManager.getUserFolder());
        }
      }

      this.currentSortFunc = this.sortFuncs['name'][0];
      this.fileUpload = _div(null, [['dir', 'className', 'fileUpload']]);
      this.fileHeader = _div(null, [['css', 'height', '24px']]);
      this.fileCanvas = _div(null, [['dir', 'className', 'fileCanvas']]);
      $(this.parentCanvas).bind('dragover', function () {
        return false;
      });
      $(this.parentCanvas).bind('drop', function (e) {
        if (!window.FormData) return false;
        var files = e.originalEvent.dataTransfer.files;
        var formData = new FormData();
        var totalSize = 0;

        for (var f = 0; f < files.length; f++) {
          totalSize += files[f].size;
        }

        if (totalSize > fileBrowser.MAX_UPLOAD_SIZE) {
          _this._showWarningDialog();

          return false;
        }

        for (var _f = 0; _f < files.length; _f++) {
          formData.append('rawdata', files[_f]);
        }

        formData.append('ParentDir', _this._path.get());

        _this._uploadFilesAjax(formData);

        return false;
      });

      _$6(this.parentCanvas, [this.fileHeader, this.fileCanvas, this.fileUpload]);

      this.createHeader();
      this.createUpload();

      this._updateUploadVisibility();

      this.getFiles();
    };

    fileBrowser.prototype._updateUploadVisibility = function () {
      $([this.fileUpload, this.tdAddFolder]).toggle(nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN) || this._path.isInHome());
    };

    fileBrowser.prototype.createHeader = function () {
      var reloadButton = makeImageButton("img/reload.png"),
          homeButton = makeImageButton("img/home.png"),
          discButtonTds = [],
          _this = this;

      reloadButton.style.margin = '0px 5px 0px 10px';
      homeButton.style.margin = '0px 10px 0px 5px';
      reloadButton.style.width = '14px';
      reloadButton.style.height = '15px';
      homeButton.style.width = '15px';
      homeButton.style.height = '15px';

      _title(reloadButton, _gtxt("Обновить"));

      _title(homeButton, _gtxt("Домашняя директория"));

      reloadButton.onclick = function () {
        _this.getFiles();
      };

      homeButton.onclick = function () {
        _this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, _this._homeDir);

        _this.getFiles(_layersTree.treeModel.getMapProperties().LayersDir);
      }; //if ( nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE ) )
      //{


      for (var i = 0; i < this._discs.length; i++) {
        var discButtons = makeButton(this._discs[i]);

        (function (i) {
          discButtons.onclick = function () {
            _this.getFiles(_this._discs[i]);
          };
        })(i);

        discButtonTds.push(_td([discButtons]));
      } //}


      discButtonTds.push(_td([reloadButton], [['attr', 'vAlign', 'top']]));
      discButtonTds.push(_td([homeButton], [['attr', 'vAlign', 'top']]));

      var newFolderName = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '150px']]),
          showFolderButton = makeImageButton("img/newfolder.png"),
          newFolderButton = makeButton(_gtxt("Создать")),
          createFolder = function createFolder() {
        _this._status.start();

        sendCrossDomainJSONRequest(window.serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(_this._path.get() + newFolderName.value), function (response) {
          _this._status.stop();

          if (!parseResponse(response)) return;
          _this.shownPath = newFolderName.value;
          newFolderName.value = '';

          _this.getFiles();
        });
      };

      showFolderButton.style.width = '16px';
      showFolderButton.style.height = '13px';
      newFolderName.style.margin = '0px 3px';

      _title(showFolderButton, _gtxt("Новая папка"));

      showFolderButton.style.marginRight = '10px';

      showFolderButton.onclick = function () {
        $(newFolderName).toggle().focus();
        $(newFolderButton).toggle();
      };

      newFolderName.style.display = 'none';
      newFolderButton.style.display = 'none';
      $(newFolderName).on('keydown', function (e) {
        if (e.keyCode === 13) {
          if (newFolderName.value != '') createFolder();else inputError(newFolderName);
          return false;
        }
      });

      newFolderButton.onclick = function () {
        if (newFolderName.value != '') createFolder();else inputError(newFolderName);
      };

      this.tdAddFolder = _td([_table([_tbody([_tr([_td([showFolderButton], [['attr', 'vAlign', 'top']]), _td([newFolderName]), _td([newFolderButton])])])])], [['attr', 'vAlign', 'top'], ['css', 'height', '20px']]);
      discButtonTds.push(this.tdAddFolder);

      _$6(this.fileHeader, [_table([_tbody([_tr(discButtonTds)])])]);
    };

    fileBrowser.prototype.createUpload = function () {
      var div = _div(null, [['css', 'height', '30px']]),
          _this = this;

      var formFile = _form(null, [['attr', 'enctype', 'multipart/form-data'], ['dir', 'method', 'post'], ['dir', 'action', window.serverBase + 'FileBrowser/Upload.ashx?WrapStyle=message'], ['attr', 'target', 'fileBrowserUpload_iframe']]);

      var attach = _input(null, [['attr', 'type', 'file'], ['dir', 'name', 'rawdata'], ['css', 'width', '200px'], ['attr', 'multiple', 'multiple']]);

      _$6(formFile, [attach]);

      attach.onchange = function () {
        if (attach.files && attach.files[0] && attach.files[0].size > fileBrowser.MAX_UPLOAD_SIZE) {
          _this._showWarningDialog();

          return;
        } //если можем послать через AJAX, посылаем - будет работать прогресс-бар


        if (window.FormData) {
          var formData = new FormData(formFile);
          formData.append('ParentDir', _this._path.get());

          _this._uploadFilesAjax(formData);

          return;
        }

        sendCrossDomainPostRequest(window.serverBase + 'FileBrowser/Upload.ashx', {
          WrapStyle: 'message',
          ParentDir: _this._path.get()
        }, function (response) {
          if (!parseResponse(response)) return;
          var indexSlash = String(response.Result).lastIndexOf(_this.slash),
              fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
          _this.shownPath = fileName;

          _this.getFiles();
        }, formFile);
      };

      var dropInfoDiv = window.FormData ? _div([_t(_gtxt('FileBrowser.DropInfo'))], [['dir', 'className', 'fileBrowser-dragFileMessage']]) : _div();

      _$6(div, [dropInfoDiv, _table([_tbody([_tr([_td([formFile], [['css', 'paddingTop', '18px']])])])])]);

      this.progressBar = $('<div/>').addClass('fileBrowser-progressBar').progressbar({
        value: 100
      }).hide();

      _$6(this.fileUpload, [this.progressBar[0], div]);
    };

    fileBrowser.prototype.getFiles = function (path) {
      path = typeof path != 'undefined' ? path : this._path.get();

      var alternativePath = this._path.getAlternative();

      var _this = this;

      if (this._isRestrictedPath(path)) return;

      var doProcessResponce = function doProcessResponce(response) {
        _this._status.stop();

        if (!parseResponse(response)) return;

        _this.getFilesHandler(response.Result, path);
      };

      this._status.start();

      sendCrossDomainJSONRequest(window.serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(path), function (response) {
        if (response.Status !== 'ok' && alternativePath) {
          path = alternativePath;

          _this._path.set(alternativePath);

          sendCrossDomainJSONRequest(window.serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(alternativePath), doProcessResponce);
        } else {
          doProcessResponce(response);
        }
      });
    };

    fileBrowser.prototype.getFilesHandler = function (files, path) {
      this._path.set(path);

      this.currentFiles = files;

      this._updateUploadVisibility();

      this.reloadFiles();
    };

    fileBrowser.prototype.pathWidget = function () {
      var shortPath = this._path.get();

      var _this = this;

      var parent = $('<span/>', {
        'class': 'fileBrowser-pathWidget'
      });
      var pathElements = [];

      var highlightPath = function highlightPath(index) {
        for (var e = 0; e < pathElements.length; e++) {
          if (e <= index) pathElements[e].addClass('fileBrowser-activePathElem');else pathElements[e].removeClass('fileBrowser-activePathElem');
        }
      };

      var appendElem = function appendElem(text, path) {
        var elemIndex = pathElements.length;
        var newElem = $('<span/>', {
          'class': 'fileBrowser-pathElem'
        }).text(text + _this.slash).click(function () {
          _this.getFiles(path[path.legnth - 1] === _this.slash ? path : path + _this.slash);
        }).hover(function () {
          highlightPath(elemIndex);
        }, function () {
          highlightPath(-1);
        });
        pathElements.push(newElem);
        parent.append(newElem); //.append( $('<span/>').text(_this.slash) );
      };

      var curFolder = '';

      while (shortPath.length) {
        var index = shortPath.indexOf(this.slash);
        if (index == 0) break;

        if (index < 0) {
          appendElem(shortPath, curFolder + shortPath);
          break;
        }

        var curText = shortPath.substr(0, index);
        curFolder += curText + this.slash;
        shortPath = shortPath.substr(index + 1);
        appendElem(curText, curFolder.substr(0, curFolder.length - 1));
      }

      return parent[0];
    };

    fileBrowser.prototype.quickSearch = function () {
      var input = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]),
          _this = this;

      input.onkeyup = function () {
        if (this.value != "") {
          var scroll = _this.findContent(this.value);

          if (scroll >= 0) _this.fileCanvas.lastChild.scrollTop = scroll;
        }
      };

      return input;
    };

    fileBrowser.prototype.findContent = function (value) {
      var tbody = this.fileCanvas.lastChild.firstChild.lastChild;

      for (var i = 0; i < tbody.childNodes.length; ++i) {
        var text = tbody.childNodes[i].textContent.toLowerCase();
        if (text != "[..]" && text.indexOf(value.toLowerCase()) == 0) return tbody.childNodes[i].offsetTop;
      }

      return -1;
    };

    fileBrowser.prototype.reloadFiles = function () {
      $(this.fileCanvas).empty();
      this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);

      _$6(this.fileCanvas, [_div([this.pathWidget(), _br(), _t(_gtxt("Фильтр")), this.quickSearch(), this.statusContainer], [['dir', 'className', 'currentDir'], ['css', 'color', '#153069'], ['css', 'fontSize', '12px']])]);

      _$6(this.fileCanvas, [this.draw(this.currentFiles)]);

      this.resize();

      if (this.shownPathScroll) {
        this.fileCanvas.lastChild.scrollTop = this.shownPathScroll.offsetTop;
        this.shownPathScroll = false;
      }
    };

    fileBrowser.prototype._getParentFolder = function (path) {
      var index = String(path).lastIndexOf(this.slash),
          newPath = String(path).substr(0, index);
      if (new RegExp('^[a-z]:$', 'i').test(newPath)) newPath += this.slash;
      return newPath;
    };

    fileBrowser.prototype._isRestrictedPath = function (path) {
      return this._params.restrictDir !== null && path.indexOf(this._params.restrictDir) != 0;
    };

    fileBrowser.prototype.draw = function (files) {
      var nameSort = makeLinkButton(_gtxt("Имя")),
          extSort = makeLinkButton(_gtxt("Тип")),
          sizeSort = makeLinkButton(_gtxt("Размер")),
          dateSort = makeLinkButton(_gtxt("Дата")),
          _this = this;

      nameSort.sortType = 'name';
      extSort.sortType = 'ext';
      sizeSort.sortType = 'size';
      dateSort.sortType = 'date';

      nameSort.onclick = extSort.onclick = sizeSort.onclick = dateSort.onclick = function () {
        _this.currentSortType = this.sortType;
        _this.currentSortIndex[_this.currentSortType] = 1 - _this.currentSortIndex[_this.currentSortType];

        _this.reloadFiles();
      };

      var tdRoot = _td(null, [['css', 'width', '20px']]);

      if (nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_FILE_STRUCTURE)) {
        var rootButton = makeButton(this.slash);

        _$6(tdRoot, [rootButton]);

        rootButton.onclick = function () {
          _this.getFiles(_this._path.getRoot());
        };
      }

      var tableHeaderTr = _tr([tdRoot, _td([nameSort], [['css', 'textAlign', 'left']]), _td([extSort], [['css', 'width', '10%'], ['css', 'textAlign', 'center']]), _td([sizeSort], [['css', 'width', '15%'], ['css', 'textAlign', 'center']]), _td([dateSort], [['css', 'width', '25%'], ['css', 'textAlign', 'center']])]),
          prevDirTr = _tr([_td(), _td([_t("[..]")]), _td(), _td(), _td()]),
          tableFilesTrs = [];

      var parentFolder = _this._path.getParentFolder();

      if (parentFolder && !this._isRestrictedPath(parentFolder)) {
        tableFilesTrs.push(prevDirTr);
        attachEffects(prevDirTr, 'hover');

        prevDirTr.onclick = function () {
          _this.getFiles(parentFolder);
        };
      }

      tableFilesTrs = tableFilesTrs.concat(this.drawFolders(files));
      tableFilesTrs = tableFilesTrs.concat(this.drawFiles(files));
      return _div([_table([_thead([tableHeaderTr]), _tbody(tableFilesTrs)], [['css', 'width', '100%']])], [['css', 'overflowY', 'scroll']]);
    };

    fileBrowser.prototype.getCurrentSortFunc = function () {
      return this.sortFuncs[this.currentSortType][this.currentSortIndex[this.currentSortType]];
    };

    fileBrowser.prototype.formatDate = function (sec) {
      var sysDate = new Date(sec * 1000),
          date = new Array(6);
      date[0] = sysDate.getDate(), date[1] = sysDate.getMonth() + 1, date[2] = sysDate.getFullYear(), date[3] = sysDate.getHours(), date[4] = sysDate.getMinutes(), date[5] = sysDate.getSeconds();

      for (var i = 0; i < 6; i++) {
        if (date[i] < 10) date[i] = '0' + date[i];
      }

      return date[0] + '.' + date[1] + '.' + date[2] + ' ' + date[3] + ':' + date[4] + ':' + date[5];
    };

    fileBrowser.prototype.drawFolders = function (arr) {
      var folders = [],
          trs = [],
          _this = this;

      for (var i = 0; i < arr.length; i++) {
        if (arr[i].Directory) folders.push(arr[i]);
      }

      if (this.currentSortType == 'name' || this.currentSortType == 'date') folders = folders.sort(this.getCurrentSortFunc());

      for (var _i = 0; _i < folders.length; _i++) {
        var tdReturn = _td();

        if (!this.returnMask.length) {
          var returnButton = makeImageButton("img/choose.png", "img/choose_a.png");
          returnButton.style.cursor = 'pointer';
          returnButton.style.marginLeft = '5px';

          _title(returnButton, _gtxt("Выбрать"));

          (function (i) {
            returnButton.onclick = function () {
              _this.close(_this._path.get() + folders[i].Name + _this.slash);
            };
          })(_i);

          _$6(tdReturn, [returnButton]);
        }

        var tr = _tr([tdReturn, _td([_div(null, [['dir', 'className', 'fileCanvas-folder-icon']]), this.createFolderActions(folders[_i].Name)]), _td(), _td([_t(_gtxt("Папка"))], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), _td([_t(this.formatDate(folders[_i].Date))], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']])]);

        (function (i) {
          tr.onclick = function () {
            _this.getFiles(_this._path.get() + folders[i].Name);
          };
        })(_i);

        attachEffects(tr, 'hover');

        if (this.shownPath && folders[_i].Name == this.shownPath) {
          $(tr).children("td").css('backgroundColor', '#CEEECE');
          this.shownPath = null;
          this.shownPathScroll = tr;
        }

        trs.push(tr);
      }

      return trs;
    };

    fileBrowser.prototype.drawFiles = function (arr) {
      var files = [],
          trs = [],
          _this = this;

      for (var i = 0; i < arr.length; i++) {
        if (!arr[i].Directory) files.push(arr[i]);
      }

      files = files.sort(this.getCurrentSortFunc());

      for (var _i2 = 0; _i2 < files.length; _i2++) {
        var index = String(files[_i2].Name).lastIndexOf('.'),
            name = String(files[_i2].Name).substr(0, index),
            ext = String(files[_i2].Name).substr(index + 1, files[_i2].Name.length),
            tdReturn = _td(),
            tdSize = _td([_t(this.makeSize(files[_i2].Size))], [['attr', 'size', files[_i2].Size], ['css', 'textAlign', 'right'], ['dir', 'className', 'invisible']]);

        if (this.returnMask.length && valueInArray(this.returnMask, ext.toLowerCase())) {
          var returnButton = makeImageButton("img/choose.png", "img/choose_a.png");
          returnButton.style.cursor = 'pointer';
          returnButton.style.marginLeft = '5px';

          _title(returnButton, _gtxt("Выбрать"));

          (function (i) {
            returnButton.onclick = function () {
              _this.close(_this._path.get() + files[i].Name);
            };
          })(_i2);

          _$6(tdReturn, [returnButton]);
        }

        var tr = _tr([tdReturn, _td([this.createFileActions(name, ext)]), _td([_t(ext)], [['css', 'textAlign', 'right'], ['css', 'fontSize', '12px']]), tdSize, _td([_t(this.formatDate(files[_i2].Date))], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']])]);

        attachEffects(tr, 'hover');

        if (this.shownPath && files[_i2].Name == this.shownPath) {
          $(tr).children("td").css('backgroundColor', '#CEEECE');
          this.shownPath = null;
          this.shownPathScroll = tr;
        }

        trs.push(tr);
      }

      return trs;
    };

    fileBrowser.prototype.createFolderActions = function (name) {
      var span = _span([_t(name)], [['css', 'fontSize', '12px']]),
          spanParent = _div([span], [['css', 'display', 'inline-block'], ['css', 'position', 'relative']]),
          _this = this;

      nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFolder', function () {
        return _this._path.isInHome() || nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_FILE_STRUCTURE);
      }, {
        fullPath: this._path.get() + name + this.slash,
        fileBrowser: this,
        enableZip: true
      });
      return spanParent;
    };

    fileBrowser.prototype.createFileActions = function (name, ext) {
      var span = _span([_t(name)], [['css', 'fontSize', '12px']]),
          spanParent = _div([span], [['css', 'display', 'inline-block'], ['css', 'position', 'relative']]),
          _this = this;

      nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFile', function () {
        return _this._path.isInHome() || nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_FILE_STRUCTURE);
      }, {
        fullPath: this._path.get() + name + '.' + ext,
        fileBrowser: this,
        enableUnzip: valueInArray(_this.ext7z, ext.toUpperCase())
      });
      return spanParent;
    }; //TODO: translate


    fileBrowser.prototype.makeSize = function (size) {
      if (size > 1024 * 1024 * 1024) return (size / (1024 * 1024 * 1024)).toFixed(2) + ' Гб';else if (size > 1024 * 1024) return (size / (1024 * 1024)).toFixed(2) + ' Мб';else if (size > 1024) return (size / 1024).toFixed(2) + ' Кб';
      return size + ' б';
    };

    window.fileBrowser = fileBrowser;
    window._fileBrowser = new fileBrowser(); ///////////////////////////////////////////////////////////////////////////////
    ////////////////////////// Контекстное меню браузера //////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    //фабрика, которая может возвращать элементы меню для архивирования (isZip=true) и разархивирования (isZip=false)

    var zipUnzipActionFactory = function zipUnzipActionFactory(isZip) {
      return {
        title: function title() {
          return isZip ? _gtxt("Упаковать") : _gtxt("Извлечь");
        },
        clickCallback: function clickCallback(context) {
          context.fileBrowser._status.start();

          sendCrossDomainJSONRequest(window.serverBase + (context.enableUnzip ? 'FileBrowser/Unzip.ashx' : 'FileBrowser/Zip.ashx') + '?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function (response) {
            context.fileBrowser._status.stop();

            if (!parseResponse(response)) return;
            var indexSlash = String(response.Result).lastIndexOf('\\'),
                fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
            context.fileBrowser.shownPath = fileName;
            context.fileBrowser.getFiles();
          });
        },
        isVisible: function isVisible(context) {
          return isZip ? !context.enableUnzip : context.enableUnzip; //XOR
        }
      };
    };

    nsGmx$1.ContextMenuController.addContextMenuElem({
      title: function title() {
        return _gtxt("Скачать");
      },
      clickCallback: function clickCallback(context) {
        var form = _form([_input(null, [['attr', 'name', 'FullName'], ['attr', 'value', context.fullPath]])], [['css', 'display', 'none'], ['attr', 'method', 'POST'], ['attr', 'action', window.serverBase + "FileBrowser/Download.ashx"]]);

        _$6(document.body, [form]);

        form.submit();
        form.removeNode(true);
      }
    }, ['FileBrowserFolder', 'FileBrowserFile']);
    nsGmx$1.ContextMenuController.addContextMenuElem({
      title: function title() {
        return _gtxt("Удалить");
      },
      clickCallback: function clickCallback(context) {
        context.fileBrowser._status.start();

        sendCrossDomainJSONRequest(window.serverBase + 'FileBrowser/Delete.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function (response) {
          context.fileBrowser._status.stop();

          if (!parseResponse(response)) return;
          context.fileBrowser.getFiles();
        });
      }
    }, ['FileBrowserFolder', 'FileBrowserFile']);
    nsGmx$1.ContextMenuController.addContextMenuElem({
      title: function title() {
        return _gtxt("Очистить");
      },
      clickCallback: function clickCallback(context) {
        context.fileBrowser._status.start();

        sendCrossDomainJSONRequest(window.serverBase + 'FileBrowser/CleanFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function (response) {
          context.fileBrowser._status.stop();

          if (!parseResponse(response)) return;
          context.fileBrowser.getFiles();
        });
      }
    }, 'FileBrowserFolder'); //упаковываем и файлы и папки

    nsGmx$1.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(true), ['FileBrowserFolder', 'FileBrowserFile']); //распаковываем только файлы

    nsGmx$1.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(false), 'FileBrowserFile');
    var _fileBrowser = window._fileBrowser;

    window._translationsHash.addtext("rus", {
      "tableBrowser.title": "Список таблиц",
      "tableBrowser.filterText": "Фильтр по названию"
    });

    window._translationsHash.addtext("eng", {
      "tableBrowser.title": "Tables list",
      "tableBrowser.filterText": "Filter by name"
    });

    var tableBrowser = function tableBrowser() {
      this.sortFuncs = {
        name: [function (_a, _b) {
          var a = String(_a).toLowerCase(),
              b = String(_b).toLowerCase();
          if (a > b) return 1;else if (a < b) return -1;else return 0;
        }, function (_a, _b) {
          var a = String(_a).toLowerCase(),
              b = String(_b).toLowerCase();
          if (a < b) return 1;else if (a > b) return -1;else return 0;
        }]
      };
      this.tables = [];
    };

    tableBrowser.prototype.createBrowser = function (closeFunc) {
      var canvas = $('#tableBrowserDialog');

      if (canvas) {
        canvas.parent().dialog("destroy");
        canvas.parent().remove();
      }

      this.closeFunc = closeFunc;
      if (!this.tables.length) this.loadInfo();else this.loadInfoHandler(this.tables);
    };

    tableBrowser.prototype.close = function (name) {
      this.closeFunc(name);
      var canvas = $('#tableBrowserDialog');
      $(canvas).parent().dialog("destroy");
      $(canvas).parent().remove();
    };

    tableBrowser.prototype.loadInfo = function () {
      sendCrossDomainJSONRequest(window.serverBase + "VectorLayer/GetGeometryTables.ashx?WrapStyle=func", function (response) {
        if (!parseResponse(response)) return;

        _tableBrowser.loadInfoHandler(response.Result);
      });
    };

    tableBrowser.prototype.loadInfoHandler = function (tables) {
      this.tables = tables;

      var _this = this;

      var renderTableRow = function renderTableRow(table) {
        var tdName = _td([_t(table)], [['css', 'fontSize', '12px']]),
            returnButton = makeImageButton("img/choose.png", "img/choose_a.png"),
            tr = _tr([_td([returnButton]), tdName], [['dir', 'className', 'tableTableRow']]);

        returnButton.style.cursor = 'pointer';
        returnButton.style.marginLeft = '5px';

        _title(returnButton, _gtxt("Выбрать"));

        returnButton.onclick = function () {
          _this.close(table);
        };

        attachEffects(tr, 'hover');

        for (var i = 0; i < tr.childNodes.length; i++) {
          tr.childNodes[i].style.width = this._fields[i].width;
        }

        return tr;
      };

      var sortFuncs = {};
      sortFuncs[_gtxt('Имя')] = this.sortFuncs['name'];
      var tableProvider = new nsGmx$1.ScrollTable.StaticDataProvider();
      tableProvider.setOriginalItems(this.tables);
      tableProvider.setSortFunctions(sortFuncs);
      var tableTable = new nsGmx$1.ScrollTable({
        limit: 5000,
        pagesCount: 5,
        height: 220,
        showFooter: false
      });
      tableTable.setDataProvider(tableProvider);

      var tableParent = _div(null, [['dir', 'id', 'tableBrowserDialog']]);

      tableTable.createTable({
        parent: tableParent,
        name: 'tableTable',
        width: 0,
        fields: ['', _gtxt('Имя')],
        fieldsWidths: ['10%', '90%'],
        sortableFields: sortFuncs,
        drawFunc: renderTableRow,
        isWidthScroll: false
      });

      var filterInput = _input(null, [['css', 'width', '150px'], ['dir', 'className', 'selectStyle']]);

      $(tableParent).prepend(filterInput).prepend($('<span/>', {
        'class': 'tableFilter'
      }).text(_gtxt("tableBrowser.filterText") + ": "));
      tableProvider.attachFilterEvents(filterInput, 'Table', function (fieldName, fieldValue, vals) {
        return vals.filter(function (val) {
          return String(val).toLowerCase().indexOf(fieldValue.toLowerCase()) > -1;
        });
      });
      showDialog(_gtxt("tableBrowser.title"), tableParent, {
        width: 300,
        height: 300
      });
    };

    var _tableBrowser = new tableBrowser();

    /** Виджет для выбора полей для X и Y координат из списка полей
    * @function
    * @param parent {DOMElement} - контейнер для размещения виджета
    * @param columns {LatLngColumnsModel} - модель для сохранения выбранных колонок
    * @param sourceColumns {Array} - доступные для выбора колонки
    */

    var SelectLatLngColumnsWidget = function SelectLatLngColumnsWidget(parent, columns, sourceColumns) {
      var updateWidget = function updateWidget() {
        var parsedColumns = nsGmx$1.LayerProperties.parseColumns(sourceColumns);
        $(parent).empty();

        if (!parsedColumns.geomCount && parsedColumns.coordColumns.length) {
          var fields = parsedColumns.coordColumns;

          var selectLat = nsGmx$1.Utils._select(null, [['attr', 'selectLat', true], ['dir', 'className', 'selectStyle'], ['css', 'width', '150px'], ['css', 'margin', '0px']]),
              selectLon = nsGmx$1.Utils._select(null, [['attr', 'selectLon', true], ['dir', 'className', 'selectStyle'], ['css', 'width', '150px'], ['css', 'margin', '0px']]);

          selectLat.onchange = function () {
            columns.set('YCol', this.value);
          };

          selectLon.onchange = function () {
            columns.set('XCol', this.value);
          };

          for (var i = 0; i < fields.length; i++) {
            var opt = _option([_t(fields[i])], [['attr', 'value', fields[i]]]);

            _(selectLat, [opt.cloneNode(true)]);

            _(selectLon, [opt.cloneNode(true)]);
          }

          nsGmx$1.Utils._(parent, [_table([_tbody([_tr([_td([_span([_t(_gtxt("Y (широта)"))], [['css', 'margin', '0px 3px']])], [['css', 'width', '73px'], ['css', 'border', 'none']]), _td([selectLat], [['css', 'width', '150px'], ['css', 'border', 'none']])]), _tr([_td([_span([_t(_gtxt("X (долгота)"))], [['css', 'margin', '0px 3px']])], [['css', 'width', '73px'], ['css', 'border', 'none']]), _td([selectLon], [['css', 'width', '150px'], ['css', 'border', 'none']])])])])]);

          if (columns.get('XCol')) {
            selectLon = switchSelect(selectLon, columns.get('XCol'));
          }

          if (columns.get('YCol')) {
            selectLat = switchSelect(selectLat, columns.get('YCol'));
          }

          columns.set({
            XCol: selectLon.value,
            YCol: selectLat.value
          });
        }
      };

      updateWidget();

      this.updateColumns = function (newFields) {
        sourceColumns = newFields;
        updateWidget();
      };
    };

    var getSourceColumns = function getSourceColumns(name) {
      var deferred = $.Deferred();
      sendCrossDomainJSONRequest(window.serverBase + "VectorLayer/GetSourceColumns.ashx?SourceName=" + encodeURIComponent(name), function (response) {
        if (!parseResponse(response)) {
          deferred.reject();
          return;
        }

        deferred.resolve(response.Result);
      });
      return deferred.promise();
    };

    var getFileExt = function getFileExt(path) {
      return String(path).substr(String(path).lastIndexOf('.') + 1, path.length);
    };
    /**
     Диалог редактирования свойств слоя с вкладками (tabs) и кнопкой "Сохранить" под ними
     @memberOf nsGmx
     @param {DOMElement} div Элемент дерева слоёв, соответствующий редактируемому слою
     @param {String} type тип слоя ("Vector" или "Raster")
     @param {DOMElement} parent контейнер, в которым нужно разместить диалог
     @param {Object} properties Параметры слоя. В том формате, в котором они приходят с сервера.
     @param {Object} [params] Дополнительные параметры
     @param {String[]} [params.standardTabs] Массив с названиями стандартных вкладок, которые нужно показывать. По умолчанию показывать все (main, attrs, metadata, advanced)
     @param {Object[]} [params.additionalTabs] Массив дополнительных вкладок со следующими полями:

       - {String} title Что будет написано но вкладке
       - {String} name Уникальный идентификатор вкладки
       - {DOMElement} container Контент вкладки

     @param {String} [params.selected] Идентификатор вкладки, которую нужно сделать активной
     @param {Function(controller)} [params.createdCallback] Ф-ция, которая будет вызвана после того, как диалог будет создан.
            В ф-цию передаётся объект со следующими свойствами:

       - {function(tabName)} selectTab Активизировать вкладку с идентификатором tabName

      @param {Object} [params.additionalUI] Хеш массивов с доп. UI во вкладках. Ключ хеша - ID вкладки (main, attrs, metadata, advanced)
      @param {Boolean} [params.copy] Является ли создаваемый слой копией
    */


    var LayerEditor = function LayerEditor(div, type, parent, properties, params) {
      /** Генерируется перед изменением/добавлением слоя. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
       * @event nsGmx.LayerEditor#premodify
       */
      var _params = $.extend({
        addToMap: true,
        doneCallback: null,
        standardTabs: ['main', 'attrs', 'metadata', 'advanced'],
        additionalUI: {}
      }, params); // меняем тип источника на 'Sql', если слой является копией


      if (_params.copy) {
        properties = JSON.parse(JSON.stringify(properties));
        properties.SourceType = 'Sql';
      }

      var _this = this;

      this._originalTabs = [];
      this._saveButton = null;

      this.selectTab = function (tabName) {
        var selectedTab = $(tabMenu).tabs('option', 'active');
        $.each(tabs, function (i, tab) {
          if (tab.name === tabName && i !== selectedTab) {
            $(tabMenu).tabs('option', 'active', i);
          }
        });
      };

      params = params || {};

      var genPageDiv = function genPageDiv() {
        return _div([_div(null, [['dir', 'className', 'layer-container-inner']])], [['dir', 'className', 'layer-container-outer']]);
      };

      var props = div && (typeof div === 'string' ? properties : div.gmxProperties.content.properties) || {};
      var isReadonly = div && _queryMapLayers.layerRights(props.name || props.Name) !== 'edit' && props.Access !== 'edit'; // var isReadonly = div && _queryMapLayers.layerRights(div.gmxProperties.content.properties.name) !== 'edit' && div.gmxProperties.content.properties.Access !== 'edit';

      var createUI = function createUI() {
        // var divProperties = div ? div.gmxProperties.content.properties : !_params.copy ? {} : false,
        var divProperties = props ? props : !_params.copy ? {} : false,
            layerProperties = new nsGmx$1.LayerProperties(); // tabs = [];

        layerProperties.initFromViewer(type, divProperties, properties || divProperties);
        _params = LayerEditor.applyInitHooks(_this, layerProperties, _params);
        var mainContainer = genPageDiv();
        var metadataContainer = genPageDiv();
        var advancedContainer = genPageDiv();
        var attrContainer = genPageDiv();

        if (_params.standardTabs.indexOf('main') >= 0) {
          _this._originalTabs.push({
            title: _gtxt('Общие'),
            name: 'main',
            container: mainContainer
          });
        }

        if (type === 'Vector' && _params.standardTabs.indexOf('attrs') >= 0) {
          _this._originalTabs.push({
            title: _gtxt('Колонки'),
            name: 'attrs',
            container: attrContainer
          });
        }

        if (!isReadonly) {
          if (_params.standardTabs.indexOf('metadata') >= 0) {
            _this._originalTabs.push({
              title: _gtxt('Метаданные'),
              name: 'metadata',
              container: metadataContainer
            });
          }

          if (type === 'Vector' && _params.standardTabs.indexOf('advanced') >= 0) {
            _this._originalTabs.push({
              title: _gtxt('Дополнительно'),
              name: 'advanced',
              container: advancedContainer
            });
          }
        }

        _this._saveButton = null;
        _this._saveButton = makeLinkButton(div ? _gtxt("Изменить") : _gtxt("Создать"));
        var origLayerProperties = layerProperties.clone();

        _this._createPageMain(mainContainer.firstChild, layerProperties, isReadonly, _params);

        _this._createPageMetadata(metadataContainer.firstChild, layerProperties, isReadonly, _params);

        if (type === 'Vector') {
          _this._createPageAdvanced(advancedContainer.firstChild, layerProperties, isReadonly, _params);

          _this._createPageAttributes(attrContainer.firstChild, layerProperties, isReadonly, _params);
        }

        for (var i in _params.additionalUI) {
          var tab = _.findWhere(_this._originalTabs, {
            name: i
          });

          if (tab) {
            var container = tab.container.firstChild;

            _params.additionalUI[i].forEach(function (ui) {
              $(container).append(ui);
            });
          }
        }

        if (div) {
          layerProperties.on({
            'change:Title': function changeTitle() {
              var title = layerProperties.get('Title');
              var span = $(div).find(".layer")[0];
              $(span).empty();

              nsGmx$1.Utils._(span, [_t(title)]);

              divProperties.title = title;
            },
            'change:Copyright': function changeCopyright() {
              var copyright = layerProperties.get('Copyright');
              nsGmx$1.gmxMap.layersByID[layerProperties.get('Name')].options.attribution = copyright;

              nsGmx$1.leafletMap.gmxControlIconManager.get('copyright')._redraw();

              divProperties.Copyright = copyright;
            },
            'change:Description': function changeDescription() {
              var description = layerProperties.get('Description');
              var span = $(div).find(".layerDescription")[0];
              $(span).empty();
              span.innerHTML = description;
              divProperties.description = description;
            },
            'change:Legend': function changeLegend() {
              divProperties.Legend = layerProperties.get('Legend');
            },
            'change:NameObject': function changeNameObject() {
              divProperties.NameObject = layerProperties.get('NameObject');
            }
          });
        }

        _this._saveButton.onclick = function () {
          $(_this).trigger('premodify');

          var name = layerProperties.get('Name'),
              curBorder = _mapHelper.drawingBorders.get(name),
              oldDrawing = origLayerProperties.get('Geometry'),
              isVector = layerProperties.get('Type') === 'Vector',
              needRetiling = false; // если изменились поля с геометрией, то нужно тайлить заново и перегрузить слой в карте


          if (isVector || layerProperties.get('ShapePath').Path != origLayerProperties.get('ShapePath').Path || layerProperties.get('TilePath').Path != origLayerProperties.get('TilePath').Path || oldDrawing && typeof curBorder != 'undefined' || !oldDrawing && typeof curBorder != 'undefined' || oldDrawing && typeof curBorder == 'undefined') {
            needRetiling = true;
          }

          var def = layerProperties.save(needRetiling, null, _params),
              layerTitle = layerProperties.get('Title'); //doneCallback вызываем при первом progress notification - признаке того, что вызов непосредственно скрипта модификации слоя прошёл успешно

          var onceCallback = _.once(function () {
            _params.doneCallback && _params.doneCallback(def, layerTitle);
          });

          def.always(parseResponse);
          def.then(onceCallback, null, onceCallback);

          if (isVector && !name && layerProperties.get('SourceType') === 'manual') {
            if (_params.addToMap) {
              def.done(function (response) {
                var mapProperties = _layersTree.treeModel.getMapProperties(),
                    targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                    gmxProperties = {
                  type: 'layer',
                  content: response.Result
                };

                gmxProperties.content.properties.mapName = mapProperties.name;
                gmxProperties.content.properties.hostName = mapProperties.hostName;
                gmxProperties.content.properties.visible = true;
                gmxProperties.content.properties.styles = [{
                  MinZoom: 1,
                  MaxZoom: 21,
                  RenderStyle: gmxProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[gmxProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[gmxProperties.content.properties.GeometryType]
                }];

                _layersTree.copyHandler(gmxProperties, targetDiv, false, true);
              });
            }
          } else if (name) {
            _queryMapLayers.asyncUpdateLayer(def, properties, true);
          } else if (_params.addToMap) {
            _queryMapLayers.asyncCreateLayer(def, layerTitle);
          }
        };
      };

      createUI(); // var id = 'layertabs' + (div ? div.gmxProperties.content.properties.name : '');

      var id = 'layertabs' + (props ? props.name : '');
      var tabs = this._originalTabs;

      if (!isReadonly) {
        tabs = tabs.concat(params.additionalTabs || []);
      }

      var lis = [],
          containers = [];

      for (var t = 0; t < tabs.length; t++) {
        lis.push(_li([_a([_t(tabs[t].title)], [['attr', 'href', '#' + tabs[t].name + id]])]));
        containers.push(tabs[t].container);
        $(tabs[t].container).attr('id', tabs[t].name + id);
      }

      var tabMenu = _div([_ul(lis)].concat(containers));

      var saveMenuCanvas;

      if (isReadonly) {
        saveMenuCanvas = _div([_t(_gtxt("Недостаточно прав для редактирования настроек слоя"))], [['css', 'padding', '5px 0px 5px 5px'], ['css', 'color', 'red']]);
      } else {
        saveMenuCanvas = _div([this._saveButton]);
      }

      $(parent).empty().append(_table([_tr([_td([tabMenu])], [['css', 'height', '100%'], ['css', 'verticalAlign', 'top']]), _tr([_td([_div(null, [['css', 'height', '1px']]), saveMenuCanvas])])], [['css', 'height', '100%'], ['css', 'width', '100%'], ['css', 'position', 'relative']]));

      var getTabIndex = function getTabIndex(tabName) {
        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].name === tabName) return i;
        }

        return -1;
      };

      var selectIndex = getTabIndex(params.selected);
      $(tabMenu).tabs({
        active: selectIndex > -1 ? selectIndex : 0,
        activate: function activate() {
          var activeIndex = $(tabMenu).tabs('option', 'active');
          $(saveMenuCanvas).toggle(activeIndex < _this._originalTabs.length);
        }
      });
      $(saveMenuCanvas).toggle(selectIndex < this._originalTabs.length);
      params.createdCallback && params.createdCallback(this);
    };

    LayerEditor.prototype._createPageMain = function (parent, layerProperties, isReadonly, params) {
      var title = _input(null, [['attr', 'fieldName', 'title'], ['attr', 'value', layerProperties.get('Title')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      title.onkeyup = function () {
        layerProperties.set('Title', this.value);
        return true;
      };

      layerProperties.on('change:Title', function () {
        var newTitle = layerProperties.get('Title');

        if (newTitle !== title.value) {
          title.value = newTitle;
        }
      });

      var copyright = _input(null, [['attr', 'fieldName', 'copyright'], ['attr', 'value', layerProperties.get('Copyright')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      copyright.onkeyup = function () {
        layerProperties.set('Copyright', this.value);
        return true;
      };

      var legend = _input(null, [['attr', 'fieldName', 'Legend'], ['attr', 'value', layerProperties.get('Legend')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      legend.onkeyup = legend.onchange = function () {
        layerProperties.set('Legend', this.value);
        return true;
      };

      var descr = _textarea(null, [['attr', 'fieldName', 'description'], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px'], ['css', 'height', '50px']]);

      descr.onkeyup = function () {
        layerProperties.set('Description', this.value);
        return true;
      };

      descr.value = layerProperties.get('Description');
      var currentGeometryType = layerProperties.get('GeometryType');
      var geometryTitle = null;
      var geometryTypes = [{
        title: _gtxt('полигоны'),
        type: 'polygon'
      }, {
        title: _gtxt('линии'),
        type: 'linestring'
      }, {
        title: _gtxt('точки'),
        type: 'point'
      }];

      for (var i = 0; i < geometryTypes.length; i++) {
        if (currentGeometryType === geometryTypes[i].type) {
          geometryTitle = geometryTypes[i].title;
        }
      }

      var geometryType = _input(null, [['attr', 'fieldName', 'geom_type'], ['attr', 'value', geometryTitle], ['attr', 'disabled', 'disabled'], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      var shownProperties = [];
      shownProperties.push({
        name: _gtxt("Имя"),
        field: 'Title',
        elem: title
      });
      shownProperties.push({
        name: _gtxt("Копирайт"),
        field: 'Copyright',
        elem: copyright
      });

      if (layerProperties.get('Name')) {
        shownProperties.push({
          name: _gtxt("ID"),
          field: 'Name'
        });
      }

      shownProperties.push({
        name: _gtxt("Описание"),
        field: 'Description',
        elem: descr
      });

      if (layerProperties.get('Type') === "Vector" && layerProperties.get('Geometry') !== undefined) {
        shownProperties.push({
          name: _gtxt("Геометрия"),
          field: 'geometryType',
          elem: geometryType
        });
      }

      if (layerProperties.get('Type') != "Vector") {
        var selectImage = new mapHelper.ImageSelectionWidget();
        selectImage.on('selected', function (url) {
          var imgHtml = '<img src="' + url + '"></img>';
          legend.value = imgHtml;
          layerProperties.set('Legend', imgHtml);
        });
        var tr = $(Handlebars.compile('<tr>' + '<td class="propertiesTable-title">{{i "Легенда"}}<span class="layer-editor-legend-image"></span></td>' + '<td class="layer-editor-legend"></td>' + '</tr>')());
        tr.find('.layer-editor-legend-image').append(selectImage.el);
        tr.find('.layer-editor-legend').append(legend);
        shownProperties.push({
          tr: tr[0]
        });
      }

      if (!isReadonly) {
        if (layerProperties.get('Type') === "Vector") {
          shownProperties = shownProperties.concat(!params.copy ? this._createPageVectorSource(layerProperties, params) : []);
        } else if (layerProperties.get('Type') === "Raster") {
          shownProperties = shownProperties.concat(this._createPageRasterSource(layerProperties));
        }
      }

      var trs = _mapHelper.createPropertiesTable(shownProperties, layerProperties.attributes, {
        leftWidth: 70
      });

      nsGmx$1.Utils._(parent, [_table([_tbody(trs)], [['dir', 'className', 'propertiesTable']])]);

      if (isReadonly) {
        $(parent).find('input, textarea').prop('disabled', true);
      }
    };

    LayerEditor.prototype._createPageVectorSource = function (layerProperties, params) {
      var _this = this;

      var LatLngColumnsModel = nsGmx$1.LatLngColumnsModel;
      var shownProperties = [];
      var layerName = layerProperties.get('Name');
      var sourceType = layerProperties.get('SourceType');
      /*------------ Источник: файл ------------*/

      var shapePath = layerProperties.get('ShapePath');

      var shapePathInput = _input(null, [['attr', 'fieldName', 'ShapePath.Path'], ['attr', 'value', shapePath.Path || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]),
          shapeFileLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
          encodingParent = _div(),
          xlsColumnsParent = _div();

      shapePathInput.onkeyup = shapePathInput.onchange = function () {
        layerProperties.set('ShapePath', {
          Path: this.value
        });
      };

      var fileSourceColumns = sourceType === 'file' ? layerProperties.get('Columns') : [];
      var fileSelectedColumns = sourceType === 'file' ? layerProperties.get('GeometryColumnsLatLng') : new LatLngColumnsModel();
      var fileColumnsWidget = !params.copy ? new SelectLatLngColumnsWidget(xlsColumnsParent, fileSelectedColumns, fileSourceColumns) : null;
      shapeFileLink.style.marginLeft = '3px';
      var encodingWidget = new nsGmx$1.ShpEncodingWidget();
      shapePathInput.oldValue = shapePathInput.value;
      $(encodingWidget).change(function () {
        layerProperties.set('EncodeSource', encodingWidget.getServerEncoding());
      });

      if (getFileExt(shapePathInput.value) === 'shp') {
        encodingWidget.drawWidget(encodingParent, layerProperties.get('EncodeSource'));
      }

      if (shapePath && shapePath.Path != null && shapePath.Path != '' && !shapePath.Exists) {
        $(shapePathInput).addClass('error');
      } //TODO: использовать события модели


      shapeFileLink.onclick = function () {
        window._fileBrowser.createBrowser(_gtxt("Файл"), ['shp', 'tab', 'xls', 'xlsx', 'xlsm', 'mif', 'gpx', 'kml', 'csv', 'sxf', 'gdbtable', 'geojson', 'kmz', 'sqlite'], function (path) {
          shapePathInput.value = path;
          layerProperties.set('ShapePath', {
            Path: path
          });
          var index = String(path).lastIndexOf('.'),
              ext = String(path).substr(index + 1, path.length);

          if (layerProperties.get('Title') == '') {
            var indexSlash = String(path).lastIndexOf('\\'),
                fileName = String(path).substring(indexSlash + 1, index);
            layerProperties.set('Title', fileName);
          }

          getSourceColumns(path).done(function (sourceColumns) {
            layerProperties.set('Columns', sourceColumns);
            fileSourceColumns = sourceColumns;
          });
          $(encodingParent).empty();

          if (ext === 'shp') {
            encodingWidget.drawWidget(encodingParent);
          }
        });
      };

      var sourceFile = _div(null, [['dir', 'id', 'fileSource' + layerName]]);

      nsGmx$1.Utils._(sourceFile, [shapePathInput, shapeFileLink, encodingParent, xlsColumnsParent
      /*, fileAddAttribute, fileColumnsContainer*/
      ]);
      /*------------ Источник: таблица ------------*/


      var tableLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
          tableColumnsParent = _div();

      var tableSourceColumns = sourceType === 'table' ? layerProperties.get('Columns') : [];
      var tableSelectedColumns = sourceType === 'table' ? layerProperties.get('GeometryColumnsLatLng') : new LatLngColumnsModel();
      var tableColumnsWidget = new SelectLatLngColumnsWidget(tableColumnsParent, tableSelectedColumns, tableSourceColumns);

      var tablePathInput = _input(null, [['attr', 'fieldName', 'TableName'], ['attr', 'value', layerProperties.get('TableName') || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]);

      tablePathInput.onkeyup = tablePathInput.onchange = function () {
        layerProperties.set('TableName', this.value);
      };

      tableLink.onclick = function () {
        _tableBrowser.createBrowser(function (name) {
          tablePathInput.value = name;
          layerProperties.set('TableName', name);

          if (layerProperties.get('Title') == '') {
            layerProperties.set('Title', name);
          }

          getSourceColumns(name).done(function (sourceColumns) {
            layerProperties.set('Columns', sourceColumns);
            tableSourceColumns = sourceColumns;
          });
        });
      };

      tableLink.style.marginLeft = '3px';

      var TableCSParent = _div();

      var TableCSSelect = $('<select/>', {
        'class': 'selectStyle'
      }).css('width', '165px').append($('<option>').val('EPSG:4326').text(_gtxt('Широта/Долгота (EPSG:4326)'))).append($('<option>').val('EPSG:3395').text(_gtxt('Меркатор (EPSG:3395)'))).change(function () {
        layerProperties.set('TableCS', $(this).find(':selected').val());
      });

      if (layerProperties.get('TableCS')) {
        TableCSSelect.find('[value="' + layerProperties.get('TableCS') + '"]').attr('selected', 'selected');
      }

      $(TableCSParent).append($('<span/>').text(_gtxt('Проекция')).css('margin', '3px')).append(TableCSSelect);

      var sourceTable = _div([tablePathInput, tableLink, TableCSParent, tableColumnsParent], [['dir', 'id', 'tableSource' + layerName]]);
      /*------------ Источник: вручную ------------*/


      var geometryTypes = [{
        title: _gtxt('полигоны'),
        type: 'polygon',
        className: 'manual-polygon'
      }, {
        title: _gtxt('линии'),
        type: 'linestring',
        className: 'manual-linestring'
      }, {
        title: _gtxt('точки'),
        type: 'point',
        className: 'manual-point'
      }];

      var RadioButtonsWidget = function RadioButtonsWidget(container, buttons, activeType) {
        var _this = this;

        var _activeType = activeType || buttons[0].type;

        $(container).empty().addClass('manual-type-widget');

        for (var b = 0; b < buttons.length; b++) {
          $('<div/>').addClass(buttons[b].className).toggleClass('manual-active-type', _activeType === buttons[b].type).attr('title', buttons[b].title).appendTo(container).data('type', buttons[b].type);
        }

        $('div', container).click(function () {
          $(this).siblings().removeClass('manual-active-type');
          $(this).addClass('manual-active-type');
          _activeType = $(this).data('type');
          $(_this).change();
        });

        this.getActiveType = function () {
          return _activeType;
        };
      };

      var geometryTypeContainer = $('<div/>').css({
        'display': 'inline-block',
        'vertical-align': 'middle'
      });
      var geometryTypeWidget = new RadioButtonsWidget(geometryTypeContainer, geometryTypes, layerProperties.get('GeometryType'));
      $(geometryTypeWidget).change(function () {
        layerProperties.set('GeometryType', geometryTypeWidget.getActiveType());
      });
      layerProperties.set('GeometryType', geometryTypeWidget.getActiveType());
      var editAttributeLink = $('<span/>').addClass('buttonLink').text(_gtxt('Редактировать колонки')).click(function () {
        _this.selectTab('attrs');
      });

      var attrViewParent = _div();

      var geometryTypeTitle = _span([_t(_gtxt('Геометрия') + ': ')], [['css', 'height', '20px'], ['css', 'verticalAlign', 'middle']]);

      var attrContainer = _div([_div([layerName ? _div() : _div([geometryTypeTitle, geometryTypeContainer[0]]), editAttributeLink[0]]), _div([attrViewParent], [['css', 'margin', '3px']])], [['css', 'marginLeft', '3px']]);

      var sourceManual = _div([attrContainer], [['dir', 'id', 'manualSource' + layerName]]);
      /*------------ Общее ------------*/


      layerProperties.on({
        'change:Columns': function changeColumns() {
          var columns = layerProperties.get('Columns');
          tableColumnsWidget.updateColumns(columns);
          fileColumnsWidget && fileColumnsWidget.updateColumns(columns);
        }
      });
      /*------------ Переключалка источника слоя ------------*/

      var sourceContainers = [sourceFile, sourceTable, sourceManual];
      var template = Handlebars.compile('<form>' + '<label><input type="radio" name="sourceCheckbox" id="chxFileSource" data-container-idx="0" checked>{{i "Файл"}}</label><br/>' + '{{#unless copy}}' + '{{#if admin}}<label><input type="radio" name="sourceCheckbox" id="chxTableSource" data-container-idx="1">{{i "Таблица"}}</label><br/>{{/if}}' + '<label><input type="radio" name="sourceCheckbox" id="chxManualSource" data-container-idx="2">{{i "Вручную"}}</label>' + '{{/unless}}' + '</form>');
      var sourceCheckbox = $(template({
        admin: nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
        copy: params.copy
      }));
      sourceCheckbox.find('input, label').css({
        verticalAlign: 'middle'
      });
      sourceCheckbox.find('input').css({
        marginRight: 2
      });
      sourceCheckbox.find('input').click(function () {
        var activeIdx = $(this).data('containerIdx');
        $(sourceTab).tabs('option', 'active', activeIdx);
      });
      var activeCheckboxID = {
        'file': 'chxFileSource',
        'table': 'chxTableSource',
        'manual': 'chxManualSource'
      }[sourceType];
      $('#' + activeCheckboxID, sourceCheckbox).attr('checked', 'checked');

      var sourceTab = _div([_ul([_li([_a([_t(_gtxt('Файл'))], [['attr', 'href', '#fileSource' + layerName]])]), _li([_a([_t(_gtxt('Таблица'))], [['attr', 'href', '#tableSource' + layerName]])]), _li([_a([_t(_gtxt('Вручную'))], [['attr', 'href', '#manualSource' + layerName]])])], [['css', 'display', 'none']])]);

      var selectedSource = {
        'file': 0,
        'table': 1,
        'manual': 2
      }[sourceType];

      nsGmx$1.Utils._(sourceTab, sourceContainers);

      $(sourceTab).tabs({
        active: selectedSource,
        activate: function activate() {
          var selectedSource = $(sourceTab).tabs('option', 'active');

          if (selectedSource == 0) {
            layerProperties.set('Columns', fileSourceColumns);
            layerProperties.set('SourceType', 'file');
            layerProperties.set('GeometryColumnsLatLng', fileSelectedColumns);
          } else if (selectedSource == 1) {
            layerProperties.set('Columns', tableSourceColumns);
            layerProperties.set('SourceType', 'table');
            layerProperties.set('GeometryColumnsLatLng', tableSelectedColumns);
            layerProperties.set('TableCS', TableCSSelect.find(':selected').val());
          } else if (selectedSource == 2) {
            layerProperties.set('SourceType', 'manual');
          }
        }
      });
      var sourceTr2;

      if (!layerName) {
        sourceTr2 = _tr([_td([sourceCheckbox[0]], [['css', 'padding', '5px'], ['css', 'verticalAlign', 'top'], ['css', 'lineHeight', '18px']]), _td([_div([sourceTab])])]);
      } else {
        var sourceTitle = {
          'file': _gtxt('Файл'),
          'table': _gtxt('Таблица'),
          'manual': _gtxt('Вручную')
        }[sourceType];
        var sourceControls = {
          'file': sourceFile,
          'table': sourceTable,
          'manual': sourceManual
        }[sourceType];
        sourceTr2 = _tr([_td([_t(_gtxt("Источник") + ': ' + sourceTitle)], [['css', 'padding', '5px'], ['css', 'verticalAlign', 'top'], ['css', 'lineHeight', '18px']]), _td([sourceControls])]);
      }

      if (!layerName || sourceType !== 'manual') {
        shownProperties.push({
          tr: sourceTr2
        });
      }

      return shownProperties;
    };

    LayerEditor.prototype._createPageRasterSource = function (layerProperties) {
      var shapePath = layerProperties.get('ShapePath');
      var tilePath = layerProperties.get('TilePath');
      var name = layerProperties.get('Name');

      var shapePathInput = _input(null, [['attr', 'fieldName', 'ShapePath.Path'], ['attr', 'value', shapePath.Path || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]),
          tilePathInput = _input(null, [['attr', 'fieldName', 'TilePath.Path'], ['attr', 'value', tilePath.Path || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]),
          tileCatalogLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
          tileFileLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
          shapeLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
          drawingBorderLink = makeImageButton("img/choose2.png", "img/choose2_a.png"),
          drawingBorderDescr = _span(null, [['attr', 'id', 'drawingBorderDescr' + name], ['css', 'color', '#215570'], ['css', 'marginLeft', '3px']]),
          removeBorder = makeImageButton('img/closemin.png', 'img/close_orange.png'),
          divBorder = _div([drawingBorderDescr, removeBorder]),
          isAdmin = nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
          catalogPathElems = [_t(_gtxt("Каталог")), tileCatalogLink, _br()],
          filePathElems = [_t(_gtxt("Файл")), tileFileLink],
          trPath = _tr([_td(isAdmin ? catalogPathElems.concat(filePathElems) : filePathElems, [['css', 'paddingLeft', '5px'], ['css', 'fontSize', '12px']]), _td([tilePathInput])]),
          trShape = _tr([_td([_t(_gtxt("Граница")), shapeLink], [['css', 'paddingLeft', '5px'], ['css', 'fontSize', '12px']]), _td([shapePathInput, divBorder])]),
          shapeVisible = function shapeVisible(flag) {
        if (flag) {
          shapePathInput.style.display = '';
          divBorder.style.display = 'none';
        } else {
          shapePathInput.style.display = 'none';
          divBorder.style.display = '';
        }
      };

      divBorder.style.cssText = "height:22px; padding-top:3px;";
      removeBorder.style.cssText = "height:16px;padding:0;width:16px;cursor:pointer;margin:-1px 0px -3px 5px;";

      _title(removeBorder, _gtxt("Удалить"));

      tilePathInput.onchange = tilePathInput.oninput = function () {
        layerProperties.set('TilePath', {
          Path: this.value
        });
      };

      shapePathInput.onchange = shapePathInput.oninput = function () {
        layerProperties.set('ShapePath', {
          Path: this.value
        });
      };

      removeBorder.onclick = function () {
        shapeVisible(true);

        _mapHelper.drawingBorders.removeRoute(name, true);

        layerProperties.set('Geometry', null);
      };

      if (name) {
        nsGmx$1.Utils._(trShape.firstChild, [_br(), _t(_gtxt("Контур")), drawingBorderLink]);

        if (shapePath.Path) shapeVisible(true);else {
          shapeVisible(false);
          var geometry = layerProperties.get('Geometry');
          var geom = L.gmxUtil.geometryToGeoJSON(geometry, true);
          var drawingBorder = nsGmx$1.leafletMap.gmxDrawing.addGeoJSON(geom)[0];

          _mapHelper.drawingBorders.set(name, drawingBorder);

          _mapHelper.drawingBorders.updateBorder(name, drawingBorderDescr);
        }
      } else {
        shapeVisible(true);
      }

      if (shapePath && shapePath.Path != null && shapePath.Path != '' && !shapePath.Exists) $(shapePathInput).addClass('error');
      if (tilePath.Path != null && tilePath.Path != '' && !tilePath.Exists) $(tilePathInput).addClass('error');

      tileCatalogLink.onclick = function () {
        _fileBrowser.createBrowser(_gtxt("Каталог"), [], function (path) {
          tilePathInput.value = path;
          layerProperties.set('TilePath', {
            Path: path
          });

          if (!layerProperties.get('Title')) {
            path = path.substring(0, path.length - 1); //убираем слеш на конце

            var indexSlash = String(path).lastIndexOf('\\'),
                fileName = String(path).substring(indexSlash + 1, path.length);
            layerProperties.set('Title', fileName);
          }
        });
      };

      var appendMetadata = function appendMetadata(data) {
        var layerTags = layerProperties.get('MetaProperties');
        if (!data || !layerTags) return; // var convertedTagValues = {};

        for (var mp in data) {
          var tagtype = data[mp].Type;
          layerTags.addNewTag(mp, nsGmx$1.Utils.convertFromServer(tagtype, data[mp].Value), tagtype);
        }

        if (!layerProperties.get('Title')) {
          var platform = layerTags.getTagByName('platform');
          var dateTag = layerTags.getTagByName('acqdate');
          var timeTag = layerTags.getTagByName('acqtime');

          if (typeof platform !== 'undefined' && typeof dateTag !== 'undefined' && typeof timeTag !== 'undefined') {
            var timeOffset = new Date().getTimezoneOffset() * 60 * 1000;
            var dateInt = nsGmx$1.Utils.convertToServer('Date', dateTag.value);
            var timeInt = nsGmx$1.Utils.convertToServer('Time', timeTag.value);
            var date = new Date((dateInt + timeInt) * 1000 + timeOffset);
            var dateString = $.datepicker.formatDate('yy.mm.dd', date);
            var timeString = $.datepicker.formatTime('HH:mm', {
              hour: date.getHours(),
              minute: date.getMinutes()
            });
            layerProperties.set('Title', platform.value + '_' + dateString + '_' + timeString + '_UTC');
          }
        }
      };

      tileFileLink.onclick = function () {
        _fileBrowser.createBrowser(_gtxt("Файл"), ['jpeg', 'jpg', 'tif', 'tiff', 'bmp', 'png', 'img', 'tiles', 'cpyr', 'mbtiles'], function (path) {
          tilePathInput.value = path;
          layerProperties.set('TilePath', {
            Path: path
          });
          sendCrossDomainJSONRequest(window.serverBase + 'Layer/GetMetadata.ashx?basepath=' + encodeURIComponent(path), function (response) {
            if (!parseResponse(response)) return;
            appendMetadata(response.Result.MetaProperties);

            if (!layerProperties.get('Title')) {
              var indexExt = String(path).lastIndexOf('.');
              var indexSlash = String(path).lastIndexOf('\\'),
                  fileName = String(path).substring(indexSlash + 1, indexExt);
              layerProperties.set('Title', fileName);
            }
          });
        });
      };

      shapeLink.onclick = function () {
        _fileBrowser.createBrowser(_gtxt("Граница"), ['mif', 'tab', 'shp', 'geojson', 'kmz'], function (path) {
          shapePathInput.value = path;
          layerProperties.set('ShapePath', {
            Path: path
          });

          _mapHelper.drawingBorders.removeRoute(name, true);

          shapeVisible(true);
          sendCrossDomainJSONRequest(window.serverBase + 'Layer/GetMetadata.ashx?geometryfile=' + encodeURIComponent(path), function (response) {
            if (!parseResponse(response)) return;
            appendMetadata(response.Result.MetaProperties);
          });
        });
      };

      drawingBorderLink.onclick = function () {
        nsGmx$1.Controls.chooseDrawingBorderDialog(name, function (polygon) {
          _mapHelper.drawingBorders.set(name, polygon);

          _mapHelper.drawingBorders.updateBorder(name);

          shapeVisible(false);
        }, {
          geomType: 'POLYGON',
          errorMessage: _gtxt("$$phrase$$_17")
        });
      };

      tileCatalogLink.style.marginLeft = '3px';
      tileFileLink.style.marginLeft = '3px';
      shapeLink.style.marginLeft = '3px';
      drawingBorderLink.style.marginLeft = '3px';
      var shownProperties = [{
        tr: trPath
      }, {
        tr: trShape
      }];
      return shownProperties;
    };

    LayerEditor.prototype._createPageAttributes = function (parent, props, isReadonly, params) {
      var isNewLayer = !props.get('Name');

      var fileColumnsContainer = _div();

      var fileAttrModel = new nsGmx$1.ManualAttrModel(props.get('RC').get('IsRasterCatalog'));
      var type = props.get('SourceType');

      if (isNewLayer) {
        props.on('change:Columns', function () {
          if (props.get('SourceType') !== 'manual' && props.get('SourceType') !== 'Sql') {
            fileAttrModel.initFromServerFormat(props.get('Columns'));
          }
        });
      }

      fileAttrModel.initFromServerFormat(props.get('Columns'));
      var fileAttrView = new nsGmx$1.ManualAttrView();
      fileAttrView.init(fileColumnsContainer, fileAttrModel, {
        copy: params.copy
      });
      var allowEdit = !isReadonly && (type === 'manual' || !isNewLayer && type === 'file' || params.copy);
      fileAttrView.setActive(allowEdit);
      $(fileAttrModel).change(function () {
        props.set('Columns', fileAttrModel.toServerFormat());
      });

      nsGmx$1.Utils._(parent, [fileColumnsContainer]);

      props.on('change:SourceType', function () {
        var type = props.get('SourceType');
        var allowEdit = type === 'manual' || !isNewLayer && type === 'file';
        fileAttrModel.initFromServerFormat(props.get('Columns'));
        fileAttrView.setActive(allowEdit);
      });
    };

    LayerEditor.prototype._createPageMetadata = function (parent, layerProperties) {
      nsGmx$1.TagMetaInfo.loadFromServer(function (tagsInfo) {
        var layerTags = layerProperties.get('MetaProperties');
        nsGmx$1.LayerTagsWithInfo.call(layerTags, tagsInfo);
        new nsGmx$1.LayerTagSearchControl(layerTags, parent);
      });
    };

    LayerEditor.prototype._createPageAdvanced = function (parent, layerProperties) {
      //мультивременной слой
      var temporalLayerParent = _div(null, [['dir', 'className', 'TemporalLayer']]);

      var temporalProperties = layerProperties.get('Temporal');
      var temporalLayerView = new nsGmx$1.TemporalLayerParamsWidget(temporalLayerParent, temporalProperties, []);
      var isTemporalCheckbox = $('<input/>').attr({
        type: 'checkbox'
      }).change(function () {
        temporalProperties.set('isTemporal', this.checked);
      });

      var updateTemporalVisibility = function updateTemporalVisibility() {
        var isTemporal = temporalProperties.get('isTemporal');

        if (isTemporal) {
          temporalFieldset.children('fieldset').removeAttr('disabled');
        } else {
          temporalFieldset.children('fieldset').attr('disabled', 'disabled');
        }

        if (isTemporalCheckbox[0].checked != isTemporal) {
          isTemporalCheckbox[0].checked = isTemporal;
        }
      };

      var updateTemporalColumns = function updateTemporalColumns() {
        var parsedColumns = nsGmx$1.LayerProperties.parseColumns(layerProperties.get('Columns'));
        temporalLayerView.updateColumns(parsedColumns.dateColumns);

        if (parsedColumns.dateColumns.length === 0) {
          isTemporalCheckbox.attr('disabled', 'disabled');
          $('legend label', temporalFieldset).css('color', 'gray');
          $('legend', temporalFieldset).attr('title', _gtxt("Отсутствует временной атрибут"));
          temporalProperties.set('isTemporal', false);
        } else {
          isTemporalCheckbox.removeAttr('disabled');
          $('legend label', temporalFieldset).css('color', '');
          $('legend', temporalFieldset).removeAttr('title');
        }
      };

      temporalProperties.on('change:isTemporal', updateTemporalVisibility);
      layerProperties.on('change:Columns', updateTemporalColumns);
      var temporalFieldset = $('<fieldset/>').addClass('layer-fieldset').append($('<legend/>').append($('<label/>').append(isTemporalCheckbox).append(_gtxt("Данные с датой"))), $('<fieldset/>').append(temporalLayerParent) //вложенный fieldset нужен из-за бага в Opera
      ).appendTo(parent);
      updateTemporalVisibility();
      updateTemporalColumns(); //каталог растров

      var RCTemplate = Handlebars.compile('<fieldset class="layer-fieldset">' + '<legend><label>' + '<input type="checkbox" id="rc-params-isRC" {{#isRC}}checked{{/isRC}}>{{i "Каталог растров"}}' + '</label></legend>' + //вложенный fieldset нужен из-за бага в Opera
      '<fieldset {{^isRC}}disabled="disabled"{{/isRC}}><div id="rc-params-div"></div></fieldset>' + '</fieldset>');
      var rcFieldset = $(RCTemplate({
        isRC: layerProperties.get('RC').get('IsRasterCatalog')
      })).appendTo(parent); // var rasterCatalogControl = new nsGmx.LayerRasterCatalogWidget($('#rc-params-div', rcFieldset), layerProperties.get('RC'));
      // var quicklookTemplate = Handlebars.compile(
      //     '<fieldset class="layer-fieldset">' +
      //         '<legend>{{i "Накладываемое изображение"}}</legend>' +
      //         '<div class="layer-editor-quicklooks"></div>' +
      //     '</fieldset>'
      // );
      // var quicklookFieldset = $(quicklookTemplate()).appendTo(parent);
      // var quicklookWidget = new nsGmx.LayerQuicklookWidget($('.layer-editor-quicklooks', quicklookFieldset), layerProperties);

      $('#rc-params-isRC', rcFieldset).change(function () {
        layerProperties.get('RC').set('IsRasterCatalog', this.checked);
        rcFieldset.children('fieldset').prop('disabled', !this.checked);
      }); //Шаблон имени

      var nameObjectInput = _input(null, [['attr', 'fieldName', 'NameObject'], ['attr', 'value', layerProperties.get('NameObject')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      nameObjectInput.onkeyup = function () {
        layerProperties.set('NameObject', this.value);
        return true;
      };

      $('<div/>').append($('<span/>').text(_gtxt("Шаблон названий объектов")).css('margin-left', '5px'), nameObjectInput).appendTo(parent);
    };

    LayerEditor._initHooks = [];

    LayerEditor.addInitHook = function (hook) {
      LayerEditor._initHooks.push(hook);
    };

    LayerEditor.applyInitHooks = function (layerEditor, layerProperties, params) {
      LayerEditor._initHooks.forEach(function (hook) {
        params = hook(layerEditor, layerProperties, params) || params;
      });

      return params;
    };

    var createLayerEditor = function createLayerEditor(div, type, parent, properties, params) {
      var def = $.Deferred();
      params = $.extend(true, {}, params);

      params.createdCallback = function () {
        def.resolve(layerEditor);
      };

      var layerEditor = new LayerEditor(div, type, parent, properties, params);
      return def;
    };

    nsGmx$1.LayerEditor = LayerEditor;
    window.gmxCore.addModule('LayerEditor', {
      createLayerEditor: createLayerEditor,
      LayerEditor: LayerEditor
    }, {// require: ['LayerProperties']
    });

    var nsMapCommon = function ($) {
      var publicInterface = {
        generateWinniePermalink: function generateWinniePermalink() {
          var mapProps = nsGmx$1.gmxMap.properties,
              lmap = nsGmx$1.leafletMap,
              center = lmap.getCenter(),
              layersState = {
            expanded: {},
            visible: {}
          };

          _layersTree.treeModel.forEachNode(function (elem) {
            var props = elem.content.properties;

            if (elem.type == 'group') {
              var groupId = props.GroupID;

              if ($("div[GroupID='" + groupId + "']").length || props.changedByViewer) {
                layersState.expanded[groupId] = props.expanded;
              }
            } else if (props.changedByViewer) {
              layersState.visible[props.name] = props.visible;
            }
          });

          var config = {
            app: {
              gmxMap: {
                mapID: mapProps.name,
                apiKey: window.apiKey
              }
            },
            state: {
              map: {
                position: {
                  x: center.lng,
                  y: center.lat,
                  z: lmap.getZoom()
                }
              },
              calendar: nsGmx$1.widgets.commonCalendar.getDateInterval().saveState(),
              baseLayersManager: lmap.gmxBaseLayersManager.saveState(),
              layersTree: layersState
            }
          };
          return nsGmx$1.Utils.TinyReference.create(config, false);
        },

        /**
        * Выбирает данные из дерева слоёв по описанию слоёв и групп
        * @param {FlashMapObject} map - текущая карта
        * @param {object} mapTree - дерево, в котором нужно искать
        * @param {array} description - массив с описанием нужных слоёв. Каждый элемент массива может быть либо строкой (имя слоя), либо объектом {group: '<groupName>'} - выбрать все слои из группы
        */
        selectLayersFromTree: function selectLayersFromTree(map, mapTree, description) {
          var _array = [];
          var _hash = {};

          var _getLayersInGroup = function _getLayersInGroup(map, mapTree, groupTitle) {
            var res = {};

            var visitor = function visitor(treeElem, isInGroup) {
              if (treeElem.type === "layer" && isInGroup) {
                res[treeElem.content.properties.name] = map.layers[treeElem.content.properties.name];
              } else if (treeElem.type === "group") {
                isInGroup = isInGroup || treeElem.content.properties.title == groupTitle;
                var a = treeElem.content.children;

                for (var k = a.length - 1; k >= 0; k--) {
                  visitor(a[k], isInGroup);
                }
              }
            };

            visitor({
              type: "group",
              content: {
                children: mapTree.children,
                properties: {}
              }
            }, false);
            return res;
          };

          for (var k = 0; k < description.length; k++) {
            if (typeof description[k] === "string") {
              _hash[description[k]] = map.layers[description[k]];

              _array.push(map.layers[description[k]]);
            } else if ('group' in description[k]) {
              var groupHash = _getLayersInGroup(map, mapTree, description[k].group);

              for (var l in groupHash) {
                _hash[l] = groupHash[l];

                _array.push(groupHash[l]);
              }
            }
          }

          return {
            asArray: function asArray() {
              return _array;
            },
            asHash: function asHash() {
              return _hash;
            },
            names: function names() {
              var res = [];

              for (var l in _hash) {
                res.push(l);
              }

              return res;
            }
          };
        }
      };

      if (typeof window.gmxCore !== 'undefined') {
        window.gmxCore.addModule('MapCommon', publicInterface);
      }

      return publicInterface;
    }(jQuery);

    (function () {
      //Интерфейс для провайдеров значений параметров
      nsGmx$1.ILazyAttributeValuesProvider = function () {
        this.isAttributeExists = function () {};

        this.getValuesForAttribute = function () {};
      }; //Простая обёртка над массивами для обратной совместимости


      nsGmx$1.LazyAttributeValuesProviderFromArray = function (attributes) {
        var _attrs = attributes;

        this.isAttributeExists = function (attrName) {
          return attrName in _attrs;
        };

        this.getValuesForAttribute = function (attrName, callback) {
          if (attrName in _attrs) callback(_attrs[attrName]);else callback();
        };
      };

      nsGmx$1.LazyAttributeValuesProviderFromArray.prototype = new nsGmx$1.ILazyAttributeValuesProvider();
      /** При необходимости этот провайдер будет запрашивать значения аттрибутов у сервера
       * @class
       * @memberOf nsGmx
       * @param {Object} attributes Хеш имён атрибутов, значения которых хочется иметь
       * @param {String} layerName ID слоя
      */

      nsGmx$1.LazyAttributeValuesProviderFromServer = function (attributes, layerName) {
        var _attrs = attributes;
        var _isInited = false;
        var _isProcessing = false; //в процессе ожидания ответа от сервера мы можем получать запросы на разные аттрибуты
        //важно все их правильно сохранить и выхвать при получении данных

        var _callbacks = {};
        /** Проверить, есть ли такой атрибут
            @param {String} attrName Имя атрибута
            @return {Boolean} Есть ли такой атрибут среди атрибутов
        */

        this.isAttributeExists = function (attrName) {
          return attrName in _attrs;
        };
        /** Получить доступные значения атрибута
            @param {String} attrName Имя атрибута
            @param {Function} callback Ф-ция, которая будет вызвана со списком атрибутов, когда он станет доступным
        */


        this.getValuesForAttribute = function (attrName, callback) {
          if (!(attrName in _attrs)) //вообще нет такого имени
            callback();else if (_attrs[attrName].length) //есть вектор значений!
            callback(_attrs[attrName]);else if (_isInited) //вектора значений всё ещё нет и уже ходили на сервер - второй раз пробовать не будем...
            callback();else {
            if (!(attrName in _callbacks)) _callbacks[attrName] = [];

            _callbacks[attrName].push(callback);

            if (_isProcessing) return; //идём на сервер и запрашиваем значения аттрибутов!

            _isProcessing = true;
            sendCrossDomainJSONRequest(window.serverBase + "VectorLayer/GetVectorAttrValues.ashx?WrapStyle=func&LayerName=" + layerName, function (response) {
              _isInited = true;
              _isProcessing = false;

              if (!parseResponse(response)) {
                for (var n in _callbacks) {
                  for (var k = 0; k < _callbacks[n].length; k++) {
                    _callbacks[n][k]();
                  }
                }

                return;
              }

              _attrs = response.Result;

              for (var _n in _callbacks) {
                for (var _k = 0; _k < _callbacks[_n].length; _k++) {
                  _callbacks[_n][_k](_attrs[_n]);
                }
              }
            });
          }
        };

        this.getAttributesTypesHash = function (layerName) {
          var layer = nsGmx$1.gmxMap.layersByID[layerName],
              props = layer.getGmxProperties && layer.getGmxProperties(),
              res = {};

          if (props) {
            var attrTypes = props.attrTypes,
                attributes = props.attributes;

            for (var i = 0; i < attributes.length; i++) {
              res[attributes[i]] = attrTypes[i];
            }
          }

          return res;
        };

        var _attrsTypes = this.getAttributesTypesHash(layerName);

        this.getAttributeType = function (attr) {
          return _attrsTypes[attr];
        };
      };

      nsGmx$1.LazyAttributeValuesProviderFromServer.prototype = new nsGmx$1.ILazyAttributeValuesProvider();
    })();

    /**
     *
     * Zoomimage
     * Author: Stefan Petre www.eyecon.ro
     * 
     */
    (function ($) {
      var EYE = window.EYE = function () {
        var _registered = {
          init: []
        };
        return {
          init: function init() {
            $.each(_registered.init, function (nr, fn) {
              fn.call();
            });
          },
          extend: function extend(prop) {
            for (var i in prop) {
              if (prop[i] != undefined) {
                this[i] = prop[i];
              }
            }
          },
          register: function register(fn, type) {
            if (!_registered[type]) {
              _registered[type] = [];
            }

            _registered[type].push(fn);
          }
        };
      }();

      $(EYE.init);
    })(jQuery);

    /**
     *
     * Utilities
     * Author: Stefan Petre www.eyecon.ro
     * 
     */

    (function ($) {
      window.EYE.extend({
        getPosition: function getPosition(e, forceIt) {
          var x = 0;
          var y = 0;
          var es = e.style;
          var restoreStyles = false;

          if (forceIt && jQuery.curCSS(e, 'display') == 'none') {
            var oldVisibility = es.visibility;
            var oldPosition = es.position;
            restoreStyles = true;
            es.visibility = 'hidden';
            es.display = 'block';
            es.position = 'absolute';
          }

          var el = e;

          if (el.getBoundingClientRect) {
            // IE
            var box = el.getBoundingClientRect();
            x = box.left + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) - 2;
            y = box.top + Math.max(document.documentElement.scrollTop, document.body.scrollTop) - 2;
          } else {
            x = el.offsetLeft;
            y = el.offsetTop;
            el = el.offsetParent;

            if (e != el) {
              while (el) {
                x += el.offsetLeft;
                y += el.offsetTop;
                el = el.offsetParent;
              }
            }

            if (jQuery.browser.safari && jQuery.curCSS(e, 'position') == 'absolute') {
              x -= document.body.offsetLeft;
              y -= document.body.offsetTop;
            }

            el = e.parentNode;

            while (el && el.tagName.toUpperCase() != 'BODY' && el.tagName.toUpperCase() != 'HTML') {
              if (jQuery.curCSS(el, 'display') != 'inline') {
                x -= el.scrollLeft;
                y -= el.scrollTop;
              }

              el = el.parentNode;
            }
          }

          if (restoreStyles == true) {
            es.display = 'none';
            es.position = oldPosition;
            es.visibility = oldVisibility;
          }

          return {
            x: x,
            y: y
          };
        },
        getSize: function getSize(e) {
          var w = parseInt(jQuery.curCSS(e, 'width'), 10);
          var h = parseInt(jQuery.curCSS(e, 'height'), 10);
          var wb = 0;
          var hb = 0;

          if (jQuery.curCSS(e, 'display') != 'none') {
            wb = e.offsetWidth;
            hb = e.offsetHeight;
          } else {
            var es = e.style;
            var oldVisibility = es.visibility;
            var oldPosition = es.position;
            es.visibility = 'hidden';
            es.display = 'block';
            es.position = 'absolute';
            wb = e.offsetWidth;
            hb = e.offsetHeight;
            es.display = 'none';
            es.position = oldPosition;
            es.visibility = oldVisibility;
          }

          return {
            w: w,
            h: h,
            wb: wb,
            hb: hb
          };
        },
        getClient: function getClient(e) {
          var h, w;

          if (e) {
            w = e.clientWidth;
            h = e.clientHeight;
          } else {
            var de = document.documentElement;
            w = window.innerWidth || self.innerWidth || de && de.clientWidth || document.body.clientWidth;
            h = window.innerHeight || self.innerHeight || de && de.clientHeight || document.body.clientHeight;
          }

          return {
            w: w,
            h: h
          };
        },
        getScroll: function getScroll(e) {
          var t = 0,
              l = 0,
              w = 0,
              h = 0,
              iw = 0,
              ih = 0;

          if (e && e.nodeName.toLowerCase() != 'body') {
            t = e.scrollTop;
            l = e.scrollLeft;
            w = e.scrollWidth;
            h = e.scrollHeight;
          } else {
            if (document.documentElement) {
              t = document.documentElement.scrollTop;
              l = document.documentElement.scrollLeft;
              w = document.documentElement.scrollWidth;
              h = document.documentElement.scrollHeight;
            } else if (document.body) {
              t = document.body.scrollTop;
              l = document.body.scrollLeft;
              w = document.body.scrollWidth;
              h = document.body.scrollHeight;
            }

            if (typeof pageYOffset != 'undefined') {
              t = pageYOffset;
              l = pageXOffset;
            }

            iw = self.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0;
            ih = self.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0;
          }

          return {
            t: t,
            l: l,
            w: w,
            h: h,
            iw: iw,
            ih: ih
          };
        },
        getMargins: function getMargins(e, toInteger) {
          var t = jQuery.curCSS(e, 'marginTop') || '';
          var r = jQuery.curCSS(e, 'marginRight') || '';
          var b = jQuery.curCSS(e, 'marginBottom') || '';
          var l = jQuery.curCSS(e, 'marginLeft') || '';
          if (toInteger) return {
            t: parseInt(t, 10) || 0,
            r: parseInt(r, 10) || 0,
            b: parseInt(b, 10) || 0,
            l: parseInt(l, 10)
          };else return {
            t: t,
            r: r,
            b: b,
            l: l
          };
        },
        getPadding: function getPadding(e, toInteger) {
          var t = jQuery.curCSS(e, 'paddingTop') || '';
          var r = jQuery.curCSS(e, 'paddingRight') || '';
          var b = jQuery.curCSS(e, 'paddingBottom') || '';
          var l = jQuery.curCSS(e, 'paddingLeft') || '';
          if (toInteger) return {
            t: parseInt(t, 10) || 0,
            r: parseInt(r, 10) || 0,
            b: parseInt(b, 10) || 0,
            l: parseInt(l, 10)
          };else return {
            t: t,
            r: r,
            b: b,
            l: l
          };
        },
        getBorder: function getBorder(e, toInteger) {
          var t = jQuery.curCSS(e, 'borderTopWidth') || '';
          var r = jQuery.curCSS(e, 'borderRightWidth') || '';
          var b = jQuery.curCSS(e, 'borderBottomWidth') || '';
          var l = jQuery.curCSS(e, 'borderLeftWidth') || '';
          if (toInteger) return {
            t: parseInt(t, 10) || 0,
            r: parseInt(r, 10) || 0,
            b: parseInt(b, 10) || 0,
            l: parseInt(l, 10) || 0
          };else return {
            t: t,
            r: r,
            b: b,
            l: l
          };
        },
        traverseDOM: function traverseDOM(nodeEl, func) {
          func(nodeEl);
          nodeEl = nodeEl.firstChild;

          while (nodeEl) {
            window.EYE.traverseDOM(nodeEl, func);
            nodeEl = nodeEl.nextSibling;
          }
        },
        getInnerWidth: function getInnerWidth(el, scroll) {
          var offsetW = el.offsetWidth;
          return scroll ? Math.max(el.scrollWidth, offsetW) - offsetW + el.clientWidth : el.clientWidth;
        },
        getInnerHeight: function getInnerHeight(el, scroll) {
          var offsetH = el.offsetHeight;
          return scroll ? Math.max(el.scrollHeight, offsetH) - offsetH + el.clientHeight : el.clientHeight;
        },
        getExtraWidth: function getExtraWidth(el) {
          if ($.boxModel) return (parseInt($.curCSS(el, 'paddingLeft')) || 0) + (parseInt($.curCSS(el, 'paddingRight')) || 0) + (parseInt($.curCSS(el, 'borderLeftWidth')) || 0) + (parseInt($.curCSS(el, 'borderRightWidth')) || 0);
          return 0;
        },
        getExtraHeight: function getExtraHeight(el) {
          if ($.boxModel) return (parseInt($.curCSS(el, 'paddingTop')) || 0) + (parseInt($.curCSS(el, 'paddingBottom')) || 0) + (parseInt($.curCSS(el, 'borderTopWidth')) || 0) + (parseInt($.curCSS(el, 'borderBottomWidth')) || 0);
          return 0;
        },
        isChildOf: function isChildOf(parentEl, el, container) {
          if (parentEl == el) {
            return true;
          }

          if (!el || !el.nodeType || el.nodeType != 1) {
            return false;
          }

          if (parentEl.contains) {
            return parentEl.contains(el);
          }

          if (parentEl.compareDocumentPosition) {
            return !!(parentEl.compareDocumentPosition(el) & 16);
          }

          var prEl = el.parentNode;

          while (prEl && prEl != container) {
            if (prEl == parentEl) return true;
            prEl = prEl.parentNode;
          }

          return false;
        },
        centerEl: function centerEl(el, axis) {
          var clientScroll = window.EYE.getScroll();
          var size = window.EYE.getSize(el);
          if (!axis || axis == 'vertically') $(el).css({
            top: clientScroll.t + (Math.min(clientScroll.h, clientScroll.ih) - size.hb) / 2 + 'px'
          });
          if (!axis || axis == 'horizontally') $(el).css({
            left: clientScroll.l + (Math.min(clientScroll.w, clientScroll.iw) - size.wb) / 2 + 'px'
          });
        }
      });

      if (!$.easing.easeout) {
        $.easing.easeout = function (p, n, firstNum, delta, duration) {
          return -delta * ((n = n / duration - 1) * n * n * n - 1) + firstNum;
        };
      }
    })(jQuery);

    /**
     *
     * Color picker
     * Author: Stefan Petre www.eyecon.ro
     * 
     * Dual licensed under the MIT and GPL licenses
     * 
     */

    (function ($) {
      var ColorPicker = function () {
        var // ids = {},
        // inAction,
        charMin = 65,
            // visible,
        tpl = '<div class="colorpicker"><div class="colorpicker_color"><div><div></div></div></div><div class="colorpicker_hue"><div></div></div><div class="colorpicker_new_color"></div><div class="colorpicker_current_color"></div><div class="colorpicker_hex"><input type="text" maxlength="6" size="6" /></div><div class="colorpicker_rgb_r colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_g colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_rgb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_h colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_s colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_hsb_b colorpicker_field"><input type="text" maxlength="3" size="3" /><span></span></div><div class="colorpicker_submit"></div></div>',
            defaults = {
          eventName: 'click',
          onShow: function onShow() {},
          onBeforeShow: function onBeforeShow() {},
          onHide: function onHide() {},
          onChange: function onChange() {},
          onSubmit: function onSubmit() {},
          color: 'ff0000',
          livePreview: true,
          flat: false
        },
            fillRGBFields = function fillRGBFields(hsb, cal) {
          var rgb = HSBToRGB(hsb);
          $(cal).data('colorpicker').fields.eq(1).val(rgb.r).end().eq(2).val(rgb.g).end().eq(3).val(rgb.b).end();
        },
            fillHSBFields = function fillHSBFields(hsb, cal) {
          $(cal).data('colorpicker').fields.eq(4).val(hsb.h).end().eq(5).val(hsb.s).end().eq(6).val(hsb.b).end();
        },
            fillHexFields = function fillHexFields(hsb, cal) {
          $(cal).data('colorpicker').fields.eq(0).val(HSBToHex(hsb)).end();
        },
            setSelector = function setSelector(hsb, cal) {
          $(cal).data('colorpicker').selector.css('backgroundColor', '#' + HSBToHex({
            h: hsb.h,
            s: 100,
            b: 100
          }));
          $(cal).data('colorpicker').selectorIndic.css({
            left: parseInt(150 * hsb.s / 100, 10),
            top: parseInt(150 * (100 - hsb.b) / 100, 10)
          });
        },
            setHue = function setHue(hsb, cal) {
          $(cal).data('colorpicker').hue.css('top', parseInt(150 - 150 * hsb.h / 360, 10));
        },
            setCurrentColor = function setCurrentColor(hsb, cal) {
          $(cal).data('colorpicker').currentColor.css('backgroundColor', '#' + HSBToHex(hsb));
        },
            setNewColor = function setNewColor(hsb, cal) {
          $(cal).data('colorpicker').newColor.css('backgroundColor', '#' + HSBToHex(hsb));
        },
            keyDown = function keyDown(ev) {
          var pressedKey = ev.charCode || ev.keyCode || -1;

          if (pressedKey > charMin && pressedKey <= 90 || pressedKey == 32) {
            return false;
          }

          var cal = $(this).parent().parent();

          if (cal.data('colorpicker').livePreview === true) {
            change.apply(this);
          }
        },
            change = function change(ev) {
          var cal = $(this).parent().parent(),
              col;

          if (this.parentNode.className.indexOf('_hex') > 0) {
            cal.data('colorpicker').color = col = HexToHSB(fixHex(this.value));
          } else if (this.parentNode.className.indexOf('_hsb') > 0) {
            cal.data('colorpicker').color = col = fixHSB({
              h: parseInt(cal.data('colorpicker').fields.eq(4).val(), 10),
              s: parseInt(cal.data('colorpicker').fields.eq(5).val(), 10),
              b: parseInt(cal.data('colorpicker').fields.eq(6).val(), 10)
            });
          } else {
            cal.data('colorpicker').color = col = RGBToHSB(fixRGB({
              r: parseInt(cal.data('colorpicker').fields.eq(1).val(), 10),
              g: parseInt(cal.data('colorpicker').fields.eq(2).val(), 10),
              b: parseInt(cal.data('colorpicker').fields.eq(3).val(), 10)
            }));
          }

          if (ev) {
            fillRGBFields(col, cal.get(0));
            fillHexFields(col, cal.get(0));
            fillHSBFields(col, cal.get(0));
          }

          setSelector(col, cal.get(0));
          setHue(col, cal.get(0));
          setNewColor(col, cal.get(0));
          cal.data('colorpicker').onChange.apply(cal, [col, HSBToHex(col), HSBToRGB(col)]);
        },
            blur = function blur() {
          var cal = $(this).parent().parent();
          cal.data('colorpicker').fields.parent().removeClass('colorpicker_focus');
        },
            focus = function focus() {
          charMin = this.parentNode.className.indexOf('_hex') > 0 ? 70 : 65;
          $(this).parent().parent().data('colorpicker').fields.parent().removeClass('colorpicker_focus');
          $(this).parent().addClass('colorpicker_focus');
        },
            downIncrement = function downIncrement(ev) {
          var field = $(this).parent().find('input').focus();
          var current = {
            el: $(this).parent().addClass('colorpicker_slider'),
            max: this.parentNode.className.indexOf('_hsb_h') > 0 ? 360 : this.parentNode.className.indexOf('_hsb') > 0 ? 100 : 255,
            y: ev.pageY,
            field: field,
            val: parseInt(field.val(), 10),
            preview: $(this).parent().parent().data('colorpicker').livePreview
          };
          $(document).bind('mouseup', current, upIncrement);
          $(document).bind('mousemove', current, moveIncrement);
        },
            moveIncrement = function moveIncrement(ev) {
          ev.data.field.val(Math.max(0, Math.min(ev.data.max, parseInt(ev.data.val + ev.pageY - ev.data.y, 10))));

          if (ev.data.preview) {
            change.apply(ev.data.field.get(0), [true]);
          }

          return false;
        },
            upIncrement = function upIncrement(ev) {
          change.apply(ev.data.field.get(0), [true]);
          ev.data.el.removeClass('colorpicker_slider').find('input').focus();
          $(document).unbind('mouseup', upIncrement);
          $(document).unbind('mousemove', moveIncrement);
          return false;
        },
            downHue = function downHue() {
          var current = {
            cal: $(this).parent(),
            y: $(this).offset().top
          };
          current.preview = current.cal.data('colorpicker').livePreview;
          $(document).bind('mouseup', current, upHue);
          $(document).bind('mousemove', current, moveHue);
        },
            moveHue = function moveHue(ev) {
          change.apply(ev.data.cal.data('colorpicker').fields.eq(4).val(parseInt(360 * (150 - Math.max(0, Math.min(150, ev.pageY - ev.data.y))) / 150, 10)).get(0), [ev.data.preview]);
          return false;
        },
            upHue = function upHue(ev) {
          fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
          fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
          $(document).unbind('mouseup', upHue);
          $(document).unbind('mousemove', moveHue);
          return false;
        },
            downSelector = function downSelector() {
          var current = {
            cal: $(this).parent(),
            pos: $(this).offset()
          };
          current.preview = current.cal.data('colorpicker').livePreview;
          $(document).bind('mouseup', current, upSelector);
          $(document).bind('mousemove', current, moveSelector);
        },
            moveSelector = function moveSelector(ev) {
          change.apply(ev.data.cal.data('colorpicker').fields.eq(6).val(parseInt(100 * (150 - Math.max(0, Math.min(150, ev.pageY - ev.data.pos.top))) / 150, 10)).end().eq(5).val(parseInt(100 * Math.max(0, Math.min(150, ev.pageX - ev.data.pos.left)) / 150, 10)).get(0), [ev.data.preview]);
          return false;
        },
            upSelector = function upSelector(ev) {
          fillRGBFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
          fillHexFields(ev.data.cal.data('colorpicker').color, ev.data.cal.get(0));
          $(document).unbind('mouseup', upSelector);
          $(document).unbind('mousemove', moveSelector);
          return false;
        },
            enterSubmit = function enterSubmit() {
          $(this).addClass('colorpicker_focus');
        },
            leaveSubmit = function leaveSubmit() {
          $(this).removeClass('colorpicker_focus');
        },
            clickSubmit = function clickSubmit() {
          var cal = $(this).parent();
          var col = cal.data('colorpicker').color;
          cal.data('colorpicker').origColor = col;
          setCurrentColor(col, cal.get(0));
          cal.data('colorpicker').onSubmit(col, HSBToHex(col), HSBToRGB(col), cal.data('colorpicker').el);
        },
            show = function show() {
          var cal = $('#' + $(this).data('colorpickerId'));
          cal.data('colorpicker').onBeforeShow.apply(this, [cal.get(0)]);
          var pos = $(this).offset();
          var viewPort = getViewport();
          var top = pos.top + this.offsetHeight;
          var left = pos.left;

          if (top + 176 > viewPort.t + viewPort.h) {
            top -= this.offsetHeight + 176;
          }

          if (left + 356 > viewPort.l + viewPort.w) {
            left -= 356;
          }

          cal.css({
            left: left + 'px',
            top: top + 'px'
          });

          if (cal.data('colorpicker').onShow.apply(this, [cal.get(0)]) != false) {
            cal.show();
          }

          $(document).bind('mousedown', {
            cal: cal
          }, hide);
          return false;
        },
            hide = function hide(ev) {
          if (!isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
            if (ev.data.cal.data('colorpicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
              ev.data.cal.hide();
            }

            $(document).unbind('mousedown', hide);
          }
        },
            isChildOf = function isChildOf(parentEl, el, container) {
          if (parentEl == el) {
            return true;
          }

          if (parentEl.contains) {
            return parentEl.contains(el);
          }

          if (parentEl.compareDocumentPosition) {
            return !!(parentEl.compareDocumentPosition(el) & 16);
          }

          var prEl = el.parentNode;

          while (prEl && prEl != container) {
            if (prEl == parentEl) return true;
            prEl = prEl.parentNode;
          }

          return false;
        },
            getViewport = function getViewport() {
          var m = document.compatMode == 'CSS1Compat';
          return {
            l: window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
            t: window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
            w: window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
            h: window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
          };
        },
            fixHSB = function fixHSB(hsb) {
          return {
            h: Math.min(360, Math.max(0, hsb.h)),
            s: Math.min(100, Math.max(0, hsb.s)),
            b: Math.min(100, Math.max(0, hsb.b))
          };
        },
            fixRGB = function fixRGB(rgb) {
          return {
            r: Math.min(255, Math.max(0, rgb.r)),
            g: Math.min(255, Math.max(0, rgb.g)),
            b: Math.min(255, Math.max(0, rgb.b))
          };
        },
            fixHex = function fixHex(hex) {
          var len = 6 - hex.length;

          if (len > 0) {
            var o = [];

            for (var i = 0; i < len; i++) {
              o.push('0');
            }

            o.push(hex);
            hex = o.join('');
          }

          return hex;
        },
            HexToRGB = function HexToRGB(hex) {
          hex = parseInt(hex.indexOf('#') > -1 ? hex.substring(1) : hex, 16);
          return {
            r: hex >> 16,
            g: (hex & 0x00FF00) >> 8,
            b: hex & 0x0000FF
          };
        },
            HexToHSB = function HexToHSB(hex) {
          return RGBToHSB(HexToRGB(hex));
        },
            RGBToHSB = function RGBToHSB(rgb) {
          var hsb = {
            h: 0,
            s: 0,
            b: 0
          };
          var min = Math.min(rgb.r, rgb.g, rgb.b);
          var max = Math.max(rgb.r, rgb.g, rgb.b);
          var delta = max - min;
          hsb.b = max;
          hsb.s = max != 0 ? 255 * delta / max : 0;

          if (hsb.s != 0) {
            if (rgb.r == max) {
              hsb.h = (rgb.g - rgb.b) / delta;
            } else if (rgb.g == max) {
              hsb.h = 2 + (rgb.b - rgb.r) / delta;
            } else {
              hsb.h = 4 + (rgb.r - rgb.g) / delta;
            }
          } else {
            hsb.h = -1;
          }

          hsb.h *= 60;

          if (hsb.h < 0) {
            hsb.h += 360;
          }

          hsb.s *= 100 / 255;
          hsb.b *= 100 / 255;
          return hsb;
        },
            HSBToRGB = function HSBToRGB(hsb) {
          var rgb = {};
          var h = Math.round(hsb.h);
          var s = Math.round(hsb.s * 255 / 100);
          var v = Math.round(hsb.b * 255 / 100);

          if (s == 0) {
            rgb.r = rgb.g = rgb.b = v;
          } else {
            var t1 = v;
            var t2 = (255 - s) * v / 255;
            var t3 = (t1 - t2) * (h % 60) / 60;
            if (h == 360) h = 0;

            if (h < 60) {
              rgb.r = t1;
              rgb.b = t2;
              rgb.g = t2 + t3;
            } else if (h < 120) {
              rgb.g = t1;
              rgb.b = t2;
              rgb.r = t1 - t3;
            } else if (h < 180) {
              rgb.g = t1;
              rgb.r = t2;
              rgb.b = t2 + t3;
            } else if (h < 240) {
              rgb.b = t1;
              rgb.r = t2;
              rgb.g = t1 - t3;
            } else if (h < 300) {
              rgb.b = t1;
              rgb.g = t2;
              rgb.r = t2 + t3;
            } else if (h < 360) {
              rgb.r = t1;
              rgb.g = t2;
              rgb.b = t1 - t3;
            } else {
              rgb.r = 0;
              rgb.g = 0;
              rgb.b = 0;
            }
          }

          return {
            r: Math.round(rgb.r),
            g: Math.round(rgb.g),
            b: Math.round(rgb.b)
          };
        },
            RGBToHex = function RGBToHex(rgb) {
          var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];
          $.each(hex, function (nr, val) {
            if (val.length == 1) {
              hex[nr] = '0' + val;
            }
          });
          return hex.join('');
        },
            HSBToHex = function HSBToHex(hsb) {
          return RGBToHex(HSBToRGB(hsb));
        },
            restoreOriginal = function restoreOriginal() {
          var cal = $(this).parent();
          var col = cal.data('colorpicker').origColor;
          cal.data('colorpicker').color = col;
          fillRGBFields(col, cal.get(0));
          fillHexFields(col, cal.get(0));
          fillHSBFields(col, cal.get(0));
          setSelector(col, cal.get(0));
          setHue(col, cal.get(0));
          setNewColor(col, cal.get(0));
        };

        return {
          init: function init(opt) {
            opt = $.extend({}, defaults, opt || {});

            if (typeof opt.color == 'string') {
              opt.color = HexToHSB(opt.color);
            } else if (opt.color.r != undefined && opt.color.g != undefined && opt.color.b != undefined) {
              opt.color = RGBToHSB(opt.color);
            } else if (opt.color.h != undefined && opt.color.s != undefined && opt.color.b != undefined) {
              opt.color = fixHSB(opt.color);
            } else {
              return this;
            }

            return this.each(function () {
              if (!$(this).data('colorpickerId')) {
                var options = $.extend({}, opt);
                options.origColor = opt.color;
                var id = 'collorpicker_' + parseInt(Math.random() * 1000);
                $(this).data('colorpickerId', id);
                var cal = $(tpl).attr('id', id);

                if (options.flat) {
                  cal.appendTo(this).show();
                } else {
                  cal.appendTo(document.body);
                }

                options.fields = cal.find('input').bind('keyup', keyDown).bind('change', change).bind('blur', blur).bind('focus', focus);
                cal.find('span').bind('mousedown', downIncrement).end().find('>div.colorpicker_current_color').bind('click', restoreOriginal);
                options.selector = cal.find('div.colorpicker_color').bind('mousedown', downSelector);
                options.selectorIndic = options.selector.find('div div');
                options.el = this;
                options.hue = cal.find('div.colorpicker_hue div');
                cal.find('div.colorpicker_hue').bind('mousedown', downHue);
                options.newColor = cal.find('div.colorpicker_new_color');
                options.currentColor = cal.find('div.colorpicker_current_color');
                cal.data('colorpicker', options);
                cal.find('div.colorpicker_submit').bind('mouseenter', enterSubmit).bind('mouseleave', leaveSubmit).bind('click', clickSubmit);
                fillRGBFields(options.color, cal.get(0));
                fillHSBFields(options.color, cal.get(0));
                fillHexFields(options.color, cal.get(0));
                setHue(options.color, cal.get(0));
                setSelector(options.color, cal.get(0));
                setCurrentColor(options.color, cal.get(0));
                setNewColor(options.color, cal.get(0));

                if (options.flat) {
                  cal.css({
                    position: 'relative',
                    display: 'block'
                  });
                } else {
                  $(this).bind(options.eventName, show);
                }
              }
            });
          },
          showPicker: function showPicker() {
            return this.each(function () {
              if ($(this).data('colorpickerId')) {
                show.apply(this);
              }
            });
          },
          hidePicker: function hidePicker() {
            return this.each(function () {
              if ($(this).data('colorpickerId')) {
                $('#' + $(this).data('colorpickerId')).hide();
              }
            });
          },
          setColor: function setColor(col) {
            if (typeof col == 'string') {
              col = HexToHSB(col);
            } else if (col.r != undefined && col.g != undefined && col.b != undefined) {
              col = RGBToHSB(col);
            } else if (col.h != undefined && col.s != undefined && col.b != undefined) {
              col = fixHSB(col);
            } else {
              return this;
            }

            return this.each(function () {
              if ($(this).data('colorpickerId')) {
                var cal = $('#' + $(this).data('colorpickerId'));
                cal.data('colorpicker').color = col;
                cal.data('colorpicker').origColor = col;
                fillRGBFields(col, cal.get(0));
                fillHSBFields(col, cal.get(0));
                fillHexFields(col, cal.get(0));
                setHue(col, cal.get(0));
                setSelector(col, cal.get(0));
                setCurrentColor(col, cal.get(0));
                setNewColor(col, cal.get(0));
              }
            });
          }
        };
      }();

      $.fn.extend({
        ColorPicker: ColorPicker.init,
        ColorPickerHide: ColorPicker.hidePicker,
        ColorPickerShow: ColorPicker.showPicker,
        ColorPickerSetColor: ColorPicker.setColor
      });
    })(jQuery);

    (function () {
      window._translationsHash.addtext('rus', {
        gridPlugin: {
          gridSettings: 'Настройка координатной сетки',
          gridColorSettings: 'цвет',
          gridStepSettings: 'шаг',
          gridUnitsSettings: 'единицы',
          gridFormatSettings: 'формат вывода',
          set: 'установить',
          reset: 'сбросить',
          unitsKilometers: 'км',
          unitsDegrees: 'градусы',
          formatDecimal: 'десятичные градусы',
          formatDM: 'градусы, минуты',
          formatDMS: 'градусы, минуты, секунды',
          latitude: 'по широте',
          longitude: 'по долготе'
        }
      });

      window._translationsHash.addtext('eng', {
        gridPlugin: {
          gridSettings: 'Coordinate grid settings',
          gridColorSettings: 'color',
          gridStepSettings: 'step',
          gridUnitsSettings: 'units',
          gridFormatSettings: 'format',
          set: 'set',
          reset: 'reset',
          unitsKilometers: 'km',
          unitsDegrees: 'degrees',
          formatDecimal: 'decimal degrees',
          formatDM: 'degrees minutes',
          formatDMS: 'degrees minutes seconds',
          latitude: 'latitude',
          longitude: 'longitude'
        }
      }); // создает левое меню с параметрами координатной сетки


      var ConfigureGridMenu = function ConfigureGridMenu(manager) {
        var control = manager.gridControl,
            tempStyle = {
          outline: {
            color: control.options.color
          }
        },
            lm = new leftMenu(); // заполняем левое меню

        function createGridLeftMenu() {
          var gridConfigLeftMenu = nsGmx$1.Utils._div(null, [['dir', 'className', 'gridConfigLeftMenu']]);

          createGridConfig(gridConfigLeftMenu);
          return gridConfigLeftMenu;
        } // создание элементов отображения настроек сетки


        function createGridConfig(menu) {
          var gridConfigCanvas = nsGmx$1.Utils._div(null, [['dir', 'className', 'gridSettings']]),
              gridConfigTitle = nsGmx$1.Utils._span(null, [['dir', 'className', 'gridSettingsTitle']]),
              gridConfigIcon = CreateGridConfigIcon(tempStyle, 'linestring');

          $(gridConfigIcon).find('.borderIcon')[0].style.borderColor = tempStyle.outline.color;
          $(gridConfigTitle).append(window._gtxt('gridPlugin.gridSettings'));
          $(gridConfigCanvas).append(gridConfigIcon, gridConfigTitle);
          $(menu).append(gridConfigCanvas);

          gridConfigIcon.onclick = function () {
            createConfigDialog(this);
          };
        } // диалоговое окно для редактирования координатной сетки


        function createConfigDialog(elem) {
          if (manager.configDialog) {
            return;
          }

          var map = nsGmx$1.leafletMap,
              gridConfigEditor = nsGmx$1.Utils._div(null, [['dir', 'className', 'gridConfigEditor']]); // редактирование цвета сетки - колорпикер


          var fcp = nsGmx$1.Controls.createColorPicker(tempStyle.outline.color, function (colpkr) {
            $(colpkr).fadeIn(500);
            return false;
          }, function (colpkr) {
            $(colpkr).fadeOut(500);
            $(this).change();
            return false;
          }, function (hsb, hex) {
            tempStyle.outline.color = '#' + hex;
            fcp.style.backgroundColor = tempStyle.outline.color;
            control.setColor(tempStyle.outline.color);
            $(elem).find('.borderIcon')[0].style.borderColor = tempStyle.outline.color;
            manager.saveOptions();
            $(this).ColorPickerSetColor(tempStyle.outline.color);
            $(this).change();
          });
          $(fcp).ColorPickerSetColor(tempStyle.outline.color);
          $(fcp).css('background-color', tempStyle.outline.color); // редактирования шага сетки

          var gridStepYInputPanel = nsGmx$1.Utils._span(null, [['dir', 'className', 'gridStepConfig']]),
              gridStepXInputPanel = nsGmx$1.Utils._span(null, [['dir', 'className', 'gridStepConfig']]),
              gridStepYInput = nsGmx$1.Utils._input(null, [['dir', 'className', 'gridStepInput']]),
              gridStepXInput = nsGmx$1.Utils._input(null, [['dir', 'className', 'gridStepInput']]),
              gridUnitsConfig = nsGmx$1.Utils._span(null, [['dir', 'className', 'gridStepConfig']]),
              gridStepConfig = nsGmx$1.Utils._span(null, [['dir', 'className', 'gridStepConfig']]),
              gridFormatConfig = nsGmx$1.Utils._span(null, [['dir', 'className', 'gridFormatConfig']]),
              gridStepUnitsDegrees = nsGmx$1.Utils._input(null, [['dir', 'id', 'gridStepUnitsDegrees'], ['attr', 'type', 'radio'], ['attr', 'id', 'gridStepUnitsDegrees'], ['attr', 'name', 'gridStepUnits'], ['attr', 'value', 'degrees']]),
              gridStepUnitsKilometers = nsGmx$1.Utils._input(null, [['dir', 'id', 'gridStepUnitsKilometers'], ['attr', 'type', 'radio'], ['attr', 'name', 'gridStepUnits'], ['attr', 'value', 'kilometers']]),
              gridFormatDD = nsGmx$1.Utils._input(null, [['dir', 'id', 'gridFormatDD'], ['attr', 'type', 'radio'], ['attr', 'name', 'gridFormat'], ['attr', 'value', 0], control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []]),
              gridFormatDM = nsGmx$1.Utils._input(null, [['dir', 'id', 'gridFormatDM'], ['attr', 'type', 'radio'], ['attr', 'name', 'gridFormat'], ['attr', 'value', 1], control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []]),
              gridFormatDMS = nsGmx$1.Utils._input(null, [['dir', 'id', 'gridFormatDMS'], ['attr', 'type', 'radio'], ['attr', 'name', 'gridFormat'], ['attr', 'value', 2], control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []]),
              gridSetStepButton = nsGmx$1.Utils._button([nsGmx$1.Utils._t(window._gtxt('gridPlugin.set'))], [['dir', 'className', 'gridStepButton']]),
              gridResetStepButton = nsGmx$1.Utils._button([nsGmx$1.Utils._t(window._gtxt('gridPlugin.reset'))], [['dir', 'className', 'gridStepButton']]);

          $(gridStepYInputPanel).append(gridStepYInput, nsGmx$1.Utils._t(window._gtxt('gridPlugin.latitude')));
          $(gridStepXInputPanel).append(gridStepXInput, nsGmx$1.Utils._t(window._gtxt('gridPlugin.longitude')));
          $(gridUnitsConfig).append(nsGmx$1.Utils._label([gridStepUnitsDegrees, nsGmx$1.Utils._t(window._gtxt('gridPlugin.unitsDegrees'))], [['dir', 'className', 'gridUnitsLabel'], ['attr', 'for', 'gridStepUnitsDegrees']]), nsGmx$1.Utils._label([gridStepUnitsKilometers, nsGmx$1.Utils._t(window._gtxt('gridPlugin.unitsKilometers'))], [['dir', 'className', 'gridUnitsLabel'], ['attr', 'for', 'gridStepUnitsKilometers']]));
          $(gridFormatConfig).append(nsGmx$1.Utils._label([gridFormatDD, nsGmx$1.Utils._t(window._gtxt('gridPlugin.formatDecimal'))], [['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'], ['attr', 'for', 'gridFormatDD']]), $('<br></br>'), nsGmx$1.Utils._label([gridFormatDM, nsGmx$1.Utils._t(window._gtxt('gridPlugin.formatDM'))], [['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'], ['attr', 'for', 'gridFormatDM']]), $('<br></br>'), nsGmx$1.Utils._label([gridFormatDMS, nsGmx$1.Utils._t(window._gtxt('gridPlugin.formatDMS'))], [['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'], ['attr', 'for', 'gridFormatDMS']]));
          $(gridStepConfig).append(gridSetStepButton, gridResetStepButton);
          $(gridConfigEditor).append(nsGmx$1.Utils._table([nsGmx$1.Utils._tbody([nsGmx$1.Utils._tr([nsGmx$1.Utils._td([nsGmx$1.Utils._t(window._gtxt('gridPlugin.gridColorSettings'))], [['css', 'width', '70px']]), nsGmx$1.Utils._td([fcp])]), nsGmx$1.Utils._tr(null, [['dir', 'className', 'bigEmptyTableRow']]), nsGmx$1.Utils._tr([nsGmx$1.Utils._td([nsGmx$1.Utils._t(window._gtxt('gridPlugin.gridStepSettings'))], [['attr', 'rowspan', '2'], ['css', 'width', '70px']]), nsGmx$1.Utils._td([gridStepYInputPanel])]), nsGmx$1.Utils._tr([nsGmx$1.Utils._td([gridStepXInputPanel])]), nsGmx$1.Utils._tr(null, [['dir', 'className', 'bigEmptyTableRow']]), nsGmx$1.Utils._tr([nsGmx$1.Utils._td([nsGmx$1.Utils._t(window._gtxt('gridPlugin.gridUnitsSettings'))], [['css', 'width', '70px']]), nsGmx$1.Utils._td([gridUnitsConfig])]), nsGmx$1.Utils._tr(null, [['dir', 'className', 'bigEmptyTableRow']]), nsGmx$1.Utils._tr([nsGmx$1.Utils._td([nsGmx$1.Utils._t(window._gtxt('gridPlugin.gridFormatSettings'))], [['css', 'width', '70px'], ['css', 'vertical-align', 'middle']]), nsGmx$1.Utils._td([gridFormatConfig])]), nsGmx$1.Utils._tr(null, [['dir', 'className', 'bigEmptyTableRow']]), nsGmx$1.Utils._tr([nsGmx$1.Utils._td(null, [['css', 'width', '70px']]), nsGmx$1.Utils._td([gridStepConfig])])])], [['dir', 'className', 'gridConfigTable']]));

          if (control.options.units === 'degrees') {
            gridStepUnitsDegrees.checked = true;
            enableFormats();
          } else if (control.options.units === 'kilometers') {
            gridStepUnitsKilometers.checked = true;
            disableFormats();
          }

          gridStepUnitsDegrees.onclick = handleUnits;
          gridStepUnitsKilometers.onclick = handleUnits;
          gridFormatDD.onclick = handleFormats;
          gridFormatDM.onclick = handleFormats;
          gridFormatDMS.onclick = handleFormats;

          gridSetStepButton.onclick = function () {
            control.setStep(gridStepXInput.value, gridStepYInput.value);
            updateInputsValues();
          };

          gridResetStepButton.onclick = function () {
            control.setTitleFormat(0);
            control.clearStep();
            enableFormats();
            gridStepUnitsDegrees.checked = true;
            gridFormatDD.checked = true;
            updateInputsValues();
          };

          gridStepUnitsDegrees.checked = true;
          gridFormatDD.checked = true;
          updateInputsValues();
          handleFormats();
          map.on('zoomend', function () {
            control.repaint();
            updateInputsValues();
          });
          var pos = nsGmx$1.Utils.getDialogPos(elem, false, 0);

          var closeFunc = function closeFunc() {
            $(gridConfigEditor).find('.colorSelector').each(function () {
              $('#' + $(this).data('colorpickerId')).remove();
            });
            manager.configDialog = null;
            control.options.units === 'degrees' ? enableFormats() : disableFormats(); // control.clearStep();
          };

          var params = {
            width: 280,
            height: 280,
            posX: pos.left,
            posY: pos.top,
            resizeFunc: false,
            closeFunc: closeFunc
          };
          manager.configDialog = nsGmx$1.Utils.showDialog(window._gtxt('gridPlugin.gridSettings'), gridConfigEditor, params);

          function updateInputsValues() {
            gridStepXInput.value = control.options.customStep.x ? Math.round(control.options.customStep.x * 100) / 100 : control.options.defaultStep.x;
            gridStepYInput.value = control.options.customStep.y ? Math.round(control.options.customStep.y * 100) / 100 : control.options.defaultStep.y;
          }

          function handleUnits() {
            var value = this.value;

            if (control.options.units !== value) {
              control.setUnits(value);
            }

            value === 'degrees' ? enableFormats() : disableFormats();
            updateInputsValues();
          }

          function handleFormats() {
            var value = this.value;

            if (control.options.titleFormat !== value) {
              control.setTitleFormat(value);
            }
          }

          function disableFormats() {
            $('#gridFormatDD').prop('disabled', true);
            $('#gridFormatDM').prop('disabled', true);
            $('#gridFormatDMS').prop('disabled', true);
            $('.gridFormatLabel').addClass('disabledLabel');
          }

          function enableFormats() {
            $('#gridFormatDD').prop('disabled', false);
            $('#gridFormatDM').prop('disabled', false);
            $('#gridFormatDMS').prop('disabled', false);
            $('.gridFormatLabel').removeClass('disabledLabel');
          }
        } // создание иконки редактирования стиля


        function CreateGridConfigIcon(style, type) {
          var icon = nsGmx$1.Controls.createGeometryIcon(style, type);

          nsGmx$1.Utils._title(icon, window._gtxt('gridPlugin.gridSettings'));

          return icon;
        }

        this.Load = function () {
          if (lm != null) {
            var alreadyLoaded = lm.createWorkCanvas('mapGrid', function () {
              if (manager.state) {
                manager.setState({
                  isActive: false
                });
              } else {
                this.Unload();
              }
            });

            if (!alreadyLoaded) {
              $(lm.workCanvas).append(createGridLeftMenu());
              control.setColor(tempStyle.outline.color);
              manager.saveOptions();
            }
          }
        };

        this.Unload = function () {
          $(manager.configDialog).remove();
          manager.configDialog = null;
          $(lm.parentWorkCanvas).hide();
        };
      };

      var publicInterface = {
        pluginName: 'GridPlugin',
        ConfigureGridMenu: ConfigureGridMenu
      };
      window.gmxCore.addModule('GridPlugin', publicInterface);
    })();

    var MAX_SIZE = 10000;
    var EPS = 1E-9; // мы не хотим, чтобы рамка фигурировала в списке пользовательских объектов

    nsGmx$1.DrawingObjectCustomControllers.addDelegate({
      isHidden: function isHidden(obj) {
        if (obj.options.exportRect) {
          return true;
        }

        return false;
      }
    });

    window._translationsHash.addtext('rus', {
      mapExport: {
        settings: {
          settings: 'Настройки экспорта карты:',
          zoom: 'масштаб (зум)',
          size: 'размер',
          format: 'формат растра',
          fileType: 'тип файла',
          width: 'ширина (пк)',
          height: 'высота (пк)',
          name: 'имя файла'
        },
        formats: {
          geoTiff: 'GEOTIFF',
          geoTiffJpeg: 'GEOTIFF-JPEG',
          jpeg: 'JPEG',
          png: 'PNG'
        },
        filetypes: {
          raster: 'растр',
          mbTiles: 'MBTiles',
          kmz: 'kmz'
        },
        select: 'Выделить область карты',
        unselect: 'Снять выделение',
        zoomToBox: 'Перейти к выделенному',
        zoomToLevel: 'Перейти на зум',
        exportMap: 'Экспорт',
        cancel: 'Отмена',
        sizeWarn: 'максимальный размер - 10000 пикселей',
        valueWarn: 'недопустимое значение',
        inQueue: 'в очереди',
        inProcess: 'файл формируется',
        exportError: 'ошибка экспорта'
      }
    });

    window._translationsHash.addtext('eng', {
      mapExport: {
        exportTooltip: 'Select area',
        settings: {
          settings: 'Map export settings:',
          zoom: 'zoom',
          size: 'size',
          format: 'raster format',
          fileType: 'file type',
          width: 'width (px)',
          height: 'height (px)',
          name: 'file name'
        },
        formats: {
          geoTiff: 'GEOTIFF',
          geoTiffJpeg: 'GEOTIFF-JPEG',
          jpeg: 'JPEG',
          png: 'PNG'
        },
        filetypes: {
          raster: 'raster',
          mbTiles: 'MBTiles',
          kmz: 'kmz'
        },
        select: 'Select',
        unselect: 'Clear selection',
        zoomToBox: 'Zoom to selected',
        zoomToLevel: 'Zoom to level',
        exportMap: 'Export',
        cancel: 'Cancel',
        sizeWarn: 'incorrect size',
        valueWarn: 'incorrect value',
        inQueue: 'waiting',
        inProcess: 'processing file',
        exportError: 'export error'
      }
    });

    var formatTypes = ['geoTiff', 'geoTiffJpeg', 'jpeg', 'png'];
    var view;

    var MapExportMenu = function MapExportMenu() {
      var canvas = _div(null, [['dir', 'className', 'mapExportConfigLeftMenu']]);

      var ExportModel = Backbone.Model.extend({
        defaults: {
          lm: new leftMenu(),
          lmap: nsGmx$1.leafletMap,
          selArea: null,
          exportMode: true,
          width: 0,
          height: 0,
          widthValueErr: false,
          heightValueErr: false,
          widthSizeErr: false,
          heightSizeErr: false,
          format: null,
          fileType: null,
          x: null,
          y: null,
          z: null,
          latLng: null,
          coords: null,
          zoomLevels: getZoomLevels(),
          formatTypes: getTypes(formatTypes),
          fileTypes: null,
          name: '',
          taskInfo: null,
          exportErr: false
        }
      });
      var model = new ExportModel();
      var ExportView = Backbone.View.extend({
        el: $(canvas),
        model: model,
        template: Handlebars.compile('<div class="selectButtons">' + '<span class="buttonLink areaButton mapExportSelectButton"> {{i "mapExport.select"}}</span>' + '<span class="zoomToBoxButton" style="display:none">' + '</span>' + '</div>' + '<div class="exportSettings">' + '<span>' + '{{i "mapExport.settings.settings"}}' + '</span>' + '</div>' + '<table class="settings">' + '<tbody>' + '<tr class="zoomSelect">' + '<td class="eLabel">{{i "mapExport.settings.zoom"}}</td>' + '<td class="eInput">' + '<select class="zoomLevel">' + '{{#each this.zoomLevels}}' + '<option value="{{this.zoom}}"' + '{{#if this.current}} selected="selected"{{/if}}>' + '{{this.zoom}}' + '</option>' + '{{/each}}' + '</select>' + '</td>' + '<td class="zoomToLevel">' + '<span class="zoomToLevelButtonWrap" style="display:none">' + '</span>' + '</td>' + '</tr>' + '<tr class="dims">' + '<td class="eLabel">{{i "mapExport.settings.width"}}</td>' + '<td class="eInput">' + '<input type="text" class="mapExportWidth" value="{{width}}"/>' + '</td>' + '<td class="mapExportWarn" rowspan=2></td>' + '</tr>' + '<tr class="dims">' + '<td class="eLabel">{{i "mapExport.settings.height"}}</td>' + '<td class="eInput">' + '<input type="text" class="mapExportHeight" value="{{height}}"/>' + '</td>' + '</tr>' + '<tr class="formatSelect">' + '<td class="eLabel">{{i "mapExport.settings.format"}}</td>' + '<td class="eInput">' + '<select class="formatTypes">' + '{{#each this.formatTypes}}' + '<option value="{{this.type}}"' + '{{#if this.current}} selected="selected" {{/if}}>' + '{{this.type}}' + '</option>' + '{{/each}}' + '</select>' + '</td>' + '</tr>' + '<tr class="typeSelect">' + '<td class="eLabel">{{i "mapExport.settings.fileType"}}</td>' + '<td class="eInput">' + '<select class="fileTypes">' + '{{#each this.fileTypes}}' + '<option value="{{this.type}}"' + '{{#if this.current}} selected="selected" {{/if}}>' + '{{this.type}}' + '</option>' + '{{/each}}' + '</select>' + '</td>' + '</tr>' + '<tr class="nameSelect">' + '<td class="eLabel">{{i "mapExport.settings.name"}}</td>' + '<td class="eInput">' + '<input type="text" class="mapExportName" value=""/>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '<div class="exportWrap">' + '<div class="export">' + '<span class="buttonLink mapExportButton"> {{i "mapExport.exportMap"}}</span>' + '<span class="buttonLink cancelButton" style="display:none"> {{i "mapExport.cancel"}}</span>' + '<span class="spinHolder" style="display:none">' + // '<img src="img/progress.gif"/>' +
        '<span class="spinMessage"></span>' + '</span>' + '<span class="exportErrorMessage" style="display:none">{{i "mapExport.exportError"}}</span>' + '</div>' + '<div class="export-progress-container" style="display:none">' + '<div class="export-progressbar"></div>' + '</div>' + '</div>'),
        events: {
          'click .mapExportSelectButton': 'selectArea',
          'click .mapExportUnselectButton': 'unselectArea',
          'click .zoomToBoxButton': 'zoomToBox',
          'click .zoomToLevelButtonWrap': 'zoomToLevel',
          'input .mapExportWidth': 'resize',
          'input .mapExportHeight': 'resize',
          'change .zoomLevel': 'setZoom',
          'change .formatTypes': 'setFormat',
          'change .fileTypes': 'setFileType',
          'input .mapExportName': 'setName',
          'click .mapExportButton': 'exportMap',
          'click .cancelButton': 'cancelExport'
        },
        initialize: function initialize() {
          var attrs = this.model.toJSON(),
              currentZoom = attrs.lmap.getZoom(),
              zoomLevels = attrs.zoomLevels,
              formatTypes = attrs.formatTypes,
              // объявление типов файлов происходит здесь, так как необходима обработка смены языка
          // типы файлов хранятся в текущем языке
          fileTypes = [window._gtxt('mapExport.filetypes.raster'), window._gtxt('mapExport.filetypes.mbTiles'), window._gtxt('mapExport.filetypes.kmz')],
              updatedFileTypes = getTypes(fileTypes);
          this.listenTo(this.model, 'change:selArea', this.updateArea);
          this.listenTo(this.model, 'change:width', this.updateSize);
          this.listenTo(this.model, 'change:height', this.updateSize);
          this.listenTo(this.model, 'change:widthValueErr', this.handleValueError);
          this.listenTo(this.model, 'change:heightValueErr', this.handleValueError);
          this.listenTo(this.model, 'change:widthSizeErr', this.handleSizeError);
          this.listenTo(this.model, 'change:heightSizeErr', this.handleSizeError);
          this.listenTo(this.model, 'change:name', this.updateName);
          this.listenTo(this.model, 'change:z', this.updateZoom);
          this.listenTo(this.model, 'change:exportErr', this.handleExportError);
          this.listenTo(this.model, 'change:format', this.handleFormat);
          this.listenTo(this.model, 'change:fileType', this.handleFormat);

          for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
            zoomLevels[i].current = false;

            if (i === currentZoom) {
              zoomLevels[i].current = true;
            }
          }

          for (var j = 0; j < formatTypes.length; j++) {
            if (formatTypes[j].current === true) {
              this.model.set('format', formatTypes[j].type);
            }
          }

          for (var _j = 0; _j < updatedFileTypes.length; _j++) {
            if (updatedFileTypes[_j].current === true) {
              this.model.set('fileType', updatedFileTypes[_j].type);
            }
          }

          this.model.set({
            z: currentZoom,
            zoomLevels: zoomLevels,
            formatTypes: formatTypes,
            fileTypes: updatedFileTypes,
            format: 'jpeg',
            name: nsGmx$1.gmxMap.properties.title
          });
          this.updateArea();
          this.render();
        },
        render: function render() {
          var zoomToBoxButton, zoomToLevelButton;
          this.$el.html(this.template(this.model.toJSON()));
          this.$('.zoomLevel').prop('disabled', true);
          this.$('.mapExportWidth').prop('disabled', true);
          this.$('.mapExportHeight').prop('disabled', true);
          this.$('.formatTypes').prop('disabled', true);
          this.$('.fileTypes').prop('disabled', true);
          this.$('.mapExportName').val(this.model.get('name'));
          this.$('.mapExportName').prop('disabled', true);
          this.$('.mapExportButton').addClass('gmx-disabled');
          zoomToBoxButton = nsGmx$1.Utils.makeImageButton('img/zoom_to_box_tool_small.png', 'img/zoom_to_box_tool_small.png');

          nsGmx$1.Utils._title(zoomToBoxButton, window._gtxt('mapExport.zoomToBox'));

          this.$('.zoomToBoxButton').append(zoomToBoxButton);
          zoomToLevelButton = nsGmx$1.Utils.makeImageButton('img/zoom_to_level_tool_small.png', 'img/zoom_to_level_tool_small.png');
          $(zoomToLevelButton).addClass('zoomToLevelButton');

          nsGmx$1.Utils._title(zoomToLevelButton, window._gtxt('mapExport.zoomToLevel') + ' ' + this.model.get('z'));

          this.$('.zoomToLevelButtonWrap').append(zoomToLevelButton);
          return this;
        },
        updateArea: function updateArea() {
          var attrs = this.model.toJSON(),
              // format = attrs.format,
          areaButton = this.$('.areaButton'),
              zoomToBoxButton = this.$('.zoomToBoxButton'),
              zoomToLevelButton = this.$('.zoomToLevelButtonWrap'),
              zoomSelect = this.$('.zoomLevel'),
              widthInput = this.$('.mapExportWidth'),
              heightInput = this.$('.mapExportHeight'),
              formatSelect = this.$('.formatTypes'),
              fileSelect = this.$('.fileTypes'),
              exportNameInput = this.$('.mapExportName'),
              exportButton = this.$('.mapExportButton'),
              inputs = [zoomSelect, widthInput, heightInput, formatSelect, fileSelect, exportNameInput, exportButton];

          for (var i = 0; i < inputs.length; i++) {
            if (!attrs.selArea) {
              $(inputs[i]).prop('disabled', true);
            } else {
              $(inputs[i]).prop('disabled', false);
            }
          }

          if (attrs.selArea) {
            $(areaButton).removeClass('mapExportSelectButton');
            $(areaButton).addClass('mapExportUnselectButton');
            $(areaButton).text(window._gtxt('mapExport.unselect'));
            $(zoomToBoxButton).show();
            $(zoomToLevelButton).show();

            if (!attrs.widthValueErr && !attrs.widthSizeErr && !attrs.heightValueErr && !attrs.heightSizeErr && attrs.name !== '') {
              $(exportButton).removeClass('gmx-disabled');
            }
          } else {
            $(areaButton).removeClass('mapExportUnselectButton');
            $(areaButton).addClass('mapExportSelectButton');
            $(areaButton).text(window._gtxt('mapExport.select'));
            $(zoomToBoxButton).hide();
            $(zoomToLevelButton).hide();
            $(exportButton).addClass('gmx-disabled');
          }

          this.handleFormat();
        },
        updateSize: function updateSize() {
          var attrs = this.model.toJSON(),
              widthInput = this.$('.mapExportWidth'),
              width = Number(attrs.width).toFixed(0),
              heightInput = this.$('.mapExportHeight'),
              height = Number(attrs.height).toFixed(0);

          if (!attrs.widthValueErr) {
            $(widthInput).val(width);
          }

          if (!attrs.heightValueErr) {
            $(heightInput).val(height);
          }
        },
        handleValueError: function handleValueError() {
          var attrs = this.model.toJSON(),
              widthInput = this.$('.mapExportWidth'),
              heightInput = this.$('.mapExportHeight'),
              exportButton = this.$('.mapExportButton'),
              warn = this.$('.mapExportWarn');

          if (attrs.widthValueErr) {
            $(widthInput).addClass('error');
          } else if (!attrs.widthSizeErr) {
            $(widthInput).removeClass('error');
          }

          if (attrs.heightValueErr) {
            $(heightInput).addClass('error');
          } else if (!attrs.heightSizeErr) {
            $(heightInput).removeClass('error');
          }

          if (attrs.widthValueErr || attrs.heightValueErr) {
            $(exportButton).addClass('gmx-disabled');
            $(warn).html(window._gtxt('mapExport.valueWarn'));
          } else {
            if (attrs.selArea && attrs.name) {
              $(exportButton).removeClass('gmx-disabled');
            }

            if (attrs.widthSizeErr || attrs.heightSizeErr) {
              $(warn).html(window._gtxt('mapExport.sizeWarn'));
            } else {
              $(warn).html('');
            }
          }
        },
        handleSizeError: function handleSizeError() {
          var attrs = this.model.toJSON(),
              widthInput = this.$('.mapExportWidth'),
              heightInput = this.$('.mapExportHeight'),
              exportButton = this.$('.mapExportButton'),
              warn = this.$('.mapExportWarn');

          if (attrs.widthSizeErr) {
            $(widthInput).addClass('error');
          } else if (!attrs.widthValueErr) {
            $(widthInput).removeClass('error');
          }

          if (attrs.heightSizeErr) {
            $(heightInput).addClass('error');
          } else if (!attrs.heightValueErr) {
            $(heightInput).removeClass('error');
          }

          if (attrs.widthSizeErr || attrs.heightSizeErr) {
            $(exportButton).addClass('gmx-disabled');

            if (!attrs.widthValueErr && !attrs.heightValueErr) {
              $(warn).html(window._gtxt('mapExport.sizeWarn'));
            }
          } else if (!attrs.widthValueErr && !attrs.heightValueErr) {
            if (attrs.selArea && attrs.name) {
              $(exportButton).removeClass('gmx-disabled');
            }

            $(warn).html('');
          }
        },
        handleExportError: function handleExportError() {
          var attrs = this.model.toJSON(),
              exportButton = this.$('.mapExportButton'),
              progressBarContainer = this.$('.export-progress-container'),
              spinHolder = this.$('.spinHolder'),
              cancelButton = this.$('.cancelButton'),
              exportErrorMessage = this.$('.exportErrorMessage');

          if (attrs.selArea) {
            $(exportButton).removeClass('gmx-disabled');
          } else {
            $(exportButton).addClass('gmx-disabled');
          }

          if (attrs.exportErr) {
            $(spinHolder).toggle();
            $(progressBarContainer).toggle();
            $(exportButton).toggle();
            $(cancelButton).toggle();
            $(exportErrorMessage).toggle();
          } else {
            $(exportErrorMessage).toggle();
          }
        },
        handleFormat: function handleFormat() {
          var attrs = this.model.toJSON(),
              format = attrs.format,
              fileType = attrs.fileType;
          var fileSelect = this.$('.fileTypes');

          if (format === 'geoTiff' || format === 'geoTiffJpeg') {
            fileType = window._gtxt('mapExport.filetypes.raster');
            fileSelect.prop('disabled', true);
          } else {
            fileSelect.prop('disabled', false);
          }

          this.$('.formatTypes').val(format);
          fileSelect.val(fileType);
          this.model.set({
            fileType: fileType
          });
        },
        updateName: function updateName() {
          var attrs = this.model.toJSON(),
              exportNameInput = this.$('.mapExportName'),
              exportButton = this.$('.mapExportButton');

          if (attrs.name === '') {
            $(exportNameInput).addClass('error');
            $(exportButton).addClass('gmx-disabled');
          } else {
            if (attrs.selArea && !attrs.widthValueErr && !attrs.widthSizeErr && !attrs.heightValueErr && !attrs.heightSizeErr) {
              $(exportButton).removeClass('gmx-disabled');
            }

            $(exportNameInput).removeClass('error');
          }
        },
        updateZoom: function updateZoom() {
          var attrs = this.model.toJSON(),
              levels = this.$('.zoomLevel'),
              list = $(levels).find('option'),
              zoomToLevelButton = this.$('.zoomToLevelButton')[0];

          for (var i = 0; i < list.length; i++) {
            var el = list[i];

            if (el.tagName === 'OPTION') {
              if (Number($(el).val()) === attrs.z) {
                $(el).prop('selected', true);
              } else {
                $(el).prop('selected', false);
              }
            }
          }

          if (zoomToLevelButton) {
            nsGmx$1.Utils._title(zoomToLevelButton, window._gtxt('mapExport.zoomToLevel') + ' ' + attrs.z);
          }
        },
        setZoom: function setZoom(e) {
          var attrs = this.model.toJSON(),
              selectedZoom = Number(e.target.value),
              zoomLevels = attrs.zoomLevels;

          for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
            zoomLevels[i].current = false;

            if (i === selectedZoom) {
              zoomLevels[i].current = true;
            }
          }

          this.model.set({
            zoomLevels: zoomLevels,
            z: selectedZoom
          });

          this._updateCoords();
        },
        setFormat: function setFormat(e) {
          var attrs = this.model.toJSON(),
              formatTypes = attrs.formatTypes,
              selectedFormat = e.target.value;

          for (var i = 0; i < formatTypes.length; i++) {
            formatTypes[i].current = false;

            if (formatTypes[i].type === selectedFormat) {
              formatTypes[i].current = true;
            }
          }

          this.model.set({
            formatTypes: formatTypes,
            format: selectedFormat
          });
        },
        setFileType: function setFileType(e) {
          var attrs = this.model.toJSON(),
              fileTypes = attrs.fileTypes,
              selectedFileType = e.target.value;

          for (var i = 0; i < fileTypes.length; i++) {
            fileTypes[i].current = false;

            if (fileTypes[i].type === selectedFileType) {
              fileTypes[i].current = true;
            }
          }

          this.model.set({
            fileTypes: fileTypes,
            fileType: selectedFileType
          });
        },
        setName: function setName(e) {
          this.model.set('name', e.target.value);
        },
        selectArea: function selectArea() {
          var attrs = this.model.toJSON();

          if (!attrs.lmap || attrs.selArea) {
            return;
          }

          var currentZoom = attrs.lmap.getZoom(),
              zoomLevels = attrs.zoomLevels,
              mapBounds = attrs.lmap.getBounds(),
              latLngs = [mapBounds.getSouthWest(), mapBounds.getNorthWest(), mapBounds.getNorthEast(), mapBounds.getSouthEast()],
              // n = mapBounds.getNorth(),
          // e = mapBounds.getEast(),
          // s = mapBounds.getSouth(),
          // w = mapBounds.getWest(),
          // mapHeight = n - s,
          // mapWidth = e - w,
          // какую часть экрана отсекать с краев первоначальной рамки
          scale = 4,
              converted = this._convertFromLatLngs(latLngs, attrs.z),
              dims = this._getDimensions(converted),
              xx = [converted[0].x, converted[1].x, converted[2].x, converted[3].x],
              yy = [converted[0].y, converted[1].y, converted[2].y, converted[3].y],
              bottomLeft = L.point(this._getMin(xx) + dims.width / scale, this._getMax(yy) - dims.height / scale),
              topLeft = L.point(this._getMin(xx) + dims.width / scale, this._getMin(yy) + dims.height / scale),
              topRight = L.point(this._getMax(xx) - dims.width / scale, this._getMin(yy) + dims.height / scale),
              bottomRight = L.point(this._getMax(xx) - dims.width / scale, this._getMax(yy) - dims.height / scale),
              initialBounds = this._convertToLantLngs([bottomLeft, topLeft, topRight, bottomRight], attrs.z);

          for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
            zoomLevels[i].current = false;

            if (i === currentZoom) {
              zoomLevels[i].current = true;
            }
          } // прямоугольная рамка


          var rect = L.rectangle(initialBounds);
          this.model.set({
            z: currentZoom,
            zoomLevels: zoomLevels
          });

          this._createFrame(rect);

          this._updateCoords();
        },
        unselectArea: function unselectArea() {
          var attrs = this.model.toJSON();

          this._removeFrame();

          this.model.set({
            width: 0,
            height: 0,
            z: attrs.lmap.getZoom(),
            widthValueErr: false,
            widthSizeErr: false,
            heightValueErr: false,
            heightSizeErr: false,
            exportErr: false
          });
        },
        zoomToBox: function zoomToBox() {
          var attrs = this.model.toJSON();
          attrs.lmap.fitBounds(attrs.selArea.getBounds());
        },
        zoomToLevel: function zoomToLevel() {
          var attrs = this.model.toJSON(),
              initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr(),
              converted = this._convertFromLatLngs(initialCoords, attrs.z),
              dims = this._getDimensions(converted);

          attrs.lmap.setView(dims.latLng, attrs.z);
        },
        exportMap: function exportMap() {
          var _this = this,
              attrs = this.model.toJSON(),
              initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr(),
              screenCoords = !attrs.coords ? this._convertFromLatLngs(initialCoords, attrs.z) : this._convertFromLatLngs(attrs.coords, attrs.z),
              dimensions = this._getDimensions(screenCoords),
              mapStateParams = {
            exportMode: true,
            isFullScreen: true,
            width: Math.floor(Number(attrs.width)) + 'px',
            height: Math.floor(Number(attrs.height)) + 'px',
            position: {
              x: dimensions.mercCenter.x,
              y: dimensions.mercCenter.y,
              z: attrs.z ? 17 - attrs.z : 17 - attrs.lmap.getZoom()
            },
            latLng: dimensions.latLng,
            exportBounds: attrs.selArea.getBounds(),
            grid: nsGmx$1.gridManager.state
          },
              exportParams = {
            width: Math.floor(Number(attrs.width)),
            height: Math.floor(Number(attrs.height)),
            filename: attrs.name,
            container: attrs.fileType === window._gtxt('mapExport.filetypes.raster') ? 'grimage' : attrs.fileType,
            format: attrs.format
          },
              exportButton = this.$('.mapExportButton'),
              cancelButton = this.$('.cancelButton'),
              progressBarContainer = this.$('.export-progress-container'),
              progressBar = this.$('.export-progressbar'),
              spinHolder = this.$('.spinHolder'),
              spinMessage = this.$('.spinMessage'),
              def;

          $(exportButton).toggle();
          $(cancelButton).toggle();

          if (attrs.format === 'png' && nsGmx$1.leafletMap.gmxBaseLayersManager.getCurrentID() === 'empty') {
            exportParams.transparentColor = 'DDDDDD';
          }

          window._mapHelper.createExportPermalink(mapStateParams, processLink);

          function processLink(id) {
            var url = window.serverBase + 'Map/Render?' + $.param(exportParams) + '&uri=' + window.location.protocol + '//' + window.location.host + window.location.pathname + '?permalink=' + id;

            _this.model.set({
              exportErr: false
            });

            $(exportButton).addClass('gmx-disabled');
            $(progressBarContainer).toggle();
            $(spinHolder).toggle();
            $(progressBar).progressbar({
              max: 100,
              value: 0
            });
            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(url);
            def.done(function (taskInfo) {
              var url2 = window.serverBase + taskInfo.Result.downloadFile,
                  selArea = _this.model.get('selArea');

              if (selArea) {
                $(exportButton).removeClass('gmx-disabled');
              } else {
                $(exportButton).addClass('gmx-disabled');
              }

              $(exportButton).toggle();
              $(cancelButton).toggle();
              $(spinHolder).toggle();
              $(progressBarContainer).toggle();
              downloadFile(url2);
            }).fail(function (taskInfo) {
              if (taskInfo.ErrorInfo.ErrorMessage !== 'Task is canceled') {
                $(exportButton).removeClass('gmx-disabled');

                _this.model.set({
                  exportErr: true
                });
              }
            }).progress(function (taskInfo) {
              _this.model.set({
                taskInfo: taskInfo
              });

              if (taskInfo.Status === 'queue') {
                $(spinMessage).html(window._gtxt('mapExport.inQueue'));
              } else if (taskInfo.Status === 'progress') {
                $(spinMessage).html(window._gtxt('mapExport.inProcess'));
                $(progressBar).progressbar('value', taskInfo.Progress);
              }
            });

            function downloadFile(url) {
              var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1,
                  isSafari = navigator.userAgent.toLowerCase().indexOf('safari') > -1;

              if (isChrome || isSafari) {
                var link = document.createElement('a');
                link.href = url;
                link.download = attrs.name;

                if (document.createEvent) {
                  var e = document.createEvent('MouseEvents');
                  e.initEvent('click', true, true);
                  link.dispatchEvent(e);
                  return true;
                }
              } else {
                window.open(url, '_self');
              }
            }
          }
        },
        cancelExport: function cancelExport() {
          var attrs = this.model.toJSON(),
              taskInfo = this.model.get('taskInfo'),
              exportButton = this.$('.mapExportButton'),
              cancelButton = this.$('.cancelButton'),
              progressBarContainer = this.$('.export-progress-container'),
              spinHolder = this.$('.spinHolder'),
              spinMessage = this.$('.spinMessage'),
              url;
          url = window.serverBase + 'AsyncTaskCancel?' + $.param({
            TaskID: taskInfo.TaskID
          });
          sendCrossDomainJSONRequest(url, function (response) {
            if (!parseResponse(response)) return;

            if (response.Result) {
              if (attrs.selArea) {
                $(exportButton).removeClass('gmx-disabled');
              }

              $(exportButton).toggle();
              $(cancelButton).toggle();
              $(spinMessage).empty();
              $(spinHolder).toggle();
              $(progressBarContainer).toggle();
            }
          });
        },
        resize: function resize(e) {
          var attrs = this.model.toJSON(),
              start = e.target.selectionStart,
              end = e.target.selectionEnd,
              initialCoords,
              scale,
              screenCoords,
              width,
              height,
              bottomLeft,
              bottomRight,
              topLeft,
              topRight,
              newBounds,
              value,
              valueErr,
              sizeErr;

          if (!attrs.lmap || !attrs.selArea) {
            return;
          }

          initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr(); // разница между целевым и текущим зумом

          scale = Math.pow(2, attrs.z - attrs.lmap.getZoom());
          screenCoords = !attrs.coords ? this._revertCoords(this._convertFromLatLngs(initialCoords, attrs.z)) : this._revertCoords(this._convertFromLatLngs(attrs.coords, attrs.z));
          value = Number(e.target.value);
          valueErr = value <= 0 || isNaN(value);
          sizeErr = value - MAX_SIZE > EPS; // обработка инпута ширины

          if (e.target.className === 'mapExportWidth' || e.target.className === 'mapExportWidth error') {
            if (valueErr) {
              this.model.set('widthValueErr', true);
            } else {
              this.model.set('widthValueErr', false);
              this.model.set('width', e.target.value);

              if (sizeErr) {
                this.model.set('widthSizeErr', true);
              } else {
                this.model.set('widthSizeErr', false);
              }
            }
          } // обработка инпута высоты


          if (e.target.className === 'mapExportHeight' || e.target.className === 'mapExportHeight error') {
            if (valueErr) {
              this.model.set('heightValueErr', true);
            } else {
              this.model.set('heightValueErr', false);
              this.model.set('height', e.target.value);

              if (sizeErr) {
                this.model.set('heightSizeErr', true);
              } else {
                this.model.set('heightSizeErr', false);
              }
            }
          }

          attrs = this.model.toJSON();
          if (attrs.widthValueErr || attrs.heightValueErr) return;
          width = e.target.className === 'mapExportWidth' || e.target.className === 'mapExportWidth error' ? Number(e.target.value) : Number(attrs.width);
          height = e.target.className === 'mapExportHeight' || e.target.className === 'mapExportHeight error' ? Number(e.target.value) : Number(attrs.height);
          newBounds = []; // изменяем координаты объекта, учитывая изменившуюся ширину или высоту
          // геометрия изменяется в соответствии с введенными значениями
          // topLeft остается неизменным

          bottomLeft = screenCoords[0];
          topLeft = screenCoords[1];
          topRight = screenCoords[2];
          bottomRight = screenCoords[3];
          topRight.x = topLeft.x + width;
          topRight.y = topLeft.y;
          bottomLeft.x = topLeft.x;
          bottomLeft.y = topLeft.y + height;
          bottomRight.x = topLeft.x + width;
          bottomRight.y = topLeft.y + height; // topLeft.x = topLeft.x;
          // topLeft.y = topLeft.y;

          newBounds.push([attrs.lmap.unproject([bottomLeft.x / scale, bottomLeft.y / scale])], [attrs.lmap.unproject([topRight.x / scale, topRight.y / scale])]); // измененная прямоугольная рамка

          var newRect = L.rectangle(newBounds);
          this.model.set('coords', L.version === "0.7.7" ? newRect.getLatLngs() : newRect.getLatLngs()[0]);
          attrs.lmap.gmxDrawing.remove(attrs.selArea);

          this._createFrame(newRect);

          this._updateCoords(); // восстановим позицию курсора


          e.target.setSelectionRange(start, end);
        },
        _createFrame: function _createFrame(rectangle) {
          var attrs = this.model.toJSON(),
              options = {
            editable: true,
            map: true,
            lineStyle: {
              dashArray: '5 5',
              color: '#f57c00',
              weight: 3.5
            },
            pointStyle: {
              size: L.Browser.mobile ? 40 : 8,
              color: '#f57c00'
            }
          };
          this.model.set({
            selArea: attrs.lmap.gmxDrawing.add(rectangle, L.extend(options, {
              exportRect: true
            }))
          }); // навешивает обработчики на рамку выделения

          var frame = this.model.get('selArea'),
              _this = this;

          frame.on('edit', _this._resizeFrame.bind(_this));
          frame.on('remove', function () {
            // var attrs = _this.model.toJSON();
            _this.model.set({
              width: 0,
              height: 0,
              widthValueErr: false,
              widthSizeErr: false,
              heightValueErr: false,
              heightSizeErr: false,
              exportErr: false
            });
          });
        },
        _resizeFrame: function _resizeFrame() {
          var attrs = this.model.toJSON(),
              initialCoords,
              screenCoords,
              dimensions,
              w,
              h;
          initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr();
          screenCoords = this._convertFromLatLngs(initialCoords, attrs.z);
          dimensions = this._getDimensions(screenCoords);
          w = Math.abs(dimensions.width);
          h = Math.abs(dimensions.height);

          if (w - MAX_SIZE > EPS) {
            this.model.set('widthSizeErr', true);
          } else {
            this.model.set('widthSizeErr', false);
          }

          if (h - MAX_SIZE > EPS) {
            this.model.set('heightSizeErr', true);
          } else {
            this.model.set('heightSizeErr', false);
          }

          this.model.set({
            coords: initialCoords,
            width: String(w),
            height: String(h)
          });
        },
        _removeFrame: function _removeFrame() {
          var attrs = this.model.toJSON();

          if (!attrs.selArea) {
            return;
          }

          attrs.lmap.gmxDrawing.remove(attrs.selArea);
          this.model.set({
            selArea: null,
            coords: null
          });
        },
        _updateCoords: function _updateCoords() {
          var attrs = this.model.toJSON(),
              initialCoords,
              screenCoords,
              dimensions,
              w,
              h;

          if (!attrs.selArea) {
            return;
          }

          initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr();
          screenCoords = !attrs.coords ? this._convertFromLatLngs(initialCoords, attrs.z) : this._convertFromLatLngs(attrs.coords, attrs.z);
          dimensions = this._getDimensions(screenCoords);
          w = Math.abs(dimensions.width);
          h = Math.abs(dimensions.height);

          if (!attrs.coords) {
            this.model.set('coords', initialCoords);
          }

          if (w - MAX_SIZE > EPS) {
            this.model.set('widthSizeErr', true);
          } else {
            this.model.set('widthSizeErr', false);
          }

          if (h - MAX_SIZE > EPS) {
            this.model.set('heightSizeErr', true);
          } else {
            this.model.set('heightSizeErr', false);
          }

          this.model.set({
            width: String(w),
            height: String(h)
          });
        },
        _revertCoords: function _revertCoords(coords) {
          var xx, yy, bottomLeft, topLeft, topRight, bottomRight;
          xx = [coords[0].x, coords[1].x, coords[2].x, coords[3].x];
          yy = [coords[0].y, coords[1].y, coords[2].y, coords[3].y];
          bottomLeft = L.point(this._getMin(xx), this._getMax(yy));
          topLeft = L.point(this._getMin(xx), this._getMin(yy));
          topRight = L.point(this._getMax(xx), this._getMin(yy));
          bottomRight = L.point(this._getMax(xx), this._getMax(yy));
          return [bottomLeft, topLeft, topRight, bottomRight];
        },
        _convertFromLatLngs: function _convertFromLatLngs(latlngs, zoom) {
          var attrs = this.model.toJSON(),
              converted = latlngs.map(function (ll) {
            return attrs.lmap.project([ll.lat, ll.lng], zoom);
          });
          return converted;
        },
        _convertToLantLngs: function _convertToLantLngs(points, zoom) {
          var attrs = this.model.toJSON(),
              converted = points.map(function (point) {
            return attrs.lmap.unproject([point.x, point.y], zoom);
          });
          return converted;
        },
        _getDimensions: function _getDimensions(points) {
          var attrs = this.model.toJSON(),
              bottomLeft,
              topRight,
              width,
              height,
              x,
              y;
          points = this._revertCoords(points);
          bottomLeft = points[0];
          topRight = points[2];
          width = Math.abs(topRight.x - bottomLeft.x);
          height = Math.abs(bottomLeft.y - topRight.y);
          x = bottomLeft.x + width / 2;
          y = topRight.y + height / 2;
          return {
            bottomLeft: bottomLeft,
            topRight: topRight,
            width: width,
            height: height,
            mercCenter: L.Projection.Mercator.project(attrs.lmap.unproject([x, y], attrs.z)),
            latLng: attrs.lmap.unproject([x, y], attrs.z)
          };
        },
        _getMax: function _getMax(arr) {
          return Math.max.apply(null, arr);
        },
        _getMin: function _getMin(arr) {
          return Math.min.apply(null, arr);
        }
      });
      view = new ExportView();

      function getZoomLevels() {
        var zoomLevels = [],
            lmap = nsGmx$1.leafletMap,
            min = lmap.getMinZoom() || 0,
            max = lmap.getMaxZoom() !== Infinity ? lmap.getMaxZoom() : 21,
            currentZoom = lmap.getZoom();

        for (var i = min; i <= max; i++) {
          zoomLevels[i] = {
            zoom: i,
            current: false
          };

          if (i === currentZoom) {
            zoomLevels[i].current = true;
          }
        }

        return zoomLevels;
      }

      function getTypes(types) {
        var arr = [];

        for (var i = 0; i < types.length; i++) {
          arr[i] = {
            type: types[i],
            current: false
          };

          if (i === 0) {
            arr[i].current = true;
          }
        }

        return arr;
      }

      this.Load = function () {
        var lm = model.get('lm');

        if (lm != null) {
          var alreadyLoaded = lm.createWorkCanvas('export', this.Unload);

          if (!alreadyLoaded) {
            $(lm.workCanvas).append(view.el);
          }
        }
      };

      this.Unload = function () {
        var attrs = model.toJSON();
        attrs.lmap.gmxDrawing.remove(attrs.selArea);
        model.set({
          selArea: null,
          width: 0,
          height: 0,
          widthValueErr: false,
          heightValueErr: false,
          widthSizeErr: false,
          heightSizeErr: false,
          format: null,
          x: null,
          z: attrs.lmap.getZoom(),
          y: null,
          latLng: null,
          coords: null,
          zoomLevels: getZoomLevels(),
          formatTypes: getTypes(formatTypes),
          fileTypes: null,
          exportErr: false
        });
      };
    };

    var publicInterface$2 = {
      pluginName: 'MapExport',
      MapExportMenu: MapExportMenu
    };
    gmxCore.addModule('MapExport', publicInterface$2);

    (function () {
      window._translationsHash.addtext('rus', {
        bufferZones: {
          title: 'Создание буферных зон',
          selectTooltip: 'Выберите кликом векторный слой',
          select: 'Кликните на векторный слой в панели слоев',
          selectedLayer: 'Выбранный слой',
          layerTypeError: 'Слой не является векторным',
          bufferSize: 'Размер буфера',
          createBuffer: 'Создать',
          units: 'м'
        }
      });

      window._translationsHash.addtext('eng', {
        bufferZones: {
          title: 'Buffer zones creation',
          selectTooltip: 'Select vector layer by click',
          select: 'Select vector layer',
          selectedLayer: 'Selected layer',
          layerTypeError: 'Selected layer is not vector type',
          bufferSize: 'Buffer size',
          createBuffer: 'Create',
          units: 'm'
        }
      });

      var view;

      var BufferZonesMenu = function BufferZonesMenu() {
        var canvas = nsGmx$1.Utils._div(null, [['dir', 'className', 'bufferZonesConfigLeftMenu']]);

        var BufferModel = window.Backbone.Model.extend({
          defaults: {
            lm: new leftMenu(),
            lmap: nsGmx$1.leafletMap,
            selectedLayer: null,
            selectedLayerName: '',
            bufferSize: 50,
            error: true
          }
        });
        var model = new BufferModel();
        var BufferView = window.Backbone.View.extend({
          el: $(canvas),
          model: model,
          template: window.Handlebars.compile('<div class="">' + '<div class="buffer-row buffer-select-title">{{i "bufferZones.select"}}:</div>' + '<div class="buffer-row buffer-layer-name {{#if error}}buffer-layer-name-error{{/if}}">' + '{{selectedLayerName}}' + '</div>' + '<div class="buffer-row">{{i "bufferZones.bufferSize"}}: ' + '<input type="number" class="buffer-size" value={{bufferSize}}></input>' + ' {{i "bufferZones.units"}}' + '</div>' + '<div class="buffer-row buffer-button-container"><span class="buttonLink create-buffer-button {{#if error}}gmx-disabled{{/if}}">{{i "bufferZones.createBuffer"}}</span></div>' + '</div>'),
          events: {
            'click .create-buffer-button': 'createBuffer',
            'change .buffer-size': 'setBufferSize'
          },
          initialize: function initialize() {
            var // attrs = this.model.toJSON(),
            _this = this;

            $(_layersTree).on('activeNodeChange', function (event, elem) {
              if (elem) {
                if (elem.hasAttribute('groupid')) {
                  _this.model.set({
                    selectedLayerName: '',
                    selectedLayer: null,
                    error: true
                  });

                  return;
                }

                var layerID = $(elem).attr('layerid'),
                    layer = nsGmx$1.gmxMap.layersByID[layerID];

                if (layer && layer.getGmxProperties) {
                  var type = layer.getGmxProperties().type;

                  if (type === 'Vector') {
                    _this.model.set({
                      selectedLayerName: layer.getGmxProperties ? layer.getGmxProperties().title : '',
                      selectedLayer: layerID,
                      error: false
                    });
                  } else {
                    _this.model.set({
                      selectedLayerName: window._gtxt('bufferZones.layerTypeError'),
                      selectedLayer: null,
                      error: true
                    });
                  }
                } else {
                  _this.model.set({
                    selectedLayerName: window._gtxt('bufferZones.layerTypeError'),
                    selectedLayer: null,
                    error: true
                  });
                }
              } else {
                _this.model.set({
                  selectedLayerName: '',
                  selectedLayer: null,
                  error: true
                });
              }
            });
            this.listenTo(this.model, 'selectedLayerName: change', this.render);
            this.listenTo(this.model, 'bufferSize: change', this.render);
            this.render();
          },
          render: function render() {
            this.$el.html(this.template(this.model.toJSON())); // console.log('----- bs: ', this.model.get('bufferSize'));

            return this;
          },
          setBufferSize: function setBufferSize(e) {
            var value = Number(e.target.value);

            if (isNaN(value)) {
              this.model.set('error', true);
              return;
            } else {
              this.model.set({
                error: false,
                bufferSize: value
              });
            }
          },
          createBuffer: function createBuffer() {
            var attrs = this.model.toJSON(),
                _this = this,
                selectedLayer = attrs.selectedLayer;

            if (!selectedLayer) {
              return;
            }

            sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?NeedAttrValues=false&LayerName=" + encodeURIComponent(selectedLayer), function (response) {
              if (!parseResponse(response)) {
                return;
              }

              var layerProperties = new nsGmx$1.LayerProperties(),
                  params = {
                sourceLayerName: selectedLayer,
                copy: true,
                addToMap: true,
                buffer: true,
                bufferSize: _this.model.toJSON().bufferSize
              },
                  properties = {
                Columns: response.Result.Columns,
                Title: response.Result.Title + '_' + window._gtxt('Буфер').toLowerCase(),
                Copyright: response.Result.Copyright,
                Description: response.Result.Description,
                Date: response.Result.Date,
                MetaProperties: response.Result.MetaProperties,
                TilePath: {
                  Path: ''
                },
                ShapePath: response.Result.ShapePath,
                IsRasterCatalog: response.Result.IsRasterCatalog,
                SourceType: "sql",
                Quicklook: response.Result.Quicklook
              },
                  layerTitle;
              layerProperties.initFromViewer('Vector', null, properties);
              var def = layerProperties.save(true, null, params);
              layerTitle = layerProperties.get('Title');

              if (params.addToMap) {
                window._queryMapLayers.asyncCreateLayer(def, layerTitle);
              }
            });
          }
        });
        view = new BufferView(); // DEBUG:

        window.v = view;

        this.Load = function () {
          var lm = model.get('lm');

          if (lm != null) {
            var alreadyLoaded = lm.createWorkCanvas('buffer', this.Unload);

            if (!alreadyLoaded) {
              $(lm.workCanvas).append(view.el);
            }
          }
        };

        this.Unload = function () {
          // var attrs = model.toJSON();
          model.set({});
        };
      };

      var publicInterface = {
        pluginName: 'BufferZones',
        BufferZonesMenu: BufferZonesMenu
      };
      window.gmxCore.addModule('BufferZones', publicInterface);
    })();

    var MAX_INDEX_COUNT = 10000;
    var KM_PER_DEGREE = 111.31949;
    nsGmx$1.DrawingObjectCustomControllers.addDelegate({
      isHidden: function isHidden(obj) {
        if (obj.options.exportRect) {
          return true;
        }

        return false;
      }
    });

    window._translationsHash.addtext('rus', {
      indexGrid: {
        settings: 'Настройки индексной сетки',
        select: 'Выделить область карты',
        unselect: 'Снять выделение',
        coordinates: 'координаты',
        lat: 'широта',
        lng: 'долгота',
        min: 'мин',
        max: 'макс',
        step: 'шаг (км)',
        onLat: 'по широте',
        onLng: 'по долготе',
        count: 'количество идексов',
        name: 'имя слоя',
        create: 'Создать слой индексной сетки',
        valueWarn: 'недопустимое значение',
        indexCountWarn: 'превышено допустимое число ячеек (10 000)',
        nameWarn: 'имя слоя не должно быть пустым'
      }
    });

    window._translationsHash.addtext('eng', {
      indexGrid: {
        settings: 'Index grid settings',
        select: 'Select',
        unselect: 'Clear selection',
        coordinates: 'coordinates',
        lat: 'latitude',
        lng: 'longitude',
        max: 'max',
        min: 'min',
        step: 'Step (km)',
        onLat: 'on latitude',
        onLng: 'on longitude',
        count: 'index count',
        name: 'layer name',
        create: 'Create index grid layer',
        valueWarn: 'incorrect value',
        indexCountWarn: 'max ceils number exceeded (10 000)',
        nameWarn: 'layer name cannot be empty'
      }
    });

    var view$1;

    var IndexGridMenu = function IndexGridMenu() {
      var canvas = nsGmx$1.Utils._div(null, [['dir', 'className', 'indexGridConfigLeftMenu']]);

      var IndexGridModel = window.Backbone.Model.extend({
        defaults: {
          lm: new leftMenu(),
          lmap: nsGmx$1.leafletMap,
          selArea: null,
          xStep: 1,
          yStep: 1,
          xCount: null,
          yCount: null,
          xStepErr: false,
          yStepErr: false,
          indexCount: null,
          indexCountErr: false,
          maxLat: null,
          maxLng: null,
          minLat: null,
          minLng: null,
          maxLatErr: false,
          maxLngErr: false,
          minLatErr: false,
          minLngErr: false,
          z: null,
          coords: null,
          name: '',
          nameErr: true
        }
      });
      var model = new IndexGridModel();
      var IndexGridView = window.Backbone.View.extend({
        el: $(canvas),
        model: model,
        template: window.Handlebars.compile('<div class="selectButtons">' + '<span class="buttonLink areaButton indexGridSelectButton"> {{i "indexGrid.select"}}</span>' + '</span>' + '</div>' + '<div class="indexgridsettings">' + '<span>' + '{{i "indexGrid.settings"}}' + '</span>' + '</div>' + '<table class="settings">' + '<tbody>' + // Широта / Долгота
        '<tr class="dims">' + '<td class="eLabel">{{i "indexGrid.coordinates"}}</td>' + '<td class="eLabel colname">{{i "indexGrid.lat"}}</td>' + '<td class="eLabel colname">{{i "indexGrid.lng"}}</td>' + '</tr>' + // Макс
        '<tr class="dims">' + '<td class="eLabel">{{i "indexGrid.max"}}</td>' + '<td class="eInput">' + '<input type="text" class="maxLat" value="{{maxLat}}"/>' + '</td>' + '<td class="eInput">' + '<input type="text" class="maxLng" value="{{maxLng}}"/>' + '</td>' + '</tr>' + // Мин
        '<tr class="dims">' + '<td class="eLabel">{{i "indexGrid.min"}}</td>' + '<td class="eInput">' + '<input type="text" class="minLat" value="{{minLat}}"/>' + '</td>' + '<td class="eInput">' + '<input type="text" class="minLng" value="{{minLng}}"/>' + '</td>' + '</tr>' + // Шаг
        '<tr class="dims">' + '<td class="eLabel" rowspan=2>{{i "indexGrid.step"}}</td>' + '<td class="eLabel">{{i "indexGrid.onLat"}}</td>' + '<td class="eInput">' + '<input type="text" class="yStep" value="{{yStep}}"/>' + '</td>' + '</tr>' + '<tr class="dims">' + '<td class="eLabel">{{i "indexGrid.onLng"}}</td>' + '<td class="eInput">' + '<input type="text" class="xStep" value="{{xStep}}"/>' + '</td>' + '</tr>' + // Количество индексов
        '<tr class="dims">' + '<td class="eLabel">{{i "indexGrid.count"}}</td>' + '<td class="eLabel"></td>' + '<td class="eLabel indexCount">{{indexCount}}</td>' + '</tr>' + // Имя
        '<tr class="nameSelect">' + '<td class="eLabel">{{i "indexGrid.name"}}</td>' + '<td class="eInput" colspan=2>' + '<input type="text" class="name" value=""/>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '<div class="createWrap">' + '<div class="create">' + '<span class="buttonLink createIndexGridButton"> {{i "indexGrid.create"}}</span>' + '<span class="spinHolder" style="display:none">' + '<img src="img/progress.gif"/>' + '<span class="spinMessage"></span>' + '</span>' + '<br/>' + '<span class="warnMessage errorMessage" style="display:none"></span>' + '</div>' + '</div>'),
        events: {
          'click .indexGridSelectButton': 'selectArea',
          'click .indexGridUnelectButton': 'unselectArea',
          'input .minLat': 'resize',
          'input .maxLat': 'resize',
          'input .minLng': 'resize',
          'input .maxLng': 'resize',
          'input .xStep': 'setStep',
          'input .yStep': 'setStep',
          'input .name': 'setName',
          'click .createIndexGridButton': 'createIndexGrid'
        },
        initialize: function initialize() {
          var attrs = this.model.toJSON(),
              currentZoom = attrs.lmap.getZoom();
          this.listenTo(this.model, 'change:selArea', this.updateArea);
          this.listenTo(this.model, 'change:selArea', this.updateStepInput.bind(this, 'xStep'));
          this.listenTo(this.model, 'change:selArea', this.updateStepInput.bind(this, 'yStep'));
          this.listenTo(this.model, 'change:minLat', this.updateLatLngInput.bind(this, 'minLat'));
          this.listenTo(this.model, 'change:maxLat', this.updateLatLngInput.bind(this, 'maxLat'));
          this.listenTo(this.model, 'change:maxLng', this.updateLatLngInput.bind(this, 'maxLng'));
          this.listenTo(this.model, 'change:minLng', this.updateLatLngInput.bind(this, 'minLng'));
          this.listenTo(this.model, 'change:minLatErr', this.handleInputErr.bind(this, 'minLat'));
          this.listenTo(this.model, 'change:maxLatErr', this.handleInputErr.bind(this, 'maxLat'));
          this.listenTo(this.model, 'change:maxLngErr', this.handleInputErr.bind(this, 'maxLng'));
          this.listenTo(this.model, 'change:minLngErr', this.handleInputErr.bind(this, 'minLng'));
          this.listenTo(this.model, 'change:xStep', this.updateStepInput.bind(this, 'xStep'));
          this.listenTo(this.model, 'change:yStep', this.updateStepInput.bind(this, 'yStep'));
          this.listenTo(this.model, 'change:xStepErr', this.handleInputErr.bind(this, 'xStep'));
          this.listenTo(this.model, 'change:yStepErr', this.handleInputErr.bind(this, 'yStep'));
          this.listenTo(this.model, 'change:indexCount', this.updateIndexCount);
          this.listenTo(this.model, 'change:indexCountErr', this.handleIndexCountErr);
          this.listenTo(this.model, 'change:name', this.updateName);
          this.listenTo(this.model, 'change:nameErr', this.handleInputErr.bind(this, 'name'));
          this.model.set({
            z: currentZoom,
            name: nsGmx$1.gmxMap.properties.title,
            nameErr: false
          });
          this.updateArea();
          this.render();
        },
        render: function render() {
          this.$el.html(this.template(this.model.toJSON()));
          this.$('.minLat').prop('disabled', true);
          this.$('.maxLat').prop('disabled', true);
          this.$('.maxLng').prop('disabled', true);
          this.$('.minLng').prop('disabled', true);
          this.$('.xStep').prop('disabled', true);
          this.$('.yStep').prop('disabled', true);
          this.$('.name').val(this.model.get('name'));
          this.$('.name').prop('disabled', true);
          this.$('.createIndexGridButton').addClass('gmx-disabled');
          return this;
        },
        updateArea: function updateArea() {
          var attrs = this.model.toJSON(),
              minLatInput = this.$('.minLat'),
              maxLatInput = this.$('.maxLat'),
              maxLngInput = this.$('.maxLng'),
              minLngInput = this.$('.minLng'),
              xStepInput = this.$('.xStep'),
              yStepInput = this.$('.yStep'),
              areaButton = this.$('.areaButton'),
              nameInput = this.$('.name'),
              createIndexGridButton = this.$('.createIndexGridButton'),
              inputs = [minLatInput, maxLatInput, maxLngInput, minLngInput, xStepInput, yStepInput, nameInput, createIndexGridButton];

          for (var i = 0; i < inputs.length; i++) {
            if (!attrs.selArea) {
              $(inputs[i]).prop('disabled', true);
            } else {
              $(inputs[i]).prop('disabled', false);
            }
          }

          if (attrs.selArea) {
            $(areaButton).removeClass('indexGridSelectButton');
            $(areaButton).addClass('indexGridUnelectButton');
            $(areaButton).text(window._gtxt('indexGrid.unselect'));

            if (!attrs.minLatErr && !attrs.maxLatErr && !attrs.maxLngErr && !attrs.minLngErr && !attrs.xStepErr && !attrs.yStepErr && !attrs.indexCountErr && attrs.name !== '') {
              $(createIndexGridButton).removeClass('gmx-disabled');
            }
          } else {
            $(areaButton).removeClass('indexGridUnelectButton');
            $(areaButton).addClass('indexGridSelectButton');
            $(areaButton).text(window._gtxt('indexGrid.select'));
            $(createIndexGridButton).addClass('gmx-disabled');
          }
        },
        updateLatLngInput: function updateLatLngInput(latLng) {
          var // attrs = this.model.toJSON(),
          input = this.$('.' + latLng),
              value = this.model.get(latLng);
          $(input).val(value !== null ? this._roundInputNumber(value) : '');
        },
        handleInputErr: function handleInputErr(inputName) {
          var input = this.$('.' + inputName);
          $(input).toggleClass('error', this.model.get(inputName + 'Err'));
          this.setCreateButtonStatus();
          this.setWarnMessage();
        },
        updateStepInput: function updateStepInput(inputName) {
          var // attrs = this.model.toJSON(),
          input = this.$('.' + inputName),
              value = this.model.get(inputName);
          $(input).val(value);
        },
        updateXStep: function updateXStep() {
          var attrs = this.model.toJSON(),
              xStepInput = this.$('.xStep');
          $(xStepInput).val(attrs.xStep);
        },
        updateYStep: function updateYStep() {
          var attrs = this.model.toJSON(),
              yStepInput = this.$('.yStep');
          $(yStepInput).val(attrs.yStep);
        },
        updateIndexCount: function updateIndexCount() {
          var attrs = this.model.toJSON(),
              indexCount = this.$('.indexCount');
          $(indexCount).html(attrs.indexCount ? attrs.indexCount : '');
        },
        handleIndexCountErr: function handleIndexCountErr() {
          var attrs = this.model.toJSON(),
              indexCount = this.$('.indexCount');
          $(indexCount).toggleClass('errorMessage', attrs.indexCountErr);
          this.setCreateButtonStatus();
          this.setWarnMessage();
        },
        updateName: function updateName() {
          var attrs = this.model.toJSON(),
              nameInput = this.$('.name');
          $(nameInput).val(attrs.name);
        },
        setCreateButtonStatus: function setCreateButtonStatus() {
          var attrs = this.model.toJSON(),
              createIndexGridButton = this.$('.createIndexGridButton'),
              err = attrs.minLatErr || attrs.maxLatErr || attrs.maxLngErr || attrs.minLngErr || attrs.xStepErr || attrs.yStepErr || attrs.indexCountErr;
          $(createIndexGridButton).toggleClass('gmx-disabled', err);
        },
        setWarnMessage: function setWarnMessage() {
          var attrs = this.model.toJSON(),
              warnMessage = this.$('.warnMessage'),
              err = attrs.minLatErr || attrs.maxLatErr || attrs.maxLngErr || attrs.minLngErr || attrs.xStepErr || attrs.yStepErr || attrs.indexCountErr || attrs.nameErr;
          $(warnMessage).toggle(err);

          if (attrs.minLatErr || attrs.maxLatErr || attrs.maxLngErr || attrs.minLngErr || attrs.xStepErr || attrs.yStepErr) {
            $(warnMessage).text(window._gtxt('indexGrid.valueWarn'));
          } else if (attrs.indexCountErr) {
            $(warnMessage).text(window._gtxt('indexGrid.indexCountWarn'));
          } else if (attrs.nameErr) {
            $(warnMessage).text(window._gtxt('indexGrid.nameWarn'));
          } else {
            $(warnMessage).text('');
          }
        },
        setName: function setName(e) {
          var value, valueErr;
          value = e.target.value;
          valueErr = value === '';

          if (valueErr) {
            this.model.set('nameErr', true);
          } else {
            this.model.set('nameErr', false);
            this.model.set('name', value);
          }
        },
        selectArea: function selectArea() {
          var attrs = this.model.toJSON();

          if (!attrs.lmap || attrs.selArea) {
            return;
          }

          var currentZoom = attrs.lmap.getZoom(),
              mapBounds = attrs.lmap.getBounds(),
              latLngs = [mapBounds.getSouthWest(), mapBounds.getNorthWest(), mapBounds.getNorthEast(), mapBounds.getSouthEast()],
              // n = mapBounds.getNorth(),
          // e = mapBounds.getEast(),
          // s = mapBounds.getSouth(),
          // w = mapBounds.getWest(),
          // mapHeight = n - s,
          // mapWidth = e - w,
          // какую часть экрана отсекать с краев первоначальной рамки
          scale = 4,
              converted = this._convertFromLatLngs(latLngs, attrs.z),
              dims = this._getDimensions(converted),
              xx = [converted[0].x, converted[1].x, converted[2].x, converted[3].x],
              yy = [converted[0].y, converted[1].y, converted[2].y, converted[3].y],
              bottomLeft = L.point(this._getMin(xx) + dims.width / scale, this._getMax(yy) - dims.height / scale),
              topLeft = L.point(this._getMin(xx) + dims.width / scale, this._getMin(yy) + dims.height / scale),
              topRight = L.point(this._getMax(xx) - dims.width / scale, this._getMin(yy) + dims.height / scale),
              bottomRight = L.point(this._getMax(xx) - dims.width / scale, this._getMax(yy) - dims.height / scale),
              initialBounds = this._convertToLantLngs([bottomLeft, topLeft, topRight, bottomRight], attrs.z); // прямоугольная рамка


          var rect = L.rectangle(initialBounds);
          this.model.set({
            z: currentZoom
          });

          this._createFrame(rect);

          this._updateCoords();

          this._updateCorners();

          this._countIndex();
        },
        unselectArea: function unselectArea() {
          var attrs = this.model.toJSON();

          this._removeFrame();

          this.model.set({
            width: 0,
            height: 0,
            z: attrs.lmap.getZoom(),
            xStep: 1,
            yStep: 1,
            xCount: null,
            yCount: null,
            xStepErr: false,
            yStepErr: false,
            indexCount: null,
            indexCountErr: false,
            minLat: null,
            minLng: null,
            maxLat: null,
            maxLng: null,
            minLatErr: false,
            maxLatErr: false,
            maxLngErr: false,
            minLngErr: false
          });
        },
        createIndexGrid: function createIndexGrid() {
          var attrs = this.model.toJSON(),
              name = attrs.name,
              columns = [{
            Name: "gmx_id",
            ColumnSimpleType: "Integer",
            IsIdentity: true,
            IsComputed: false,
            IsPrimary: true
          }, {
            Name: "index",
            ColumnSimpleType: "String",
            IsIdentity: false,
            IsComputed: false,
            IsPrimary: false
          }],
              layerParams = {
            Title: name,
            geometrytype: 'polygon',
            Columns: JSON.stringify(columns)
          },
              indexes = this.generatePolygons(),
              spinHolder = this.$('.spinHolder'),
              def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/CreateVectorLayer.ashx", layerParams),
              // promise,
          _this = this;

          def.done(function (response) {
            var layerName = response.Result.properties.name,
                mapProperties = _layersTree.treeModel.getMapProperties(),
                targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                gmxProperties = {
              type: 'layer',
              content: response.Result
            },
                def2 = _mapHelper.modifyObjectLayer(layerName, indexes, 'EPSG:4326');

            gmxProperties.content.properties.mapName = mapProperties.name;
            gmxProperties.content.properties.hostName = mapProperties.hostName;
            gmxProperties.content.properties.visible = true;
            gmxProperties.content.properties.styles = [{
              MinZoom: 1,
              MaxZoom: 21,
              RenderStyle: _mapHelper.defaultStyles[gmxProperties.content.properties.GeometryType]
            }];
            $(spinHolder).show();
            def2.always(function () {
              _layersTree.copyHandler(gmxProperties, targetDiv, false, true);

              $(spinHolder).hide();

              _this.unselectArea();
            });
          });
        },
        generatePolygons: function generatePolygons() {
          var attrs = this.model.toJSON(),
              xStep = this._convertXStep(attrs.xStep),
              yStep = this._convertYStep(attrs.yStep),
              xCount = attrs.xCount,
              yCount = attrs.yCount,
              // proj = L.Projection.Mercator,
          north = attrs.maxLat,
              // south = attrs.minLat,
          west = attrs.minLng,
              // east = attrs.maxLng,
          indexes = [],
              index,
              letterIndexes = this._getLetterIndexes(xCount),
              letter,
              n,
              s,
              e,
              w;

          for (var i = 0; i < yCount; i++) {
            n = north - yStep * i;
            s = north - yStep * (i + 1);

            for (var j = 0; j < xCount; j++) {
              letter = letterIndexes[j];
              w = west + xStep * j;
              e = west + xStep * (j + 1);
              index = {
                geometry: L.polygon([L.latLng(s, w), L.latLng(n, w), L.latLng(n, e), L.latLng(s, e)]).toGeoJSON(),
                properties: {
                  index: letter + (i + 1)
                }
              };
              indexes.push(index);
            }
          }

          return indexes;
        },
        setStep: function setStep(e) {
          var value, valueErr;
          value = Number(e.target.value);
          valueErr = value <= 0 || isNaN(value); // обработка xStep

          if (e.target.className === 'xStep' || e.target.className === 'xStep error') {
            if (valueErr) {
              this.model.set('xStepErr', true);
            } else {
              this.model.set('xStepErr', false);
              this.model.set('xStep', value);
            }
          } // обработка yStep


          if (e.target.className === 'yStep' || e.target.className === 'yStep error') {
            if (valueErr) {
              this.model.set('yStepErr', true);
            } else {
              this.model.set('yStepErr', false);
              this.model.set('yStep', value);
            }
          }

          this._countIndex();
        },
        resize: function resize(e) {
          var attrs = this.model.toJSON(),
              initialCoords,
              coords,
              // bounds,
          // scale,
          // screenCoords,
          // newBounds,
          value,
              valueErr;

          if (!attrs.lmap || !attrs.selArea) {
            return;
          } // разница между целевым и текущим зумом
          // scale = Math.pow(2, (attrs.z - attrs.lmap.getZoom()));


          initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
          coords = attrs.coords ? attrs.coords : initialCoords;
          value = Number(e.target.value);
          valueErr = !value || isNaN(value); // обработка ввода значений с плавающей точкой

          if (e.target.value.indexOf(".") === e.target.value.length - 1) {
            valueErr = true;
          } // обработка minLat


          if (e.target.className === 'minLat' || e.target.className === 'minLat error') {
            if (valueErr) {
              this.model.set('minLatErr', true);
            } else {
              var north = this._getBounds(coords).getNorth();

              if (value < north) {
                this.model.set('minLatErr', false);
                this.model.set('minLat', value);
              } else {
                this.model.set('minLatErr', true);
              }
            }
          } // обработка minLng


          if (e.target.className === 'minLng' || e.target.className === 'minLng error') {
            if (valueErr) {
              this.model.set('minLngErr', true);
            } else {
              var east = this._getBounds(coords).getEast();

              if (value < east) {
                this.model.set('minLngErr', false);
                this.model.set('minLng', value);
              } else {
                this.model.set('minLngErr', true);
              }
            }
          } // обработка maxLat


          if (e.target.className === 'maxLat' || e.target.className === 'maxLat error') {
            if (valueErr) {
              this.model.set('maxLatErr', true);
            } else {
              var south = this._getBounds(coords).getSouth();

              if (value > south) {
                this.model.set('maxLatErr', false);
                this.model.set('maxLat', value);
              } else {
                this.model.set('maxLatErr', true);
              }
            }
          } // обработка maxLng


          if (e.target.className === 'maxLng' || e.target.className === 'maxLng error') {
            if (valueErr) {
              this.model.set('maxLngErr', true);
            } else {
              var west = this._getBounds(coords).getWest();

              if (value > west) {
                this.model.set('maxLngErr', false);
                this.model.set('maxLng', value);
              } else {
                this.model.set('maxLngErr', true);
              }
            }
          }

          attrs = this.model.toJSON();
          if (attrs.maxLngErr || attrs.minLngErr || attrs.minLatErr || attrs.maxLatErr) return;
          var newRect = L.rectangle([L.latLng(attrs.minLat, attrs.minLng), L.latLng(attrs.maxLat, attrs.maxLng)]);
          this.model.set({
            'coords': newRect._latlngs
          });

          this._removeFrame();

          this._createFrame(newRect); // restore model attributes


          this.model.set({
            xStep: attrs.xStep,
            yStep: attrs.yStep,
            xStepErr: attrs.xStepErr,
            yStepErr: attrs.yStepErr,
            minLatErr: attrs.minLatErr,
            maxLatErr: attrs.maxLatErr,
            maxLngErr: attrs.maxLngErr,
            minLngErr: attrs.minLngErr
          });

          this._updateCoords();

          this._updateCorners();

          this._countIndex();
        },
        _createFrame: function _createFrame(rectangle) {
          var attrs = this.model.toJSON(),
              options = {
            editable: true,
            map: true,
            lineStyle: {
              dashArray: '5 5',
              color: '#f57c00',
              weight: 3.5
            },
            pointStyle: {
              size: L.Browser.mobile ? 40 : 8,
              color: '#f57c00'
            }
          };
          this.model.set({
            selArea: attrs.lmap.gmxDrawing.add(rectangle, L.extend(options, {
              exportRect: true
            }))
          }); // навешивает обработчики на рамку выделения

          var frame = this.model.get('selArea'),
              _this = this;

          frame.on('edit', _this._resizeFrame.bind(_this));
          frame.on('remove', _this.unselectArea.bind(_this));
        },
        _resizeFrame: function _resizeFrame() {
          var attrs = this.model.toJSON(),
              initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
              bounds = this._getBounds(initialCoords),
              err = attrs.minLatErr || attrs.maxLatErr || attrs.maxLngErr || attrs.minLngErr;

          if (err) {
            return;
          }

          this.model.set({
            coords: initialCoords,
            minLat: bounds.getSouth(),
            minLng: bounds.getWest(),
            maxLat: bounds.getNorth(),
            maxLng: bounds.getEast()
          }); // this.model.set({
          //     minLatErr: false,
          //     maxLatErr: false,
          //     minLngErr: false,
          //     maxLngErr: false
          // });

          this._countIndex();
        },
        _countIndex: function _countIndex() {
          var attrs = this.model.toJSON(),
              initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
              coords = attrs.coords ? attrs.coords : initialCoords,
              dims = this._getLatLngDimensions(coords);

          if (attrs.xStep && attrs.yStep) {
            var xCount = Math.ceil(dims.width / this._convertXStep(attrs.xStep));
            var yCount = Math.ceil(dims.height / this._convertYStep(attrs.yStep));
            var indexCount = xCount * yCount;

            if (!attrs.xStepErr && !attrs.yStepErr) {
              if (indexCount > MAX_INDEX_COUNT) {
                this.model.set('indexCountErr', true);
              } else {
                this.model.set('indexCountErr', false);
              }

              this.model.set('xCount', xCount);
              this.model.set('yCount', yCount);
              this.model.set('indexCount', indexCount);
            }
          } else {
            this.model.set('xCount', null);
            this.model.set('yCount', null);
            this.model.set('indexCount', null);
          }
        },
        _getBounds: function _getBounds(latLngs) {
          var lats, lngs, bottomLeft, topRight;
          lats = [latLngs[0][0].lat, latLngs[0][1].lat, latLngs[0][2].lat, latLngs[0][3].lat];
          lngs = [latLngs[0][0].lng, latLngs[0][1].lng, latLngs[0][2].lng, latLngs[0][3].lng];
          bottomLeft = L.latLng(this._getMin(lats), this._getMin(lngs));
          topRight = L.latLng(this._getMax(lats), this._getMax(lngs));
          return L.latLngBounds(bottomLeft, topRight);
        },
        _removeFrame: function _removeFrame() {
          var attrs = this.model.toJSON();

          if (!attrs.selArea) {
            return;
          }

          attrs.lmap.gmxDrawing.remove(attrs.selArea);
          this.model.set({
            selArea: null,
            coords: null
          });
        },
        _updateCoords: function _updateCoords() {
          var attrs = this.model.toJSON(),
              // screenCoords,
          // dimensions,
          // bounds,
          initialCoords;

          if (!attrs.selArea) {
            return;
          }

          initialCoords = attrs.selArea.rings[0].ring.points._latlngs;

          if (!attrs.coords) {
            this.model.set('coords', initialCoords);
          }
        },
        _updateCorners: function _updateCorners() {
          var attrs = this.model.toJSON(),
              initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
              bounds = this._getBounds(initialCoords);

          this.model.set({
            minLat: bounds.getSouth(),
            minLng: bounds.getWest(),
            maxLat: bounds.getNorth(),
            maxLng: bounds.getEast()
          });
        },
        _revertCoords: function _revertCoords(coords) {
          var xx, yy, bottomLeft, topLeft, topRight, bottomRight;
          xx = [coords[0].x, coords[1].x, coords[2].x, coords[3].x];
          yy = [coords[0].y, coords[1].y, coords[2].y, coords[3].y];
          bottomLeft = L.point(this._getMin(xx), this._getMax(yy));
          topLeft = L.point(this._getMin(xx), this._getMin(yy));
          topRight = L.point(this._getMax(xx), this._getMin(yy));
          bottomRight = L.point(this._getMax(xx), this._getMax(yy));
          return [bottomLeft, topLeft, topRight, bottomRight];
        },
        _revertLatLngs: function _revertLatLngs(latlngs) {
          var lats, lngs, bottomLeft, topLeft, topRight, bottomRight;
          lats = [latlngs[0][0].lat, latlngs[0][1].lat, latlngs[0][2].lat, latlngs[0][3].lat];
          lngs = [latlngs[0][0].lng, latlngs[0][1].lng, latlngs[0][2].lng, latlngs[0][3].lng];
          bottomLeft = L.latLng(this._getMin(lats), this._getMin(lngs));
          topLeft = L.latLng(this._getMax(lats), this._getMin(lngs));
          topRight = L.latLng(this._getMax(lats), this._getMax(lngs));
          bottomRight = L.latLng(this._getMin(lats), this._getMax(lngs));
          return [bottomLeft, topLeft, topRight, bottomRight];
        },
        _convertFromLatLngs: function _convertFromLatLngs(latlngs, zoom) {
          var attrs = this.model.toJSON(),
              converted = latlngs.map(function (ll) {
            return attrs.lmap.project([ll.lat, ll.lng], zoom);
          });
          return converted;
        },
        _convertToLantLngs: function _convertToLantLngs(points, zoom) {
          var attrs = this.model.toJSON(),
              converted = points.map(function (point) {
            return attrs.lmap.unproject([point.x, point.y], zoom);
          });
          return converted;
        },
        _convertToMercator: function _convertToMercator(latlngs) {
          var attrs = this.model.toJSON(),
              converted = latlngs.map(function (ll) {
            return attrs.lmap.options.crs.project(ll);
          });
          return converted;
        },
        _convertYStep: function _convertYStep(value) {
          return value / KM_PER_DEGREE;
        },
        _convertXStep: function _convertXStep(value) {
          var attrs = this.model.toJSON(),
              centerLat = attrs.minLat + (attrs.maxLat - attrs.minLat) / 2,
              centerY = centerLat * Math.PI / 180;
          return value / KM_PER_DEGREE / Math.cos(centerY);
        },
        _getLatLngDimensions: function _getLatLngDimensions(latlngs) {
          var bottomLeft, topRight, width, height;
          latlngs = this._revertLatLngs(latlngs);
          bottomLeft = latlngs[0];
          topRight = latlngs[2];
          width = Math.abs(topRight.lng - bottomLeft.lng);
          height = Math.abs(topRight.lat - bottomLeft.lat);
          return {
            width: width,
            height: height
          };
        },
        // get array of string letters (['A'...'Z', 'AA'...'ZZ'...])
        _getLetterIndexes: function _getLetterIndexes(number) {
          var convert = function convert(srcNum, scrDict, targetDict) {
            var targetNum = "";

            for (var idx = 0; idx < srcNum.length; ++idx) {
              var srcDictIdx = scrDict.search(srcNum[idx]);
              targetNum += targetDict[srcDictIdx];
            }

            return targetNum;
          };

          var buildLettersArray = function buildLettersArray(num) {
            var xlsDict = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                jsDict = "0123456789abcdefghijklmnop",
                radix = xlsDict.length,
                numStart = 0,
                numEnd = num,
                rnt = [];

            for (var col = numStart; col <= numEnd; col++) {
              // Unfortunately, the situation is not ideal, we have A...Z and then
              // AA ... AZ, while A represents the zero digit, so in numbers it is
              // like having 0..9 and then 00..09 and only then 10...19
              // so we artificially emulate 00...09 situation here
              var prefix = "";
              var numb = col;

              if (col >= radix) {
                numb = col - radix;
              }

              if (col >= radix && col < radix * 2) {
                prefix = "A";
              }

              var jsNum = Number(numb).toString(radix);
              rnt.push(prefix + convert(jsNum, jsDict, xlsDict));
            }

            return rnt;
          };

          return buildLettersArray(number);
        },
        _getDimensions: function _getDimensions(points) {
          var // attrs = this.model.toJSON(),
          // x, y,
          bottomLeft, topRight, width, height;
          points = this._revertCoords(points);
          bottomLeft = points[0];
          topRight = points[2];
          width = Math.abs(topRight.x - bottomLeft.x);
          height = Math.abs(bottomLeft.y - topRight.y);
          return {
            width: width,
            height: height
          };
        },
        _getMax: function _getMax(arr) {
          return Math.max.apply(null, arr);
        },
        _getMin: function _getMin(arr) {
          return Math.min.apply(null, arr);
        },
        _roundInputNumber: function _roundInputNumber(value) {
          value = typeof value === 'string' ? value : String(value);

          if (value.indexOf(".") != '-1') {
            value = value.substring(0, value.indexOf(".") + 5);
          }

          return value;
        }
      });
      view$1 = new IndexGridView();

      this.Load = function () {
        var lm = model.get('lm');

        if (lm != null) {
          var alreadyLoaded = lm.createWorkCanvas('mapIndexGrid', this.Unload);

          if (!alreadyLoaded) {
            $(lm.workCanvas).append(view$1.el);
          }
        }
      };

      this.Unload = function () {
        var attrs = model.toJSON();
        attrs.lmap.gmxDrawing.remove(attrs.selArea);
        model.set({
          selArea: null,
          xStep: 1,
          yStep: 1,
          xCount: null,
          yCount: null,
          xStepErr: false,
          yStepErr: false,
          indexCount: null,
          indexCountErr: false,
          maxLat: null,
          maxLng: null,
          minLat: null,
          minLng: null,
          maxLatErr: false,
          minLatErr: false,
          maxLngErr: false,
          minLngErr: false,
          z: attrs.lmap.getZoom(),
          coords: null
        });
      };
    };

    var publicInterface$3 = {
      pluginName: 'IndexGrid',
      IndexGridMenu: IndexGridMenu
    };
    gmxCore.addModule('IndexGrid', publicInterface$3);

    window._translationsHash.addtext('rus', {
      photoLayer: {
        catalog: "Каталог",
        newCatalog: "в новый каталог",
        existingCatalog: "в существующий каталог",
        placeholder: "Введите имя каталога",
        name: "Имя каталога",
        available: "доступные каталоги",
        load: "Загрузить фотографии",
        loadShort: "ЗАГРУЗИТЬ",
        processing: "обработка изображений",
        error: "ошибка",
        successResult: "загружено фотографий",
        exifError: "ошибка чтения координат",
        ok: "готово"
      }
    });

    window._translationsHash.addtext('eng', {
      photoLayer: {
        catalog: "Catalog",
        newCatalog: "into new catalog",
        existingCatalog: "into existing catalog",
        placeholder: "Type catalog name",
        name: "name",
        available: "available catalogs",
        load: "Load photos",
        loadShort: "LOAD",
        processing: "image processing",
        error: "error",
        successResult: "images uploaded",
        exifError: "coordinates error",
        ok: "done"
      }
    });

    var PhotoLayer = function PhotoLayer() {
      var dialog;
      var PhotoLayerModel = window.Backbone.Model.extend({
        defaults: {
          fileName: null,
          photoLayersFlag: false,
          currentPhotoLayer: null,
          photoLayers: [],
          sandbox: ''
        }
      });
      var PhotoLayerView = window.Backbone.View.extend({
        tagName: 'div',
        model: new PhotoLayerModel(),
        template: Handlebars.compile('' + '<div class="photolayer-ui-container photolayer-properties-container">' + '<div class="photolayer-ui-container photolayer-catalog-selector-container">' + '{{#if photoLayersFlag}}' + '<span class="select-catalog-button existing-catalog-button">{{i "photoLayer.existingCatalog"}}</span>' + '{{/if}}' + '<span class="select-catalog-button new-catalog-button">{{i "photoLayer.newCatalog"}}</span>' + '</div>' + '<div class="photolayer-ui-container photolayer-newlayer-input-container"' + '{{#if photoLayersFlag}}' + 'style="display:none"' + '{{/if}}' + '>' + '<span class="photolayer-title photolayer-name-title">{{i "photoLayer.name"}}</span>' + '<input type="text" class="photolayer-name-input photolayer-newlayer-input minInputStyle"/>' + '</div>' + '<div class="photolayer-ui-container photolayer-existinglayer-input-container" ' + '{{#unless photoLayersFlag}}' + 'style="display:none"' + '{{/unless}}' + '>' + '<span class="photolayer-title photolayer-name-title">{{i "photoLayer.name"}}</span>' + '<select class="photolayer-name-input photolayer-existinglayer-input">' + '{{#each this.photoLayers}}' + '<option value="{{this.layer}}"' + '{{#if this.current}} selected="selected"{{/if}}>' + '{{this.layer}}' + '</option>' + '{{/each}}' + '</select>' + '</div>' + '<div class="photolayer-ui-block photolayer-loader-block">' + '<label class="photo-uploader-label">' + '<span class="photo-uploader-button">{{i "photoLayer.loadShort"}}</span>' + '<form id="photo-uploader-form" name="photouploader" enctype="multipart/form-data" method="post">' + '<input type="file" name="file" id="photo-uploader" accept="image/*" multiple></input>' + '</form>' + '</label>' + '<span class="photolayer-progress-container">' + '<span class="progressbar"></span>' + '</span>' + '<span class="photolayer-spin-container" style="display:none">' + '<img src="img/progress.gif"/>' + '<span class="spin-message">{{i "photoLayer.processing"}}</span>' + '</span>' + '<span class="photolayer-ui-container photolayer-ok-button-container" style="display:none">' + '<span class="ok-button">{{i "photoLayer.ok"}}</span>' + '</span>' + '<span class="photolayer-error-message" style="display:none"></span>' + '</div>' + '<div class="photo-upload-result photo-upload-result-uploaded" style="display:none">' + '</div>' + '<div class="photo-upload-result photo-upload-result-error" style="display:none">' + '</div>' + '</div>'),
        events: {
          'click .select-catalog-button': 'setCatalogType',
          'keyup .photolayer-newlayer-input': 'setName',
          'change .photolayer-existinglayer-input': 'setCurrentLayer',
          'change #photo-uploader': 'selectFile'
        },
        initialize: function initialize() {
          this.getPhotoLayers();
          this.createSandbox();
          this.render();
          this.listenTo(this.model, 'change:fileName', this.updateName);
          this.listenTo(this.model, 'change:photoLayers', this.updatePhotoLayersList);
        },
        render: function render() {
          var attrs = this.model.toJSON();
          this.$el.html(this.template(this.model.toJSON()));
          this.updatePhotoLayersList();
          var firstButton = this.$('.select-catalog-button')[0],
              uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));
          $(firstButton).addClass('active');
          $(uploadBlock).toggleClass('gmx-disabled', !attrs.photoLayersFlag);
          this.$('.photolayer-newlayer-input').prop('placeholder', _gtxt('photoLayer.placeholder'));
        },
        getPhotoLayers: function getPhotoLayers(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var attrs = this.model.toJSON(),
              photoLayersFlag = attrs.photoLayersFlag,
              currentPhotoLayer,
              photoLayers = [];

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties(),
                isPhotoLayer = void 0;

            if (props) {
              isPhotoLayer = props.IsPhotoLayer;

              if (isPhotoLayer && props.Access === 'edit') {
                photoLayersFlag = true;
                photoLayers.push({
                  layer: props.title,
                  LayerID: props.LayerID,
                  current: false
                });
              }
            }

            for (var j = 0; j < photoLayers.length; j++) {
              photoLayers[j].current = j === 0;

              if (j === 0) {
                currentPhotoLayer = nsGmx$1.gmxMap.layersByID[photoLayers[j].LayerID];
              }
            }
          }

          this.model.set({
            photoLayersFlag: photoLayersFlag,
            photoLayers: photoLayers,
            currentPhotoLayer: currentPhotoLayer
          });
        },
        setCatalogType: function setCatalogType(e) {
          var attrs = this.model.toJSON(),
              newCatalog = $(e.target).hasClass('new-catalog-button'),
              newContainer = $('.photolayer-newlayer-input-container'),
              existingContainer = $('.photolayer-existinglayer-input-container'),
              newLayerInput = this.$('.photolayer-newlayer-input'),
              uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

          if (newCatalog) {
            $(uploadBlock).toggleClass('gmx-disabled', !attrs.fileName);
            $(newContainer).toggle(true);
            $(existingContainer).toggle(false);
            $(e.target).toggleClass('active', true);
            $('.existing-catalog-button').toggleClass('active', false);
            $(newLayerInput).focus();
            this.model.set({
              photoLayers: [],
              fileName: null,
              currentPhotoLayer: null
            });
            this.createSandbox();
          } else {
            this.getPhotoLayers();
            $(uploadBlock).toggleClass('gmx-disabled', false);
            $(existingContainer).toggle(true);
            $(newContainer).toggle(false);
            $(e.target).toggleClass('active', true);
            $('.new-catalog-button').toggleClass('active', false);
          }
        },
        createSandbox: function createSandbox() {
          var _this = this;

          sendCrossDomainJSONRequest(window.serverBase + 'Sandbox/CreateSandbox', function (response) {
            if (parseResponse(response) && response.Result) {
              _this.model.set('sandbox', response.Result.sandbox);
            }
          });
        },
        setName: function setName(e) {
          var layers = layers || nsGmx$1.gmxMap.layers,
              // attrs = this.model.toJSON(),
          start = e.target.selectionStart,
              end = e.target.selectionEnd,
              matchingLayer;

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties();

            if (props) {
              if (e.target.value === props.title) {
                matchingLayer = layer;
              }
            }
          }

          this.model.set('fileName', e.target.value);
          this.model.set('currentPhotoLayer', matchingLayer ? matchingLayer : null); // восстановим позицию курсора

          e.target.setSelectionRange(start, end);
        },
        setCurrentLayer: function setCurrentLayer(e) {
          var layers = nsGmx$1.gmxMap.layers,
              currentPhotoLayer;

          for (var i = 0, len = layers.length; i < len; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties();

            if (props && props.title === e.target.value) {
              currentPhotoLayer = layer;
              break;
            }
          }

          this.model.set({
            currentPhotoLayer: currentPhotoLayer
          });
        },
        updateName: function updateName() {
          var attrs = this.model.toJSON(),
              newLayerInput = this.$('.photolayer-newlayer-input'),
              uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));
          $(newLayerInput).val(attrs.fileName);
          $(uploadBlock).toggleClass('gmx-disabled', !attrs.fileName);
        },
        updatePhotoLayersList: function updatePhotoLayersList() {
          var attrs = this.model.toJSON(),
              photoLayers = attrs.photoLayers,
              currentPhotoLayerName = attrs.currentPhotoLayer && attrs.currentPhotoLayer.getGmxProperties().title,
              str = '',
              select = this.$('.photolayer-existinglayer-input');

          if (photoLayers.length) {
            for (var i = 0; i < photoLayers.length; i++) {
              str += '<option>' + photoLayers[i].layer + '</option>';
            }
          }

          $(select).html(str);
          $('.photolayer-existinglayer-input option[value="' + currentPhotoLayerName + '"]').prop('selected', true);
        },
        selectFile: function selectFile(e) {
          var files = e.target.files,
              form = this.$('#photo-uploader-form'),
              arr = [],
              newLayerInput = this.$('.photolayer-newlayer-input'),
              uploadLabel = this.$('.photo-uploader-label'),
              uploadButton = this.$('.photo-uploader-button'),
              progressBarContainer = this.$('.photolayer-progress-container'),
              progressBar = this.$('.progressbar'),
              spinContainer = this.$('.photolayer-spin-container'),
              okButton = this.$('.photolayer-ok-button-container'),
              uploadResSuccess = this.$('.photo-upload-result-uploaded'),
              uploadResError = this.$('.photo-upload-result-error'),
              errorMessage = this.$('.photolayer-error-message');

          for (var key in files) {
            if (files.hasOwnProperty(key)) {
              arr.push(files[key]);
            }
          }

          $(progressBarContainer).hide();
          $(spinContainer).hide();
          $(okButton).hide();
          $(errorMessage).hide();
          $(uploadResSuccess).hide();
          $(uploadResError).hide();
          files = e.target.files;

          var attrs = this.model.toJSON(),
              _this = this,
              // sandbox,
          uploadParams = {
            sandbox: attrs.sandbox
          },
              params,
              url,
              def;

          if (attrs.currentPhotoLayer) {
            params = {
              LayerID: attrs.currentPhotoLayer.getGmxProperties().LayerID,
              PhotoSource: JSON.stringify({
                sandbox: attrs.sandbox
              })
            };
          } else {
            params = {
              Columns: "[]",
              Copyright: "",
              Description: "",
              SourceType: "manual",
              title: attrs.fileName,
              IsPhotoLayer: true,
              PhotoSource: JSON.stringify({
                sandbox: attrs.sandbox
              })
            };
          }

          $(form).prop('action', window.serverBase + 'Sandbox/Upload' + '?' + $.param(uploadParams));
          var formData = new FormData($(form)[0]);
          formData.append("sandbox", attrs.sandbox);

          for (var i = 0; i < files.length; i++) {
            formData.append(i, files[i]);
          }

          $(progressBar).progressbar({
            max: 100,
            value: 0
          });
          $(progressBarContainer).show();
          var xhr = new XMLHttpRequest();
          xhr.upload.addEventListener("progress", function (e) {
            $(progressBar).progressbar('option', 'value', e.loaded / e.total * 100);
          }, false);
          xhr.open('POST', window.serverBase + 'Sandbox/Upload');
          $(uploadButton).toggleClass('gmx-disabled', true);
          $(uploadLabel).toggleClass('gmx-disabled', true);
          xhr.withCredentials = true;

          xhr.onload = function () {
            if (xhr.status === 200) {
              var response = xhr.responseText;

              if (!response) {
                return;
              }

              $(progressBarContainer).hide();
              $(spinContainer).show();

              if (attrs.currentPhotoLayer) {
                url = window.serverBase + 'Photo/AppendPhoto' + '?' + $.param(params);
              } else {
                url = window.serverBase + 'VectorLayer/Insert.ashx' + '?' + $.param(params);
              }

              def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(url);
              def.done(function (taskInfo) {
                if (!attrs.currentPhotoLayer) {
                  var mapProperties = window._layersTree.treeModel.getMapProperties(),
                      targetDiv = $(window._queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                      gmxProperties = {
                    type: 'layer',
                    content: taskInfo.Result
                  },
                      imageUrlParams = {
                    LayerID: gmxProperties.content.properties.LayerID,
                    size: 'M'
                  },
                      bigImageUrlParams = {
                    LayerID: gmxProperties.content.properties.LayerID,
                    size: 'Native'
                  },
                      imageUrl = window.serverBase + 'rest/ver1/photo/getimage.ashx' + '?' + $.param(imageUrlParams) + '&rowId=[gmx_id]',
                      bigImageUrl = window.serverBase + 'rest/ver1/photo/getimage.ashx' + '?' + $.param(bigImageUrlParams) + '&rowId=[gmx_id]',
                      balloonString = '' + '<div style="min-width: 300px;">' + '<div style="width: 100%; text-align: center;">' + '<a href="' + bigImageUrl + '" target="_blank">' + '<img class="popupImage" src="' + imageUrl + '" alt=""/>' + '</a>' + '</div>' + '<div>' + '<b>' + window._gtxt("Имя") + ':</b> ' + '[GMX_Filename]' + '</div>' + '<div>' + '<b>' + window._gtxt("Момент съемки") + ':</b> ' + '[GMX_Date]' + '</div>' + '<div>' + '[SUMMARY]' + '</div>' + '<div>' + '<b>' + "Комментарии" + ':</b> ' + '[Comments]' + '</div>' + '</div>';

                  gmxProperties.content.properties.mapName = mapProperties.name;
                  gmxProperties.content.properties.hostName = mapProperties.hostName;
                  gmxProperties.content.properties.visible = true;
                  var renderStyle = {
                    marker: {
                      center: _mapHelper.defaultPhotoIconStyles.point.marker.center,
                      image: window.serverBase ? window.serverBase.replace('http://', '//').replace('https://', '//') + _mapHelper.defaultPhotoIconStyles.point.marker.image : _mapHelper.defaultPhotoIconStyles.point.marker.image
                    }
                  };
                  gmxProperties.content.properties.styles = [{
                    MinZoom: 1,
                    MaxZoom: 21,
                    Balloon: balloonString,
                    RenderStyle: renderStyle
                  }]; // вставляем фотослой на карту

                  var modifyMapObjects = [{
                    Action: 'insert',
                    index: 'top',
                    LayerName: gmxProperties.content.properties.LayerID,
                    Styles: gmxProperties.content.properties.styles
                  }],
                      modifyMapParams = {
                    MapName: mapProperties.MapID,
                    Objects: JSON.stringify(modifyMapObjects)
                  },
                      modifyMapUrl = window.serverBase + 'Map/ModifyMap.ashx' + '?' + $.param(modifyMapParams); // вставляем фотографии в пустой слой

                  var photoAppendParams = {
                    LayerID: gmxProperties.content.properties.LayerID,
                    PhotoSource: JSON.stringify({
                      sandbox: attrs.sandbox
                    })
                  },
                      photoAppendUrl = window.serverBase + 'Photo/AppendPhoto' + '?' + $.param(photoAppendParams);
                  sendCrossDomainJSONRequest(modifyMapUrl, function () {
                    var def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(photoAppendUrl);
                    def.done(function (taskInfo) {
                      parseGeometry(taskInfo, gmxProperties);

                      window._layersTree.copyHandler(gmxProperties, targetDiv, false, true);

                      var newLayer = nsGmx$1.gmxMap.layersByID[gmxProperties.content.properties.LayerID];
                      newLayer.bindClusters({
                        iconCreateFunction: function iconCreateFunction(cluster) {
                          var photoClusterIcon = L.divIcon({
                            html: '<img src="' + (window.serverBase ? window.serverBase + _mapHelper.defaultPhotoIconStyles.point.marker.image : _mapHelper.defaultPhotoIconStyles.point.marker.image) + '" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                            className: 'photo-div-icon',
                            iconSize: [14, 12],
                            iconAnchor: [0, 0]
                          });
                          return photoClusterIcon;
                        },
                        maxClusterRadius: 40,
                        spiderfyOnMaxZoom: true,
                        spiderfyZoom: 14,
                        spiderfyDistanceMultiplier: 1.2,
                        disableClusteringAtZoom: 19,
                        maxZoom: 19
                      }); // newLayer.updateVersion(gmxProperties.content);

                      _this.model.set({
                        currentPhotoLayer: newLayer
                      });

                      afterLoad(taskInfo);
                    }).fail(function (taskInfo) {
                      var message = taskInfo.ErrorInfo && taskInfo.ErrorInfo.ErrorMessage;
                      $(errorMessage).html(message in _mapHelper.customErrorsHash ? _gtxt(_mapHelper.customErrorsHash[message]) : _gtxt('photoLayer.error'));
                      $(errorMessage).show();
                      afterLoad(taskInfo);
                    }).progress(function () {});
                  });
                  $(newLayerInput).focus();
                } else {
                  // var curName = attrs.currentPhotoLayer.getGmxProperties().name;
                  // parseGeometry(taskInfo, gmxProperties);
                  // window.sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + curName, function(response) {
                  //     if (!parseResponse(response)) {
                  //         return;
                  //     }
                  //     debugger;
                  //     console.log(response);
                  //     // L.gmx.layersVersion.chkVersion(response.Result, null);
                  //     attrs.currentPhotoLayer.updateVersion(response.Result);
                  // });
                  // L.gmx.layersVersion.chkVersion(gmxProperties.content);
                  // attrs.currentPhotoLayer.updateVersion(gmxProperties.content);
                  afterLoad(taskInfo);
                }
              }).fail(function (taskInfo) {
                var message = taskInfo.ErrorInfo && taskInfo.ErrorInfo.ErrorMessage;
                $(errorMessage).html(message in _mapHelper.customErrorsHash ? _gtxt(_mapHelper.customErrorsHash[message]) : _gtxt('photoLayer.error'));
                $(errorMessage).show();
                afterLoad(taskInfo);
              }).progress(function () {});
            }

            function parseGeometry(info, properties) {
              var coords = [],
                  appended = info.Result.Appended,
                  updated = info.Result.Updated,
                  addCoords = function addCoords(objects, coordinates) {
                for (var a = 0; a < objects.length; a++) {
                  if (objects[a].longitude && objects[a].latitude) {
                    var point = nsGmx$1.leafletMap.options.crs.project(L.latLng(objects[a].longitude, objects[a].latitude));
                    coordinates.push([point.x, point.y]);
                  }
                }
              };

              addCoords(appended, coords);
              addCoords(updated, coords);

              if (!coords.length) {
                properties.content.geometry = null;
              } else {
                properties.content.geometry.coordinates = coords.length === 1 ? coords[0] : coords;
                properties.content.geometry.type = coords.length === 1 ? 'POINT' : 'POLYGON';
              }
            }

            function afterLoad(taskInfo) {
              var resObj = taskInfo.Result;

              if (resObj) {
                if (resObj.Appended.length) {
                  $(uploadResSuccess).html(_gtxt('photoLayer.successResult') + ": " + resObj.Appended.length);
                  $(uploadResSuccess).show();
                }

                if (resObj.NoCoords.length) {
                  $(uploadResError).html(_gtxt('photoLayer.exifError') + ": " + resObj.NoCoords.length);
                  $(uploadResError).show();
                }
              }

              $(spinContainer).hide();
              $(uploadButton).toggleClass('gmx-disabled', false);
              $(uploadLabel).toggleClass('gmx-disabled', false);

              _this.createSandbox();
            }
          };

          xhr.send(formData);
        }
      });

      this.Load = function () {
        var view = new PhotoLayerView(),
            resizeFunc = function resizeFunc() {},
            closeFunc = function closeFunc() {
          view.model.set({
            photoLayersFlag: false,
            photoLayers: [],
            currentPhotoLayer: null
          });
        };

        dialog = nsGmx$1.Utils.showDialog(_gtxt('photoLayer.load'), view.el, 340, 220, null, null, resizeFunc, closeFunc);
      };

      this.Unload = function () {
        $(dialog).remove();
      };
    };

    var publicInterface$4 = {
      pluginName: 'PhotoLayer',
      PhotoLayer: PhotoLayer
    };
    window.gmxCore.addModule('PhotoLayer', publicInterface$4);

    (function () {

      nsGmx$1.Translations.addText('rus', {
        uglw: {
          headerTitle: 'Фильтр',
          listheader: {
            title: 'Название',
            description: 'Описание'
          },
          groupProps: {
            title: 'Название',
            description: 'Описание'
          },
          popover: {
            title: 'Удалить группу',
            ok: 'Ok',
            cancel: 'Отмена'
          },
          shareLabel: 'Права на ресурсы внутри группы:',
          share: {
            'public': 'общие',
            'private': 'раздельные'
          }
        }
      });
      nsGmx$1.Translations.addText('eng', {
        uglw: {
          headerTitle: 'Filter',
          listheader: {
            title: 'Title',
            description: 'Description'
          },
          groupProps: {
            title: 'Title',
            description: 'Description'
          },
          popover: {
            title: 'Delete group',
            ok: 'Ok',
            cancel: 'Cancel'
          },
          shareLabel: 'Sharing resources among members:',
          share: {
            'public': 'selectively',
            'private': 'by default'
          }
        }
      });
      var Group = Backbone.Model.extend({
        idAttribute: 'UserID'
      });
      var GroupList = Backbone.Collection.extend({
        model: Group
      });
      var GroupListView = Backbone.View.extend({
        template: Handlebars.compile('<table class="uglw-table">' + '<thead class="tableHeader">' + '<th class="uglw-table-title">{{i "uglw.listheader.title"}}</th>' + '<th class="uglw-table-descr">{{i "uglw.listheader.description"}}</th>' + '<th></th>' + '</thead><tbody class="tableBody">' + '{{#users}}' + '<tr class="uglw-row">' + '<td><span class="uglw-group-name" data-groupid="{{UserID}}">{{Nickname}}</span></td>' + '<td>{{Description}}</td>' + '<td><div class="gmx-icon-recycle" data-groupid="{{UserID}}"></div></td>' + '</tr>' + '{{/users}}</tbody></table>'),
        initialize: function initialize() {
          this.listenTo(this.model, 'reset', this.render);
        },
        render: function render() {
          var _this = this;

          var rawAttributes = this.model.map(function (user) {
            return user.attributes;
          });
          this.$el.empty().append($(this.template({
            users: rawAttributes
          })));
          this.$el.find('.uglw-group-name').click(function () {
            var groupID = Number($(this).data('groupid'));
            var groupSecurity = new UserGroupSecurity();
            $(groupSecurity).on('savedone', function () {
              _this.trigger('needupdate');
            });
            groupSecurity.propertyValue = groupID;
            groupSecurity.title = _this.model.get(groupID).get('Nickname');
            groupSecurity.getSecurityFromServer(groupID).then(function (res) {
              groupSecurity.createSecurityDialog(res);
              $(groupSecurity._dialogDiv).find('.security-props-title').focus();
            });
          });
          var popoverUI = $(Handlebars.compile('<div>' + '<div>{{i "uglw.popover.title"}}?</div>' + '<div class="uglw-popover-buttons">' + '<button class="uglw-popover-ok">{{i "uglw.popover.ok"}}</button>' + '<button class="uglw-popover-cancel">{{i "uglw.popover.cancel"}}</button>' + '</div>' + '</div>')());
          popoverUI.find('.uglw-popover-ok').click(function () {
            sendCrossDomainJSONRequest(window.serverBase + 'User/DeleteGroup?GroupID=' + _this._popoverGroupID, function (response) {
              if (!parseResponse(response)) {
                return;
              }

              _this.trigger('needupdate');

              _this.$el.find('.gmx-icon-recycle').popover('hide');
            });
          });
          popoverUI.find('.uglw-popover-cancel').click(function () {
            _this.$el.find('.gmx-icon-recycle').popover('hide');
          });
          this.$el.find('.gmx-icon-recycle').click(function () {
            var groupID = Number($(this).data('groupid'));
            _this._popoverGroupID = groupID;
          }).popover({
            content: popoverUI[0],
            placement: 'left',
            html: true
          }).on('shown.bs.popover', function (event) {
            _this.$el.find('.gmx-icon-recycle').each(function (i, icon) {
              if (icon !== event.target) {
                $(icon).popover('hide');
              }
            });
          });
        }
      });

      nsGmx$1.UserGroupListWidget = function (container) {
        var ui = $(nsGmx$1.UserGroupListWidget._mainTemplate()).appendTo(container);
        var groupList = new GroupList();
        var listView = new GroupListView({
          el: ui.find('.uglw-list-placeholder')[0],
          model: groupList
        });

        var refilterUsers = function refilterUsers() {
          nsGmx$1.security.findUsers(ui.find('.uglw-filter-input').val(), {
            type: 'Group'
          }).then(function (users) {
            groupList.reset(users);
          });
        };

        listView.on('needupdate', refilterUsers);
        var lastValue = null;
        ui.find('.uglw-filter-input').on('keyup change', function () {
          if (lastValue !== this.value) {
            lastValue = this.value;
            refilterUsers();
          }
        });
        ui.find('.uglw-filter-input').change();
        ui.find('.uglw-add-icon').click(function () {
          var groupSecurity = new UserGroupSecurity();

          groupSecurity._save = function () {
            var // _this = this,
            si = this._securityInfo.SecurityInfo;

            if (this.saveCustomParams()) {
              return;
            }

            var membersJson = si.Users.map(function (user) {
              return {
                Access: user.Access,
                UserID: user.UserID
              };
            });
            sendCrossDomainPostRequest(window.serverBase + 'User/CreateGroup', {
              WrapStyle: 'message',
              Nickname: si.Nickname,
              Description: si.Description,
              MembersJson: JSON.stringify(membersJson)
            }, function (response) {
              if (!parseResponse(response)) {
                return;
              }

              $(groupSecurity._dialogDiv).dialog('close');
              refilterUsers();
            });
          };

          groupSecurity.createSecurityDialog({
            SecurityInfo: {
              Users: []
            }
          }, {
            showOwner: false
          });
          $(groupSecurity._dialogDiv).find('.security-props-title').focus();
        });
      };

      nsGmx$1.UserGroupListWidget._mainTemplate = Handlebars.compile('<div>' + '<div class="uglw-header">' + '{{i "uglw.headerTitle"}} <input class="uglw-filter-input inputStyle">' + '<div class="uglw-add-icon" title="Добавить группу"></div>' + '</div>' + '<div class="uglw-list-placeholder"></div>' + '</div>');

      var UserGroupSecurity = function UserGroupSecurity() {
        this.getSecurityName = "User/GetUserGroupSecurity";
        this.updateSecurityName = "User/UpdateUserGroupSecurity";
        this.propertyName = "UserID";
        this.dialogTitle = "Состав группы [value0]";
        this.accessTypes = ['no', 'view', 'edit'];
      };

      UserGroupSecurity.prototype = new nsGmx$1.security();
      UserGroupSecurity.prototype.constructor = UserGroupSecurity;

      UserGroupSecurity.prototype.saveCustomParams = function () {
        var nicknameInput = this._ui.find('.security-props-title'),
            nickname = nicknameInput.val();

        if (nickname) {
          this._securityInfo.SecurityInfo.Nickname = nickname;
          this._securityInfo.SecurityInfo.Description = this._ui.find('.security-props-description').val();
        } else {
          inputError(nicknameInput[0]);
          return true;
        }

        var publicCheckbox = this._ui.find('#publicRights')[0];

        this._securityInfo.SecurityInfo.SharedResources = publicCheckbox.checked;
      };

      UserGroupSecurity.prototype.addCustomUI = function (ui, securityInfo) {
        var propsTemplate = Handlebars.compile('<table class="security-props">' + '<tr><td>{{i "uglw.groupProps.title"}}:</td><td><input class="security-props-title inputStyle" value="{{Nickname}}"></td></tr>' + '<tr><td>{{i "uglw.groupProps.description"}}:</td><td><input class="security-props-description inputStyle" value="{{Description}}"></td></tr>' + '</table>' + '<div class="security-policy-control">' + '<span class="security-policy-label">{{i "uglw.shareLabel"}}</span>' + '<span class="security-policy-radiogroup">' + '<input id="privateRights" class="policy-checkbox" type="radio" name="groupEditingPolicy" {{#unless SharedResources}} checked {{/unless}}/>' + '<label class="security-policy-label" for="privateRights">{{i "uglw.share.private"}}</label>' + '<input id="publicRights" class="policy-checkbox" type="radio" name="groupEditingPolicy" {{#if SharedResources}} checked {{/if}}/>' + '<label class="security-policy-label" for="publicRights">{{i "uglw.share.public"}}</label>' + '</span>' + '</div>');
        $(propsTemplate({
          Nickname: securityInfo.Nickname,
          Description: securityInfo.Description,
          SharedResources: securityInfo.SharedResources
        })).appendTo(ui.find('.security-custom-ui'));
      };

      gmxCore.addModule('UserGroupWidget', {
        UserGroupListWidget: nsGmx$1.UserGroupListWidget // ,{
        //     css: 'css/UserGroupWidget.css'
        // }

      });
    })();

    L.Control.Dialog = L.Control.extend({
      options: {
        size: [300, 300],
        minSize: [100, 100],
        maxSize: [350, 350],
        anchor: [250, 250],
        position: 'topleft',
        initOpen: true
      },
      initialize: function (options) {
        L.setOptions(this, options);
        this._attributions = {};
      },
      onAdd: function (map) {
        this._initLayout();

        this._map = map;
        this.update();

        if (!this.options.initOpen) {
          this.close();
        }

        return this._container;
      },
      open: function () {
        if (!this._map) {
          return;
        }

        this._container.style.visibility = '';

        this._map.fire('dialog:opened', this);

        return this;
      },
      close: function () {
        this._container.style.visibility = 'hidden';

        this._map.fire('dialog:closed', this);

        return this;
      },
      destroy: function () {
        if (!this._map) {
          return this;
        }

        this.removeFrom(this._map);

        if (this.onRemove) {
          this.onRemove(this._map);
        }

        this._map.fire('dialog:destroyed', this);

        return this;
      },
      setLocation: function (location) {
        location = location || [250, 250];
        this.options.anchor[0] = 0;
        this.options.anchor[1] = 0;
        this._oldMousePos.x = 0;
        this._oldMousePos.y = 0;

        this._move(location[1], location[0]);

        return this;
      },
      setSize: function (size) {
        size = size || [300, 300];
        this.options.size[0] = 0;
        this.options.size[1] = 0;
        this._oldMousePos.x = 0;
        this._oldMousePos.y = 0;

        this._resize(size[0], size[1]);

        return this;
      },
      lock: function () {
        this._resizerNode.style.visibility = 'hidden';
        this._grabberNode.style.visibility = 'hidden';
        this._closeNode.style.visibility = 'hidden';

        this._map.fire('dialog:locked', this);

        return this;
      },
      unlock: function () {
        this._resizerNode.style.visibility = '';
        this._grabberNode.style.visibility = '';
        this._closeNode.style.visibility = '';

        this._map.fire('dialog:unlocked', this);

        return this;
      },
      freeze: function () {
        this._resizerNode.style.visibility = 'hidden';
        this._grabberNode.style.visibility = 'hidden';

        this._map.fire('dialog:frozen', this);

        return this;
      },
      unfreeze: function () {
        this._resizerNode.style.visibility = '';
        this._grabberNode.style.visibility = '';

        this._map.fire('dialog:unfrozen', this);

        return this;
      },
      setContent: function (content) {
        this._content = content;
        this.update();
        return this;
      },
      getContent: function () {
        return this._content;
      },
      getElement: function () {
        return this._container;
      },
      update: function () {
        if (!this._map) {
          return;
        }

        this._container.style.visibility = 'hidden';

        this._updateContent();

        this._updateLayout();

        this._container.style.visibility = '';

        this._map.fire('dialog:updated', this);
      },
      _initLayout: function () {
        var className = 'leaflet-control-dialog',
            container = this._container = L.DomUtil.create('div', className);
        container.style.width = this.options.size[0] + 'px';
        container.style.height = this.options.size[1] + 'px';
        container.style.top = this.options.anchor[0] + 'px';
        container.style.left = this.options.anchor[1] + 'px';
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent.on(container, 'click', stop).on(container, 'mousedown', stop).on(container, 'touchstart', stop).on(container, 'dblclick', stop).on(container, 'mousewheel', stop).on(container, 'contextmenu', stop).on(container, 'MozMousePixelScroll', stop);
        var innerContainer = this._innerContainer = L.DomUtil.create('div', className + '-inner');
        var grabberNode = this._grabberNode = L.DomUtil.create('div', className + '-grabber');
        var grabberIcon = L.DomUtil.create('i', 'fa fa-arrows');
        grabberNode.appendChild(grabberIcon);
        L.DomEvent.on(grabberNode, 'mousedown', this._handleMoveStart, this);
        var closeNode = this._closeNode = L.DomUtil.create('div', className + '-close');
        var closeIcon = L.DomUtil.create('i', 'fa fa-times');
        closeNode.appendChild(closeIcon);
        L.DomEvent.on(closeNode, 'click', this._handleClose, this);
        var resizerNode = this._resizerNode = L.DomUtil.create('div', className + '-resizer');
        var resizeIcon = L.DomUtil.create('i', 'fa fa-arrows-h fa-rotate-45');
        resizerNode.appendChild(resizeIcon);
        L.DomEvent.on(resizerNode, 'mousedown', this._handleResizeStart, this);
        var contentNode = this._contentNode = L.DomUtil.create('div', className + "-contents");
        container.appendChild(innerContainer);
        innerContainer.appendChild(contentNode);
        innerContainer.appendChild(grabberNode);
        innerContainer.appendChild(closeNode);
        innerContainer.appendChild(resizerNode);
        this._oldMousePos = {
          x: 0,
          y: 0
        };
      },
      _handleClose: function () {
        this.close();
      },
      _handleResizeStart: function (e) {
        this._oldMousePos.x = e.clientX;
        this._oldMousePos.y = e.clientY;
        L.DomEvent.on(this._map, 'mousemove', this._handleMouseMove, this);
        L.DomEvent.on(this._map, 'mouseup', this._handleMouseUp, this);

        this._map.fire('dialog:resizestart', this);

        this._resizing = true;
      },
      _handleMoveStart: function (e) {
        this._oldMousePos.x = e.clientX;
        this._oldMousePos.y = e.clientY;
        L.DomEvent.on(this._map, 'mousemove', this._handleMouseMove, this);
        L.DomEvent.on(this._map, 'mouseup', this._handleMouseUp, this);

        this._map.fire('dialog:movestart', this);

        this._moving = true;
      },
      _handleMouseMove: function (e) {
        var diffX = e.originalEvent.clientX - this._oldMousePos.x,
            diffY = e.originalEvent.clientY - this._oldMousePos.y; // this helps prevent accidental highlighting on drag:

        if (e.originalEvent.stopPropagation) {
          e.originalEvent.stopPropagation();
        }

        if (e.originalEvent.preventDefault) {
          e.originalEvent.preventDefault();
        }

        if (this._resizing) {
          this._resize(diffX, diffY);
        }

        if (this._moving) {
          this._move(diffX, diffY);
        }
      },
      _handleMouseUp: function () {
        L.DomEvent.off(this._map, 'mousemove', this._handleMouseMove, this);
        L.DomEvent.off(this._map, 'mouseup', this._handleMouseUp, this);

        if (this._resizing) {
          this._resizing = false;

          this._map.fire('dialog:resizeend', this);
        }

        if (this._moving) {
          this._moving = false;

          this._map.fire('dialog:moveend', this);
        }
      },
      _move: function (diffX, diffY) {
        var newY = this.options.anchor[0] + diffY;
        var newX = this.options.anchor[1] + diffX;
        this.options.anchor[0] = newY;
        this.options.anchor[1] = newX;
        this._container.style.top = this.options.anchor[0] + 'px';
        this._container.style.left = this.options.anchor[1] + 'px';

        this._map.fire('dialog:moving', this);

        this._oldMousePos.y += diffY;
        this._oldMousePos.x += diffX;
      },
      _resize: function (diffX, diffY) {
        var newX = this.options.size[0] + diffX;
        var newY = this.options.size[1] + diffY;

        if (newX <= this.options.maxSize[0] && newX >= this.options.minSize[0]) {
          this.options.size[0] = newX;
          this._container.style.width = this.options.size[0] + 'px';
          this._oldMousePos.x += diffX;
        }

        if (newY <= this.options.maxSize[1] && newY >= this.options.minSize[1]) {
          this.options.size[1] = newY;
          this._container.style.height = this.options.size[1] + 'px';
          this._oldMousePos.y += diffY;
        }

        this._map.fire('dialog:resizing', this);
      },
      _updateContent: function () {
        if (!this._content) {
          return;
        }

        var node = this._contentNode;
        var content = typeof this._content === 'function' ? this._content(this) : this._content;

        if (typeof content === 'string') {
          node.innerHTML = content;
        } else {
          while (node.hasChildNodes()) {
            node.removeChild(node.firstChild);
          }

          node.appendChild(content);
        }
      },
      _updateLayout: function () {
        this._container.style.width = this.options.size[0] + 'px';
        this._container.style.height = this.options.size[1] + 'px';
        this._container.style.top = this.options.anchor[0] + 'px';
        this._container.style.left = this.options.anchor[1] + 'px';
      }
    });

    L.control.dialog = function (options) {
      return new L.Control.Dialog(options);
    };

    /** ГеоМиксер активно использует {@link http://jquery.com/|jQuery}
     * @namespace jQuery
     */

    /** Официальная документация: {@link http://api.jquery.com/category/deferred-object/|jQuery Deferred}
     * @name Deferred
     * @memberOf jQuery
     */

    /** Библиотека для формализации понятия модели и представления: {@link http://backbonejs.org/|Backbone}
     * @namespace Backbone
     */

    /** Официальная документация: {@link http://backbonejs.org/#Model| Backbone Model}
     * @name Model
     * @memberOf Backbone
     */

    /**
        Основное пространство имён ГеоМиксера
        @namespace
    */

    nsGmx$1.widgets = nsGmx$1.widgets || {}; // var gmxJSHost = window.gmxJSHost || '';

    if (!window.mapHostName && window.gmxJSHost) {
      window.mapHostName = /https?:\/\/(.*)\/api\//.exec(window.gmxJSHost)[1];
    }

    var _mapHostName; //откуда грузить API


    var protocol = window.location.protocol;

    if (window.mapHostName) {
      _mapHostName = protocol + '//' + window.mapHostName + '/api/';
    } else {
      var curUri = L.gmxUtil.parseUri(window.location.href);
      _mapHostName = protocol + '//' + curUri.host + curUri.directory;
    }

    var _serverBase = window.serverBase || new RegExp('(.*)/[^/]*/').exec(_mapHostName)[1] + '/'; // //подставляет к локальному имени файла хост (window.gmxJSHost) и, опционально, рандомное поле для сброса кэша (window.gmxDropBrowserCache)
    // var _getFileName = function(localName) {
    //     return gmxJSHost + localName + (window.gmxDropBrowserCache ? '?' + Math.random() : '');
    // }


    nsGmx$1.initGeoMixer = function () {
      var oSearchLeftMenu = new leftMenu();
      window.searchLogic = new nsGmx$1.SearchLogic(); //для синхронизации меню и тулбара при включении/выключении сетки координат

      nsGmx$1.gridManager = {
        state: false,
        gridControl: null,
        options: null,
        menu: null,
        setState: function setState(state) {
          var isActive = state.isActive,
              options = state.options;

          if (this.state == isActive) {
            return;
          } //lazy instantantion


          this.gridControl = this.gridControl || new L.GmxGrid();
          nsGmx$1.leafletMap[isActive ? 'addLayer' : 'removeLayer'](this.gridControl);

          if (options) {
            this.restoreOptions(options);
          }

          this.state = isActive;
          nsGmx$1.leafletMap.gmxControlIconManager.get('gridTool').setActive(isActive);

          _menuUp.checkItem('mapGrid', isActive);

          _mapHelper$1.gridView = isActive; //можно удалить?

          if (this.state) {
            this.configureGrid();
          } else if (this.menu) {
            this.menu.Unload();
          }
        },
        saveOptions: function saveOptions() {
          this.options = this.gridControl.options;
        },
        restoreOptions: function restoreOptions(options) {
          this.gridControl.setUnits(options.units);

          if (options.customStep) {
            this.gridControl.setStep(options.customStep.x, options.customStep.y);
          }

          this.gridControl.setColor(options.color);
          this.gridControl.setTitleFormat(options.titleFormat);
        },
        configureGrid: function configureGrid() {
          var _this = this;

          window.gmxCore.loadModule('GridPlugin' // , 'src/GridPlugin.js'
          ).then(function (def) {
            _this.menu = new def.ConfigureGridMenu(nsGmx$1.gridManager);

            _this.menu.Load();
          });
        }
      };

      var createMenuNew = function createMenuNew() {
        //формирует описание элемента меню для включения/выключения плагина
        var getPluginToMenuBinding = function getPluginToMenuBinding(pluginName, menuItemName, menuTitle) {
          var plugin = nsGmx$1.pluginsManager.getPluginByName(pluginName);

          if (!plugin) {
            return null;
          }

          var sel = function sel() {
            nsGmx$1.pluginsManager.setUsePlugin(pluginName, true);
            nsGmx$1.pluginsManager.done(function () {
              var paramsClone = $.extend(true, {}, plugin.params);
              plugin.body.afterViewer && plugin.body.afterViewer(paramsClone, nsGmx$1.leafletMap);

              _mapHelper$1.mapPlugins.addPlugin(pluginName, plugin.params);
            });
          };

          var unsel = function unsel() {
            nsGmx$1.pluginsManager.setUsePlugin(pluginName, false);
            nsGmx$1.pluginsManager.done(function () {
              _mapHelper$1.mapPlugins.remove(pluginName);

              plugin.body.unload && plugin.body.unload();
            });
          };

          return {
            id: menuItemName,
            title: menuTitle,
            onsel: sel,
            onunsel: unsel,
            checked: plugin.isUsed()
          };
        };

        var isMapEditor = _queryMapLayers.currentMapRights() === 'edit',
            isLogined = nsGmx$1.AuthManager.isLogin();
        _menuUp.submenus = [];

        _menuUp.addItem({
          id: 'mapsMenu',
          title: _gtxt('Карта'),
          childs: [].concat(isLogined ? [{
            id: 'mapList',
            title: _gtxt('Открыть'),
            func: function func() {
              _queryMapLayers.getMaps();
            }
          }] : [], [{
            id: 'mapCreate',
            title: _gtxt('Создать'),
            func: function func() {
              _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap);
            }
          }, {
            id: 'mapSave',
            title: _gtxt('Сохранить'),
            func: _queryMapLayers.saveMap
          }, {
            id: 'mapSaveAs',
            title: _gtxt('Сохранить как'),
            func: function func() {
              _queryMapLayers.createMapDialog(_gtxt('Сохранить карту как'), _gtxt('Сохранить'), _queryMapLayers.saveMapAs);
            },
            delimiter: true
          }, {
            id: 'export',
            title: _gtxt('Экспорт'),
            func: function func() {
              mapExportMenu();
            },
            disabled: !isLogined
          }, {
            id: 'shareMenu',
            title: _gtxt('Поделиться'),
            func: function func() {
              _mapHelper$1.showPermalink();
            }
          }, // {id: 'codeMap',      title: _gtxt('Код для вставки'),   func: function(){_mapHelper.createAPIMapDialog()}, disabled: true},
          {
            id: 'mapTabsNew',
            title: _gtxt('Добавить закладку'),
            func: function func() {
              mapHelp.tabs.load('mapTabs');

              _queryTabs.add();
            }
          }, {
            id: 'printMap',
            title: _gtxt('Печать'),
            func: function func() {
              _mapHelper$1.print();
            },
            delimiter: true
          }, {
            id: 'mapProperties',
            title: _gtxt('Свойства'),
            func: function func() {
              var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
              nsGmx$1.createMapEditor(div);
            },
            disabled: !isMapEditor
          }, {
            id: 'createGroup',
            title: _gtxt('Добавить подгруппу'),
            func: function func() {
              var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
              nsGmx$1.addSubGroup(div, _layersTree);
            },
            disabled: !isMapEditor
          }, {
            id: 'mapSecurity',
            title: _gtxt('Права доступа'),
            func: function func() {
              var securityDialog = new nsGmx$1.mapSecurity(),
                  props = _layersTree.treeModel.getMapProperties();

              securityDialog.getRights(props.MapID, props.title);
            },
            disabled: !isMapEditor
          }])
        });

        _menuUp.addItem({
          id: 'dataMenu',
          title: _gtxt('Данные'),
          childs: [{
            id: 'layerList',
            title: _gtxt('Открыть слой'),
            func: function func() {
              _queryMapLayers.getLayers();
            },
            disabled: !isMapEditor
          }, {
            id: 'createLayer',
            title: _gtxt('Создать слой'),
            childs: [{
              id: 'createRasterLayer',
              title: _gtxt('Растровый'),
              func: _mapHelper$1.createNewLayer.bind(_mapHelper$1, 'Raster'),
              disabled: !isMapEditor
            }, {
              id: 'createVectorLayer',
              title: _gtxt('Векторный'),
              func: _mapHelper$1.createNewLayer.bind(_mapHelper$1, 'Vector'),
              disabled: !isMapEditor
            }, {
              id: 'createMultiLayer',
              title: _gtxt('Мультислой'),
              func: _mapHelper$1.createNewLayer.bind(_mapHelper$1, 'Multi'),
              disabled: !isMapEditor
            }, {
              id: 'createVirtualLayer',
              title: 'Виртуальный',
              func: function func() {
                window.gmxCore.loadModule('LayerEditor').then(function () {
                  nsGmx$1.LayerEditor.addInitHook(function (layerEditor, layerProperties, params) {
                    if (layerProperties.get('Type') !== 'Virtual') {
                      return;
                    }

                    $(layerEditor).on('premodify', function () {
                      layerProperties.set('ContentID', ui.find('.vlayer-contentid').val());
                    });
                    var template = Handlebars.compile('<div type="vlayer-container">' + '<span class="vlayer-label">Тип слоя</span>' + '<input class="vlayer-contentid inputStyle" value="{{ContentID}}">' + '</div>');
                    var ui = $(template({
                      ContentID: layerProperties.get('ContentID')
                    }));
                    params.additionalUI = params.additionalUI || {};
                    params.additionalUI.main = params.additionalUI.advanced || [];
                    params.additionalUI.main.push(ui);
                  });

                  var parent = _div(null, [['attr', 'id', 'newVirtualLayer'], ['css', 'height', '100%']]),
                      properties = {
                    Title: '',
                    Description: '',
                    Date: ''
                  };

                  var dialogDiv = showDialog('Создать виртуальный слой', parent, 340, 340, false, false);
                  nsGmx$1.createLayerEditor(false, 'Virtual', parent, properties, {
                    doneCallback: function doneCallback() {
                      removeDialog(dialogDiv);
                    }
                  });
                });
              },
              disabled: !isMapEditor
            }],
            disabled: !isMapEditor
          }, {
            id: 'baseLayers',
            title: _gtxt('Базовые слои'),
            func: function func() {
              var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
              nsGmx$1.createMapEditor(div, 1);
            },
            delimiter: true,
            disabled: !isMapEditor
          }, {
            id: 'loadFile',
            title: _gtxt('Загрузить объекты'),
            func: drawingObjects.loadShp.load,
            delimiter: true
          }, {
            id: 'loadPhotos',
            title: _gtxt('Загрузить фотографии'),
            func: function func() {
              PhotoLayerDialog();
            },
            delimiter: true,
            disabled: !isMapEditor
          }, {
            id: 'wms',
            title: _gtxt('Подключить WMS'),
            func: loadServerData.WMS.load
          }, {
            id: 'wfs',
            title: _gtxt('Подключить WFS'),
            func: loadServerData.WFS.load
          }]
        });

        _menuUp.addItem({
          id: 'viewMenu',
          title: _gtxt('Вид'),
          childs: [{
            id: 'externalMaps',
            title: _gtxt('Дополнительные карты'),
            func: mapHelp.externalMaps.load
          }, {
            id: 'mapTabs',
            title: _gtxt('Закладки'),
            func: mapHelp.tabs.load
          }, {
            id: 'DrawingObjects',
            title: _gtxt('Объекты'),
            func: window.oDrawingObjectGeomixer.Load // {id:'searchView',     title: _gtxt('Результаты поиска'),    func: oSearchControl.Load}

          }]
        });

        _menuUp.addItem({
          id: 'instrumentsMenu',
          title: _gtxt('Инструменты'),
          childs: [{
            id: 'mapGrid',
            title: _gtxt('Координатная сетка'),
            onsel: nsGmx$1.gridManager.setState.bind(nsGmx$1.gridManager, {
              isActive: true
            }),
            onunsel: nsGmx$1.gridManager.setState.bind(nsGmx$1.gridManager, {
              isActive: false
            }),
            checked: _mapHelper$1.gridView
          }, {
            id: 'mapIndexGrid',
            title: _gtxt('Индексная сетка'),
            func: function func() {
              indexGridMenu();
            }
          }, {
            id: 'buffer',
            title: _gtxt('Создание буферных зон'),
            func: function func() {
              BufferZonesMenu();
            },
            disabled: !isLogined
          }, {
            id: 'shift',
            title: _gtxt('Ручная привязка растров'),
            func: function func() {},
            disabled: true
          }, {
            id: 'crowdsourcing',
            title: _gtxt('Краудсорсинг данных'),
            func: function func() {},
            disabled: true
          }, {
            id: 'geocoding',
            title: _gtxt('Пакетный геокодинг'),
            func: function func() {},
            disabled: true
          }, {
            id: 'directions',
            title: _gtxt('Маршруты'),
            func: function func() {},
            disabled: true
          }]
        });

        function fillPluginsMenu() {
          var plugins = window.menuPlugins || []; // для локальной версии Геомиксера покажем плагины кадастра и Викимапии

          if (!window.menuPlugins) {
            if (nsGmx$1.pluginsManager.getPluginByName('Cadastre')) {
              plugins.push({
                pluginName: 'Cadastre',
                menuItemName: 'cadastre',
                menuTitle: 'Кадастр Росреестра'
              });
            }
          }

          if (plugins.length) {
            var childs = [];

            for (var p = 0; p < plugins.length; p++) {
              childs.push(getPluginToMenuBinding(plugins[p].pluginName, plugins[p].menuItemName, window._gtxt(plugins[p].menuTitle)));
            }

            _menuUp.addItem({
              id: 'pluginsMenu',
              title: _gtxt('Сервисы'),
              childs: childs
            });
          }
        }

        fillPluginsMenu();

        _menuUp.addItem({
          id: 'helpMenu',
          title: _gtxt('Справка'),
          childs: nsGmx$1.gmxMap.properties.MapID !== '31RJS' ? [{
            id: 'about',
            title: _gtxt('О проекте'),
            func: _mapHelper$1.version
          }].concat(window.mapsSite ? [{
            id: 'usage',
            title: _gtxt('Руководство пользователя'),
            func: function func() {
              window.open('http://geomixer.ru/index.php/docs/', '_blank');
            }
          }, {
            id: 'api',
            title: _gtxt('GeoMixer API'),
            func: function func() {
              window.open('https://geomixer.ru/docs/dev-manual/rest-api/get-started/', '_blank');
            }
          }, {
            id: 'pluginsUsage',
            title: _gtxt('Использование плагинов'),
            func: function func() {
              window.open('http://geomixer.ru/index.php/docs/manual/plugins', '_blank');
            }
          }] : []) : [{
            id: 'usage',
            title: _gtxt('Руководство'),
            func: function func() {
              window.open(window.location.protocol + '//kosmosnimki.ru/downloads/%D1%86%D1%81%D0%BC%D1%81.pdf', '_blank');
            }
          }]
        });
      };

      var createToolbar = function createToolbar() {
        var lmap = nsGmx$1.leafletMap;
        var SliderControl = L.Control.extend({
          options: {
            position: 'topleft'
          },
          onAdd: function onAdd() {
            var sliderContainer = $('<div class="gmx-slider-control"></div>');
            this._widget = new nsGmx$1.TransparencySliderWidget(sliderContainer);
            $(this._widget).on('slide slidechange', function (event, ui) {
              _queryMapLayers.applyOpacityToRasterLayers(ui.value * 100, _queryMapLayers.buildedTree);
            });
            return sliderContainer[0];
          },
          onRemove: function onRemove() {},
          isCollapsed: function isCollapsed() {
            return this._widget.isCollapsed();
          }
        });
        var sliderControl = new SliderControl();
        lmap.addControl(sliderControl); //пополняем тулбар

        var uploadFileIcon = L.control.gmxIcon({
          id: 'uploadFile',
          title: _gtxt('Загрузить объекты')
        }).on('click', drawingObjects.loadShp.load.bind(drawingObjects.loadShp));
        lmap.gmxControlIconManager.get('drawing').addIcon(uploadFileIcon); // выпадающие группы иконок наезжают на слайдер прозрачности.
        // Эта ф-ция разруливает этот конфликт, скрывая слайдер в нужный момент

        var resolveToolConflict = function resolveToolConflict(iconGroup) {
          iconGroup.on('collapse', function () {
            $('.gmx-slider-control').removeClass('invisible');
          }).on('expand', function () {
            sliderControl.isCollapsed() || $('.gmx-slider-control').addClass('invisible');
          });
        };

        if (_queryMapLayers.currentMapRights() === 'edit') {
          var saveMapIcon = L.control.gmxIcon({
            id: 'saveMap',
            title: _gtxt('Сохранить карту'),
            addBefore: 'drawing'
          });
          saveMapIcon.addTo(lmap);
          saveMapIcon.on('click', _queryMapLayers.saveMap.bind(_queryMapLayers)); //группа создания слоёв

          var createVectorLayerIcon = L.control.gmxIcon({
            id: 'createVectorLayer',
            title: _gtxt('Создать векторный слой'),
            addBefore: 'drawing'
          });
          createVectorLayerIcon.on('click', function () {
            _mapHelper$1.createNewLayer('Vector');

            createVectorLayerIcon.setActive(true);
            createRasterLayerIcon.setActive(false);
          });
          var createRasterLayerIcon = L.control.gmxIcon({
            id: 'createRasterLayer',
            title: _gtxt('Создать растровый слой'),
            addBefore: 'drawing'
          });
          createRasterLayerIcon.on('click', function () {
            _mapHelper$1.createNewLayer('Raster');

            createRasterLayerIcon.setActive(true);
            createVectorLayerIcon.setActive(false);
          });
          var createLayerIconGroup = L.control.gmxIconGroup({
            id: 'createLayer',
            isSortable: true,
            //isCollapsible: false,
            items: [createVectorLayerIcon, createRasterLayerIcon],
            addBefore: 'drawing'
          });
          createLayerIconGroup.addTo(lmap);
          var bookmarkIcon = L.control.gmxIcon({
            id: 'bookmark',
            title: _gtxt('Добавить закладку'),
            addBefore: 'drawing'
          });
          bookmarkIcon.on('click', function () {
            mapHelp.tabs.load('mapTabs');

            _queryTabs.add();
          });
          bookmarkIcon.addTo(lmap);
          resolveToolConflict(createLayerIconGroup);
        } else {
          resolveToolConflict(lmap.gmxControlIconManager.get('drawing'));
        }

        var printIcon = L.control.gmxIcon({
          id: 'gmxprint',
          title: _gtxt('Печать'),
          addBefore: 'drawing'
        });
        printIcon.addTo(lmap);
        printIcon.on('click', _mapHelper$1.print.bind(_mapHelper$1));
        var permalinkIcon = L.control.gmxIcon({
          id: 'permalink',
          title: _gtxt('Ссылка на карту'),
          addBefore: 'drawing'
        });
        permalinkIcon.addTo(lmap);
        permalinkIcon.on('click', _mapHelper$1.showPermalink.bind(_mapHelper$1));

        if (window.mapsSite) {
          var shareIconControl = new nsGmx$1.ShareIconControl({
            className: 'shareIcon',
            id: 'share',
            text: 'Share',
            style: {
              width: 'auto'
            },
            togglable: true,
            permalinkManager: {
              save: function save() {
                return $.when(_mapHelper$1.createPermalink(), nsMapCommon.generateWinniePermalink());
              }
            },
            permalinkUrlTemplate: '{{href}}?permalink={{permalinkId}}',
            embeddedUrlTemplate: window.location.protocol + '//winnie.kosmosnimki.ru/2.0/?config={{winnieId}}',
            winnieUrlTemplate: window.location.protocol + '//winnie.kosmosnimki.ru/2.0/?config={{winnieId}}&edit=1',
            previewUrlTemplate: 'iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}'
          });
          lmap.addControl(shareIconControl);
        }

        var gridIcon = L.control.gmxIcon({
          id: 'gridTool',
          title: _gtxt('Координатная сетка'),
          togglable: true,
          addBefore: 'drawing'
        });
        gridIcon.addTo(lmap);
        gridIcon.on('click', function () {
          var state = {
            isActive: gridIcon.options.isActive
          };
          nsGmx$1.gridManager.setState(state);
        });

        _mapHelper$1.customParamsManager.addProvider({
          name: 'GridManager',
          loadState: function loadState(state) {
            nsGmx$1.gridManager.setState(state);
          },
          saveState: function saveState() {
            return {
              version: '1.0.0',
              isActive: gridIcon.options.isActive,
              options: nsGmx$1.gridManager.options
            };
          }
        });

        lmap.addControl(L.control.gmxIcon({
          id: 'boxzoom-dashed-rounded',
          toggle: true,
          addBefore: 'drawing',
          title: 'Увеличение',
          onAdd: function onAdd(control) {
            var map = control._map,
                _onMouseDown = map.boxZoom._onMouseDown;

            map.boxZoom._onMouseDown = function (e) {
              _onMouseDown.call(map.boxZoom, {
                clientX: e.clientX,
                clientY: e.clientY,
                which: 1,
                shiftKey: true
              });
            };

            map.on('boxzoomend', function () {
              map.dragging.enable();
              map.boxZoom.removeHooks();
              control.setActive(false);
            });
          },
          stateChange: function stateChange(control) {
            var map = control._map;

            if (control.options.isActive) {
              map.dragging.disable();
              map.boxZoom.addHooks();
            } else {
              map.dragging.enable();
              map.boxZoom.removeHooks();
            }
          }
        }));
        /**
         * seachParams
         */

        var osmProvider = new nsGmx$1.searchProviders.Osm2DataProvider({
          showOnMap: true,
          serverBase: '//maps.kosmosnimki.ru',
          limit: 10
        });
        var searchProviders = [];
        searchProviders.push(osmProvider);
        osmProvider.addEventListener('fetch', function (e) {
          window.searchLogic.showResult(e.detail);
        });
        window.searchControl = new main_4({
          id: 'searchcontrol',
          placeHolder: 'Поиск по векторным слоям и адресной базе',
          position: 'topright',
          limit: 10,
          retrieveManyOnEnter: true,
          providers: searchProviders,
          style: {
            editable: false,
            map: true,
            pointStyle: {
              size: 8,
              weight: 1,
              opacity: 1,
              color: '#00008B'
            },
            lineStyle: {
              fill: false,
              weight: 3,
              opacity: 1,
              color: '#008B8B'
            }
          }
        });
        window.searchLogic.searchControl = window.searchControl;
        lmap.addControl(window.searchControl);
        lmap.gmxControlsManager.add(window.searchControl); // shitty trick
        // 'cause Aryunov doesn't use controls id

        window.searchControl._container._id = 'searchcontrol';
        var searchContainer = window.searchControl._widget._container;
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent.on(searchContainer, 'mousemove', stop).on(searchContainer, 'touchstart', stop).on(searchContainer, 'mousedown', stop).on(searchContainer, 'dblclick', stop).on(searchContainer, 'contextmenu', stop).on(searchContainer, 'click', stop);
        var gmxLayers = new L.control.gmxLayers2(null, null, {
          title: window._gtxt('Панель оверлеев'),
          collapsed: true,
          togglable: true,
          addBefore: 'searchcontrol',
          direction: '',
          placeHolder: window._gtxt("оверлеи отсутствуют")
        });
        lmap.addControl(gmxLayers);
        lmap.gmxControlsManager.add(gmxLayers);
      };

      var createDefaultMenu = function createDefaultMenu() {
        _menuUp.submenus = [];

        _menuUp.addItem({
          id: 'mapsMenu',
          title: _gtxt('Карта'),
          childs: [{
            id: 'mapCreate',
            title: _gtxt('Создать'),
            func: function func() {
              _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap);
            }
          }, {
            id: 'mapList',
            title: _gtxt('Открыть'),
            func: function func() {
              _queryMapLayers.getMaps();
            }
          }]
        });

        _menuUp.addItem({
          id: 'helpMenu',
          title: _gtxt('Справка'),
          childs: [{
            id: 'usage',
            title: _gtxt('Использование'),
            onsel: mapHelp.mapHelp.load,
            onunsel: mapHelp.mapHelp.unload
          }, {
            id: 'serviceHelp',
            title: _gtxt('Сервисы'),
            onsel: mapHelp.serviceHelp.load,
            onunsel: mapHelp.serviceHelp.unload
          }, {
            id: 'about',
            title: _gtxt('О проекте'),
            func: _mapHelper$1.version
          }]
        });
      };

      var parseURLParams = function parseURLParams() {
        var q = window.location.search,
            kvp = q.length > 1 ? q.substring(1).split('&') : [];

        for (var i = 0; i < kvp.length; i++) {
          kvp[i] = kvp[i].split('=');
        }

        var params = {},
            givenMapName = false;

        for (var j = 0; j < kvp.length; j++) {
          if (kvp[j].length == 1) {
            if (!givenMapName) givenMapName = decodeURIComponent(kvp[j][0]);
          } else {
            params[kvp[j][0]] = kvp[j][1];
          }
        }

        return {
          params: params,
          givenMapName: givenMapName
        };
      };

      $(function () {
        var virtualLayerManager = new nsGmx$1.VirtualLayerManager();
        L.gmx.addLayerClassLoader(virtualLayerManager.loader);
        $('body').on('keyup', function (event) {
          if ((event.target === document.body || $(event.target).hasClass('leaflet-container')) && event.keyCode === 79) {
            _queryMapLayers.getMaps();

            return false;
          }
        });
        var languageFromSettings = translationsHash.getLanguageFromCookies() || window.defaultLang;
        window.language = languageFromSettings || 'rus';
        window.shownTitle = window.pageTitle || _gtxt('ScanEx Web Geomixer - просмотр карты');
        document.title = window.shownTitle;
        window.serverBase = _serverBase;
        addParseResponseHook('*', function (response) {
          if (response.Warning) {
            //мы дожидаемся загрузки дерева слоёв, чтобы не добавлять notification widget слишком рано (до инициализации карты в контейнере)
            _queryMapLayers.loadDeferred.then(function () {
              nsGmx$1.widgets.notifications.stopAction(null, 'warning', response.Warning, 0);
            });
          }
        });
        var customErrorTemplate = Handlebars.compile('<div class="CustomErrorText">{{description}}</div>'),
            commonErrorTemplate = Handlebars.compile('<div class="CommonErrorText"><table class="CommonErrorTable">' + '<tr><td>{{message}}</td></tr>' + '<tr class="StacktraceContainer"><td class="StacktraceContainer">{{#if stacktrace}}<textarea class="inputStyle error StacktraceErrorText">{{stacktrace}}</textarea>{{/if}}</td></tr>' + '</table></div>'); //при каждой ошибке от сервера будем показывать диалог с ошибкой и стектрейсом.

        addParseResponseHook('error', function (response, customErrorDescriptions) {
          var errInfo = response.ErrorInfo;

          if (errInfo.ErrorMessage && !(errInfo.ErrorMessage in _mapHelper$1.customErrorsHash)) {
            if (customErrorDescriptions && errInfo.ExceptionType in customErrorDescriptions) {
              var canvas = $(customErrorTemplate({
                description: customErrorDescriptions[errInfo.ExceptionType]
              }));
              showDialog(_gtxt('Ошибка!'), canvas[0], 220, 100);
            } else {
              var stackTrace = response.ErrorInfo.ExceptionType && response.ErrorInfo.StackTrace;

              var _canvas = $(commonErrorTemplate({
                message: errInfo.ErrorMessage,
                stacktrace: stackTrace
              }));

              showDialog(_gtxt('Ошибка сервера'), _canvas[0], 220, 170, false, false);
              return false;
            }
          }
        });

        _translationsHash.addErrorHandler(function (text) {
          showErrorMessage('Не найдено тектовое описание для "' + text + '"');
        });

        nsGmx$1.pluginsManager = new (window.gmxCore.getModule('PluginsManager').PluginsManager)(); //будем сохранять в пермалинке все активные плагины

        _mapHelper$1.customParamsManager.addProvider({
          name: 'PluginManager',
          loadState: function loadState(state) {
            for (var p in state.usage) {
              var plugin = nsGmx$1.pluginsManager.getPluginByName(p);
              plugin && plugin.setUsage(state.usage[p] ? 'used' : 'notused');
            }
          },
          saveState: function saveState() {
            var usage = {};
            nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
              if (plugin.pluginName) {
                usage[plugin.pluginName] = plugin.isUsed();
              }
            });
            return {
              version: '1.0.0',
              usage: usage
            };
          }
        }); //сейчас подгружаются все глобальные плагины + все плагины карт, у которых нет имени в конфиге


        nsGmx$1.pluginsManager.done(function () {
          nsGmx$1.AuthManager.checkUserInfo(function () {
            nsGmx$1.pluginsManager.beforeMap();
            var parsedURL = parseURLParams();
            parseReferences(parsedURL.params, parsedURL.givenMapName);
          }, function () {//TODO: обработка ошибок
          });
        });
      });

      function parseReferences(params, givenMapName) {
        window.documentHref = window.location.href.split('?')[0];

        if (params['permalink']) {
          eraseCookie('TinyReference');
          createCookie('TinyReference', params['permalink']);

          if (location.search.indexOf('debug=1') === -1) {
            window.location.replace(window.documentHref + (givenMapName ? '?' + givenMapName : ''));
          } else {
            var tinyRef = readCookie('TinyReference');

            _mapHelper$1.restoreTinyReference(tinyRef, function (obj) {
              if (obj.mapName) {
                window.globalMapName = obj.mapName;
              }

              loadMap(obj);
            });
          }

          return;
        }

        var defaultState = {
          isFullScreen: params['fullscreen'] == 'true' || params['fullscreen'] == 'false' ? params['fullscreen'] : 'false'
        };
        if ('x' in params && 'y' in params && 'z' in params && !isNaN(Number(params.x)) && !isNaN(Number(params.y)) && !isNaN(Number(params.z))) defaultState.position = {
          x: Number(params.x),
          y: Number(params.y),
          z: Number(params.z)
        };
        if ('mx' in params && 'my' in params && !isNaN(Number(params.mx)) && !isNaN(Number(params.my))) defaultState.marker = {
          mx: Number(params.mx),
          my: Number(params.my),
          mt: 'mt' in params ? params.mt : false
        };
        if ('mode' in params) defaultState.mode = params.mode;

        if ('dt' in params) {
          defaultState.dt = params.dt;
        }

        window.defaultMapID = typeof window.defaultMapID !== 'undefined' ? window.defaultMapID : 'DefaultMap';
        var mapName = window.defaultMapID && !givenMapName ? window.defaultMapID : givenMapName;
        window.globalMapName = mapName;

        if (!window.globalMapName) {
          // нужно прописать дефолтную карту в конфиге
          alert(_gtxt('$$phrase$$_1'));
          return;
        } else {
          checkUserInfo(defaultState);
        }
      }

      function checkUserInfo(defaultState) {
        var tinyRef = readCookie('TinyReference');

        if (tinyRef) {
          eraseCookie('TinyReference');

          _mapHelper$1.restoreTinyReference(tinyRef, function (obj) {
            if (obj.mapName) {
              window.globalMapName = obj.mapName;
            }

            loadMap(obj);
          }, function () {
            loadMap(defaultState); //если пермалинк какой-то не такой, просто открываем дефолтное состояние
          });

          var tempPermalink = readCookie('TempPermalink');

          if (tempPermalink && tempPermalink == tinyRef) {
            nsGmx$1.Utils.TinyReference.remove(tempPermalink);
            eraseCookie('TempPermalink');
          }
        } else {
          loadMap(defaultState);
        }
      }

      window.layersShown = true;

      window.resizeAll = function () {
        if (window.printMode) {
          return;
        }

        var top = 0,
            bottom = 0,
            right = 0,
            left,
            headerHeight = $('#header').outerHeight(),
            mainDiv = $('#flash')[0];

        if (window.exportMode) {
          left = 0;
        } else if (window.iconSidebarWidget) {
          left = window.iconSidebarWidget.getWidth();
        } else {
          left = window.layersShown ? 400 : 40;
        }

        mainDiv.style.left = left + 'px';
        mainDiv.style.top = top + 'px';
        mainDiv.style.width = getWindowWidth() - left - right + 'px';
        mainDiv.style.height = getWindowHeight() - top - headerHeight - bottom + 'px';
        nsGmx$1.leafletMap && nsGmx$1.leafletMap.invalidateSize();

        if (window.layersShown) {
          $('#leftMenu').show();
          var mapNameHeight = $('.mainmap-title').outerHeight();
          var baseHeight = getWindowHeight() - top - bottom - headerHeight;
          $('#leftMenu')[0].style.height = baseHeight + 'px';
          var leftContentContainer = $('#leftContent')[0];

          if (leftContentContainer) {
            leftContentContainer.style.top = $('#leftPanelHeader')[0].offsetHeight + mapNameHeight + 'px';
            leftContentContainer.style.height = baseHeight - $('#leftPanelHeader')[0].offsetHeight - $('#leftPanelFooter')[0].offsetHeight - mapNameHeight + 'px';
          }
        } else {
          $('#leftMenu').hide();
        }
      };

      var editUIInited = false;

      var initEditUI = function initEditUI() {
        if (editUIInited) {
          return;
        }

        var isEditableLayer = function isEditableLayer(layer) {
          var props = layer.getGmxProperties(),
              layerRights = _queryMapLayers.layerRights(props.name);

          return props.type === 'Vector' && (layerRights === 'edit' || layerRights === 'editrows');
        };

        var hasEditableLayer = false;

        for (var iL = 0; iL < nsGmx$1.gmxMap.layers.length; iL++) {
          if (isEditableLayer(nsGmx$1.gmxMap.layers[iL])) {
            hasEditableLayer = true;
            break;
          }
        }

        if (!hasEditableLayer) return; //добавляем пункт меню к нарисованным объектам

        nsGmx$1.ContextMenuController.addContextMenuElem({
          title: _gtxt('EditObject.drawingMenuTitle'),
          isVisible: function isVisible() {
            var active = $(_queryMapLayers.treeCanvas).find('.active'); //должен быть векторный слой

            if (!active[0] || !active[0].parentNode.getAttribute('LayerID') || !active[0].parentNode.gmxProperties.content.properties.type === 'Vector') {
              return false;
            } //TODO: проверить тип геометрии


            var layer = nsGmx$1.gmxMap.layersByID[active[0].parentNode.gmxProperties.content.properties.name]; //слой поддерживает редактирование и у нас есть права на это

            return isEditableLayer(layer);
          },
          clickCallback: function clickCallback(context) {
            var active = $(_queryMapLayers.treeCanvas).find('.active');
            var layerName = active[0].parentNode.gmxProperties.content.properties.name;
            new nsGmx$1.EditObjectControl(layerName, null, {
              drawingObject: context.obj
            });
          }
        }, 'DrawingObject'); //добавляем пункт меню ко всем слоям

        nsGmx$1.ContextMenuController.addContextMenuElem({
          title: _gtxt('EditObject.menuTitle'),
          isVisible: function isVisible(context) {
            var layer = nsGmx$1.gmxMap.layersByID[context.elem.name];
            return !context.layerManagerFlag && isEditableLayer(layer);
          },
          clickCallback: function clickCallback(context) {
            new nsGmx$1.EditObjectControl(context.elem.name);
          }
        }, 'Layer'); //добавляем тул в тублар карты

        var listeners = {}; // var pluginPath = window.gmxCore.getModulePath('EditObjectPlugin');

        var editIcon = L.control.gmxIcon({
          id: 'editTool',
          title: _gtxt('Редактировать'),
          togglable: true,
          addBefore: 'gmxprint'
        }).addTo(nsGmx$1.leafletMap);
        editIcon.on('statechange', function () {
          if (editIcon.options.isActive) {
            var clickHandler = function clickHandler(event) {
              var layer = event.target,
                  props = layer.getGmxProperties(),
                  id = event.gmx.properties[props.identityField];
              layer.bringToTopItem(id);
              new nsGmx$1.EditObjectControl(props.name, id, {
                event: event
              });
              return true; // TODO: как oтключить дальнейшую обработку события
            };

            for (var _iL = 0; _iL < nsGmx$1.gmxMap.layers.length; _iL++) {
              var layer = nsGmx$1.gmxMap.layers[_iL],
                  props = layer.getGmxProperties();

              if (layer.disableFlip && layer.disablePopup) {
                layer.disableFlip();
                layer.disablePopup();
              }

              listeners[props.name] = clickHandler.bind(null); //bind чтобы были разные ф-ции

              if (layer instanceof L.gmx.VectorLayer) {
                layer.on('click', listeners[props.name]);
              }
            }
          } else {
            for (var layerName in listeners) {
              // let pt = listeners[layerName];
              var _layer = nsGmx$1.gmxMap.layersByID[layerName];

              if (_layer && _layer instanceof L.gmx.VectorLayer) {
                _layer.off('click', listeners[layerName]);

                if (_layer.getGmxProperties().type !== 'Virtual') {
                  _layer.enableFlip();

                  _layer.enablePopup();
                }
              }
            }

            listeners = {};
          }
        });
        editUIInited = true;
      };

      function initAuthWidget() {
        var registrationCallback = function registrationCallback() {
          window.gmxCore.loadModule('ProfilePlugin').then(function (AccountModule) {
            AccountModule.showRegistrationForm(function () {
              window.location.reload();
            });
          });
        };

        var nativeAuthWidget = new nsGmx$1.GeoMixerAuthWidget($('<div/>')[0], nsGmx$1.AuthManager, function () {
          _mapHelper$1.reloadMap();
        }, {
          registrationCallback: registrationCallback
        }); // прокси между nsGmx.AuthManager редактора и AuthManager'а из общей библиотеки

        var authManagerProxy = {
          getUserInfo: function getUserInfo() {
            var def = $.Deferred();
            nsGmx$1.AuthManager.checkUserInfo(function () {
              var auth = nsGmx$1.AuthManager;
              def.resolve({
                Status: 'ok',
                Result: {
                  Login: auth.getLogin(),
                  Nickname: auth.getNickname(),
                  FullName: auth.getFullname()
                }
              });
            });
            return def;
          },
          login: function login() {
            nativeAuthWidget.showLoginDialog();
          },
          logout: function logout() {
            var def = $.Deferred();
            nsGmx$1.AuthManager.logout(function () {
              def.resolve({
                Status: 'ok',
                Result: {}
              });

              _mapHelper$1.reloadMap();
            });
            return def;
          },
          getNative: function getNative() {
            return nativeAuthWidget;
          }
        };
        nsGmx$1.widgets.authWidget = new nsGmx$1.AuthWidget({
          authManager: authManagerProxy,
          showAccountLink: !!window.mapsSite,
          accountLink: null,
          showMapLink: !!window.mapsSite,
          changePassword: !window.mapsSite,
          isAdmin: nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
          callbacks: {
            'authWidget-usergroupMenuItem': showUserList
          }
        });
        var authPlaceholder = nsGmx$1.widgets.header.getAuthPlaceholder();
        nsGmx$1.widgets.authWidget.appendTo(authPlaceholder);
        authPlaceholder.on('click', '#AuthWidgetAccountLink', function () {
          window.gmxCore.loadModule('ProfilePlugin').then(function (AccountModule) {
            AccountModule.showProfile();
          });
        }); //ugly hack

        nsGmx$1.widgets.authWidget.showLoginDialog = nativeAuthWidget.showLoginDialog.bind(nativeAuthWidget);
      }

      function loadMap(state) {
        //при переходе на новое API мы изменили место хранения мапплетов карты
        //раньше мапплеты хранились в свойстве onLoad карты
        //теперь - внутри клиентских данных (UserData)
        nsGmx$1.mappletLoader = {
          _script: '',
          //UserObjectsManager interface
          collect: function collect() {
            return this._script;
          },
          load: function load(data) {
            this._script = data;
          },
          //self public interface
          execute: function execute() {// if (this._script) {
            //     var evalStr = '(' + this._script + ')';
            //     try {
            //         eval(evalStr)();
            //     } catch (e) {
            //         console.error(e);
            //     }
            // }
          },
          get: function get() {
            return this._script;
          },
          set: function set(data) {
            this._script = data;
          }
        };
        nsGmx$1.userObjectsManager.addDataCollector('mapplet_v2', nsGmx$1.mappletLoader);
        window.layersShown = state.isFullScreen == 'false';

        if (state.language) {
          window.language = state.language;
          translationsHash.updateLanguageCookies(window.language);
        }

        window.onresize = window.resizeAll;
        window.resizeAll();
        L.Icon.Default.imagePath = (window.gmxJSHost || '') + 'img';
        var iconUrl = L.Icon.Default.imagePath + '/flag_blau1.png';

        if (L.version !== '0.7.7') {
          L.Icon.Default = L.Icon.Default.extend({
            _getIconUrl: function _getIconUrl(name) {
              return L.Icon.prototype._getIconUrl.call(this, name);
            }
          });
        }

        L.Marker = L.Marker.extend({
          options: {
            icon: new L.Icon.Default({
              iconUrl: iconUrl,
              iconSize: [36, 41],
              iconAnchor: [7, 37],
              popupAnchor: [3, -25],
              shadowUrl: iconUrl,
              shadowSize: [0, 0],
              shadowAnchor: [0, 0],
              iconRetinaUrl: L.Icon.Default.imagePath + '/marker-icon.png'
            })
          }
        });

        L.marker = function (latlng, options) {
          return new L.Marker(latlng, options);
        };

        var hostName = L.gmxUtil.normalizeHostname(window.serverBase),
            apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера
        //мы явно получаем описание карты, но пока что не начинаем создание слоёв
        //это нужно, чтобы получить список плагинов и загрузить их до того, как начнутся создаваться слои

        var skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '';
        var srs = window.mapOptions ? window.mapOptions.srs : '';

        if (!srs) {
          var arr = location.href.match(/[?&][cs]rs=(\d+)/);

          if (arr) {
            srs = arr[1];
          }
        }

        var isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;
        L.gmx.gmxMapManager.loadMapProperties({
          srs: srs,
          serverHost: hostName,
          apiKey: apiKey,
          mapName: window.globalMapName,
          skipTiles: skipTiles,
          isGeneralized: isGeneralized
        }).then(function (mapInfo) {
          var userObjects = state.userObjects || mapInfo && mapInfo.properties.UserData;
          userObjects && nsGmx$1.userObjectsManager.setData(JSON.parse(userObjects)); //в самом начале загружаем только данные о плагинах карты.
          //Остальные данные будем загружать чуть позже после частичной инициализации вьюера
          //О да, формат хранения данных о плагинах часто менялся!
          //Поддерживаются все предыдущие форматы из-за старых версий клиента и сложности обновления базы данных

          nsGmx$1.userObjectsManager.load('mapPlugins');
          nsGmx$1.userObjectsManager.load('mapPlugins_v2');
          nsGmx$1.userObjectsManager.load('mapPlugins_v3'); //вызываем сразу после загрузки списка плагинов ГеоМиксера,
          //так как в state может содержаться информация о включённых плагинах

          if (state.customParamsCollection) {
            _mapHelper$1.customParamsManager.loadParams(state.customParamsCollection);
          } //после загрузки списка плагинов карты начали загружаться не глобальные плагины,
          //у которых имя плагина было прописано в конфиге. Ждём их загрузки.


          nsGmx$1.pluginsManager.done(function () {
            nsGmx$1.pluginsManager.preloadMap();
            L.gmx.loadMap(window.globalMapName, {
              srs: srs,
              skipTiles: skipTiles,
              hostName: window.serverBase,
              apiKey: apiKey,
              setZIndex: true,
              isGeneralized: isGeneralized
            }).then(processGmxMap.bind(null, state));
          });
        }, function (resp) {
          initHeader();
          initAuthWidget();
          _menuUp.defaultHash = 'usage';

          _menuUp.createMenu = function () {
            createDefaultMenu();
            nsGmx$1.pluginsManager.addMenuItems(_menuUp);
          };

          _menuUp.go(nsGmx$1.widgets.header.getMenuPlaceholder()[0]);

          $('#left_usage').hide();

          _menuUp.checkView();

          var str = resp && resp.ErrorInfo && resp.ErrorInfo.ErrorMessage ? resp.ErrorInfo.ErrorMessage : 'У вас нет прав на просмотр данной карты';
          nsGmx$1.widgets.notifications.stopAction(null, 'failure', _gtxt(str) || str, 0);
          window.onresize = window.resizeAll;
          window.resizeAll();
          state.originalReference && createCookie('TinyReference', state.originalReference);
          nsGmx$1.widgets.authWidget.showLoginDialog();
        });
      } //создаём подложки в BaseLayerManager по описанию из config.js


      function initDefaultBaseLayers() {
        var lang = L.gmxLocale.getLanguage(),
            iconPrefix = 'img/baseLayers/',
            blm = nsGmx$1.leafletMap.gmxBaseLayersManager,
            zIndexOffset = 2000000,
            defaultMapID = window.baseMap.defaultMapID,
            promises = [],
            defaultHostName;

        if (window.baseMap.defaultHostName) {
          defaultHostName = window.baseMap.defaultHostName === '/' ? _serverBase : window.baseMap.defaultHostName;
        } else {
          defaultHostName = 'maps.kosmosnimki.ru';
        }

        if (window.baseMap.baseLayers) {
          var promise;

          (function () {
            var baseLayers = window.baseMap.baseLayers,
                bl; // проставляем дефолтным слоям свойства, зависящие от путей, языка, zIndex

            for (var i = 0; i < baseLayers.length; i++) {
              bl = baseLayers[i]; // у Спутника в конфиге нет иконки и копирайта

              if (bl.id === 'sputnik') {
                bl.icon = iconPrefix + 'basemap_sputnik_ru.png';
                bl.layers[0].attribution = '<a href="http://maps.sputnik.ru">Спутник</a> © ' + (lang === 'rus' ? 'Ростелеком' : 'Rostelecom') + ' | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
              } // у ОСМ в конфиге нет иконки и урл


              if (bl.id === 'OSM') {
                bl.icon = iconPrefix + 'basemap_osm_' + (lang === 'rus' ? 'ru' : 'eng') + '.png';
                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmo' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
              } // у гибрида в конфиге нет урл


              if (bl.id === 'OSMHybrid') {
                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmohyb' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png'; // bl.layers[0].setZIndex(zIndexOffset);
              } // у спутника нет иконки


              if (bl.id === 'satellite') {
                bl.icon = iconPrefix + 'basemap_satellite.png';
              }
            }

            for (var _i = 0; _i < baseLayers.length; _i++) {
              var _bl = baseLayers[_i];

              if (_bl.layers && _bl.layers.length) {
                var l = _bl.layers;

                for (var j = 0; j < l.length; j++) {
                  if (l[j].urlTemplate) {
                    // заменяем в подложках с айди описания слоев на L.tileLayers
                    l[j] = L.tileLayer(l[j].urlTemplate, l[j]);
                  } else {
                    // let currentTl = bl,
                    var layerID = l[j].layerID,
                        hostName = l[j].hostName || defaultHostName,
                        mapID = l[j].mapID || defaultMapID,
                        skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '',
                        srs = window.mapOptions ? window.mapOptions.srs : '',
                        isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;

                    if (!srs) {
                      var arr = location.href.match(/[?&][cs]rs=(\d+)/);

                      if (arr) {
                        srs = arr[1];
                      }
                    } // resolve promise -> заменяем в подложках с айди описания слоев на gmxLayers


                    promise = L.gmx.loadLayer(mapID, layerID, {
                      hostName: hostName,
                      srs: srs,
                      isGeneralized: isGeneralized,
                      skipTiles: skipTiles
                    }).then(function (layer) {
                      var id = layer.getGmxProperties().name;

                      for (var k = 0; k < baseLayers.length; k++) {
                        var _bl2 = baseLayers[k];

                        if (_bl2.layers && _bl2.layers.length) {
                          var l = _bl2.layers;

                          for (var m = 0; m < l.length; m++) {
                            if (l[m].layerID && l[m].layerID === id) {
                              l[m] = layer;
                            }
                          }
                        }
                      }
                    });
                    promises.push(promise);
                  }
                }
              }
            }
          })();
        }

        return L.gmx.Deferred.all.apply(null, promises).then(function () {
          if (window.baseMap.baseLayers) {
            var layers = window.baseMap.baseLayers,
                layersToLoad = {};
            layers.forEach(function (bl) {
              layersToLoad[bl.id] = bl;
            }); // добавим в гибрид снимок

            if (layersToLoad.satellite && layersToLoad.OSMHybrid) {
              layersToLoad.OSMHybrid.layers[0].setZIndex(zIndexOffset);
              layersToLoad.OSMHybrid.layers.push(layersToLoad.satellite.layers[0]);
            }

            _$1.each(layersToLoad, function (l, name) {
              blm.add(name, l);
            });
          }
        });
      }

      function showUserList() {
        window.gmxCore.loadModule('UserGroupWidget').then(function (module) {
          var canvas = $('<div/>');
          new module.UserGroupListWidget(canvas);
          canvas.dialog({
            width: 400,
            height: 400,
            title: _gtxt('Управление группами пользователей')
          });
        });
      } // Инициализации шапки. Будем оттягивать с инициализацией до последнего момента, так как при инициализации
      // требуется знать текущий язык, а он становится известен только после загрузки карты


      function initHeader() {
        // var rightLinks = [];
        nsGmx$1.widgets.header = new nsGmx$1.HeaderWidget({
          logo: window.gmxViewerUI && window.gmxViewerUI.logoImage || 'img/geomixer_transpar_small.svg'
        });
        nsGmx$1.widgets.header.appendTo($('.header'));
      }

      function processGmxMap(state, gmxMap) {
        var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
        var defCenter = [55.7574, 37.5952],
            mapProps = gmxMap.properties,
            defZoom = mapProps.DefaultZoom || 5,
            data = gmxMap.rawTree;

        if (mapProps.DefaultLat && mapProps.DefaultLong) {
          defCenter = [mapProps.DefaultLat, mapProps.DefaultLong];
        } else {
          //подсчитаем общий extend всех видимых слоёв
          var visBounds = L.latLngBounds([]);

          for (var l = 0; l < gmxMap.layers.length; l++) {
            var layer = gmxMap.layers[l];

            if (layer.getGmxProperties().visible && layer.getBounds) {
              visBounds.extend(layer.getBounds());
            }
          }

          if (visBounds.isValid()) {
            //вычислям центр и максимальный zoom по bounds (map.fitBounds() использовать не можем, так как ещё нет карты)
            var proj = L.Projection.Mercator;
            var mercBounds = L.bounds([proj.project(visBounds.getNorthWest()), proj.project(visBounds.getSouthEast())]);
            var ws = 2 * proj.project(L.latLng(0, 180)).x,
                screenSize = [$('#flash').width(), $('#flash').height()];
            var zoomX = Math.log(ws * screenSize[0] / (mercBounds.max.x - mercBounds.min.x)) / Math.log(2) - 8;
            var zoomY = Math.log(ws * screenSize[1] / (mercBounds.max.y - mercBounds.min.y)) / Math.log(2) - 8;
            defZoom = Math.floor(Math.min(zoomX, zoomY, 17));
            defCenter = proj.unproject(mercBounds.getCenter());
          }
        } //если информации о языке нет ни в куках ни в config.js, то используем данные о языке из карты


        if (!translationsHash.getLanguageFromCookies() && !window.defaultLang && data) {
          window.language = data.properties.DefaultLanguage;
        }

        initHeader();

        if (!window.gmxViewerUI || !window.gmxViewerUI.hideLanguage) {
          var langContainer = nsGmx$1.widgets.header.getLanguagePlaceholder();
          nsGmx$1.widgets.languageWidget = new nsGmx$1.LanguageWidget();
          nsGmx$1.widgets.languageWidget.appendTo(langContainer);
        }

        var mapOptions = L.extend(window.mapOptions ? window.mapOptions : {}, {
          contextmenu: true,
          // если есть пермалинк, центрируем и зумируем карту сразу по его параметрам
          center: state.position ? [state.position.y, state.position.x] : defCenter,
          zoom: state.position ? state.position.z : defZoom,
          // boxZoom: false,
          zoomControl: false,
          attributionControl: false,
          trackResize: true,
          fadeAnimation: !window.gmxPhantom,
          // отключение fadeAnimation при запуске тестов
          zoomAnimation: !window.gmxPhantom,
          // отключение zoomAnimation при запуске тестов
          distanceUnit: mapProps.DistanceUnit,
          squareUnit: mapProps.SquareUnit,
          minZoom: mapProps.MinZoom || undefined,
          maxZoom: mapProps.MaxZoom || undefined,
          maxPopupCount: mapProps.maxPopupContent
        });
        var lmap = new L.Map($('#flash')[0], mapOptions); // update layers zIndexes

        var currentZoom = lmap.getZoom(),
            layerOrder = gmxMap.rawTree.properties.LayerOrder;
        updateZIndexes();
        lmap.on('zoomend', function () {
          currentZoom = lmap.getZoom();
          updateZIndexes();
        }); //clip polygons

        if (mapProps.MinViewX && mapProps.MinViewY && mapProps.MaxViewX && mapProps.MaxViewY) {
          lmap.on('layeradd', function (e) {
            if (e.layer.addClipPolygon) {
              _mapHelper$1.clipLayer(e.layer, mapProps);
            }
          });
        } // bind clusters to photoLayers


        for (var _l = 0; _l < gmxMap.layers.length; _l++) {
          var _layer2 = gmxMap.layers[_l],
              props = _layer2.getGmxProperties();

          if (props.IsPhotoLayer) {
            _layer2.bindClusters({
              iconCreateFunction: function iconCreateFunction(cluster) {
                var photoClusterIcon = L.divIcon({
                  html: '<img src="' + (window.serverBase ? window.serverBase + _mapHelper$1.defaultPhotoIconStyles.point.marker.image : _mapHelper$1.defaultPhotoIconStyles.point.marker.image) + '" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                  className: 'photo-div-icon',
                  iconSize: [14, 12],
                  iconAnchor: [0, 0]
                });
                return photoClusterIcon;
              },
              maxClusterRadius: 40,
              spiderfyOnMaxZoom: true,
              spiderfyZoom: 14,
              spiderfyDistanceMultiplier: 1.2,
              disableClusteringAtZoom: 19,
              maxZoom: 19
            });
          }
        }

        lmap.contextmenu.insertItem({
          text: _gtxt('Поставить маркер'),
          callback: function callback(event) {
            lmap.gmxDrawing.addGeoJSON({
              type: 'Point',
              coordinates: [event.latlng.lng, event.latlng.lat]
            });
          }
        });
        lmap.contextmenu.insertItem({
          text: _gtxt('Центрировать'),
          callback: function callback(event) {
            lmap.setView(event.latlng);
          }
        });

        function updateZIndexes() {
          for (var l = 0; l < gmxMap.layers.length; l++) {
            var layer = gmxMap.layers[l],
                props = layer.getGmxProperties();

            switch (layerOrder) {
              case 'VectorOnTop':
                if (props.type === 'Vector' && layer.setZIndexOffset) {
                  var rcMinZoom = void 0,
                      quickLookMinZoom = void 0,
                      defaultMinZoom = 6;

                  if (props.IsRasterCatalog || props.Quicklook && props.Quicklook !== 'null') {
                    rcMinZoom = props.IsRasterCatalog ? props.RCMinZoomForRasters : null;
                    quickLookMinZoom = props.Quicklook && nsGmx$1.Utils.isJSON(props.Quicklook) ? JSON.parse(props.Quicklook).minZoom : null;

                    if (props.IsRasterCatalog && !props.Quicklook) {
                      var minZoom = nsGmx$1.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                    } else if (!props.IsRasterCatalog && props.Quicklook) {
                      var _minZoom = nsGmx$1.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                    } else if (props.IsRasterCatalog && props.Quicklook) {
                      rcMinZoom = nsGmx$1.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                      quickLookMinZoom = nsGmx$1.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                    }

                    layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                  } else {
                    layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                  }
                }

                break;
            }
          }
        } // Begin: запоминание текущей позиции карты


        function saveMapPosition(key) {
          window.localStorage.setItem('lastMapPosiotion_' + key, JSON.stringify({
            zoom: lmap.getZoom(),
            center: lmap.getCenter()
          }));
        }

        function getMapPosition(key) {
          return JSON.parse(localStorage.getItem('lastMapPosiotion_' + key));
        }

        lmap.on('boxzoomstart', function () {
          saveMapPosition('z');
        });
        L.DomEvent.on(document, 'keydown', function (ev) {
          var key = ev.key;

          if (lmap.gmxMouseDown === 1) {
            var pos = getMapPosition(key);

            if (pos && (key === 'z' || Number(key) >= 0)) {
              lmap.setView(pos.center, pos.zoom);
            }
          } else if (lmap.gmxMouseDown > 1) {
            if (Number(key) >= 0) {
              saveMapPosition(key);
            }
          }
        }, lmap); // End: запоминание текущей позиции карты

        lmap.gmxControlsManager.init(window.controlsOptions); // lmap.addControl(new L.Control.gmxLayers(lmap.gmxBaseLayersManager, {
        //     // position: 'topleft',
        //     collapsed: true,
        //     hideBaseLayers: true
        // }));

        nsGmx$1.leafletMap = lmap;
        var loc = nsGmx$1.leafletMap.gmxControlsManager.get('location');
        loc.setCoordinatesFormat(gmxMap.properties.coordinatesFormat);
        loc.on('coordinatesformatchange', function (ev) {
          nsGmx$1.leafletMap.options.coordinatesFormat = ev.coordinatesFormat;
        });
        var baseLayerDef = 'baseMap' in window ? initDefaultBaseLayers() : lmap.gmxBaseLayersManager.initDefaults({
          hostName: window.mapHostName,
          apiKey: window.apiKey,
          srs: lmap.options.srs,
          skipTiles: lmap.options.skipTiles,
          isGeneralized: lmap.options.isGeneralized
        });
        baseLayerDef.then(function () {
          nsGmx$1.gmxMap = gmxMap;
          window.gmxAPI.layersByID = gmxMap.layersByID; // слои по layerID

          var mapProp = gmxMap.rawTree.properties || {};
          var baseLayers = mapProp.BaseLayers ? JSON.parse(mapProp.BaseLayers) : [window.language === 'eng' ? 'mapbox' : 'sputnik', 'OSMHybrid', 'satellite'];
          lmap.gmxBaseLayersManager.setActiveIDs(baseLayers);
          var baseLayersControl = new L.Control.GmxIconLayers(lmap.gmxBaseLayersManager, {
            id: 'iconLayers'
          });
          lmap.gmxControlsManager.add(baseLayersControl);
          lmap.addControl(baseLayersControl);
          nsGmx$1.widgets.commonCalendar = new nsGmx$1.CommonCalendarWidget(); // добавление временных слоев в commonCalendar
          // добавление происходит безопасно, в клон объекта со списком слоев

          var initTemporalLayers = function initTemporalLayers(layers) {
            layers = layers || nsGmx$1.gmxMap.layers;
            var attrs = nsGmx$1.widgets.commonCalendar.model.toJSON(),
                showCalendar = undefined,
                dateInterval,
                dateBegin,
                dateEnd;

            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i],
                  props = layer.getGmxProperties(),
                  // isVisible = props.visible,
              isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.setDateInterval;

              if (isTemporalLayer) {
                // показываем виджет календаря, если в карте есть хоть один мультивременной слой
                showCalendar = true;
                dateInterval = layer.getDateInterval ? layer.getDateInterval() : new nsGmx$1.DateInterval();

                if (dateInterval.beginDate && dateInterval.endDate) {
                  dateBegin = dateInterval.beginDate;
                  dateEnd = dateInterval.endDate;
                } else {
                  dateInterval = new nsGmx$1.DateInterval();
                  dateBegin = dateInterval.get('dateBegin');
                  dateEnd = dateInterval.get('dateEnd');
                }

                if (!(props.name in attrs.unbindedTemporalLayers)) {
                  nsGmx$1.widgets.commonCalendar.bindLayer(props.name);
                  layer.setDateInterval(dateBegin, dateEnd);

                  if (props.LayerID in attrs.dailyFiltersHash) {
                    nsGmx$1.widgets.commonCalendar.applyDailyFilter([layer]);
                  }
                } //подписка на изменение dateInterval


                if (layer.getDateInterval) {
                  layer.on('dateIntervalChanged', nsGmx$1.widgets.commonCalendar.onDateIntervalChanged, nsGmx$1.widgets.commonCalendar);
                }
              }
            }

            nsGmx$1.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            if (showCalendar && !attrs.isAppended) {
              nsGmx$1.widgets.commonCalendar.show();
            }
          }; // привяжем изменение активной ноды к календарю


          $(_layersTree).on('activeNodeChange', function (e, p) {
            var layerID = $(p).attr('layerid'); // calendar = nsGmx.widgets.commonCalendar.model.get('calendar'),
            // synchronyzed = nsGmx.widgets.commonCalendar.model.get('synchronyzed');

            lmap.fireEvent('layersTree.activeNodeChange', {
              layerID: layerID
            });
          });
          $(_layersTree).on('layerVisibilityChange', function (event, elem) {
            var props = elem.content.properties,
                attrs = nsGmx$1.widgets.commonCalendar.model.toJSON(),
                visible = props.visible,
                layerID = props.LayerID,
                // calendar = attrs.calendar,
            currentLayer = attrs.currentLayer,
                synchronyzed = attrs.synchronyzed;

            if (synchronyzed) {
              return;
            } else if (layerID) {
              var _layer3 = nsGmx$1.gmxMap.layersByID[layerID],
                  _props = _layer3.getGmxProperties(),
                  isTemporalLayer = _layer3 instanceof L.gmx.VectorLayer && _props.Temporal || _props.type === 'Virtual' && _layer3.getDateInterval,
                  visibleTemporalLayers,
                  index;

              if (isTemporalLayer) {
                if (visible) {
                  if (currentLayer) {
                    return;
                  } else {
                    var dateInterval = _layer3.getDateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                      nsGmx$1.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, _layer3);
                    }
                  }
                } else if (currentLayer) {
                  if (layerID !== currentLayer) {
                    return;
                  } else {
                    visibleTemporalLayers = getLayersListWithTarget(nsGmx$1.gmxMap.layers, _layer3);
                    index = visibleTemporalLayers.indexOf(_layer3);

                    if (visibleTemporalLayers.length === 1) {
                      nsGmx$1.widgets.commonCalendar.model.set('currentLayer', null);
                    } else if (index === 0) {
                      var targetLayer = visibleTemporalLayers[index + 1],
                          // targetLayerID = targetLayer.getGmxProperties().LayerID,
                      _dateInterval = targetLayer.getDateInterval();

                      nsGmx$1.widgets.commonCalendar.setDateInterval(_dateInterval.beginDate, _dateInterval.endDate, targetLayer); // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                    } else {
                      var _targetLayer = visibleTemporalLayers[index - 1],
                          // targetLayerID = targetLayer.getGmxProperties().LayerID,
                      _dateInterval2 = _targetLayer.getDateInterval();

                      nsGmx$1.widgets.commonCalendar.setDateInterval(_dateInterval2.beginDate, _dateInterval2.endDate, _targetLayer); // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                    }
                  }
                } else {
                  return;
                }
              }
            }

            nsGmx$1.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            function getLayersListWithTarget(layers, targetLayer) {
              var visibleTemporalLayers = [];

              for (var i = 0; i < layers.length; i++) {
                var _layer4 = layers[i],
                    _props2 = _layer4.getGmxProperties && _layer4.getGmxProperties(),
                    _isTemporalLayer = void 0,
                    isVisible = void 0;

                if (_props2) {
                  _isTemporalLayer = _layer4 instanceof L.gmx.VectorLayer && _props2.Temporal || _props2.type === 'Virtual' && _layer4.getDateInterval;
                  isVisible = _props2.visible;

                  if (_isTemporalLayer && isVisible || _layer4 === targetLayer) {
                    visibleTemporalLayers.push(_layer4);
                  }
                }
              }

              return visibleTemporalLayers;
            }
          });
          $(_layersTree).on('styleVisibilityChange', function (event, styleVisibilityProps) {
            var it = nsGmx$1.gmxMap.layersByID[styleVisibilityProps.elem.name],
                styles = it.getStyles(),
                st = styles[styleVisibilityProps.styleIndex];
            var div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + styleVisibilityProps.elem.LayerID + "']")[0],
                elemProperties = div.gmxProperties.content.properties,
                treeStyles = window.newStyles ? elemProperties.gmxStyles.styles : elemProperties.styles,
                treeSt = treeStyles[styleVisibilityProps.styleIndex];

            if (typeof treeSt._MinZoom === 'undefined') {
              treeSt._MinZoom = treeSt.MinZoom;
            }

            if (styleVisibilityProps.show) {
              treeSt.MinZoom = treeSt._MinZoom;
              st.MinZoom = treeSt._MinZoom;
              treeSt.disabled = false;
            } else {
              treeSt.disabled = true;
            }

            st.disabled = treeSt.disabled;
            it.setStyles(styles);
          });

          _mapHelper$1.customParamsManager.addProvider({
            name: 'commonCalendar',
            loadState: function loadState(state) {
              if (!('version' in state)) {
                var tmpDateInterval = new nsGmx$1.DateInterval({
                  dateBegin: new Date(state.dateBegin),
                  dateEnd: new Date(state.dateEnd)
                });
                nsGmx$1.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
              } else if (state.version === '1.0.0') {
                nsGmx$1.widgets.commonCalendar.model.set('synchronyzed', typeof state.synchronyzed !== 'undefined' ? state.synchronyzed : true);
                nsGmx$1.widgets.commonCalendar.model.set('currentLayer', typeof state.currentLayer !== 'undefined' ? state.currentLayer : null);
                nsGmx$1.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
                nsGmx$1.widgets.commonCalendar.model.set('dailyFilter', typeof state.dailyFilter !== 'undefined' ? state.dailyFilter : true);
              } else {
                throw 'Unknown params version';
              }
            },
            saveState: function saveState() {
              return {
                version: '1.0.0',
                dateInterval: nsGmx$1.widgets.commonCalendar.getDateInterval().saveState(),
                currentLayer: nsGmx$1.widgets.commonCalendar.model.get('currentLayer'),
                synchronyzed: nsGmx$1.widgets.commonCalendar.model.get('synchronyzed'),
                dailyFilter: nsGmx$1.widgets.commonCalendar.model.get('dailyFilter')
              };
            }
          });

          $('#flash').bind('dragover', function () {
            return false;
          });
          $('#flash').bind('drop', function (e) {
            if (!e.originalEvent.dataTransfer) {
              return;
            }

            _queryLoadShp.loadAndShowFiles(e.originalEvent.dataTransfer.files);

            return false;
          });

          if (state.dt) {
            try {
              var dateLocal = $.datepicker.parseDate('dd.mm.yy', state.dt);
              var dateBegin = nsGmx$1.CalendarWidget.fromUTC(dateLocal);
              var dateEnd = new Date(dateBegin.valueOf() + 24 * 3600 * 1000);
              var dateInterval = nsGmx$1.widgets.commonCalendar.getDateInterval();
              dateInterval.set({
                dateBegin: dateBegin,
                dateEnd: dateEnd
              });
            } catch (e) {
              console.log(e);
            }
          }

          nsGmx$1.pluginsManager.beforeViewer(); //для каждого ответа сервера об отсутствии авторизации (Status == 'auth') сообщаем об этом пользователю или предлагаем залогиниться

          addParseResponseHook('auth', function () {
            if (nsGmx$1.AuthManager.isLogin()) {
              showErrorMessage(_gtxt('Недостаточно прав для совершения операции'), true);
            } else {
              nsGmx$1.widgets.authWidget.showLoginDialog();
            }

            return false;
          });
          initAuthWidget(); //инициализация контролов пользовательских объектов
          //соответствующий модуль уже загружен
          // let oDrawingObjectsModule = window.gmxCore.getModule('DrawingObjects');

          window.oDrawingObjectGeomixer = new DrawingObjectGeomixer();
          window.oDrawingObjectGeomixer.Init(nsGmx$1.leafletMap, nsGmx$1.gmxMap); //для всех слоёв должно выполняться следующее условие: если хотя бы одна групп-предков невидима, то слой тоже невидим.

          (function fixVisibilityConstrains(o) {
            // o.content.properties.visible = o.content.properties.visible;
            if (o.type === 'group') {
              var a = o.content.children;
              var isAnyVisibleChild = false;

              for (var k = a.length - 1; k >= 0; k--) {
                var childrenVisibility = fixVisibilityConstrains(a[k]);
                isAnyVisibleChild = isAnyVisibleChild || childrenVisibility;
              } // если внутри группы есть включенные слои, группа тоже включается
              // если же ни одного включенного слоя нет, то группа выключается


              o.content.properties.visible = isAnyVisibleChild ? true : false;
            }

            return o.content.properties.visible;
          })({
            type: 'group',
            content: {
              children: data.children,
              properties: {
                visible: true
              }
            }
          });

          window.oldTree = JSON.parse(JSON.stringify(data));
          window.defaultLayersVisibility = {};

          for (var k = 0; k < gmxMap.layers.length; k++) {
            var _props3 = gmxMap.layers[k].getGmxProperties();

            window.defaultLayersVisibility[_props3.name] = _props3.visible;
          } //основная карта всегда загружена с того-же сайта, что и серверные скрипты


          data.properties.hostName = window.serverBase.slice(7).slice(0, -1); //DEPRICATED. Do not use it!

          _mapHelper$1.mapProperties = data.properties; //DEPRICATED. Do not use it!

          _mapHelper$1.mapTree = data;

          if (window.copyright && typeof window.copyright === 'string') {
            lmap.gmxControlsManager.get('copyright').setMapCopyright(window.copyright);
          }

          var condition = false,
              mapStyles = false,
              LayersTreePermalinkParams = false;

          if (state.condition) {
            condition = state.condition;
          }

          if (state.mapStyles) {
            mapStyles = state.mapStyles;
          }

          if (state.LayersTreePermalinkParams) {
            LayersTreePermalinkParams = state.LayersTreePermalinkParams;
          }
          /**
           *
           * SIDEBAR
           *
           */


          window.iconSidebarWidget = new IconSidebarWidget(document.getElementById('leftMenu'), {
            collapsedWidth: 40,
            extendedWidth: 400,
            position: 'left'
          });
          window.iconSidebarWidget.addEventListener('opened', window.resizeAll);
          window.iconSidebarWidget.addEventListener('closed', window.resizeAll);

          window.createTabFunction = function (options) {
            return function (state) {
              var el = document.createElement("div"),
                  tabEl = document.createElement("div"),
                  href = '#' + options.icon.toLowerCase(),
                  symbol = document.querySelector(href);
              $(el).addClass("tab-icon");
              if (symbol) $(symbol).addClass("sidebar-icon");
              tabEl.innerHTML = '<svg role="img" class="svgIcon">\
                    <use xlink:href="' + href + '" href="' + href + '"></use>\
                    </svg>';
              el.appendChild(tabEl);
              options.hint && el.setAttribute("title", options.hint);
              $(tabEl).addClass(options.icon);

              if (state === "active") {
                $(tabEl).addClass(options.active);
                $(el).addClass("tab-icon-active");
                if (symbol) $(symbol).addClass("sidebar-active-icon");
              } else {
                if (symbol && $(symbol).hasClass("sidebar-active-icon")) {
                  $(symbol).removeClass("sidebar-active-icon");
                }

                $(tabEl).addClass(options.inactive);
              }

              return el;
            };
          }; // init tab


          window.iconSidebarWidget._activeTabId = "layers-tree";
          var leftMainContainer = nsGmx$1.layersTreePane = window.iconSidebarWidget.setPane("layers-tree", {
            createTab: window.createTabFunction({
              icon: "s-tree",
              active: "sidebar-icon-active",
              inactive: "sidebar-icon-inactive",
              hint: "Слои"
            })
          });
          leftMainContainer.innerHTML = '<div class="leftMenu">' + '<div class="mainmap-title">' + data.properties.title + '</div>' + '<div id="leftPanelHeader" class="leftPanelHeader"></div>' + '<div id="leftContent" class="leftContent">' + '<div id="leftContentInner" class="leftContentInner"></div>' + '</div>' + '<div id="leftPanelFooter" class="leftPanelFooter"></div>' + '</div>';
          window.iconSidebarWidget.open("layers-tree"); // $('.leftContent').mCustomScrollbar();
          // function handleSidebarResize (e) {
          //     var sidebarWidth = window.iconSidebarWidget.getWidth(),
          //         lmap = nsGmx.leafletMap,
          //         newBottomLeft,
          //         newBounds;
          //     var c = lmap.getContainer();
          //     var pBounds = lmap.getPixelBounds(),
          //         bl = pBounds.getBottomLeft(),
          //         tr = pBounds.getTopRight(),
          //         blll = L.latLng(lmap.unproject(bl)),
          //         trll = L.latLng(lmap.unproject(tr));
          //     if (e.type === 'sidebar:opened') {
          //         newBottomLeft = L.point(bl.x + sidebarWidth, bl.y);
          //     } else {
          //         newBottomLeft = L.point(bl.x - sidebarWidth, bl.y);
          //     }
          //     newBounds = L.latLngBounds(L.latLng(lmap.unproject(newBottomLeft)), trll);
          // }

          /**
           *
           * SIDEBAR END
           *
           */

          _queryMapLayers.addLayers(data, condition, mapStyles, LayersTreePermalinkParams); // переписать на вкладку с деревом


          var headerDiv = $('.mainmap-title'); // special for steppe Project

          if (data.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
            $(headerDiv).toggle();
          }

          nsGmx$1.ContextMenuController.bindMenuToElem(headerDiv[0], 'Map', function () {
            return _queryMapLayers.currentMapRights() == 'edit';
          }, function () {
            return {
              div: $(_layersTree._treeCanvas).find('div[MapID]')[0],
              tree: _layersTree
            };
          }); // _menuUp.defaultHash = 'layers';

          window.mapLayers.mapLayers.load(); //создаём тулбар
          // var iconContainer = _div(null, [
          //     ['css', 'borderLeft', '1px solid #216b9c']
          // ]);
          // var searchContainer = nsGmx.widgets.header.getSearchPlaceholder()[0];

          window.searchLogic.init({
            oMenu: oSearchLeftMenu
          }); //инициализация контролов поиска (модуль уже загружен)
          // var oSearchModule = window.gmxCore.getModule('search');
          // window.oSearchControl = new oSearchModule.SearchGeomixer();
          // if (document.getElementById('searchCanvas')) {
          // window.oSearchControl.Init({
          //     Menu: oSearchLeftMenu,
          //     ContainerInput: searchContainer,
          //     ServerBase: window.serverBase,
          //     layersSearchFlag: true,
          //     Map: lmap,
          //     gmxMap: gmxMap
          // });

          _menuUp.createMenu = function () {
            createMenuNew();
          };

          _menuUp.go(nsGmx$1.widgets.header.getMenuPlaceholder()[0]);

          var headerLinks = nsGmx$1.addHeaderLinks();

          if (headerLinks.length) {
            _menuUp.addItem({
              id: 'linksMenu',
              title: _gtxt('Ссылки'),
              childs: headerLinks
            });
          } // Загружаем все пользовательские данные


          nsGmx$1.userObjectsManager.load(); // выставляет правильные z-indexes слоям-вьюхам

          _layersTree.updateZIndexes(); //выполняем мапплет карты нового формата


          nsGmx$1.mappletLoader.execute(); //динамически добавляем пункты в меню. DEPRICATED.

          nsGmx$1.pluginsManager.addMenuItems(_menuUp);
          _mapHelper$1.gridView = false;

          var updateLeftPanelVis = function updateLeftPanelVis() {
            // $('.leftCollapser-icon')
            //     .toggleClass('leftCollapser-right', !layersShown)
            //     .toggleClass('leftCollapser-left', !!layersShown);
            window.resizeAll();
          }; // $('#leftCollapser').click(function() {
          //     layersShown = !layersShown;
          //     updateLeftPanelVis();
          // });


          updateLeftPanelVis();
          createToolbar();
          var controls = lmap.gmxControlsManager.getAll();

          for (var key in controls) {
            var ctrl = controls[key],
                cntr = ctrl.getContainer();
            cntr.addEventListener('click', function (e) {
              _menuUp.hideOnClick(e);
            });
          }

          if (state.mode) {
            lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(state.mode) || state.mode);
          } else if (baseLayers.length && !lmap.gmxBaseLayersManager.getCurrentID()) {
            lmap.gmxBaseLayersManager.setCurrentID(baseLayers[0]);
          }

          if (state.drawings) {
            lmap.gmxDrawing.loadState(state.drawings);
          } else if (state.drawnObjects) {
            state.drawnObjects.forEach(function (objInfo) {
              //старый формат - число, новый - строка
              var lineStyle = {};

              if (objInfo.color) {
                lineStyle.color = typeof objInfo.color === 'number' ? '#' + L.gmxUtil.dec2hex(objInfo.color) : objInfo.color;
              }

              if (objInfo.thickness) {
                lineStyle.weight = objInfo.thickness;
              }

              if (objInfo.opacity) {
                lineStyle.opacity = objInfo.opacity / 100;
              }

              var featureOptions = $.extend(true, {}, objInfo.properties, {
                lineStyle: lineStyle
              });
              var drawingFeature = lmap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(objInfo.geometry), featureOptions)[0];

              if (objInfo.isBalloonVisible) {
                drawingFeature.openPopup();
              }
            });
          } else if (state.marker) {
            nsGmx$1.leafletMap.gmxDrawing.addGeoJSON({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [state.marker.mx, state.marker.my]
              },
              properties: {
                title: state.marker.mt
              }
            });
          }

          if (state.openPopups) {
            for (var _l2 in state.openPopups) {
              var _layer5 = nsGmx$1.gmxMap.layersByID[_l2];

              if (_layer5 && _layer5.addPopup) {
                state.openPopups[_l2].forEach(_layer5.addPopup.bind(_layer5));
              }
            }
          }

          _menuUp.checkView();

          if (nsGmx$1.AuthManager.isLogin()) {
            _queryMapLayers.addUserActions();
          }

          if (state.dateIntervals) {
            for (var lid in gmxMap.layersByID) {
              if (lid in state.dateIntervals) {
                var _l3 = gmxMap.layersByID[lid],
                    beginDate = new Date(state.dateIntervals[lid].beginDate),
                    endDate = new Date(state.dateIntervals[lid].endDate);

                _l3.setDateInterval(beginDate, endDate);
              }
            }
          }

          if (state.filters) {
            for (var _key in state.filters) {
              var _l4 = nsGmx$1.gmxMap.layersByID[_key],
                  filtersArr = state.filters[_key];

              for (var i = 0; i < filtersArr.length; i++) {
                if ('filterById' in filtersArr[i]) {
                  (function () {
                    var filteredId = filtersArr[i]['filterById'];

                    _l4.addLayerFilter(function (it) {
                      return it.id === filteredId;
                    });
                  })();
                }
              }
            }
          }

          initEditUI();
          initTemporalLayers();
          gmxMap.addLayersToMap(lmap);
          nsGmx$1.leafletMap.on('layeradd', function (event) {
            var layer = event.layer;

            if (layer.getGmxProperties) {
              // var layerProps = layer.getGmxProperties();
              initEditUI();
              initTemporalLayers([layer]);
            }
          }); // if (mapProp.MapID !== 'ATTBP') {

          nsGmx$1.gmxMap.on('onRemoveLayer', function (event) {
            var layer = event.layer;

            if (!layer.getGmxProperties()) {
              return;
            }

            var props = layer.getGmxProperties(),
                isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

            if (isTemporalLayer && !(props.name in nsGmx$1.widgets.commonCalendar._unbindedTemporalLayers)) {
              nsGmx$1.widgets.commonCalendar.unbindLayer(props.name);
              nsGmx$1.widgets.commonCalendar.updateTemporalLayers();
              delete nsGmx$1.widgets.commonCalendar._unbindedTemporalLayers[props.name];
            }
          }); // special for steppe project

          if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
            nsGmx$1.widgets.commonCalendar.show();
          }

          nsGmx$1.pluginsManager.afterViewer(); // обработка специальных параметров плагинов

          nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
            if (plugin.moduleName === "gmxTimeLine" && nsGmx$1.timeLineControl) {
              var treeLayers = $(window._layersTree);
              nsGmx$1.timeLineControl.on('layerRemove', function (e) {
                treeLayers.triggerHandler('layerTimelineRemove', e);
              }).on('layerAdd', function (e) {
                treeLayers.triggerHandler('layerTimelineAdd', e);
              }).saveState().dataSources.forEach(function (it) {
                treeLayers.triggerHandler('layerTimelineAdd', {
                  type: 'layerAdd',
                  layerID: it.layerID
                });
              });
            }
          }); // экспорт карты

          if (state.exportMode) {
            _mapHelper$1.exportMap(state);
          }
        });
      }

      function mapExportMenu() {
        window.gmxCore.loadModule('MapExport' // , 'src/MapExport/MapExport.js'
        ).then(function (def) {
          var menu = new def.MapExportMenu();
          menu.Load();
        });
      }

      function BufferZonesMenu() {
        window.gmxCore.loadModule('BufferZones' // , 'src/BufferZones/BufferZones.js'
        ).then(function (def) {
          var menu = new def.BufferZonesMenu();
          menu.Load();
        });
      }

      function indexGridMenu() {
        window.gmxCore.loadModule('IndexGrid' // , 'src/IndexGrid/IndexGrid.js'
        ).then(function (def) {
          var menu = new def.IndexGridMenu();
          menu.Load();
        });
      }

      function PhotoLayerDialog() {
        window.gmxCore.loadModule('PhotoLayer' // , 'src/PhotoLayer/PhotoLayer.js'
        ).then(function (def) {
          var dialog = new def.PhotoLayer();
          dialog.Load();
        });
      }

      function promptFunction(title, value) {
        var ui = $(Handlebars.compile('<div class="gmx-prompt-canvas">' + '<input class="inputStyle gmx-prompt-input" value="{{value}}">' + '</div>')({
          value: value
        }));
        ui.find('input').on('keydown', function (e) {
          // var evt = e || window.event;
          if (e.which === 13) {
            var coord = L.gmxUtil.parseCoordinates(this.value);
            nsGmx$1.leafletMap.panTo(coord);
            return false;
          }
        });
        showDialog(title, ui[0], 300, 80, false, false);
      }

      window.prompt = promptFunction;
    };

    tinyMCE.init({
      mode: "none",
      theme: "advanced",
      plugins: 'fullscreen',
      language: 'ru',
      convert_urls: false,
      theme_advanced_buttons1: 'bold,italic,underline,|,justifyleft,justifycenter,justifyright,|,link,unlink,fullscreen,code',
      theme_advanced_buttons2: '',
      theme_advanced_buttons3: '',
      theme_advanced_statusbar_location: 'none',
      theme_advanced_toolbar_location: 'bottom',
      theme_advanced_toolbar_align: 'center'
    });
    nsGmx$1.initGeoMixer();

}());
//# sourceMappingURL=main.js.map
